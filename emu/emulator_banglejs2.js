// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != 'undefined';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string' && process.type != 'renderer';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {

}

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {...Module};

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var readAsync, readBinary;

if (ENVIRONMENT_IS_NODE) {
  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  var nodeVersion = process.versions.node;
  var numericVersion = nodeVersion.split('.').slice(0, 3);
  numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);
  var minVersion = 160000;
  if (numericVersion < 160000) {
    throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');
  }

  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = require('fs');
  var nodePath = require('path');

  scriptDirectory = __dirname + '/';

// include: node_shell_read.js
readBinary = (filename) => {
  // We need to re-wrap `file://` strings to URLs.
  filename = isFileURI(filename) ? new URL(filename) : filename;
  var ret = fs.readFileSync(filename);
  assert(Buffer.isBuffer(ret));
  return ret;
};

readAsync = async (filename, binary = true) => {
  // See the comment in the `readBinary` function.
  filename = isFileURI(filename) ? new URL(filename) : filename;
  var ret = fs.readFileSync(filename, binary ? undefined : 'utf8');
  assert(binary ? Buffer.isBuffer(ret) : typeof ret == 'string');
  return ret;
};
// end include: node_shell_read.js
  if (!Module['thisProgram'] && process.argv.length > 1) {
    thisProgram = process.argv[1].replace(/\\/g, '/');
  }

  arguments_ = process.argv.slice(2);

  if (typeof module != 'undefined') {
    module['exports'] = Module;
  }

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

} else
if (ENVIRONMENT_IS_SHELL) {

  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof WorkerGlobalScope != 'undefined') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.startsWith('blob:')) {
    scriptDirectory = '';
  } else {
    scriptDirectory = scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);
  }

  if (!(typeof window == 'object' || typeof WorkerGlobalScope != 'undefined')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  {
// include: web_or_worker_shell_read.js
if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.responseType = 'arraybuffer';
      xhr.send(null);
      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = async (url) => {
    // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
    // See https://github.com/github/fetch/pull/92#issuecomment-140665932
    // Cordova or Electron apps are typically loaded from a file:// url.
    // So use XHR on webview if URL is a file URL.
    if (isFileURI(url)) {
      return new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = () => {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            resolve(xhr.response);
            return;
          }
          reject(xhr.status);
        };
        xhr.onerror = reject;
        xhr.send(null);
      });
    }
    var response = await fetch(url, { credentials: 'same-origin' });
    if (response.ok) {
      return response.arrayBuffer();
    }
    throw new Error(response.status + ' : ' + response.url);
  };
// end include: web_or_worker_shell_read.js
  }
} else
{
  throw new Error('environment detection error');
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.error.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used.
moduleOverrides = null;
checkIncomingModuleAPI();

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');

if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');
assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');
assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
legacyModuleProp('asm', 'wasmExports');
legacyModuleProp('readAsync', 'readAsync');
legacyModuleProp('readBinary', 'readBinary');
legacyModuleProp('setWindowTitle', 'setWindowTitle');
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';
var ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';
var JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';
var OPFS = 'OPFS is no longer included by default; build with -lopfs.js';

var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';

assert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');

// end include: shell.js

// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');

// include: wasm2js.js
// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.

// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
/** @suppress{duplicate, const} */
var
WebAssembly = {
  // Note that we do not use closure quoting (this['buffer'], etc.) on these
  // functions, as they are just meant for internal use. In other words, this is
  // not a fully general polyfill.
  /** @constructor */
  Memory: function(opts) {
    this.buffer = new ArrayBuffer(opts['initial'] * 65536);
  },

  Module: function(binary) {
    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
  },

  /** @constructor */
  Instance: function(module, info) {
    // TODO: use the module somehow - right now the wasm2js output is embedded in
    // the main JS
    // This will be replaced by the actual wasm2js code.
    this.exports = (
function instantiate(info) {
function Table(ret) {
  // grow method not included; table is not growable
  ret.set = function(i, func) {
    this[i] = func;
  };
  ret.get = function(i) {
    return this[i];
  };
  return ret;
}

  var bufferView;
  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);
  for (var i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    }
    return uint8Array;
  }
function initActiveSegments(imports) {
  base64DecodeToExistingUint8Array(bufferView, 1024, "/wB2YXIgcD0wO3JldHVybntyZWFkOmZ1bmN0aW9uKGwpe3JldHVybiBzLnN1YnN0cmluZyhwLHArPWwpfHx1bmRlZmluZWQ7fX0AoyhnbG9iYWwuV0lER0VUUyl7rGQ9Zy5nZXRXaWR0aCgpLGU9Zy5nZXRIZWlnaHQoKSxjPXt0bDp7eDrTLHk60yxyOtMsYzrTfSx0cjp7eDpkLdQBLHk60yxyOtQBLGM6030sYmw6e3g60yx5OmUt1BgscjrTLGM6030sYnI6e3g6ZC3UASx5OmUt1BgscjrUASxjOtN9fSxiLGE7pyhhxldJREdFVFMpKGI9Y1thLmFyZWFdKZ7TjGEud2lkdGieKGEueD1iLngtYi5yKmEud2lkdGgsYS55PWIueSxiLniWYS53aWR0aCoo1AEt1AIqYi5yKSxiLmOYKTtnLnJlc2V0KCk7KGMudGwuY6BjLnRyLmMpnmcuY2xlYXJSZWN0KNMs0yxkLdQBLNQXKTsoYy5ibC5joGMuYnIuYymeZy5jbGVhclJlY3Qo0yxlLdQYLGQt1AEsZS3UASk7sXunKGHGV0lER0VUUylhLmRyYXcoYSl9Y2F0Y2goZil7cHJpbnQoZil9fQCre3JlYWQ6qigpe6shIWdsb2JhbFvRAf9dLkxFRDF9LHNldDqqKCl7ry53cml0ZSjUASl9LHJlc2V0OqooKXuvLndyaXRlKNMpfSx3cml0ZTqqKGEpe2cuc2V0Q29sb3IoKGdsb2JhbFvRAf9dLkxFRDE9ISFhKT/RBCNmMDA6Zy50aGVtZS5iZykuZmlsbENpcmNsZSgoZy5nZXRXaWR0aCgpLdQUKS/UAizUBSzUBSk7QmFuZ2xlLnNldExDRFBvd2VyKNQBKX0sdG9nZ2xlOqooKXuvLndyaXRlKCGvLnJlYWQoKSl9fQCre3JlYWQ6qigpe6shIWdsb2JhbFvRAf9dLkxFRDJ9LHNldDqqKCl7ry53cml0ZSjUASl9LHJlc2V0OqooKXuvLndyaXRlKNMpfSx3cml0ZTqqKGEpe2cuc2V0Q29sb3IoKGdsb2JhbFvRAf9dLkxFRDI9ISFhKT/RBCMwZjA6Zy50aGVtZS5iZykuZmlsbENpcmNsZSgoZy5nZXRXaWR0aCgpK9QUKS/UAizUBSzUBSk7QmFuZ2xlLnNldExDRFBvd2VyKNQBKX0sdG9nZ2xlOqooKXuvLndyaXRlKCGvLnJlYWQoKSl9fQB7fQB7JXN9AKplKGEsYil7wNOLYp4oYj3UASk7q2EudG9GaXhlZChNYXRoLm1pbihiLGItTWF0aC5mbG9vcihNYXRoLmxvZyhhKS9NYXRoLmxvZyjUCikpKSl9qmYoKXvA04tnnihnPShyZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QxzZXR0aW5nLmpzb24s1AEpoHt9KVvRBjEyaG91cl0pO6tnfaxnO2V4cG9ydHM9e25hbWU60QZzeXN0ZW0sY3VycmVuY3lTeW060QGjLHRyYW5zbGF0ZTphomEsZGF0ZTooYSxiKaJiPyjRATArYS5nZXREYXRlKCkpLnN1YnN0cijU/ikr0QEvKyjRATArKGEuZ2V0TW9udGgoKSvUASkpLnN1YnN0cijU/ikr0QEvK2EuZ2V0RnVsbFllYXIoKTphLnRvU3RyaW5nKCkuc3Vic3RyKNQELNQLKS50cmltKCksdGltZTooYSxiKaJ7rGM9YS5nZXRIb3VycygpLGQ9YS5nZXRNaW51dGVzKCk7ZigpnihjPdOKYyXUDD/UDDpjJdQMKTurKNEBICtjKS5zdWJzdHIo1P4pK9EBOiso0QEwK2QpLnN1YnN0cijU/ikrKGI/IiI60QEuKyjRATArYS5nZXRTZWNvbmRzKCkpLnN1YnN0cijU/ikpfSxkb3c6KGEsYimi0ThTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheS5zcGxpdCjRASApW2EuZ2V0RGF5KCldLnN1YnN0cijTLGI/1AM61AopLG1vbnRoOihhLGIpotFVSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlci5zcGxpdCjRASApW2EuZ2V0TW9udGgoKV0uc3Vic3RyKNMsYj/UAzrUCiksbnVtYmVyOihhLGIponu2imKeKGI91AIpO6xjPWEudG9GaXhlZChiKSxkPWN80zthPdM+YT/UATrTO2I9KCIiK01hdGguYWJzKGMtZCkudG9GaXhlZChiKSkuc3Vic3RyKNQCLGIpO2Q9IiIrZDtjPWQubGVuZ3RoO6corGg9IiI7KGOX1AMpPmE7KWg90QEsK2Quc3Vic3RyKGMs1AMpK2g7q2Quc3Vic3RyKNMsYyvUAykraCsoYj/RAS4rYjoiIil9LGN1cnJlbmN5OmGie2NvbnNvbGUubG9nKNErV2FybmluZzogQ3VycmVuY3kgaW5mb3JtYXRpb24gaXMgZGVwcmVjYXRlZCk7q9EBoythLnRvRml4ZWQo1AIpfSxkaXN0YW5jZTooYSxiKaLV6AM+YT9lKGEsYikr0QFtOmUoYS/V6AMsYikr0QJrbSxzcGVlZDooYSxiKaJlKGEvMS42MDkzNCxiKSvRA21waCx0ZW1wOihhLGIpomUoYSxiKSvRAidDLG1lcmlkaWFuOihhLGIpomKgZigpP9QMkWEuZ2V0SG91cnMoKT/RAmFtOtECcG06IiIsaXMxMkhvdXJzOmZ9AKMoIWdsb2JhbC5XSURHRVRTKXtnbG9iYWwuV0lER0VUUz17fTtyZXF1aXJlKNEHU3RvcmFnZSkubGlzdCgvXC53aWRcLmpzJC8pLmZvckVhY2goYaJ7sXtldmFsKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKGEpKX1jYXRjaChjKXtwcmludChhLGMpfX0pO6xiPVdJREdFVFM7V0lER0VUUz17fTtPYmplY3Qua2V5cyhiKS5zb3J0KChhLGMpoijTfGJbY10uc29ydG9yZGVyKS0o03xiW2FdLnNvcnRvcmRlcikpLmZvckVhY2goYaJXSURHRVRTW2FdPWJbYV0pfQB7IFtuYXRpdmUgY29kZV0gfQAKfQAvLVx8AHsAdHoARnJlcXVlbmN5IG11c3QgYmUgYWJvdmUgMC4wMDFIegB4eQBhY3Rpdml0eQAjb25wYXJpdHkALUluZmluaXR5AGhpc3RvcnkATm90IGVub3VnaCBtZW1vcnkATWF4aW11bSBudW1iZXIgb2YgcG9pbnRzICglZCkgZXhjZWVkZWQgZm9yIGZpbGxQb2x5AEFTQ0lJIG9ubHkAaW5hbGx5AGR5AFRoaXJkIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIGFycmF5AFVpbnQ4Q2xhbXBlZEFycmF5AFVpbnQ4QXJyYXkASW50OEFycmF5AFVpbnQxNkFycmF5AEludDE2QXJyYXkARmxvYXQ2NEFycmF5AFVpbnQyNEFycmF5AFVpbnQzMkFycmF5AEludDMyQXJyYXkARmxvYXQzMkFycmF5AGRheQB0eAByeABsb3dSZXNpc3RhbmNlRml4AP9nZngAaW50ZXJsZWF2ZXgAaW5kZXgAbGFzdEluZGV4AGFjY0hpc3RvcnlJZHgAbWF4AFVuZmluaXNoZWQgY2hhcmFjdGVyIHNldCBpbiBSZWdFeABVbmtub3duIGVycm9yOiAtMHgleABocm93AFRvbyBtdWNoIHJlY3Vyc2lvbiAtIHRoZSBzdGFjayBpcyBhYm91dCB0byBvdmVyZmxvdwBzdGVwQ291bnRlclRocmVzaG9sZExvdwBBcnJheUJ1ZmZlclZpZXcuc3ViYXJyYXkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGFuIEFycmF5QnVmZmVyVmlldwBDYW4gb25seSBiZSBjYWxsZWQgb24gYW4gQXJyYXlCdWZmZXJWaWV3AERhdGFWaWV3ACNvbkhSTS1lbnYAZGl2AFx2AHNldEZvbnQldgAjb24ldgAldi4ldgBkYXRhOmltYWdlL2JtcDtiYXNlNjQsJXYAZnVuY3Rpb24gJXYAVW5rbm93biBXYXRjaCAldgAldjogJXYAVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOiAldgB0ZXh0AG5leHQAYWZfb3V0cHV0AGlucHV0AFVuZXhwZWN0ZWQgZW5kIG9mIElucHV0AHRpbWVyLEZsYXNoLFN0b3JhZ2UsaGVhdHNocmluayxjcnlwdG8sbG9jYWxlLExheW91dAB0aW1lb3V0AHR3aXN0VGltZW91dABiYWNrbGlnaHRUaW1lb3V0AGxjZFBvd2VyVGltZW91dABsb2NrVGltZW91dABidG5Mb2FkVGltZW91dAAuYm9vdHJzdABvbnN0ACNvbnR3aXN0AHdha2VPblR3aXN0AGRzdABsYXN0AHBvcnQAZXhjZXB0AGNvdW50AHRyYXNoQ291bnQAZ2VzdHVyZUluYWN0aXZlQ291bnQAYWNjR2VzdHVyZUNvdW50AGZpbGVDb3VudABhY2NJZGxlQ291bnQAaW1hZ2VDb3VudABmcm9udABmb250AHNldEZvbnQAaW50AGV2ZW50AHRyYW5zcGFyZW50AEV4cGVjdGVkIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgd2l0aCA2IGVudHJpZXMgZm9yIHNlY29uZCBhcmd1bWVudABtb3ZlbWVudABBc3NpZ25tZW50IHRvIGEgY29uc3RhbnQATm90IGVub3VnaCBtZW1vcnkgZm9yIHJlc3VsdABlZmF1bHQAI29uaW5pdABvbkluaXQAZHJhaW5XYWl0AHJpZ2h0ACNvbm1pZG5pZ2h0ACNvbmJhY2tsaWdodABMQ0RfYmFja2xpZ2h0AGhlaWdodABtYXhJbWFnZUhlaWdodABzb2Z0AGZvcmNlU29mdABsZWZ0AHByb3BlcnRpZXNPYmplY3QgaXMgbm90IHN1cHBvcnRlZCB5ZXQAU29mdHdhcmUgU2VyaWFsIENLIG5vdCBpbXBsZW1lbnRlZCB5ZXQAb2Zmc2V0AGJ5dGVPZmZzZXQAI29ucGFja2V0AGdldABvYmplY3QAT2JqZWN0AGZpbGxSZWN0AGlGaWxsUmVjdABmbG9hdABGbGF0AHJlcGVhdAD/Y2F0AFx0AEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgQXJyYXksIG5vdCAldABFeHBlY3Rpbmcgb3B0aW9ucyB0byBiZSB1bmRlZmluZWQgb3IgYW4gT2JqZWN0LCBub3QgJXQARk9SIGxvb3AgY2FuIG9ubHkgaXRlcmF0ZSBvdmVyIEFycmF5cywgU3RyaW5ncyBvciBPYmplY3RzLCBub3QgJXQAZm9yKGEgJXMgYikgLSAnYScgbXVzdCBiZSBhIHZhcmlhYmxlIG5hbWUsIG5vdCAldABGaXJzdCBhcmd1bWVudCBtdXN0IGl0ZXJhYmxlLCBub3QgJXQARXhwZWN0aW5nIENhbGxiYWNrIEZ1bmN0aW9uIG9yIGFuIE9iamVjdCBidXQgZ290ICV0AEV4cGVjdGluZyBOdW1iZXIgb3IgQXJyYXksIGdvdCAldABGaXJzdCBhcmd1bWVudCBtdXN0IGJlIE9iamVjdCwgRnVuY3Rpb24gb3IgQXJyYXksIGdvdCAldABFeHBlY3RpbmcgU3RyaW5nIG9yIEFycmF5LCBnb3QgJXQARXhwZWN0aW5nIFN0cmluZyBhcyBmaXJzdCBhcmd1bWVudCwgZ290ICV0AFByb3RvdHlwZSBzaG91bGQgYmUgYW4gb2JqZWN0LCBnb3QgJXQARXhwZWN0aW5nIE9iamVjdCwgZ290ICV0AEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgT2JqZWN0LCBnb3QgJXQAU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgT2JqZWN0LCBnb3QgJXQAUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBPYmplY3QsIGdvdCAldABBZGRyZXNzIHNob3VsZCBiZSBhbiBpbnRlZ2VyLCBnb3QgJXQARXhwZWN0aW5nIEFycmF5QnVmZmVyLCBnb3QgJXQAJ2J1ZmZlcicgc2hvdWxkIGJlIEFycmF5QnVmZmVyLCBnb3QgJXQARnVuY3Rpb24uYmluZCBleHBlY3RzIHRvIGJlIGNhbGxlZCBvbiBmdW5jdGlvbiwgZ290ICV0AEV4cGVjdGluZyBmdW5jdGlvbiwgZ290ICV0AEV4cGVjdGluZyBjb21wYXJlIGZ1bmN0aW9uLCBnb3QgJXQAJ2V4dGVuZHMnIGFyZ3VtZW50ICVxIHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBnb3QgJXQARXhwZWN0aW5nIG1vZHVsZSBuYW1lIGFzIGEgc3RyaW5nLCBnb3QgJXQARXhwZWN0aW5nIFN0cmluZywgZ290ICV0AEV4cGVjdGluZyBOdW1iZXIgb3IgaXRlcmFibGUsIGdvdCAldABFeHBlY3Rpbmcgc29tZXRoaW5nIGl0ZXJhYmxlLCBnb3QgJXQAU2Vjb25kIGFyZ3VtZW50IHRvIEZ1bmN0aW9uLmFwcGx5IG11c3QgYmUgaXRlcmFibGUsIGdvdCAldABFeHBlY3RpbmcgT2JqZWN0IG9yIHVuZGVmaW5lZCwgZ290ICV0AEV4cGVjdGluZyBmdW5jdGlvbiBvbiBSSFMsIGdvdCAldABDb25zdHJ1Y3RvciBzaG91bGQgYmUgYSBmdW5jdGlvbiwgYnV0IGlzICV0AEZpZWxkIG9yIG1ldGhvZCAlcSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LCBhbmQgY2FuJ3QgY3JlYXRlIGl0IG9uICV0AFVuc3VwcG9ydGVkIGZpcnN0IGFyZ3VtZW50IG9mIHR5cGUgJXQAVW5hYmxlIHRvIGFzc2lnbiB2YWx1ZSB0byBub24tcmVmZXJlbmNlICV0AENhbid0IGV4dGVuZCAldABFeHBlY3RpbmcgZmlyc3QgMiBhcmd1bWVudHMgdG8gYmUgaXRlcmFibGUsIG5vdCAldCBhbmQgJXQARXhwZWN0aW5nIGZpcnN0IDIgYXJndW1lbnRzIHRvIGJlIGl0ZXJhYmxlIG9yIHVuZGVmaW5lZCwgbm90ICV0IGFuZCAldABDYW4ndCB1c2UgJ2luJyBvcGVyYXRvciB0byBzZWFyY2ggYSAldABPYmplY3QgcHJvdG90eXBlIG1heSBvbmx5IGJlIGFuIE9iamVjdCBvciBudWxsOiAldABleHBvcnRzAEUuc3RvcEV2ZW50UHJvcGFnYXRpb24oKSBjYWxsZWQgd2hlbiBub3QgaGFuZGxpbmcgZXZlbnRzAEluc3VmZmljaWVudCBzdGFjayBmb3IgdGhpcyBtYW55IGFyZ3VtZW50cwBVbmV4cGVjdGVkIGFyZ3VtZW50cwBQYWxldHRlIHNwZWNpZmllZCwgYnV0IG11c3QgYmUgYSBmbGF0IFVpbnQxNkFycmF5IG9mIDIsNCw4LDE2LDI1NiBlbGVtZW50cwBzdG9wYml0cwBJbnZhbGlkIG51bWJlciBvZiBiaXRzAGN0cwBhZGRyZXNzAHByb2Nlc3MAY29tcGFzcwBDYWxsaW5nICdzdXBlcicgb3V0c2lkZSBvZiBjbGFzcwBlcnJvcnMAY29sb3Jfb3JkZXIgbXVzdCBiZSAzIGNoYXJhY3RlcnMAdGltZXJzAEZpcnN0IDIgYXJndW1lbnRzIHNob3VsZCBiZSBhcnJheSBidWZmZXJzAHZlcnRpY2FsX2J5dGUgb25seSB3b3JrcyBmb3IgMWJwcCBBcnJheUJ1ZmZlcnMAdW5yZW5kZXJhYmxlQ2hhcnMAc3RlcHMAX29wdGlvbnMASW52YWxpZCBvcHRpb25zAGZ1bmN0aW9ucwBwaW5zAENvcHlyaWdodCAyMDIxIEcuV2lsbGlhbXMAanMAdGhpcwD/dGhzAGFyZ3MAZmxhZ3MAb2ZmcwB0b3RhbEJ5dGVzAHRyYXNoQnl0ZXMAZmlsZUJ5dGVzAGZyZWVCeXRlcwD/cmVzAHBpcGVzAGZyYW1lcwBtb2R1bGVzAHN0cm9rZXMARXhwZWN0aW5nIEFycmF5IGZvciBmaXJzdCBhcmd1bWVudCB3aXRoIDwlZCBlbnRyaWVzAHdhdGNoZXMAQ2FuJ3QgaGF2ZSBwYWxldHRlIG9uID44IGJpdCBpbWFnZXMAc2V0Q29uc29sZSBjYW4ndCBiZSB1c2VkIG9uICdzb2Z0JyBvciBub24tU2VyaWFsIGRldmljZXMAc2V0Q29uc29sZSBjYW4ndCBiZSB1c2VkIG9uICdzb2Z0JyBkZXZpY2VzAG5vYm91bmRzAERhdGUgb3V0IG9mIGJvdW5kcwB4dGVuZHMAR3JhcGhpY3MAQURDcwAldiVzACVxJXMAJVElcwBJRDolcwBFeHBlY3RpbmcgdmFsaWQgdmFsdWUsIGdvdCAlcwBCb29sICVzAENhbid0IHJlYWQgcHJvcGVydHkgJyVzJyBvZiAlcwBHb3QgJXMgZXhwZWN0ZWQgJXMASTJDIEVycm9yOiAlcwByZWN1cgBwdHIAaW50cgBsY2RCdWZmZXJQdHIAeG9yAFZhcmlhYmxlcyBvZiB0eXBlICV0IGFyZSBub3Qgc3VwcG9ydGVkIGluIGRhdGUgY29uc3RydWN0b3IARnVuY3Rpb24gcmVxdWlyZWQgaW4gcHJvbWlzZSBjb25zdHJ1Y3RvcgBWZWN0b3IALm9mZiBub3QgaW1wbGVtZW50ZWQgb24gZW11bGF0b3IAU3ludGF4RXJyb3IASW50ZXJuYWxFcnJvcgBUeXBlRXJyb3IAUmVmZXJlbmNlRXJyb3IAZGlyAGJncgAjb25sY2RQb3dlcgBjZW50ZXIAVW5rbm93biBmaWx0ZXIAdXBlcgBVbmFibGUgdG8gc2NoZWR1bGUgYSB0aW1lcgBgcGluYCByZXF1aXJlZCBmb3IgU0VUIHRpbWVyAGBwdHJgIG9yIGBmbmAgcmVxdWlyZWQgZm9yIEVYRUMgdGltZXIAVGltZW91dCBvbiBVdGlsaXR5IFRpbWVyAEludGVycnVwdGVkIGluIFV0aWxpdHkgVGltZXIAZWJ1Z2dlcgBGb250IHdpZHRoIG11c3QgYmUgYSBTdHJpbmcgb3IgYW4gaW50ZWdlcgBJbnRlZ2VyACNvbmJ1ZmZlcgAuYnVmZmVyAEludmFsaWQgbGVuZ3RoIGZvciBBcnJheUJ1ZmZlcgAnc2FtcGxlcycgc2hvdWxkIGJlIGEgaW50ZWdlciBvciBBcnJheUJ1ZmZlcgB1bmtub3duIEFycmF5QnVmZmVyAGN1cnJlbnRCdWZmZXIAZG91YmxlQnVmZmVyAGNvbG9yX29yZGVyAFN0cmluZyB0b28gYmlnIHRvIGNvbnZlcnQgdG8gbnVtYmVyAFB1bHNlIFRpbWUgaXMgbGVzcyB0aGFuIDAgb3Igbm90IGEgbnVtYmVyAE51bWJlcgBhZGRyAGdicgBKc1ZhcgBccgCqcihjLGgpe6pkKGUpe9EDcmFtO2UuaWSeKG5bZS5pZF09ZSk7ZS50eXBloChlLnR5cGU9IiIpO2UuY55lLmMuZm9yRWFjaChkKX2vLl9sPa8ubD1jO68ub3B0aW9ucz1ooHt9O68ubGF6eT2vLm9wdGlvbnMubGF6eaAh1AE7ry5waHlzQnRucz3UATutazujKNQCjHByb2Nlc3MuZW52LkhXVkVSU0lPTil7ry5waHlzQnRucz3UAztrPVtdO6plKHApe9EDcmFtO9EDYnRuinAudHlwZZ5rLnB1c2gocCk7cC5jnnAuYy5mb3JFYWNoKGUpfWUoYyk7ay5sZW5ndGieKK8ucGh5c0J0bnM90yyvLmJ1dHRvbnM9ayyvLnNlbGVjdGVkQnV0dG9uPdT/KX2jKK8ub3B0aW9ucy5idG5zKaMoYz2vLm9wdGlvbnMuYnRucyyvLnBoeXNCdG5zkWMubGVuZ3RoKXuvLmI9YzutZT1NYXRoLmZsb29yKEJhbmdsZS5hcHBSZWN0Lmgvry5waHlzQnRucyk7pyjUAjyvLnBoeXNCdG5zntQBimMubGVuZ3RonmMudW5zaGlmdCh7bGFiZWw6IiJ9KTuvLnBoeXNCdG5zPmMubGVuZ3RoOyljLnB1c2goe2xhYmVsOiIifSk7ry5fbC53aWR0aD1nLmdldFdpZHRoKCkt1Ag7ry5fbD17dHlwZTrRAWgsZmlsbHk61AEsYzpbry5fbCx7dHlwZTrRAXYscGFkOtQBLGZpbGx5OtQBLGM6Yy5tYXAocKIocC50eXBlPdEDdHh0LHAuZm9udD3RAzZ4OCxwLmhlaWdodD1lLHAucj3UASxwKSl9XX19pK8uX2wud2lkdGg9Zy5nZXRXaWR0aCgpLdQgLK8uX2w9e3R5cGU60QFoLGM6W68uX2wse3R5cGU60QF2LGM6Yy5tYXAoZaIoZS50eXBlPdEDYnRuLGUuZmlsbHk91AEsZS53aWR0aD3UICxlLnI91AEsZSkpfV19LGueay5wdXNoLmFwcGx5KGssry5fbC5jW9QBXS5jKTuvLnNldFVJKCk7rG49rztkKK8uX2wpO68udXBkYXRlTmVlZGVkPSHTfap1KGMsaCxkLGssbil7rGU9topjLmJnQ29sP246Zy50b0NvbG9yKGMuYmdDb2wpO6MoZYxuoNEDdHh0imMudHlwZaDRA2J0bopjLnR5cGWg0QNpbWeKYy50eXBloNEGY3VzdG9timMudHlwZSl7rHA9Yy5jO75jLmM7rGE90QFIK0UuQ1JDMzIoRS50b0pTKGMpKTtwnihjLmM9cCk7vmhbYV2gKChrW2FdPVtjLngsYy55LGMueCtjLnct1AEsYy55K2MuaC3UAV0pLmJnPbaKbj9nLnRoZW1lLmJnOm4sZJ4oZC5wdXNoKGMpLGQ9tikpfaMoYy5jKacorGLGYy5jKXUoYixoLGQsayxlKX1yLnByb3RvdHlwZS5zZXRVST2qKCl7QmFuZ2xlLnNldFVJKCk7rWM7ry5idXR0b25znihCYW5nbGUuc2V0VUkoe21vZGU60QZ1cGRvd24sYmFjazqvLm9wdGlvbnMuYmFjayxyZW1vdmU6ry5vcHRpb25zLnJlbW92ZX0saKJ7rGQ9ry5zZWxlY3RlZEJ1dHRvbixrPa8uYnV0dG9ucy5sZW5ndGg7oyjA04tonq8uYnV0dG9uc1tkXSmrry5idXR0b25zW2RdLmNiKCk7ry5idXR0b25zW2Rdnii+ry5idXR0b25zW2RdLnNlbGVjdGVkLK8ucmVuZGVyKK8uYnV0dG9uc1tkXSkpO2Q9KGQraytoKSVrO68uYnV0dG9uc1tkXZ4ory5idXR0b25zW2RdLnNlbGVjdGVkPdQBLK8ucmVuZGVyKK8uYnV0dG9uc1tkXSkpO68uc2VsZWN0ZWRCdXR0b249ZH0pLGM9IdMpOyGvLm9wdGlvbnMuYmFja54hry5vcHRpb25zLnJlbW92ZaBjoEJhbmdsZS5zZXRVSSh7bW9kZTrRBmN1c3RvbSxiYWNrOq8ub3B0aW9ucy5iYWNrLHJlbW92ZTqvLm9wdGlvbnMucmVtb3ZlfSk7oyivLmIpe6poKGQsayl7Ljc1PGsudGltZS1rLmxhc3RUaW1lnq8uYltkXS5jYmw/ry5iW2RdLmNibChrKTqvLmJbZF0uY2Kery5iW2RdLmNiKGspfUJhbmdsZS5idG5XYXRjaGVznkJhbmdsZS5idG5XYXRjaGVzLmZvckVhY2goY2xlYXJXYXRjaCk7QmFuZ2xlLmJ0bldhdGNoZXM9W107ry5iW9NdnkJhbmdsZS5idG5XYXRjaGVzLnB1c2goc2V0V2F0Y2goaC5iaW5kKK8s0yksQlROMSx7cmVwZWF0OiHTLGVkZ2U61P99KSk7ry5iW9QBXZ5CYW5nbGUuYnRuV2F0Y2hlcy5wdXNoKHNldFdhdGNoKGguYmluZCivLNQBKSxCVE4yLHtyZXBlYXQ6IdMsZWRnZTrU/30pKTuvLmJb1AJdnkJhbmdsZS5idG5XYXRjaGVzLnB1c2goc2V0V2F0Y2goaC5iaW5kKK8s1AIpLEJUTjMse3JlcGVhdDoh0yxlZGdlOtT/fSkpfaMo1AKKcHJvY2Vzcy5lbnYuSFdWRVJTSU9OKXuqaChkLGspe2QuY2Keay54kWQueJ5rLnmRZC55nmsueI5kLngrZC53nmsueY5kLnkrZC5onijUAoprLnR5cGWeZC5jYmw/ZC5jYmwoayk6ZC5jYp5kLmNiKGspKTtkLmOeZC5jLmZvckVhY2gobqJoKG4saykpfUJhbmdsZS50b3VjaEhhbmRsZXI9KGQsaymiaCivLl9sLGspO0JhbmdsZS5vbijRBXRvdWNoLEJhbmdsZS50b3VjaEhhbmRsZXIpfX07ci5wcm90b3R5cGUucmVuZGVyPaooYyl7qmgoYil70QNyYW07ZC5yZXNldCgpO8DTjWIuY29snmQuc2V0Q29sb3IoYi5jb2wpO8DTjWIuYmdDb2yeZC5zZXRCZ0NvbG9yKGIuYmdDb2wpLmNsZWFyUmVjdChiLngsYi55LGIueCtiLnct1AEsYi55K2IuaC3UASk7a1tiLnR5cGVdKGIpfWOgKGM9ry5fbCk7ry51cGRhdGVOZWVkZWSery51cGRhdGUoKTusZD1nLGs9eyIiOqooKXt9LHR4dDqqKGIpe9EDcmFtO6MoYi53cmFwKXusbD1kLnNldEZvbnQoYi5mb250KS5zZXRGb250QWxpZ24o0yzU/ykud3JhcFN0cmluZyhiLmxhYmVsLGIudyksbT1iLnkrKGIuaC1kLmdldEZvbnRIZWlnaHQoKSpsLmxlbmd0aJLUASk7ZC5kcmF3U3RyaW5nKGwuam9pbijRAQopLGIueCsoYi53ktQBKSxtKX2kZC5zZXRGb250KGIuZm9udCkuc2V0Rm9udEFsaWduKNMs0yxiLnIpLmRyYXdTdHJpbmcoYi5sYWJlbCxiLngrKGIud5LUASksYi55KyhiLmiS1AEpKX0sYnRuOqooYil70QNyYW07rGw9Yi54KyjTfGIucGFkKSxtPWIueSso03xiLnBhZCkscT1iLnctKGIucGFkj9QBKSxmPWIuaC0oYi5wYWSP1AEpO2w9W2wsbSvUBCxsK9QELG0sbCtxLdQFLG0sbCtxLdQBLG0r1AQsbCtxLdQBLG0rZi3UBSxsK3Et1AUsbStmLdQBLGwr1AQsbStmLdQBLGwsbStmLdQFLGwsbSvUBF07bT3A041iLmJ0bkJvcmRlckNvbD9iLmJ0bkJvcmRlckNvbDpkLnRoZW1lLmZnMjtxPcDTjWIuYnRuRmFjZUNvbD9iLmJ0bkZhY2VDb2w6ZC50aGVtZS5iZzI7Yi5zZWxlY3RlZJ4ocT1kLnRoZW1lLmJnSCxtPWQudGhlbWUuZmdIKTtkLnNldENvbG9yKHEpLmZpbGxQb2x5KGwpLnNldENvbG9yKG0pLmRyYXdQb2x5KGwpO8DTjWIuY29snmQuc2V0Q29sb3IoYi5jb2wpO2Iuc3JjP2Quc2V0QmdDb2xvcihxKS5kcmF3SW1hZ2Uo0QhmdW5jdGlvboq/Yi5zcmM/Yi5zcmMoKTpiLnNyYyxiLngrYi53L9QCLGIueStiLmgv1AIse3NjYWxlOmIuc2NhbGWgwNMscm90YXRlOi41Kk1hdGguUEkqKGIucqDTKX0pOmQuc2V0Rm9udChiLmZvbnSg0QU2eDg6Mikuc2V0Rm9udEFsaWduKNMs0yxiLnIpLmRyYXdTdHJpbmcoYi5sYWJlbCxiLngrYi53L9QCLGIueStiLmgv1AIpfSxpbWc6qihiKXvRA3JhbTtkLmRyYXdJbWFnZSjRCGZ1bmN0aW9uir9iLnNyYz9iLnNyYygpOmIuc3JjLGIueCtiLncv1AIsYi55K2IuaC/UAix7c2NhbGU6Yi5zY2FsZaDA0yxyb3RhdGU6LjUqTWF0aC5QSSooYi5yoNMpfSl9LGN1c3RvbTqqKGIpe9EDcmFtO2IucmVuZGVyKGIpfSxoOqooYil70QNyYW07Yi5jLmZvckVhY2goaCl9LHY6qihiKXvRA3JhbTtiLmMuZm9yRWFjaChoKX19O6Mory5sYXp5KXuvLnJlY3RzoCivLnJlY3RzPXt9KTusbj2vLnJlY3RzLmNsb25lKCksZT1bXTt1KGMsbixlLK8ucmVjdHMstik7pyiscLluKb6vLnJlY3RzW3BdO2M9T2JqZWN0LmtleXMobikubWFwKGKibltiXSkucmV2ZXJzZSgpO6corGHGYylkLnNldEJnQ29sb3IoYS5iZykuY2xlYXJSZWN0LmFwcGx5KGcsYSk7ZS5mb3JFYWNoKGgpfaRoKGMpfTtyLnByb3RvdHlwZS5mb3JnZXRMYXp5U3RhdGU9qigpe68ucmVjdHM9e319O3IucHJvdG90eXBlLmRlYnVnPaooYyxoKXtjoChjPa8uX2wpO2g9aKDUATtnLnNldENvbG9yKGgm1AEsaCbUAixoJtQEKS5kcmF3UmVjdChjLngraC3UASxjLnkraC3UASxjLngrYy53LWgsYy55K2MuaC1oKTtjLnBhZJ5nLmRyYXdSZWN0KGMueCtjLnBhZC3UASxjLnkrYy5wYWQt1AEsYy54K2Mudy1jLnBhZCxjLnkrYy5oLWMucGFkKTtomDtjLmOeYy5jLmZvckVhY2goZKKvLmRlYnVnKGQsaCkpfTtyLnByb3RvdHlwZS51cGRhdGU9qigpe6pjKGEpe9EDcmFtO25bYS50eXBlXShhKTujKGEucibUASl7rGI9YS5fdzthLl93PWEuX2g7YS5faD1ifWEuX3c9ZChhLl93KyhhLnBhZI/UASks03xhLndpZHRoKTthLl9oPWQoYS5faCsoYS5wYWSP1AEpLNN8YS5oZWlnaHQpfb6vLnVwZGF0ZU5lZWRlZDusaD1nLGQ9TWF0aC5tYXgsaz1NYXRoLnJvdW5kLG49e3R4dDqqKGEpe9EDcmFtO2EuZm9udC5lbmRzV2l0aCjRASUpnihhLmZvbnQ90QZWZWN0b3IrayhoLmdldEhlaWdodCgpKmEuZm9udC5zbGljZSjTLNT/KS/UZCkpO6MoYS53cmFwKWEuX2g9YS5fdz3TO6R7rGI9aC5zZXRGb250KGEuZm9udCkuc3RyaW5nTWV0cmljcyhhLmxhYmVsKTthLl93PWIud2lkdGg7YS5faD1iLmhlaWdodH19LGJ0bjqqKGEpe9EDcmFtO2EuZm9udJ5hLmZvbnQuZW5kc1dpdGgo0QElKZ4oYS5mb250PdEGVmVjdG9yK2soaC5nZXRIZWlnaHQoKSphLmZvbnQuc2xpY2Uo0yzU/ykv1GQpKTusYj1hLnNyYz9oLmltYWdlTWV0cmljcyjRCGZ1bmN0aW9uir9hLnNyYz9hLnNyYygpOmEuc3JjKTpoLnNldEZvbnQoYS5mb250oNEFNng4OjIpLnN0cmluZ01ldHJpY3MoYS5sYWJlbCk7YS5faD3UECtiLmhlaWdodDthLl93PdQUK2Iud2lkdGh9LGltZzqqKGEpe9EDcmFtO6xiPWguaW1hZ2VNZXRyaWNzKNEIZnVuY3Rpb26Kv2Euc3JjP2Euc3JjKCk6YS5zcmMpLGw9YS5zY2FsZaDUATthLl93PWIud2lkdGgqbDthLl9oPWIuaGVpZ2h0Kmx9LCIiOqooYSl70QNyYW07YS5fdz3TO2EuX2g9030sY3VzdG9tOqooYSl70QNyYW07YS5fdz3TO2EuX2g9030saDqqKGEpe9EDcmFtO2EuYy5mb3JFYWNoKGMpO2EuX2g9YS5jLnJlZHVjZSgoYixsKaJkKGIsbC5faCks0yk7YS5fX3c9YS5fdz1hLmMucmVkdWNlKChiLGwpomIrbC5fdyzTKTu2imEuZmlsbHieYS5jLnNvbWUoYqJiLmZpbGx4KZ4oYS5maWxseD3UASk7tophLmZpbGx5nmEuYy5zb21lKGKiYi5maWxseSmeKGEuZmlsbHk91AEpfSx2OqooYSl70QNyYW07YS5jLmZvckVhY2goYyk7YS5fX2g9YS5faD1hLmMucmVkdWNlKChiLGwpomIrbC5faCzTKTthLl93PWEuYy5yZWR1Y2UoKGIsbCmiZChiLGwuX3cpLNMpO7aKYS5maWxseJ5hLmMuc29tZShiomIuZmlsbHgpnihhLmZpbGx4PdQBKTu2imEuZmlsbHmeYS5jLnNvbWUoYqJiLmZpbGx5KZ4oYS5maWxseT3UASl9fSxlPa8uX2w7YyhlKTtlLmZpbGx4oGUuZmlsbHk/KGUudz1CYW5nbGUuYXBwUmVjdC53LGUuaD1CYW5nbGUuYXBwUmVjdC5oLGUueD1CYW5nbGUuYXBwUmVjdC54LGUueT1CYW5nbGUuYXBwUmVjdC55KTooZS53PWUuX3csZS5oPWUuX2gsZS54PUJhbmdsZS5hcHBSZWN0LnctZS53ktQBLGUueT1CYW5nbGUuYXBwUmVjdC55KyhCYW5nbGUuYXBwUmVjdC5oLWUuaJLUASkpO6xwPU1hdGguZmxvb3I7bj17aDqqKGEpe9EDcmFtO6xiPWEueCso03xhLnBhZCksbD3TLG09YS5jnmEuYy5yZWR1Y2UoKGYsdCmiZiso03x0LmZpbGx4KSzTKTttoChilmEudy0oYS5wYWSP1AEpLWEuX193ktQBLG091AEpO6xxPWI7YS5jLmZvckVhY2goZqJ7Zi54PdN8cTtilmYuX3c7bJbTfGYuZmlsbHg7cT1iK3AobCooYS53LWEuX3cpL20pO2Yudz3TfHEtZi54O2YuaD3TfChmLmZpbGx5P2EuaC0oYS5wYWSP1AEpOmYuX2gpO2YueT3TfGEueSso03xhLnBhZCkrKCjUASso03xmLnZhbGlnbikpKihhLmgtKGEucGFkj9QBKS1mLmgpktQBKTujKGYuYyluW2YudHlwZV0oZik7vmYuX3c7vmYuX2h9KTu+YS5fX3d9LHY6qihhKXvRA3JhbTusYj1hLnkrKNN8YS5wYWQpLGw90yxtPWEuY55hLmMucmVkdWNlKChmLHQpomYrKNN8dC5maWxseSks0yk7baAoYpZhLmgtKGEucGFkj9QBKS1hLl9faJLUASxtPdQBKTuscT1iO2EuYy5mb3JFYWNoKGaie2YueT3TfHE7YpZmLl9oO2yW03xmLmZpbGx5O3E9YitwKGwqKGEuaC1hLl9oKS9tKTtmLmg903xxLWYueTtmLnc903woZi5maWxseD9hLnctKGEucGFkj9QBKTpmLl93KTtmLng903xhLngrKNN8YS5wYWQpKygo1AErKNN8Zi5oYWxpZ24pKSooYS53LShhLnBhZI/UASktZi53KZLUASk7oyhmLmMpbltmLnR5cGVdKGYpO75mLl93O75mLl9ofSk7vmEuX19ofX07oyhuW2UudHlwZV0pbltlLnR5cGVdKGUpO75lLl93O75lLl9ofTtyLnByb3RvdHlwZS5jbGVhcj2qKGMpe2OgKGM9ry5fbCk7Zy5yZXNldCgpO8DTjWMuYmdDb2yeZy5zZXRCZ0NvbG9yKGMuYmdDb2wpO2cuY2xlYXJSZWN0KGMueCxjLnksYy54K2Mudy3UASxjLnkrYy5oLdQBKX07ZXhwb3J0cz1yAGlycQBmcmVxACVxJXMlcQBJbnZhbGlkIE9uZVdpcmUgZGV2aWNlIGFkZHJlc3MgJXEAVW5rbm93biBvcHRpb24gJXEAVW5zdXBwb3J0ZWQgdGltZXIgdHlwZSAlcQBVbmtub3duIG9wIHR5cGUgJXEAVW5rbm93biBkZXZpY2UgdHlwZSAlcQBVbmtub3duIHJhbmdlIG5hbWUgJXEAVW5hYmxlIHRvIGxvYWQgbW9kdWxlICVxACVzU3RyaW5nIFslZCBibG9ja3NdICVxAEludmFsaWQgZmxvdyBjb250cm9sOiAlcQBSZWdFeHAAaW5wdXRfcHVsbHVwAG9wZW5kcmFpbl9wdWxsdXAAYnBwAHN0b3AAQ09OVElOVUUgc3RhdGVtZW50IG91dHNpZGUgb2YgRk9SIG9yIFdISUxFIGxvb3AAQlJFQUsgc3RhdGVtZW50IG91dHNpZGUgb2YgU1dJVENILCBGT1Igb3IgV0hJTEUgbG9vcABmbGlwACNvbnN0ZXAAYmVlcAAjb250YXAAd3JhcABzZXRGb250Qml0bWFwAHdha2VPbkRvdWJsZVRhcAAjb25mYWNlVXAAd2FrZU9uRmFjZVVwAGF1dG8AY3J5cHRvAG1pc28AYmFybwD/c2NvAExpbWJvAP9uAGlucHV0X3B1bGxkb3duAP9ydG4AZXR1cm4AeG9uAGJ1dHRvbgBzZXR0aW5nLmpzb24AbG9uACNvbnVuY2F1Z2h0RXhjZXB0aW9uAGlycT10cnVlIHNldCwgYnV0IGZ1bmN0aW9uIGlzIG5vdCBhIG5hdGl2ZSBmdW5jdGlvbgBFZGl0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uAENhbiBvbmx5IHVzZSAnYXJndW1lbnRzJyB2YXJpYWJsZSBpbnNpZGUgYSBmdW5jdGlvbgBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24AQXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24ARnVuY3Rpb24AVmFyaWFibGUgdHlwZSAldCBub3Qgc3VpdGVkIHRvIHRyYW5zbWl0IG9wZXJhdGlvbgBkZXN0aW5hdGlvbgAjb24AbnBpbgBJbnZhbGlkIHBpbgAxMG1pbgBhZl9vcGVuZHJhaW4AUGluAP90aG4Ac2V0Rm9udEFsaWduAGZuAGV2ZW4AdGhlbgBib29sZWFuAFxuAC5ib290UG93ZXJPbgBudW0AVG9vIG1hbnkgcGlucyEgJWQgTWF4aW11bQBXYXZlZm9ybQBGdW5jdGlvbiBtYXJrZWQgd2l0aCAiY29tcGlsZWQiIHVwbG9hZGVkIGluIHNvdXJjZSBmb3JtAGJvdHRvbQBzZXRGb250Q3VzdG9tAHByb20AdHJpbQByYW0A/25hbQBzZXRGb250SW50bAByZXNsAGJvb2wAY2xrUG9sAG51bGwAI29ua2lsbABzZXRQaXhlbABDYW4ndCB1c2UgZmxvb2RGaWxsIG9uIEdyYXBoaWNzIHdpdGggbm8gZ2V0UGl4ZWwAaVNldFBpeGVsAGNoYW5uZWwAI29uYWNjZWwAc2NsAP92YWwASW52YWxpZCBpbnRlcnZhbABwb2xsSW50ZXJ2YWwAVW5rbm93biBJbnRlcnZhbABldmFsAHRvdGFsAFRlcm1pbmFsAHN3c2VyaWFsAFNlcmlhbABkYXJrAGNodW5rAGhlYXRzaHJpbmsAY2xrAHNjawAjb25sb2NrAHN0YWNrAGNhbGxiYWNrAHJlYWsAYmFzZSxqAElmIHNwZWNpZnlpbmcgYW4gb2JqZWN0LCBpdCBtdXN0IGJlIG9mIHRoZSBmb3JtIHtkYXRhIDogLi4uLCBjb3VudCA6IE59IG9yIHtjYWxsYmFjayA6IGZufSAtIGdvdCAlagBVbmtub3duIGZvbnQgJWoAVW5rbm93biBpbWFnZSB0eXBlICVqAEludmFsaWQgbW9kZSAlagBleHRpAG1vc2kAYm90aAAjb25oZWFsdGgAZW5kc1dpdGgASW52YWxpZCBhcnJheSBsZW5ndGgAZ2VzdHVyZU1pbkxlbmd0aABieXRlTGVuZ3RoAHdpZHRoACNvbmZpbmlzaABnZXN0dXJlU3RhcnRUaHJlc2gAZ2VzdHVyZUVuZFRocmVzaABsY2REb3VibGVSZWZyZXNoAC5zcGxhc2gARmxhc2gAc3RlcENvdW50ZXJUaHJlc2hvbGRIaWdoACNvbnRvdWNoAExDRF90b3VjaAB3YWtlT25Ub3VjaAB3aXRjaABVbmFibGUgdG8gc2V0IHdhdGNoLiBZb3UgbWF5IGFscmVhZHkgaGF2ZSBhIHdhdGNoIG9uIGEgcGluIHdpdGggdGhlIHNhbWUgbnVtYmVyIChlZy4gQTAgYW5kIEIwKSwKb3IgdGhpcyBwaW4gY2Fubm90IGJlIHVzZWQgd2l0aCB3YXRjaABGaWx0ZXIgbGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggdypoAGJyZwBhbmFsb2cAbWFudWFsV2F0Y2hkb2cAQXJyYXlCdWZmZXIgdG9vIGxvbmcAcmlzaW5nAFZhcmlhYmxlIHR5cGUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBzdHJpbmcARnVuY3Rpb24gY29kZSBpcyAldCwgbm90IGEgc3RyaW5nAHRvU3RyaW5nAFVURjhTdHJpbmcARmlyc3QgYXJndW1lbnQgbXVzdCBiZSBPYmplY3Qgb3IgU3RyaW5nAEV4cGVjdGluZyBTdHJpbmcARmlyc3QgYXJndW1lbnQgbXVzdCBiZSBTdHJpbmcAU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIFN0cmluZwBGb250IG11c3QgYmUgYSBTdHJpbmcARm9udCBiaXRtYXAgbXVzdCBiZSBhIFN0cmluZwBDYW4ndCBhbGxvY2F0ZSBtZW1vcnkgZm9yIGZpbHRlcmluZwBXYXZlZm9ybSBpcyBhbHJlYWR5IHJ1bm5pbmcAV2F2ZWZvcm0gaXMgbm90IHJ1bm5pbmcAI29uZnJhbWluZwBmYWxsaW5nACNvbmNoYXJnaW5nAC5sb2FkaW5nAGZnAHJiZwB6aWd6YWcAdGFnACNvbmRyYWcAI29ubWFnACNvbmVycm9yRmxhZwD/YnVmAHNmAHlwZW9mAG5zdGFuY2VvZgBJbGxlZ2FsIHJlc29sdmluZyB0byBzZWxmAGRpZmYAYWYAXGYASW52YWxpZCB0eXBlICV0IGZvciB2YWx1ZU9mAERvdWJsZSAlZgAsIGRlYm91bmNlIDogJWYAYmxvY2tzaXplAGJ5dGVzaXplAFRvbyBtdWNoIGRhdGEgZm9yIGZpbGUgc2l6ZQBjaHVua1NpemUASW52YWxpZCBTaXplAHJlbW92ZQBOYXRpdmUAd2F2ZQBwb3dlclNhdmUAQ2FuJ3QgaGF2ZSBhIGRhdGEgcGluIGFuZCBpcnE6dHJ1ZQBvbnRpbnVlAEludmFsaWQgY291bnQgdmFsdWUAVXNlZCBvbiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUAVW5rbm93biB0eXBlIG9mIGNhbGxiYWNrIGluIEV2ZW50IFF1ZXVlAGhlaWdodCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOCB3aGVuIHVzaW5nIHZlcnRpY2FsX2J5dGUAcGFsZXR0ZQBDYW4ndCBnZXQgcG9pbnRlciB0byBkYXRhIHRvIHdyaXRlACNvbmNvbXBsZXRlAGVsZXRlAHN0YXRlAHJvdGF0ZQBJbnZhbGlkIEkyQyBiaXRyYXRlAF9iYXVkcmF0ZQB2aWJyYXRlAEludmFsaWQgU1BJIGJhdWQgcmF0ZQBVbm1hdGNoZWQgVW5pY29kZSBzdXJyb2dhdGUARGF0ZQBjb21wb3NlAGNsb3NlAGZhbHNlAFByb21pc2UAYXNlACNvbmdlc3R1cmUASW52YWxpZCBTaWduYXR1cmUAbW9yZQBPbmVXaXJlAC5wcm90b3R5cGUAT3BlcmF0aW9uICVzIG5vdCBzdXBwb3J0ZWQgb24gdGhlICVzIGRhdGF0eXBlACNvbnN3aXBlAFBpcGUAbm9uZQBnY3RpbWUAbGFzdFRpbWUAdGhlbWUAZnJhbWUAbmFtZQBtb2R1bGUAaGlsZQBDYW4ndCBjcmVhdGUgemVybyBsZW5ndGggZmlsZQBVbmFibGUgdG8gZmluZCBvciBjcmVhdGUgZmlsZQBTdG9yYWdlRmlsZQBCYW5nbGUAZG91YmxlAERvdWJsZQB3cml0YWJsZQBjb25maWd1cmFibGUATXVzdCBiZSBjYWxsZWQgb24gc29tZXRoaW5nIGl0ZXJhYmxlAGVudW1lcmFibGUARmVhdHVyZSB1bmF2YWlsYWJsZQBzY2FsZQBsb2NhbGUAI29uc3Ryb2tlAEZpcnN0IGNoYXJhY3RlciBvdXQgb2YgcmFuZ2UAZWRnZQBiYXRGdWxsVm9sdGFnZQB1c2FnZQBtZXNzYWdlAFN0b3JhZ2UAaW1hZ2UARXhwZWN0aW5nIHZhbGlkIEltYWdlAGZyZWUAQ2FuJ3Qgd3JpdGUgaW4gdGhpcyBtb2RlAENhbid0IHJlYWQgaW4gdGhpcyBtb2RlAFVua25vd24gcGluIG1vZGUAaW5pdGNvZGUAYm9vdCBjb2RlAC5ib290Y2RlAHNvdXJjZQBmb3JjZQBkZWJvdW5jZQBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZQBzZXRMQ0RNb2RlIGlzIHVuc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlAHNUcmFjZQBjLGUAcHdkAGJhdWQAcGFzc3dvcmQARGVzdGluYXRpb24gU3RyZWFtIGRvZXMgbm90IGltcGxlbWVudCB0aGUgcmVxdWlyZWQgd3JpdGUoYnVmZmVyKSBtZXRob2QAU291cmNlIFN0cmVhbSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIHJlcXVpcmVkIHJlYWQobGVuZ3RoKSBtZXRob2QARGVzdGluYXRpb24gb2JqZWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgcmVxdWlyZWQgd3JpdGUoYnVmZmVyLCBsZW5ndGgpIG1ldGhvZABTb3VyY2Ugb2JqZWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgcmVxdWlyZWQgcmVhZChidWZmZXIsIGxlbmd0aCkgbWV0aG9kAP9jb2QATW9kdWxlICVxIG5vdCBmb3VuZABlbmQAdHdpc3RUaHJlc2hvbGQAb2lkAE5lc3RpbmcgJ25ldycgb3BlcmF0b3JzIGlzIHVuc3VwcG9ydGVkAENBU0UgYWZ0ZXIgREVGQVVMVCB1bnN1cHBvcnRlZABUYWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMgbm90IHN1cHBvcnRlZABCYWNrcmVmZXJlbmNlcyBub3Qgc3VwcG9ydGVkAFRhZ2dlZCBUZW1wbGF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQASW52YWxpZCBCUFAgLSAxLDIsNCBzdXBwb3J0ZWQAc3RhcnRlZABFbXVsYXRlZABuZWdhdGVkAGlycT10cnVlIHNldCwgYnV0IHdhdGNoIGlzIGFscmVhZHkgdXNlZABXYXZlZm9ybSBjb3VsZG4ndCBiZSBzdG9wcGVkAFNlY29uZCBhcmd1bWVudCBtdXN0IGJlIE9iamVjdCBvciB1bmRlZmluZWQARmlyc3QgYXJndW1lbnQgbXVzdCBiZSBTdHJpbmcgb3IgdW5kZWZpbmVkACdvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdCwgb3IgdW5kZWZpbmVkACVxIGlzIG5vdCBkZWZpbmVkAERhdGEgaXMgbm90IGRlZmluZWQAY29tcGlsZWQAQXV0aGVudGljYXRlZCBkZWNyeXB0aW9uIGZhaWxlZABzdGVwQ291bnRlckRpc2FibGVkAHNldE1vZGlmaWVkAE1vZHVsZXMuYWRkQ2FjaGVkAGhpc3BlZWQAb2RkAGFkZABsY2QAJ0UuYXNtJyBjYWxscyBzaG91bGQgaGF2ZSBiZWVuIHJlcGxhY2VkIGJ5IHRoZSBFc3BydWlubyB0b29scyBiZWZvcmUgdXBsb2FkACdFLmNvbXBpbGVkQycgY2FsbHMgc2hvdWxkIGhhdmUgYmVlbiByZXBsYWNlZCBieSB0aGUgRXNwcnVpbm8gdG9vbHMgYmVmb3JlIHVwbG9hZAAjb25wYWNrZXRVcGxvYWQAY2xlYXIlcyh1bmRlZmluZWQpIG5vdCBhbGxvd2VkLiBVc2UgY2xlYXIlcygpIGluc3RlYWQAY2xlYXJXYXRjaCh1bmRlZmluZWQpIG5vdCBhbGxvd2VkLiBVc2UgY2xlYXJXYXRjaCgpIGluc3RlYWQAcmVhZABsY2RPdnJJZAAlZC0lMDJkLSUwMmRUJTAyZDolMDJkOiUwMmQuJTAzZCVjJTA0ZAAlcyAlcyAlZCAlZCAlMDJkOiUwMmQ6JTAyZCBHTVQlYyUwNGQAJXM6JWR4JWQAJXM6JWQAJXY6JWQ6JWQASW52YWxpZCBwYXJpdHkgJWQAQXJyYXkgcGFzc2VkIHRvIEZ1bmN0aW9uLmFwcGx5IGlzIHRvbyBiaWchIE1heGltdW0gMjU2IGFyZ3VtZW50cywgZ290ICVkAEludGVnZXIgJWQARXJyb3IgUGFyc2luZyBzaWduYXR1cmUgYXQgYXJndW1lbnQgbnVtYmVyICVkAFVua25vd24gJWQAUGluICVkAEludmFsaWQgYmF1ZCByYXRlICVkAFVua25vd24gYXJnc3BlYyAlZACtYj1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QxzZXR0aW5nLmpzb24s1AEpoHt9LGM9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQoYi5sYXVuY2hlcik7oyghYyl7Yz3A0zutZD1yZXF1aXJlKNEHU3RvcmFnZSkubGlzdCgvXC5pbmZvJC8pLm1hcChhonujKChhPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTihhLNQBKSme0QZsYXVuY2iKYS50eXBlKathfSkuZmlsdGVyKGGiYSkuc29ydCgoYSxlKaJhLnNvcnRvcmRlci1lLnNvcnRvcmRlcilb0107ZJ4oYi5sYXVuY2hlcj1kLnNyYyxyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGVKU09OKNEMc2V0dGluZy5qc29uLGIpLGM9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQoZC5zcmMpKX1jP0JhbmdsZS5sb2FkKGIubGF1bmNoZXIpOmV2YWwo0WxFLnNob3dNZXNzYWdlKCJObyBMYXVuY2hlciBGb3VuZCIpO3NldFdhdGNoKCgpPT57bG9hZCgpO30sIGdsb2JhbC5CVE4yfHxCVE4sIHtyZXBlYXQ6ZmFsc2UsZWRnZToiZmFsbGluZyJ9KTspO75iO75jAFBhcmVudCBtdXN0IGJlIGFuIG9iamVjdCAtIG5vdCBhIFN0cmluZywgSW50ZWdlciwgZXRjAGZ1bmMAdGF0aWMAZ2MACCVjAG1zYgBsc2IAZ3JiAGF0b2IAcmdiAGNiADEyOjM0OjU2Ojc4OjkwOmFiAGEyYTdjNzNhYgBcYgBsY2RPdnJDYgB1c2VyZGF0YQAjb25kYXRhAEJhZCBpbnB1dCBkYXRhAEZpbGUgYWxyZWFkeSB3cml0dGVuIHdpdGggZGlmZmVyZW50IGRhdGEATm90IGVub3VnaCBzdGFjayBtZW1vcnkgZm9yIGRhdGEAaXJxRGF0YQBhcmVhAHNkYQB5LGEAZixhAGIsYQBfX3Byb3RvX18AX19GSUxFX18AW3Jhd10AW29iamVjdCBPYmplY3RdACV2WyVxXQA/WyVkXQBbRklMRU5BTUVfVEFCTEVdAFtFUkFTRURdACBdAFxcAC5cAG5ldyAlcyhbACVkLSUwMmQtJTAyZFQlMDJkOiUwMmQ6JTAyZC4lMDNkWgB0d2lzdE1heFkATUVNT1JZX0JVU1kATE9XX01FTU9SWQBPVVQgT0YgTUVNT1JZAC5ib290WABUWABVbmFibGUgdG8gYWxsb2NhdGUgZGF0YSBmb3IgU2VyaWFsIFJYAFVuYWJsZSB0byB3YXRjaCBwaW4gJXAsIG5vIFNvZnR3YXJlIFNlcmlhbCBSWABVTkZJTklTSEVEIFJFR0VYAP9mblcAVUFSVF9PVkVSRkxPVwBQS19USU1FT1VUAFBLX0ZUSU1FT1VUAFVTQVJUAFJPT1QASU5UAFVORklOSVNIRUQgQ09NTUVOVAAlcywgJWQgJXMgJWQgJTAyZDolMDJkOiUwMmQgR01UAEdJVF9DT01NSVQASW5zdWZmaWNpZW50IHN0YWNrIGZvciBjb21wdXRpbmcgRkZUAFNFVABGTE9BVABXSURHRVRTAEdQUwBNT0RVTEVTAEVYUFRSAEVSUk9SACVRAFdLVVAASW52YWxpZCBCUFAATUlTTwBOYU4AVU5LTk9XTgBOT1RfV09STgB0b0pTT04ASFdWRVJTSU9OAFRNRk4ASFJNAFRJTQBBRVMtMTI4LUNDTQBBRVMtMjU2LUNDTQBBRVMtMTkyLUNDTQBSQU0AUkVQTABOVUxMAEJVRkZFUl9GVUxMAEZJRk9fRlVMTABQS19JTABTQ0wAVU5GSU5JU0hFRCBURU1QTEFURSBMSVRFUkFMAFNFUklBTABTQ0sAQ0FMTEJBQ0sAG1tKAE1PU0kASW52YWxpZCBVUkkAU1BJLnNlbmQ4Yml0IG9ubHkgd29ya3Mgb24gaGFyZHdhcmUgU1BJAFNQSS5zZW5kNGJpdCBvbmx5IHdvcmtzIG9uIGhhcmR3YXJlIFNQSQD/Zm5IAGZnSABiZ0gAU1BJRkxBU0gAVU5GSU5JU0hFRCBTVFJJTkcAV0FMS0lORwBFT0YAc2V0Rm9udFBCRgBFWEVSQ0lTRQBDT05TT0xFAFBLX0ZJTEUAU1RPUkFHRQAbW0QAQk9BUkQASUQAG1tDAEVYRUMAREFDAEkyQwD/Zm5CAExvb3BiYWNrQgAbW0IAVVNCAEFFUy0xMjgtRUNCAEFFUy0yNTYtRUNCAEFFUy0xOTItRUNCAExvb3BiYWNrQQAbW0EAU0RBAFVuYWJsZSB0byBnZXQgcG9pbnRlciB0byBwYWxldHRlLiBJbWFnZSBpbiBmbGFzaD8ACiAgSW52YWxpZCBwYXNzd29yZApwYXNzd29yZD4APQB2YXIgbz17fSxhZGRyO2ZvciAodmFyIHJlZyBpbiBqKSB7YWRkcj1iYXNlK2pbcmVnXTtPYmplY3QuZGVmaW5lUHJvcGVydHkobyxyZWcse2dldDpwZWVrMzIuYmluZCh1bmRlZmluZWQsYWRkciksc2V0OnBva2UzMi5iaW5kKHVuZGVmaW5lZCxhZGRyKX0pO31yZXR1cm4gbzsAQmFuZ2xlLnNldExDRE92ZXJsYXkoR3JhcGhpY3MuY3JlYXRlQXJyYXlCdWZmZXIoMTYwLDQ0LDEse21zYjp0cnVlfSkuZHJhd1JlY3QoMCwwLDE1OSw0MykuZHJhd1JlY3QoMSwxLDE1OCw0Mikuc2V0Rm9udCgnMTJ4MjAnKS5zZXRGb250QWxpZ24oMCwwKS5kcmF3U3RyaW5nKCdQbGVhc2UgV2FpdCcsODAsMTQpLnNldENvbG9yKCcjODg4Jykuc2V0Rm9udCgnNng4JykuZHJhd1N0cmluZygnU1RPUkFHRSBDT01QQUNUSU9OXG5JTiBQUk9HUkVTUy4uLicsODAsMzIpLDgsNjYpO2cuZmxpcCgpOwBCYW5nbGUuc2V0TENET3ZlcmxheSgpO2cuZmxpcCgpOwBOZXdDaGlsZCBQQVJFTlQ6AAo6ADZ4OABXUjgAUkQ4ADJ2MjguNzgAMjgAMTcANHg2AFdSMTYAUkQxNgBwaW40AEhTQnRvUkdCJ3MgZm9ybWF0IGFyZyBleHBlY3RzIHVuZGVmaW5lZC8xLzE2LzI0ADE0AHBpbjMAd2FrZU9uQlROMwB5MgB4MgBidWZmZXIyAHBpbjIAZmcyAGJnMgB0b3VjaFkyAHRvdWNoWDIAd2FrZU9uQlROMgBFTVNDUklQVEVOMgBDSDIASW50bDoyADIyAHkxAHgxAP9mbjEAU2VyaWFsMQB0b3VjaFkxAHRvdWNoWDEAd2FrZU9uQlROMQBTUEkxAENIMQBMRUQxAEkyQzEAU2FtcGxlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwAGNodW5rU2l6ZSBtdXN0IGJlIGFuIGludGVnZXIgPiAwAEVycm9yIHByb2Nlc3NpbmcgU2VyaWFsIGRhdGEgaGFuZGxlciAtIHJlbW92aW5nIGl0LgBDdHJsLUMgd2hpbGUgcHJvY2Vzc2luZyBpbnRlcnZhbCAtIHJlbW92aW5nIGl0LgBDdHJsLUMgd2hpbGUgcHJvY2Vzc2luZyB3YXRjaCAtIHJlbW92aW5nIGl0LgBSRVRVUk4gc3RhdGVtZW50LCBidXQgbm90IGluIGEgZnVuY3Rpb24uAEVyYXNpbmcgc2F2ZWQgY29kZS4ATG9hZGluZy4uLgAtAEFycmF5LABPYmplY3QsACVxLABOdW1iZXIgJWosAFN0cmluZyAlaiwAJWQsJWQsJWQsAGRhdGE6aW1hZ2UvYm1wO2Jhc2U2NCwAQmFuZ2xlLnVpUmVtb3ZlPyhCYW5nbGUuc2V0VUkoKSwoX19GSUxFX189YSmgKGE90QguYm9vdGNkZSksQmFuZ2xlLnNob3dMb2FkaW5nU2NyZWVuKCksc2V0VGltZW91dChldmFsLNMscmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQoYSkpKTpsb2FkKNEILmJvb3RjZGWMYT9hOsDTKQCqcShrKXtnLnJlc2V0KCkuc2V0Rm9udEFsaWduKNMs0yk7rGg9QmFuZ2xlLmFwcFJlY3QsZD1oLnksYj1oLncsYz1nLmZpbmRGb250KGEudGl0bGWgIiIse3c6Yi3UAix3cmFwOtQBLG1heDrUGH0pO2MudGV4dD8oZy5zZXRDb2xvcihnLnRoZW1lLmZnSCkuc2V0QmdDb2xvcihnLnRoZW1lLmJnSCkuY2xlYXJSZWN0KNMsZCxiLdQBLGQr1AQrYy5oKS5kcmF3U3RyaW5nKGMudGV4dCxiL9QCLGQr1AQrYy5oL9QCKSxklmMuaCvUBCk6ZJbUBDusZj3TfNEHMDEyMzIzM1tlLmxlbmd0aF0sdT1NYXRoLmNlaWwoZS5sZW5ndGgvZiksdj0oYi3UASkvZixsPWEuYnV0dG9uSGVpZ2h0oCjUATx1oGEuaW1nP9QoOtQyKTtjPWgueTItKGQrdSpsKTujKGEuaW1nKXusbT1nLmltYWdlTWV0cmljcyhhLmltZyk7Zy5kcmF3SW1hZ2UoYS5pbWcsKGItbS53aWR0aCkv1AIsZCvUBik7Y5dtLmhlaWdodDtklm0uaGVpZ2h0fW09Zy5maW5kRm9udCh5LHt3OmIt1AIsaDpjLHdyYXA61AEsdHJpbTrUASxtaW461BB9KTtnLnNldENvbG9yKGcudGhlbWUuZmcpLnNldEJnQ29sb3IoZy50aGVtZS5iZykuZHJhd1N0cmluZyhtLnRleHQsYi/UAixkK2Mv1AIpO3c9W107ZS5mb3JFYWNoKCh4LHIponusbj1yJWYqdivUAixwPWgueTItKHUtKNN8ci9mKSkqbCvUASx0PXYt1AQsej1sLdQCO3cucHVzaCh7eDE6bi3UAix4MjpuK3Yt1AIseTE6cCx5MjpwK2x9KTt4PWcuZmluZEZvbnQoeCx7dzp0LdQELGg6bC3UBCx3cmFwOtQBfSk7Zy5zZXRCZ0NvbG9yKHKLaz9nLnRoZW1lLmJnSDpnLnRoZW1lLmJnMikuY2xlYXJSZWN0KHt4Om4r1AEseTpwK9QBLHc6dC3UAixoOnot1AIscjrUC30pLnNldENvbG9yKHKLaz9nLnRoZW1lLmZnSDpnLnRoZW1lLmZnMikuZHJhd1JlY3Qoe3g6bix5OnAsdzp0LGg6eixyOtQMfSkuZHJhd1N0cmluZyh4LnRleHQsbit0L9QCLHAr1AIrbC/UAil9KTtCYW5nbGUuc2V0TENEUG93ZXIo1AEpfWGgKGE9e30pO2EuYnV0dG9uc6AoYS5idXR0b25zPXtZZXM6IdMsTm86IdQBfSk7rGU9T2JqZWN0LmtleXMoYS5idXR0b25zKTujKNQGPGUubGVuZ3RoKbBFcnJvcijRCj42IGJ1dHRvbnMpO6x3O2cucmVzZXQoKS5jbGVhclJlY3QoQmFuZ2xlLmFwcFJlY3QpO6MoIXkpq0JhbmdsZS5zZXRVSSgpLFByb21pc2UucmVzb2x2ZSgpO3EoKTuruFByb21pc2Uoa6J7rGg9e21vZGU60QZjdXN0b20scmVtb3ZlOmEucmVtb3ZlLHJlZHJhdzpxLGJhY2s6YS5iYWNrLHRvdWNoOihkLGIpont3LmZvckVhY2goKGMsZimie2IueJFjLngxnmIueI5jLngynmIueZFjLnkxnmIueY5jLnkyniFiLmhpdJ4oYi5oaXQ9IdMscShmKSxnLmZsaXAoKSxFLnNob3dQcm9tcHQoKSzUAotiLnR5cGWeYS5idXR0b25zTG9uZ55lW2ZduWEuYnV0dG9uc0xvbmc/ayhhLmJ1dHRvbnNMb25nW2VbZl1dKTprKGEuYnV0dG9uc1tlW2ZdXSkpfSl9fTvUAYxlLmxlbmd0aKBhLmJhY2ugKGguYnRuPSgpontxKNMpO2cuZmxpcCgpO0Uuc2hvd1Byb21wdCgpO2soYS5idXR0b25zW2Vb011dKX0pO0JhbmdsZS5zZXRVSShoKX0pAFRpbWVvdXQgKHN0YXJ0KQBBcmJpdHJhdGlvbiAoc3RhcnQpACV2LmFwcGx5KHRoaXMsYXJndW1lbnRzKQBTZWFyY2ggc3RyaW5nIGlzIHRvbyBsb25nICg+PSVkIGNoYXJzKQBNb2R1bGUgbmFtZSB0b28gbG9uZyAobWF4IDEyOCBjaGFycykASW50ZXJ2YWwgaXMgdG9vIGxvbmcgKD4xMDAgeWVhcnMpAFRpbWVvdXQgKHdyKQBUaW1lb3V0IChzdG9wKQBBcmJpdHJhdGlvbiAoc3RvcCkAYXJncyBtdXN0IGJlIGFkZENhY2hlZChzdHJpbmcsIHN0cmluZ3xmdW5jdGlvbikAYnl0ZU9mZnNldCB0b28gbGFyZ2UgKG9yIG5lZ2F0aXZlKQBCYW5nbGUubG9hZCjRCC5ib290Y2RlKQBUaW1lb3V0IChyZCkAVG9vIG1hbnkgYXJndW1lbnRzICg+JWQpAG5ldyAlcyglZCkAJXMgKG9mZnMgJWQsIGxlbiAlZCkAQmFuZ2xlLnNldFVJKCk7Y2xlYXJUaW1lb3V0KCk7Y2xlYXJJbnRlcnZhbCgpO2NsZWFyV2F0Y2goKTtCYW5nbGUucmVtb3ZlQWxsTGlzdGVuZXJzKCk7RS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtOUkYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7QmFuZ2xlLnNldExDREJyaWdodG5lc3Mo1AEpO61hPXsiIjp7dGl0bGU60QhSZWNvdmVyeX0s0QpDbGVhbiBCb290OigpontyZXNldCgpfSxSZWJvb3Q6KCmie0UucmVib290KCl9LNEIVHVybiBPZmY6KCmie0JhbmdsZS5vZmYoKX19O9EJQkFOR0xFSlMyinByb2Nlc3MuZW52LkJPQVJEnk9iamVjdC5hc3NpZ24oYSx7VGVzdDpCYW5nbGUuc2hvd1Rlc3RTY3JlZW59KTtPYmplY3QuYXNzaWduKGEse9ENRmFjdG9yeSBSZXNldDooKaJ7RS5zaG93UHJvbXB0KNEoQXJlIHlvdSBzdXJlPwpUaGlzIHdpbGwgcmVtb3ZlIGFsbCBkYXRhLix7dGl0bGU60Q1GYWN0b3J5IFJlc2V0fSkudGhlbihionujKCFiKatCYW5nbGUuc2hvd1JlY292ZXJ5TWVudSgpO0Uuc2hvd01lc3NhZ2Uo0QlSZXNldHRpbmcpO0JhbmdsZS5zZXRMQ0RUaW1lb3V0KNMpO05SRi5nZXRTZWN1cml0eVN0YXR1cygpLmNvbm5lY3RlZKBUZXJtaW5hbC5zZXRDb25zb2xlKCk7QmFuZ2xlLmZhY3RvcnlSZXNldCgpfSl9LEV4aXQ6KCmie9M8cmVxdWlyZSjRB1N0b3JhZ2UpLmxpc3QoKS5sZW5ndGg/KEUuc2hvd01lc3NhZ2Uo0QpMb2FkaW5nLi4uKSxOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWSgVGVybWluYWwuc2V0Q29uc29sZSgpLGxvYWQoKSk6RS5yZWJvb3QoKX0s0Q9BdHRlbXB0IENvbXBhY3Q6KCmie0Uuc2hvd01lc3NhZ2Uo0R1Db21wYWN0aW5nLi4uCk1heSB0YWtlCjUgbWluLik7TlJGLmdldFNlY3VyaXR5U3RhdHVzKCkuY29ubmVjdGVkoFRlcm1pbmFsLnNldENvbnNvbGUoKTtyZXF1aXJlKNEHU3RvcmFnZSkuY29tcGFjdCgpO0UucmVib290KCl9LNESUmV3cml0ZSBCb290bG9hZGVyOigpontzZXRUaW1lb3V0KGxvYWQs1egDKTtldmFsKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKNENYm9vdHVwZGF0ZS5qcykpfX0pO0Uuc2hvd01lbnUoYSkAXSkAc2V0VGltZW91dChCYW5nbGUuc2hvd1JlY292ZXJ5TWVudSwxMDApAEVkaXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGVkaXQoZnVuY05hbWUpIG9yIGVkaXQoJ2Z1bmNOYW1lJykA0QZzdHJpbmeKv2GeKGE9e3RpdGxlOmF9KTthPWGge307rGI9QmFuZ2xlLmFwcFJlY3QsZD1iLnksZT1iLnc7Zy5yZXNldCgpLmNsZWFyUmVjdChiKS5zZXRGb250QWxpZ24o0yzTKTusYz1nLmZpbmRGb250KGEudGl0bGWgIiIse3c6ZS3UAix3cmFwOtQBLG1heDrUGH0pO2MudGV4dJ5nLnNldENvbG9yKGcudGhlbWUuZmdIKS5zZXRCZ0NvbG9yKGcudGhlbWUuYmdIKS5jbGVhclJlY3Qo0yxkLGUt1AEsZCvUBCtjLmgpLmRyYXdTdHJpbmcoYy50ZXh0LGUv1AIsZCvUBCtjLmgv1AIpO2SWYy5oK9QEO2I9Yi55Mi1kO6MoYS51cGxvYWRQcm9ncmVzcyl7YpfUEDtnLnNldENvbG9yKGcudGhlbWUuZmcpLmRyYXdSZWN0KHt4OtQKLHk6Zy5nZXRIZWlnaHQoKS3UEix3OmcuZ2V0V2lkdGgoKS3UFCxoOtQKLHI61B59KTusaD3TLGw9a6J7aJZrLmw7Zy5zZXRDb2xvcihnLnRoZW1lLmZnKS5maWxsUmVjdCh7eDrUCyx5OmcuZ2V0SGVpZ2h0KCkt1BEsdzooZy5nZXRXaWR0aCgpLdQWKSpoL2EudXBsb2FkUHJvZ3Jlc3MsaDrUCCxyOtQEfSl9O0Uub24o0QxwYWNrZXRVcGxvYWQsbCk7QmFuZ2xlLnNldFVJKHttb2RlOtEGY3VzdG9tLHJlbW92ZTprokUucmVtb3ZlTGlzdGVuZXIo0QxwYWNrZXRVcGxvYWQsbCl9KX1hLmltZ54oYz1nLmltYWdlTWV0cmljcyhhLmltZyksZy5yZXNldCgpLmRyYXdJbWFnZShhLmltZywoZS1jLndpZHRoKS/UAixkK9QGKSxil2MuaGVpZ2h0LGSWYy5oZWlnaHQpO8DTjWaeKGY9Zy5maW5kRm9udChmLHt3OmUt1AIsaDpiLHdyYXA61AEsdHJpbTrUASxtaW461BB9KSxnLnNldENvbG9yKGcudGhlbWUuZmcpLnNldEJnQ29sb3IoZy50aGVtZS5iZykuc2V0Rm9udEFsaWduKNMs0ykuZHJhd1N0cmluZyhmLnRleHQsZS/UAixkK2Iv1AIpKTtnLmZsaXAoKTtCYW5nbGUuc2V0TENEUG93ZXIo1AEpAHNldFRpbWVvdXQoAHNldEludGVydmFsKAAucmVwbGFjZVdpdGgoAHNldFdhdGNoKAAgKABGdW5jdGlvbiBjb2RlIG11c3QgYmUgYSBTdHJpbmcsIGdvdCAnJXQnAFN0cmluZzonJXMnACwgJWosIHsgcmVwZWF0OiVzLCBlZGdlOiclcycAJ2VkZ2UnIGluIHNldFdhdGNoIHNob3VsZCBiZSAxLCAtMSwgMCwgJ3Jpc2luZycsICdmYWxsaW5nJyBvciAnYm90aCcAU1BJIG9yZGVyIHNob3VsZCBiZSAnbXNiJyBvciAnbHNiJwBJZiBDb2xvciBpcyBhIFN0cmluZywgaXQgbXVzdCBiZSBvZiB0aGUgZm9ybSAnI3JyZ2diYicgb3IgJyNyZ2InAC5bXSgpfF4qKyQAIwBcIgBGaWxlIHRvbyBiaWchAEZ1bmN0aW9uICVxIG5vdCBmb3VuZCEARnVuY3Rpb24gbm90IGZvdW5kIQBGdW5jdGlvbiBvciBTdHJpbmcgbm90IHN1cHBsaWVkIQBPYmplY3QgeyAAR2V0dGVyL1NldHRlciB7IABGdW5jdGlvbiB7IABOYXRpdmVGdW5jdGlvbiAweCV4ICglZCkgeyAAICAgIGF0IABQYXJhbSAlcSAAcmV0dXJuIABmdW5jdGlvbiAATmFtZSAAIyVkW3IlZCxsJWRdIABBcnJheUJ1ZmZlck5hbWVbJWRdIABBcnJheSglZCkgWyAAIENPTlNUIAAldi4ldiA9IAB2YXIgJXYgPSAAJXY6IABFUlJPUjogAFdBUk5JTkc6IABDSElMRDogAFdyaXRpbmcgaW5pdGlhbCBzdG9yYWdlIGNvbnRlbnRzLi4uIABDb21wYWN0aW5nLi4uIAAgLi4uIAAldi5vbiglcSwgACkgACAgICAAewogIAAIIABmbG9vZEZpbGwgb3ZlcmZsb3cKAFVuY2F1Z2h0ICV2CgBOZXcgaW50ZXJwcmV0ZXIgZXJyb3I6ICV2CgAsICVmKTsgLy8gJXYKAApBbiBVbmNhdWdodCBFcnJvciBoYXMgYmVlbiBzYXZlZCB0byBTdG9yYWdlLiBQbGVhc2UgdHlwZToKICByZXF1aXJlKCdTdG9yYWdlJykucmVhZCgnRVJST1InKSB0byB2aWV3IGl0CiAgcmVxdWlyZSgnU3RvcmFnZScpLmVyYXNlKCdFUlJPUicpIHRvIGNsZWFyIGl0CgBMZXNzIHRoYW4gMTAgcGVyY2VudCBiYXR0ZXJ5IHJlbWFpbmluZyAtIGNhbm5vdCBjb21wYWN0CgBFc3BydWlubyAlcyAlcwoAID0gYm9vbCAlcwoALT4gJXMKADwtICVzCgAbWz83bAogX19fXyAgICAgICAgICAgICAgICAgXyAKfCAgX198X19fIF9fXyBfX18gXyBffF98X19fIF9fXyAKfCAgX198XyAtfCAuIHwgIF98IHwgfCB8ICAgfCAuIHwKfF9fX198X19ffCAgX3xffCB8X19ffF98X3xffF9fX3wKICAgICAgICAgfF98IGVzcHJ1aW5vLmNvbQogMnYyOC43OCAoYykgMjAyNSBHLldpbGxpYW1zCgpFc3BydWlubyBpcyBPcGVuIFNvdXJjZS4gT3VyIHdvcmsgaXMgc3VwcG9ydGVkCm9ubHkgYnkgc2FsZXMgb2Ygb2ZmaWNpYWwgYm9hcmRzIGFuZCBkb25hdGlvbnM6Cmh0dHA6Ly9lc3BydWluby5jb20vRG9uYXRlCgAvLyBDb2RlIHNhdmVkIHdpdGggRS5zZXRCb290Q29kZQoATm90IGltcGxlbWVudGVkIGluIHRoaXMgYnVpbGQKAEV4ZWN1dGlvbiBJbnRlcnJ1cHRlZAoAID0gaW50ICVkCgBDb3VsZG4ndCBjb252ZXJ0IHBpbiBmdW5jdGlvbiAlZAoAXgoAIH0pOwoAT2JqZWN0LmNyZWF0ZSgldik7CgAKICBMb2dnZWQgaW4uCgBFeGVjdXRpb24gSW50ZXJydXB0ZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmcuCgAKV3JpdGUgY29tcGxldGUuCgBFcmFzZSBjb21wbGV0ZS4KAHJlZixzaXplLGZsYWdzLG5hbWUsbGlua3MuLi4KAEVyYXNpbmcgU3RvcmFnZSBBcmVhLi4uCgBSdW5uaW5nIG9uSW5pdCgpLi4uCgApCgBJbml0aWFsIHN0b3JhZ2UgaXMgdG9vIGxhcmdlIHRvIGZpdCBpbiBpbnRlcm5hbCBTUEkgZmxhc2ghCgAKRG9uZSEKAAoKAAAArMwB");
  base64DecodeToExistingUint8Array(bufferView, 28768, "MAAAAC5ib290MA==");
  base64DecodeToExistingUint8Array(bufferView, 28800, "CmV2YWwocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0Q1ib290dXBkYXRlLmpzKSk79wIAAC5ib290Y2Rl");
  base64DecodeToExistingUint8Array(bufferView, 28880, "CqxzPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDHNldHRpbmcuanNvbizUASmge307CqMoZ2xvYmFsLl9fRklMRV9fniFzLmNsb2NrSGFzV2lkZ2V0cyl7bG9hZCgpO7DRJUNsb2NrIGhhcyBubyB3aWRnZXRzLCBjYW4ndCBmYXN0IGxvYWQ7fQqsX2Nsa0FwcD1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZChzLmNsb2NrKTsKoyghX2Nsa0FwcCl7X2Nsa0FwcD1yZXF1aXJlKNEHU3RvcmFnZSkubGlzdCgvXC5pbmZvJC8pLm1hcChmaWxlonuuYXBwPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTihmaWxlLNQBKTujKGFwcJ5hcHAudHlwZYrRBWNsb2NrKXurYXBwO319KS5maWx0ZXIoeKJ4KS5zb3J0KChhLGIpomEuc29ydG9yZGVyLWIuc29ydG9yZGVyKVvTXTujKF9jbGtBcHApe3MuY2xvY2s9X2Nsa0FwcC5zcmM7X2Nsa0FwcD1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZChfY2xrQXBwLnNyYyk7cy5jbG9ja0hhc1dpZGdldHM9X2Nsa0FwcC5pbmNsdWRlcyjREkJhbmdsZS5sb2FkV2lkZ2V0cyk7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlSlNPTijRDHNldHRpbmcuanNvbixzKTt9fQqjKHMuY2xvY2spX19GSUxFX189cy5jbG9jazsKvnM7CqMoIV9jbGtBcHApX2Nsa0FwcD3ReEUuc2hvd01lc3NhZ2UoIk5vIENsb2NrIEZvdW5kIik7c2V0V2F0Y2goKCk9PntCYW5nbGUuc2hvd0xhdW5jaGVyKCk7fSwgZ2xvYmFsLkJUTjJ8fEJUTiwge3JlcGVhdDpmYWxzZSxlZGdlOiJmYWxsaW5nIn0pOzsKZXZhbChfY2xrQXBwKTsKvl9jbGtBcHA7/1YdAABib290dXBkYXRlLmpz");
  base64DecodeToExistingUint8Array(bufferView, 29672, "e0Uuc2hvd01lc3NhZ2Uo0RFVcGRhdGluZyBib290MC4uLik7rXM9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEMc2V0dGluZy5qc29uLNQBKaB7fTuuRldWRVJTSU9OPXBhcnNlRmxvYXQocHJvY2Vzcy5lbnYuVkVSU0lPTi5yZXBsYWNlKNEBdiwiIikucmVwbGFjZSgvXC4oXGRcZCkkLyzRBC4wJDEpKTuuREVCVUc9cy5ib290RGVidWc7rWJvb3Q9IiIsYm9vdFBvc3Q9IiI7oyhERUJVRyl7Ym9vdJbRE3ZhciBfdG09RGF0ZS5ub3coKQo7Ym9vdFBvc3SW0QtkZWxldGUgX3RtOzt9oyhGV1ZFUlNJT0481dgAKXtFLnNob3dNZXNzYWdlKNEsUGxlYXNlIHVwZGF0ZSBCYW5nbGUuanMgZmlybXdhcmUKCkN1cnJlbnQgPSArcHJvY2Vzcy5lbnYuVkVSU0lPTix7dGl0bGU60QVFUlJPUn0pO7C4RXJyb3Io0QxPbGQgZmlybXdhcmUpO32tQ1JDPUUuQ1JDMzIocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0QxzZXR0aW5nLmpzb24pKStyZXF1aXJlKNEHU3RvcmFnZSkuaGFzaCgvXC5qcyQvKStFLkNSQzMyKHByb2Nlc3MuZW52LkdJVF9DT01NSVQpO2Jvb3SWYGlmKEUuQ1JDMzIocmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoJ3NldHRpbmcuanNvbicpKStyZXF1aXJlKCdTdG9yYWdlJykuaGFzaCgvXFwuanMkLykrRS5DUkMzMihwcm9jZXNzLmVudi5HSVRfQ09NTUlUKSE9JHtDUkN9KWA7Ym9vdJbRNWV2YWwocmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoJ2Jvb3R1cGRhdGUuanMnKSk7ZWxzZXsKO2Jvb3SW0U1FLnNldEZsYWdzKHtwcmV0b2tlbmlzZToxfSk7dmFyIGJsZVNlcnZpY2VzPXt9LGJsZVNlcnZpY2VPcHRpb25zPXt1YXJ0OnRydWV9Oztib290UG9zdJbRVU5SRi5zZXRTZXJ2aWNlcyhibGVTZXJ2aWNlcyxibGVTZXJ2aWNlT3B0aW9ucyk7ZGVsZXRlIGJsZVNlcnZpY2VzLGJsZVNlcnZpY2VPcHRpb25zOwo7oyhzLmJsZY21KXujKHMuSElEKXujKHMuSElEitEDam95KWJvb3SW0WpCYW5nbGUuSElEID0gRS50b1VpbnQ4QXJyYXkoYXRvYigiQlFFSkJLRUJDUUdoQUFVSkdRRXBCUlVBSlFHVkJYVUJnUUtWQTNVQmdRTUZBUWt3Q1RFVmdTVi9kUWlWQW9FQ3dNQT0iKSk7O6SjKHMuSElEitEDY29tKWJvb3SW0b5CYW5nbGUuSElEID0gRS50b1VpbnQ4QXJyYXkoYXRvYigiQlFFSkFxRUJoUUVKQWFFQUJRa1pBU2tGRlFBbEFaVUZkUUdCQXBVQmRRT0JBd1VCQ1RBSk1RazRGWUVsZjNVSWxRT0JCZ1VNQ2pnQ0ZZRWxmM1VJbFFHQkJzREFCUUVKQnFFQmhRSUZCeG5nS2VjVkFDVUJkUUdWQ0lFQ2RRaVZBWUVCR1FBcGN4VUFKWE9WQlhVSWdRREEiKSk7pKMocy5ISUSK0QJrYilib290ltGOQmFuZ2xlLkhJRCA9IEUudG9VaW50OEFycmF5KGF0b2IoIkJRRUpCcUVCQlFjWjRDbm5GUUFsQVhVQmxRaUJBcFVCZFFpQkFaVUZkUUVGQ0JrQktRV1JBcFVCZFFPUkFaVUdkUWdWQUNWekJRY1pBQ2x6Z1FBSkJSVUFKdjhBZFFpVkFyRUN3QT09IikpO6Rib290ltHSQmFuZ2xlLkhJRCA9IEUudG9VaW50OEFycmF5KGF0b2IoIkJRRUpCcUVCaFFJRkJ4bmdLZWNWQUNVQmRRR1ZDSUVDbFFGMUNJRUJsUVYxQVFVSUdRRXBCWkVDbFFGMUE1RUJsUVoxQ0JVQUpYTUZCeGtBS1hPQkFBa0ZGUUFtL3dCMUNKVUNzUUxBQlF3SkFhRUJoUUVWQUNVQmRRR1ZBUW0xZ1FJSnRvRUNDYmVCQWdtNGdRSUp6WUVDQ2VLQkFnbnBnUUlKNm9FQ3dBPT0iKSk7O2Jvb3SW0SJibGVTZXJ2aWNlT3B0aW9ucy5oaWQ9QmFuZ2xlLkhJRDsKO319oyhzLmJsZXJlcGyLtSl7oyhzLmxvZ5HUAil7Ym9vdJZgX0RCR0xPRz1yZXF1aXJlKCJTdG9yYWdlIikub3BlbigibG9nLnR4dCIsImEiKTsKTG9vcGJhY2tCLm9uKCdkYXRhJyxmdW5jdGlvbihkKSB7X0RCR0xPRy53cml0ZShkKTskeyhzLmxvZz09Myk/IlRlcm1pbmFsLndyaXRlKGQpOyI6IiJ9fSk7Ckxvb3BiYWNrQS5zZXRDb25zb2xlKHRydWUpO1xuYDt9pKMocy5sb2eK1AEpYm9vdJbRG1Rlcm1pbmFsLnNldENvbnNvbGUodHJ1ZSk7CjukYm9vdJbRIUUuc2V0Q29uc29sZShudWxsLHtmb3JjZTp0cnVlfSk7Cjtib290ltJ4AQpCbHVldG9vdGgubGluZT0iIjsKQmx1ZXRvb3RoLm9uKCdkYXRhJyxmdW5jdGlvbihkKSB7CiAgbGV0IGwgPSAoQmx1ZXRvb3RoLmxpbmUgKyBkKS5zcGxpdCgvW1xuXHJdLyk7CiAgQmx1ZXRvb3RoLmxpbmUgPSBsLnBvcCgpOwogIGwuZm9yRWFjaChuPT5CbHVldG9vdGguZW1pdCgibGluZSIsbikpOwp9KTsKQmx1ZXRvb3RoLm9uKCdsaW5lJyxmdW5jdGlvbihsKSB7CiAgaWYgKGwuc3RhcnRzV2l0aCgnECcpKSBsPWwuc2xpY2UoMSk7CiAgaWYgKGwuc3RhcnRzV2l0aCgnR0IoeycpICYmIGwuZW5kc1dpdGgoJ30pJykgJiYgZ2xvYmFsLkdCKQogICAgdHJ5IHsgZ2xvYmFsLkdCKEpTT04ucGFyc2UobC5zbGljZSgzLC0xKSkpOyB9IGNhdGNoKGUpIHt9Cn0pOwo7faR7oyhzLmxvZ5HUAilib290lmBfREJHTE9HPXJlcXVpcmUoIlN0b3JhZ2UiKS5vcGVuKCJsb2cudHh0IiwiYSIpOwpMb29wYmFja0Iub24oJ2RhdGEnLGZ1bmN0aW9uKGQpIHtfREJHTE9HLndyaXRlKGQpOyR7KHMubG9nPT0zKT8iVGVybWluYWwud3JpdGUoZCk7IjoiIn19KTsKaWYgKCFOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWQpIExvb3BiYWNrQS5zZXRDb25zb2xlKCk7XG5gO6SjKHMubG9nitQBKWJvb3SW0T9pZiAoIU5SRi5nZXRTZWN1cml0eVN0YXR1cygpLmNvbm5lY3RlZCkgVGVybWluYWwuc2V0Q29uc29sZSgpOwo7pGJvb3SW0RxCbHVldG9vdGguc2V0Q29uc29sZSh0cnVlKTsKO32jKHMuYmxli7UpYm9vdJbRNWlmICghTlJGLmdldFNlY3VyaXR5U3RhdHVzKCkuY29ubmVjdGVkKSBOUkYuc2xlZXAoKTsKO6Mocy50aW1lb3V0jbcpYm9vdJZgQmFuZ2xlLnNldExDRFRpbWVvdXQoJHtzLnRpbWVvdXR9KTtcbmA7oyghcy50aW1lb3V0KWJvb3SW0RdCYW5nbGUuc2V0TENEUG93ZXIoMSk7Cjtib290lmBFLnNldFRpbWVab25lKCR7cy50aW1lem9uZX0pO2A7oyhzLmxvZylib290ltHtRS5vbignZXJyb3JGbGFnJywgZnVuY3Rpb24oZXJyb3JGbGFncykgewogIGcucmVzZXQoMSkuc2V0Q29sb3IoIiNmZjAwMDAiKS5zZXRGb250KCI2eDgiKS5zZXRGb250QWxpZ24oMCwxKS5kcmF3U3RyaW5nKGVycm9yRmxhZ3MsZy5nZXRXaWR0aCgpLzIsZy5nZXRIZWlnaHQoKS0xKS5mbGlwKCk7CiAgcHJpbnQoIkludGVycHJldGVyIGVycm9yOiIsIGVycm9yRmxhZ3MpOwogIEUuZ2V0RXJyb3JGbGFncygpOwp9KTsKO6MoZ2xvYmFsLnNhdmUpYm9vdJbRd2dsb2JhbC5zYXZlID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcigiWW91IGNhbid0IHVzZSBzYXZlKCkgb24gQmFuZ2xlLmpzIHdpdGhvdXQgb3ZlcndyaXRpbmcgdGhlIGJvb3Rsb2FkZXIhIik7IH0KO6Mocy5vcHRpb25zKWJvb3SWYEJhbmdsZS5zZXRPcHRpb25zKCR7RS50b0pTKHMub3B0aW9ucyl9KTtcbmA7oyhzLmJyaWdodG5lc3ONt55zLmJyaWdodG5lc3OM1AEpYm9vdJZgQmFuZ2xlLnNldExDREJyaWdodG5lc3MoJHtzLmJyaWdodG5lc3N9KTtcbmA7oyhzLmJsZXByaXZhY3mgKHMucGFzc2tleY23nnMucGFzc2tleS5sZW5ndGiK1AYpKXutcGFzc2tleT1zLnBhc3NrZXk/YHBhc3NrZXk6JHtFLnRvSlMocy5wYXNza2V5LnRvU3RyaW5nKCkpfSxkaXNwbGF5OjEsbWl0bToxLGA6IiI7rXByaXZhY3k9cy5ibGVwcml2YWN5P2Bwcml2YWN5OiR7RS50b0pTKHMuYmxlcHJpdmFjeSl9LGA6IiI7Ym9vdJZgTlJGLnNldFNlY3VyaXR5KHske3Bhc3NrZXl9JHtwcml2YWN5fX0pO1xuYDt9oyhzLmJsZW5hbWWLtSlib290ltEpTlJGLnNldEFkdmVydGlzaW5nKHt9LHtzaG93TmFtZTpmYWxzZX0pOwo7oyhzLndoaXRlbGlzdJ4hcy53aGl0ZWxpc3RfZGlzYWJsZWQpYm9vdJbSYAFOUkYub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbihhZGRyKSB7IGlmICghTlJGLmlnbm9yZVdoaXRlbGlzdCkgeyBsZXQgd2hpdGVsaXN0ID0gKHJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTignc2V0dGluZy5qc29uJywxKXx8e30pLndoaXRlbGlzdDsgaWYgKE5SRi5yZXNvbHZlQWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7IGxldCByZXNvbHZlZEFkZHIgPSBOUkYucmVzb2x2ZUFkZHJlc3MoYWRkcik7IGlmIChyZXNvbHZlZEFkZHIgIT09IHVuZGVmaW5lZCkgYWRkciA9IHJlc29sdmVkQWRkciArICIgKHJlc29sdmVkKSI7IH0gaWYgKCF3aGl0ZWxpc3QuaW5jbHVkZXMoYWRkcikpIE5SRi5kaXNjb25uZWN0KCk7IH19KTsKO6Mocy5yb3RhdGUpYm9vdJZgZy5zZXRSb3RhdGlvbigke3Mucm90YXRlJjN9LCR7cy5yb3RhdGU+PjJ9KTtcbmBib290ltFeQmFuZ2xlLmxvYWRXaWRnZXRzPWZ1bmN0aW9uKCl7aWYoIWdsb2JhbC5XSURHRVRTKWV2YWwocmVxdWlyZSgiU3RvcmFnZSIpLnJlYWQoIi53aWRjYWNoZSIpKX07Cju+QmFuZ2xlLnNob3dDbG9jazujKCFCYW5nbGUuc2hvd0Nsb2NrKWJvb3SW0StCYW5nbGUuc2hvd0Nsb2NrID0gKCk9Pntsb2FkKCIuYm9vdGNkZSIpfTsKO75CYW5nbGUubG9hZDujKCFCYW5nbGUubG9hZClib290ltEUQmFuZ2xlLmxvYWQgPSBsb2FkOwo7oyhERUJVRylib290ltE4cHJpbnQoIi5ib290MCIsMHwoRGF0ZS5ub3coKS1fdG0pLCJtcyIpO190bT1EYXRlLm5vdygpOwqtYm9vdEZpbGVzPXJlcXVpcmUo0QdTdG9yYWdlKS5saXN0KC9cLmJvb3RcLmpzJC8pLnNvcnQoKGEsYimie61nZXRQcmlvcml0eT0vLipcLihcZCspXC5ib290XC5qcyQvO61hUHJpb3JpdHk9YS5tYXRjaChnZXRQcmlvcml0eSk7rWJQcmlvcml0eT1iLm1hdGNoKGdldFByaW9yaXR5KTujKGFQcmlvcml0eZ5iUHJpb3JpdHkpe6twYXJzZUludChhUHJpb3JpdHlb1AFdKS1wYXJzZUludChiUHJpb3JpdHlb1AFdKTt9pKMoYVByaW9yaXR5niFiUHJpb3JpdHkpe6st1AE7faSjKCFhUHJpb3JpdHmeYlByaW9yaXR5KXur1AE7fathimI/0zooYT5iP9QBOtT/KTt9KTtib290UG9zdJbRAX07rWZpbGVPZmZzZXQsZmlsZVNpemU7rW91dHB1dEZpbGU9KGRzdCxzcmMscHJlLHBvc3QponvRA3JhbTujKERFQlVHKXujKGRzdClyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUoZHN0LGAvLyR7c3JjfVxuYCxmaWxlT2Zmc2V0KTtmaWxlT2Zmc2V0ltQCK3NyYy5sZW5ndGgr1AE7faMocHJlKXujKGRzdClyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUoZHN0LHByZSxmaWxlT2Zmc2V0KTtmaWxlT2Zmc2V0lnByZS5sZW5ndGg7fa1mPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKHNyYyk7oyhzcmMuZW5kc1dpdGgo0QpjbGtpbmZvLmpzKZ5mW9NdjNEBKCl7Zj1gZXZhbChyZXF1aXJlKCdTdG9yYWdlJykucmVhZCgke0UudG9KUyhzcmMpfSkpYDt9oyhkc3Qpe61sZW49Zi5sZW5ndGg7rW9mZnNldD3TO6YobGVuKXutY2h1bms9TWF0aC5taW4obGVuLNUACCk7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKGRzdCxmLnN1YnN0cihvZmZzZXQsY2h1bmspLGZpbGVPZmZzZXQpO2ZpbGVPZmZzZXSWY2h1bms7b2Zmc2V0lmNodW5rO2xlbpdjaHVuazt9faRmaWxlT2Zmc2V0lmYubGVuZ3RoO6MoZHN0KXJlcXVpcmUo0QdTdG9yYWdlKS53cml0ZShkc3QscG9zdCxmaWxlT2Zmc2V0KTtmaWxlT2Zmc2V0lnBvc3QubGVuZ3RoO6MoREVCVUcpe6MoZHN0KXJlcXVpcmUo0QdTdG9yYWdlKS53cml0ZShkc3QsYHByaW50KCR7RS50b0pTKHNyYyl9LDB8KERhdGUubm93KCktX3RtKSwibXMiKTtfdG09RGF0ZS5ub3coKTtcbmAsZmlsZU9mZnNldCk7ZmlsZU9mZnNldJbUMCtFLnRvSlMoc3JjKS5sZW5ndGg7fX07rW91dHB1dEZpbGVDb21wbGV0ZT0oZHN0LGZuKaJ7b3V0cHV0RmlsZShkc3QsZm4sIiIs0QI7Cik7fTtmaWxlT2Zmc2V0PWJvb3QubGVuZ3RoK2Jvb3RQb3N0Lmxlbmd0aDtib290RmlsZXMuZm9yRWFjaChmbqJvdXRwdXRGaWxlQ29tcGxldGUotyxmbikpO2ZpbGVTaXplPWZpbGVPZmZzZXQ7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNEGLmJvb3QwLGJvb3Qs0yxmaWxlU2l6ZSk7ZmlsZU9mZnNldD1ib290Lmxlbmd0aDtib290RmlsZXMuZm9yRWFjaChmbqJvdXRwdXRGaWxlQ29tcGxldGUo0QYuYm9vdDAsZm4pKTtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUo0QYuYm9vdDAsYm9vdFBvc3QsZmlsZU9mZnNldCk7vmJvb3QsYm9vdFBvc3QsYm9vdEZpbGVzO613aWRnZXRGaWxlcz1yZXF1aXJlKNEHU3RvcmFnZSkubGlzdCgvXC53aWRcLmpzJC8pO613aWRnZXQ90SsvLyBNYWRlIGJ5IGJvb3R1cGRhdGUuanMKZ2xvYmFsLldJREdFVFM9e307LHdpZGdldFBvc3Q90Xh2YXIgVz1XSURHRVRTO1dJREdFVFM9e307Ck9iamVjdC5rZXlzKFcpLnNvcnQoKGEsYik9PigwfFdbYl0uc29ydG9yZGVyKS0oMHxXW2FdLnNvcnRvcmRlcikpLmZvckVhY2goaz0+V0lER0VUU1trXT1XW2tdKTs7oyhERUJVRyl3aWRnZXSW0RN2YXIgX3RtPURhdGUubm93KCk7O291dHB1dEZpbGVDb21wbGV0ZT0oZHN0LGZuKaJ7b3V0cHV0RmlsZShkc3QsZm4s0QR0cnl7LGB9Y2F0Y2goZSl7cHJpbnQoJHtFLnRvSlMoZm4pfSxlLGUuc3RhY2spfVxuYCk7fTtmaWxlT2Zmc2V0PXdpZGdldC5sZW5ndGgrd2lkZ2V0UG9zdC5sZW5ndGg7d2lkZ2V0RmlsZXMuZm9yRWFjaChmbqJvdXRwdXRGaWxlQ29tcGxldGUotyxmbikpO2ZpbGVTaXplPWZpbGVPZmZzZXQ7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNEJLndpZGNhY2hlLHdpZGdldCzTLGZpbGVTaXplKTtmaWxlT2Zmc2V0PXdpZGdldC5sZW5ndGg7d2lkZ2V0RmlsZXMuZm9yRWFjaChmbqJvdXRwdXRGaWxlQ29tcGxldGUo0Qkud2lkY2FjaGUsZm4pKTtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUo0Qkud2lkY2FjaGUsd2lkZ2V0UG9zdCxmaWxlT2Zmc2V0KTu+d2lkZ2V0LHdpZGdldFBvc3Qsd2lkZ2V0RmlsZXM7rWNpRmlsZXM9cmVxdWlyZSjRB1N0b3JhZ2UpLmxpc3QoL1wuY2xraW5mb1wuanMkLyk7rWNpPdEZLy8gTWFkZSBieSBib290dXBkYXRlLmpzCjutY2lfZXhjbHVkZT0ocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEPY2xvY2tfaW5mby5qc29uLNQBKaB7fSkuZXhjbHVkZTujKERFQlVHKWNpltETdmFyIF90bT1EYXRlLm5vdygpOztvdXRwdXRGaWxlQ29tcGxldGU9KGRzdCxmbimie6MoY2lfZXhjbHVkZZ5jaV9leGNsdWRlW2ZuXSmrO291dHB1dEZpbGUoZHN0LGZuLNELdHJ5e2xldCBmbj0sYDtsZXQgYT1mbigpLGI9bWVudS5maW5kKHg9PngubmFtZT09PWEubmFtZSk7aWYoYiliLml0ZW1zPWIuaXRlbXMuY29uY2F0KGEuaXRlbXMpZWxzZSBtZW51PW1lbnUuY29uY2F0KGEpO31jYXRjaChlKXtwcmludCgke0UudG9KUyhmbil9LGUsZS5zdGFjayl9XG5gKTt9O2ZpbGVPZmZzZXQ9Y2kubGVuZ3RoO2NpRmlsZXMuZm9yRWFjaChmbqJvdXRwdXRGaWxlQ29tcGxldGUotyxmbikpO2ZpbGVTaXplPWZpbGVPZmZzZXQ7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNENLmNsa2luZm9jYWNoZSxjaSzTLGZpbGVTaXplKTtmaWxlT2Zmc2V0PWNpLmxlbmd0aDtjaUZpbGVzLmZvckVhY2goZm6ib3V0cHV0RmlsZUNvbXBsZXRlKNENLmNsa2luZm9jYWNoZSxmbikpO75jaSxjaUZpbGVzO0Uuc2hvd01lc3NhZ2Uo0QxSZWxvYWRpbmcuLi4pO30KZXZhbChyZXF1aXJlKNEHU3RvcmFnZSkucmVhZCjRBi5ib290MCkpO///vgAAAGJvb3QuaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 37216, "eyJpZCI6ImJvb3QiLCJuYW1lIjoiQm9vdGxvYWRlciIsInR5cGUiOiJib290bG9hZGVyIiwic29ydG9yZGVyIjotMTAsInZlcnNpb24iOiIwLjY5IiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJib290LmluZm8sLmJvb3QwLC5ib290Y2RlLGJvb3R1cGRhdGUuanMiLCJkYXRhIjoiLndpZGNhY2hlLC5jbGtpbmZvY2FjaGUiff//JhQAAGFudG9uY2xrLmFwcC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 37440, "CkdyYXBoaWNzLnByb3RvdHlwZS5zZXRGb250QW50b249qihzY2FsZSl7Zy5zZXRGb250Q3VzdG9tKNL8EA==");
  base64DecodeToExistingUint8Array(bufferView, 37526, "B/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+");
  base64DecodeToExistingUint8Array(bufferView, 37694, "OAAAAAAAAAAAD+AAAAAAAAAAA/+AAAAAAAAAAf/+AAAAAAAAAH//+AAAAAAAAB///+AAAAAAAA////+AAAAAAAP////+AAAAAAD/////+AAAAAA//////+AAAAAf//////+AAAAH///////+AAAB////////+AAA/////////+AAP/////////8AD/////////+AAD/////////gAAD////////4AAAD///////+AAAAD///////AAAAAD//////wAAAAAD/////8AAAAAAD////+AAAAAAAD////gAAAAAAAD///4AAAAAAAAD//+AAAAAAAAAD//AAAAAAAAAAD/wAAAAAAAAAAD8=");
  base64DecodeToExistingUint8Array(bufferView, 37969, "gA==");
  base64DecodeToExistingUint8Array(bufferView, 38000, "P/////8AAAAAH///////wAAAAf///////8AAAB/////////AAAD/////////gAAH/////////wAAP/////////4AAf/////////8AA//////////+AA//////////+AA//////////+AB///////////AB///////////AB///////////AB///////////AD//wAAAAAH//gD//AAAAAAB//gD/+AAAAAAA//gD/+AAAAAAA//gD/+AAAAAAA//gD//AAAAAAB//gD///////////gB///////////AB///////////AB///////////AB///////////AA//////////+AA//////////+AAf/////////8AAf/////////8AAP/////////4AAH/////////wAAD/////////gAAA////////+AAAAP///////4AAAAB///////g=");
  base64DecodeToExistingUint8Array(bufferView, 38379, "D/4AAAAAAAAAAD/4AAAAAAAAAAH/4AAAAAAAAAAH/4AAAAAAAAAAH/wAAAAAAAAAAP/wAAAAAAAAAAP/gAAAAAAAAAAf/AAAAAAAAAAA//////////4AB//////////4AD//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4A==");
  base64DecodeToExistingUint8Array(bufferView, 38643, "B/+AAAAAf4AAA//+AAAAH/4AAD//+AAAAf/4AAP//+AAAB//4AAf//+AAAH//4AA///+AAAP//4AB///+AAA///4AD///+AAB///4AD///+AAD///4AH///+AAH///4AH///+AAf///4AH///+AA////4AP///+AB////4AP///+AH////4AP///+AP////4AP/8AAAf////4AP/4AAB/////4AP/4AAD/////4AP/4AAP///P/4AP/4AA///8P/4AP/8AP///4P/4AP///////wP/4AP///////AP/4AP//////+AP/4AH//////8AP/4AH//////4AP/4AH//////gAP/4AD//////AAP/4AD/////+AAP/4AB/////4AAP/4AA/////wAAP/4AAf////AAAP/4AAP///8AAAP/4AAD///wAAAP/4AAA///AAAAP/4AAAD/g==");
  base64DecodeToExistingUint8Array(bufferView, 39017, "H/4AAAAAP/AAAH//wAAAA//AAAH//8AAAD//AAAH///AAAH//AAAH///gAAP//AAAH///wAAf//AAAH///4AA///AAAH///4AA///AAAH///8AB///AAAH///8AB///AAAH///+AB///AAAH///+AD///AAAH///+AD///AAAH///+AD///D/8AB///AD//gD/8AAD//AD/+AD/8AAB//AD/+AH/+AAB//AD/+AH/+AAB//AD/+AP//AAD//AD//Af//wAH//AD//////////+AD//////////+AD//////////+AD//////////+AB//////////8AB//////////8AA//////////8AA//////////4AAf/////////wAAf///7/////gAAP///5/////AAAD///w////+AAAB///gf///4AAAAf/+AH///AAAAAA/gAAf/w==");
  base64DecodeToExistingUint8Array(bufferView, 39388, "D/wAAAAAAAAAA//wAAAAAAAAAP//wAAAAAAAAB///wAAAAAAAAf///wAAAAAAAH////wAAAAAAA/////wAAAAAAP/////wAAAAAB//////wAAAAAf//////wAAAAH///////wAAAA////////wAAAP////////wAAA///////H/wAAA//////wH/wAAA/////8AH/wAAA/////AAH/wAAA////gAAH/wAAA///4AAAH/wAAA//+AAAAH/wAAA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gAAAAAAAAH/4AAAAAAAAAAH/wAAAAAAAAAAH/wAAAAAAAAAAH/w");
  base64DecodeToExistingUint8Array(bufferView, 39787, "B//8AAA/////+B///AAA/////+B///wAA/////+B///4AA/////+B///8AA/////+B///8AA/////+B///+AA/////+B////AA/////+B////AA/////+B////AA/////+B////gA/////+B////gA/////+B////gA/////+A////gA//gP/gAAB//wA//gf/AAAA//wA//gf/AAAAf/wA//g//AAAAf/wA//g//AAAA//wA//g//gAAA//wA//g//+AAP//wA//g////////gA//g////////gA//g////////gA//g////////gA//g////////AA//gf///////AA//gf//////+AA//gP//////+AA//gH//////8AA//gD//////4AA//gB//////wAA//gA//////AAAAAAAH////8AAAAAAAA////A==");
  base64DecodeToExistingUint8Array(bufferView, 40164, "A//////4AAAAAf///////gAAAB////////4AAAH////////+AAAf/////////AAA//////////gAB//////////wAB//////////4AD//////////4AD//////////4AH//////////8AH//////////8AH//////////8AH//////////8AH//////////+AP/8AA/+AAH/+AP/4AB/8AAD/+AP/4AB/8AAD/+AP/4AD/8AAD/+AP/4AD/+AAH/+AP/8AD//gA//+AP//8D//////+AH//+D//////8AH//+D//////8AH//+D//////8AH//+D//////8AD//+D//////4AD//+B//////4AB//+B//////wAB//+A//////gAA//+A//////AAAf/+Af////+AAAP/+AP////8AAAD/+AD////wAAAAf+AA///+AAAAAAAAAB//A=");
  base64DecodeToExistingUint8Array(bufferView, 40543, "//AAAAAAAAAAA//gAAAAAAAAAA//gAAAAAAAAAA//gAAAAAAADgA//gAAAAAAP/gA//gAAAAAH//gA//gAAAAB///gA//gAAAAP///gA//gAAAD////gA//gAAAf////gA//gAAB/////gA//gAAP/////gA//gAB//////gA//gAH//////gA//gA///////gA//gD///////gA//gf///////gA//h////////gA//n////////gA//////////gAA/////////AAAA////////wAAAA///////4AAAAA///////AAAAAA//////4AAAAAA//////AAAAAAA/////4AAAAAAA/////AAAAAAAA////8AAAAAAAA////gAAAAAAAA///+AAAAAAAAA///4AAAAAAAAA///AAAAAAAAAA//4AAAAAAAAAA/+");
  base64DecodeToExistingUint8Array(bufferView, 40924, "D//gB///wAAAAP//4H///+AAAA///8P////gAAB///+f////4AAD///+/////8AAH/////////+AAH//////////AAP//////////gAP//////////gAf//////////gAf//////////wAf//////////wAf//////////wA///////////wA//4D//wAB//4A//wB//gAA//4A//gA//gAAf/4A//gA//AAAf/4A//gA//gAAf/4A//wB//gAA//4A///P//8AH//4Af//////////wAf//////////wAf//////////wAf//////////wAf//////////gAP//////////gAP//////////AAH//////////AAD/////////+AAD///+/////8AAB///8f////wAAAf//4P////AAAAH//wD///8AAAAA/+AAf//A=");
  base64DecodeToExistingUint8Array(bufferView, 41305, "H//gAAAAAAAAB///+AA/+AAAAP////gA//wAAAf////wA//4AAB/////4A//8AAD/////8A//+AAD/////+A///AAH/////+A///AAP//////A///gAP//////A///gAf//////A///wAf//////A///wAf//////A///wAf//////A///wA///////AB//4A//4AD//AAP/4A//gAB//AAP/4A//gAA//AAP/4A//gAA/+AAP/4A//gAB/8AAP/4A//wAB/8AAf/4Af//////////wAf//////////wAf//////////wAf//////////wAf//////////wAP//////////gAP//////////gAH//////////AAH/////////+AAD/////////8AAB/////////4AAAf////////wAAAP////////AAAAB///////4AAAAAD/////w==");
  base64DecodeToExistingUint8Array(bufferView, 41685, "H/wAAf/AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//");
  base64DecodeToExistingUint8Array(bufferView, 41849, "LNQuLNENEiAnGicnJycnJycnEyzUTisoc2NhbGWP1AgpKyjUAY/UECkpO307e61kcmF3VGltZW91dDutZHJhdz2qKCl7rHg9Zy5nZXRXaWR0aCgpL9QCO6x5PWcuZ2V0SGVpZ2h0KCkv1AI7Zy5yZXNldCgpLmNsZWFyUmVjdChCYW5nbGUuYXBwUmVjdCk7rGRhdGU9uERhdGUoKTusdGltZVN0cj1yZXF1aXJlKNEGbG9jYWxlKS50aW1lKGRhdGUs1AEpO2cuc2V0Rm9udEFsaWduKNMs0ykuc2V0Rm9udCjRBUFudG9uKS5kcmF3U3RyaW5nKHRpbWVTdHIseCx5KTusZGF0ZVN0cj1yZXF1aXJlKNEGbG9jYWxlKS5kYXRlKGRhdGUs0ykudG9VcHBlckNhc2UoKSvRAQorcmVxdWlyZSjRBmxvY2FsZSkuZG93KGRhdGUs0ykudG9VcHBlckNhc2UoKTtnLnNldEZvbnRBbGlnbijTLNMpLnNldEZvbnQo0QM2eDgs1AIpLmRyYXdTdHJpbmcoZGF0ZVN0cix4LHkr1DApO6MoZHJhd1RpbWVvdXQpY2xlYXJUaW1lb3V0KGRyYXdUaW1lb3V0KTtkcmF3VGltZW91dD1zZXRUaW1lb3V0KKooKXtkcmF3VGltZW91dD23O2RyYXcoKTt9LDYwMDAwLShEYXRlLm5vdygpJTYwMDAwKSk7fTtCYW5nbGUuc2V0VUkoe21vZGU60QVjbG9jayxyZW1vdmU6qigpe6MoZHJhd1RpbWVvdXQpY2xlYXJUaW1lb3V0KGRyYXdUaW1lb3V0KTtkcmF3VGltZW91dD23O75HcmFwaGljcy5wcm90b3R5cGUuc2V0Rm9udEFudG9uO30scmVkcmF3OmRyYXcsfSk7QmFuZ2xlLmxvYWRXaWRnZXRzKCk7ZHJhdygpO3NldFRpbWVvdXQoQmFuZ2xlLmRyYXdXaWRnZXRzLNMpO33//0MCAABhbnRvbmNsay5pbWc=");
  base64DecodeToExistingUint8Array(bufferView, 42632, "MDAC//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6v/q///+r6qqr///AP9Av//0DwAAC//5AP0Av//QDwAAC//AAMAAv/0ADwAAC//AAMAAtV0AD1VQD//BAMEAoA0AD//QD//vAO8AsA7wD//AH///AP8AoA/wD//AL///AP8Av//wD/8AP///AP8Av//wD/8Av///AP8Av//wD/0A////AP8Av//wD/wA////AP8Av//wD/wC////AP8AsV/wD/AD////AP8AoA/wD/AH////AP8AsA/wD/AL////AP8AoA/wD+AL////AP8Av//wD9AP////AP8Av//wD8AP////AP8Av//wD8AP////AP8Av//wD8Av////AP8A///wD4Av///////////////////////////////////62tr/66v/r56vv//6297//vv/+qvuv///r9v/6/v/rrq/v//66v//q+v/q66ub//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7gAAABhbnRvbmNsay5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 43244, "eyJpZCI6ImFudG9uY2xrIiwibmFtZSI6IkFudG9uIENsb2NrIiwidHlwZSI6ImNsb2NrIiwic3JjIjoiYW50b25jbGsuYXBwLmpzIiwiaWNvbiI6ImFudG9uY2xrLmltZyIsInZlcnNpb24iOiIwLjEyIiwidGFncyI6ImNsb2NrIiwiZmlsZXMiOiJhbnRvbmNsay5pbmZvLGFudG9uY2xrLmFwcC5qcyxhbnRvbmNsay5pbWcifZkrAABhYm91dC5hcHAuanM=");
  base64DecodeToExistingUint8Array(bufferView, 43460, "QmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwqsVz1nLmdldFdpZHRoKCksSD1nLmdldEhlaWdodCgpOwqsRU5WPXByb2Nlc3MuZW52OwqsTUVNPXByb2Nlc3MubWVtb3J5KCk7CqxzPXJlcXVpcmUo0QdTdG9yYWdlKTsKrGltZz3SGySwjAOSbZLroNjADYAAAAAcAcZJHEkSQACCYYYHEMgAMh0AUkhsAcX0c/TSQFQLoO3MOACJY7HCSAAZsDzoJbbbbaSSAHiE7br9cMPADCQQQSBhgD5VbbbAQACCDASbYBlllMWi0wgMAD28HnbQAlSdcC3ACACIbE7DbCj5sCaJIAfgBBSQAcyQ7b/rpNjYbCCCCCEHn/5JHEkAQACWbYSHFJMspgUUUEAMD/30c/TSQegLoO7MAAAJY7HCSD67MbzoJAfttJSAAH6JJAAAAMMAC0SQSQAAADaSHEgAcACCYYsAMoMsugAAAQMNJBAIAAAAAcDgAC7AAAABAMMMMMDAAggAAyABhBQAADiKieAAgAYAGoSSSQAccYaGHEgcddrroANhtJIJwQfNQENtAJJJAAAAAcC20MMMMAAJAMMMMDXgYYYAEQQBhBYEAgOJDzgACjDEhhCSSJLiDjaSHEgDiKc08ADXAChOSQAEJIABJBCKSbZJAcAUAAAbAAAACi2ii4nAAggAESBhgAAkgigIjzgAW3bEkLgSRtgQQc8AHEgAB9KqpJDXAUJwQQAAJIAAAACCCYAK2//3WAaATAf8C2gUUbbAYYAAEQQNgAAkkC0AjYbD23DDB/gCbYAf/nkBHSTREAc08q3bWhPgACgUJKFgJICCSbAK0AAVahaATIJICi22i5vYYAAAAyAAAAAkkAUIDDDD0UAbW3j22HkCD88RHbZP8ALroqim4J3ySSwAQBNAIACCCYUK2ycVrAaATASQAAANu63AYAgEgAAAAAmaEhgADADfnECDbbj23k8ADgARHJIz7iQASKQWjOj7ba8k8BmAIIQCCbYK2AC20a8bAEkAAAYAMYYYbEEEAAAkEEySQgBJAADn7YQTTNv22f8Afi4BHW2j8CfiSSSAJ4D222wAQAAAJIAAAAAC2ACigAYAAEADHAYAMYYYAAgEgAAgEEySQ/9BSQAfnECcYsPgAASQBC5BG1JXgAQASSQBOjDgAAAABKMMUJIAAABACAC2gCgAAEgC+AYMMbYYAAAAAbAkEAmSE8lIbYJLAAAJPNvgQQCAYK5BC3LXgeQDCSCB0AbgBAAADTMMUIALbAMMASe2gfX0C3YDLAYBgYYAAAAADAAAAAEwkf9BAAAIYABIVgDgOMCDAK4IC1LWgAAEkQQNttttttgACJNu2pUJthBBAAC20BusUAYBAAbYYYYbAAABDDAAACSEgaYtMiQLAMALg8gAAACABC5AC0k2gAAEAyf8kgAgwAQQAAMMULbUCgMMAAAAABusC7ZJEkAAgAAAAAAADAYAACSAASQ0rqIIMMAAD48ANsAbYC4IC0lWgiilITPskAAESASAAAMMULDAAABAIIAAABusAUBBAgAkgApy7gAAIbAAf+Sf8aaNpKRIBkFgAngAOsAYUC4BAUo0AC2kmZe8E0EgyQQQAAMMULbAkkgBRRAAAAAUWgBJAyCEgAAAAAAAIAAD8fj8cABkroQcDggAAAAANsNgUC4AIWu2jAUEzJ0gEAAESAbbYAAASzfAAtsBRRAAAEkAJBIAUiCDyTz+SfwAAJoAAn/gAahBFiQT8EH/4AYAABgAC0DABW927YAmZOgAEgAgwDAADAACCCf/gsAARQAAAEAhAIBWXAcD7bb777cADAf8HEkBgQCAccAccAB3bDbYQAMAAAAACqjujAEpJ0gADjgAAAYbYAAASQD/8sAACAADgEAhJIBW7YADqrrrrpcSTAf8EggNsOCCfgWibAAxYYYYQABgAAAAS2wd2gCNOnAAAQAAAAYAABttiAcjgsV0ccLYAEEBAJKWjCQDtvvvvt8QDAf8ggBttoCQADWwYYBJYSbASBsQcQAADE60WknN08AADjgAAADbAABgAAEktsMMfgIYAEkBAKSUAdwD/3332/0SQJoAkgANsGiCW7YCbAZJaCYYTzgf/8AAAJAAAiFGnigIDzgAJJLAABhigAcjgAV0AAJIkkkkkmSUDCQAMABgAYAQABtgwgABgACCXbUAYYZJCSAASaADjhJJJIgQEZp08CCSD+JJIkoYAANgccJAAAdcAABgAAAAEySgDCQAMAMBDXAQAMUCCAAAAAMvba0DYDAICCAgTzgIcBbLZIugiZumCBiCCSK20koBgAAAcdWoGBJJL+QgYDDDEmSgAAAAMBgBAYAf8O6iSAQSDYBq7a2gAACKDAEEAAAH/hJJJAkETJ3zhhCSAAJJIkokkmSQcdAICdLpL+RjDDDDHmSgDBhgMPZBAAYdcMUOWAQCDDFWXa0CSASSQkAjAAAGSBJJJAuiZPn+AIgMAMAAJJJBBD/8f8JACBYBL+QjbDbDEmSgDBgAN7YIACCD8MAMUAQCDYIszyWgGACeAEACCBAAABJJJAkTJ0/zggAMMMdcAAAAABJIAAANsAABL+RjDDDAHmQ0ABhgN7YAAQYQcBtiUACQDDNl//0EGAT/wYYBtgAAAYARsAiZOwSAEkANhgfoAANsAAAAAAwhjbDbDaQjDDDDAkk0AAAAMPAACAYCAAAQVgAAAAQszyWkGACeAEkCCAAIAAARhkTJ0iAgSQecAAJJAbbMFImWUgktAYDADaQAAAAAApIgAf8AMBgBIcxu1uHiQAAADAUlgAAEGAZZZZYADAAAAAQRsCZOnCE4QQSQYnAAADZhsACUAgwtvTDbASQQCCckkpIgDgDgMAMAIcySSSHgcAAABIZMkkiAiAAAAAATzzzwbYCBhzJ0TaYkAEecaTBAIDZhgAAAnEgAAADAASQSCD87YskgCgCgAAAWSwCQJJIcAcAAEk9g54gSQAAAY4SRAAAAbYASSaSEGTbEAAJIGQgAADAASCAAAgAf+SEkASQQSAk7U0AAWMOUAAYCyACAbZYAAADDEk6AssgAANvgHECBAQCQbYAQSJwgAQAAACSLQAAIAAAAQSAAAgAf+SEkDjgQCADYW0AAWRyUAYYYQACQbLbgcngAAkWgNsAD8APgY4CJAQQCbYAyaOSQnTD/gAKKDAIABSSSSSAAAAAf+SEkAcAAAAbAAMAAByR4AYYYAAAQZbYAgAAIAEnAVgAAAMMAAJABliQSZBATKUgE3TX/gACDAMBJIf//ySAAAAADgQAgJeQbgTzYBsCCSOMbADDAAAeQJJIcAcSSQEkgXBgAcBiSSB5gsgABZJCQSEAEkASAAAYCBhgSAEkkiQAAACgAAAAABeAc4/8DAAD//hjYAADjjjjgC2hJcAQQQElAQZgAcAACBBhhlgABdFQR2AAAiCCMAACYBtgQAAAAADZuT2gXgQc20cCbTTwAgAAkkgAbJJDjjgcAAChACAAAAByAQDAAcAACAKSAAAABJCZSmAAAgSNtsAAABhkSATwf8AYDAWpWgAccEDYc4gRYAAA+SSSBARAQCcccAUBIBvZBACNhhht8cAACAAQbAADAETJwiAAACCMIMARJABACATwSQAYYQxWoABf2kjAbgJCIAAA+f//gCRCCCDgdZUBAB/YAABwASQADpJJCAAQYEkcACaSEAAAASCDvjzzoAdcSDyQD/gbAEVWgABccEDZJJBIQAAA+EkkhCICSCHkMAMBJbn1BACNJCIAAJAJf8AQDEAAEDGQx0YDYAYAMCf+IDBDAAAAf/8YYEVVIABcUAACigAgAAACSSACSSACCCcejbCgDDAAAABxACIABpVpEkCSbEgAGFGFOvbDDDDAgjzzocAAcAAACSAYDQxWoABAAAAC2igAACID//gDgAAAAAHmDDCAQYQAUCCNIAJACpMJc8AAAEAAFF0hR3bDDDbAIAedIIIIAAAAQQQAAAGpAEm7YABiiihAAQBAkkhJJAADjjgADDAkiSABtjBxANsAVh0Ac8AAAEACEmkBLDU3YDDAADNsAARRDAAD2CDgAAS2gAGgEAMMAAccACIABef8C2gAAAAAAYAEAQAAMBCNCBgAAQQQAAAAAcBtp8gkjAAgAC2gAbZgEkyRD/gfgQD8AQgAAEmiEINsAcDAACBADjkkDbAAABtgAAAkIQIBhgBwBhkEkDbADAAADrhtvrgjDADAACigIKhJAkxRCSC28AcBtgAAbECgAIMAAD/gAAIgidSRttgAAMMNtttgBRAAACEABt8HkQQQYY47rgBt0AAkZJCgAC2gJKhJEgAADAC2j/gADgAAYYlttoBsADjgAggghAEhsABgAMMO2228cQAAYD5CRK8HkAAADHHFJC1t2gAgBJDAACgCIK1BA///jAC2+CcDDhIAYYAAD8cAAgAAAEAgjiSQAAAPgBtj///vsRc2SA7yBIgAC2gAIA7Trittu4AgBJAAACjCAATQE8kngNh/wQT9thJAYYAAcDkAAiCCBBAkgEkkgAABgA8i222/8TOMQABSREsAOuiSJAwABtttttgjAAAeAMCaAAY4AMABgNtjiCDgABAAbALwD8cD8kQQAIAQRIAC20AAMD/htttjgAgCCAgGQku2u2jbBA6YByOOORgAAAAeQljTAMTQAH/8gBsAASZEAJIAAALwCCAD8KqoCCAaZIAUACgWhg8gAAAf8cpcgDgCQAuYOAACQgiSZyS2yR7DAAAfwkMABsAAAAAAAAAACTI2ABIWj/rwSywBMBVYYTAHFICjbAUN2gAAAAAcfhHgW2Qz/YiDCWWWGNsTJttttt4DACCCNgBsMBgAAAAAAAAIJZG3ChBC3gIQSywD8AobYYAAhLCjAYUgt0IJAAAccACAChSQD8ybaQQCQjgAOkAAADYJLCCCMMQBgAAAAABABBtpJAAgigICj8IQCOAD8AAHEDAABICjAYcccAIIABLwAMCACgwz+0DDDAUAADwAUgO+sAAIIAQwNjHADAMMAABIJC2oIW0kgBhhjgIQCOAEkEcDAcYABICjbAEAEBIJABfgBgTyihEmQAbDDYQAAAAAEAO+sAAJIAGEMQgwAAskEABBBDbAAJIgsMMMP/gABtgEkACgCjAABICjAC8ccAAAAD+CbAD+igkBABYbYYUAAAAAggO+sCUoIB31sDHAAAshgMAAD8AAAW0ghgAAAAAAAAAbZVE+/gAABJgXAUBAAAAAACAQDACe2hEhIJbADYfjgAAAMAO+uCUsCmxykAQCGAskEAAAccEkkyQAc8AAAedJABh7ZVGm+8AABI4a2gAADgcAcEgABACf/gkBBBDbbAccYYYYBgMeueUiiiySgAAAgAAAAABgf8AAAf+SHkIEQElIIBsSRJE2/0fAAAgAQDzgccAADAEAAIJIeBH9ABAAAAf/7ADAIAAASSUsWgWUDAACAAMIAAPsccf//yTbc8AAAedBIBsSRVGm+8D6CBbaSCSAf8AQDYgAAAAQQAkD/+cAAcW24YDAhCgATiUsCwSiPAQAgANRAAMAAACCCAAAAAAAAAAJIBhgBVE2/gfCCBAQQTzgcccAfAEAAAACACgnl8fATj0AAAAB4CgATW0ACCCCDCCCGBtJBJBgDUHjjgD/gP///sAABABEAgBIAAAAQAA8wAAAAAD/yEgAf8CSSAYDs8DALji0AAAAjCgAT20SATQD/AQAABtBABAMbWiTTbDyQASSQAAJAaTEsgJAA+AAASTnwBLJttgCbQADpLiCCDbb/sDbbj0ACCQBhi4AQW2bQCDDASKQf+Sf8BPsBIYbDDbzwAAQACRAICaFkgJCSSSSQbY8gAJJhhgQbCAfJJcAAAYDnkDYocOtjDDAjCgAeSCbQAYYYAIAYnTedBBgBADbbbb/wAARhiSABMTSSQAySSSSQcbASJIJtvzzbaT5IJLgCAADs8fAIABgbAAAMCgENZASAAYYYAIASTTf8IMAAAAAAADyQMQRti2CQogCCAEGSSSSQf7AS1UBzR//N7/5AJLgQASQAARAaANtgDbcAegAdBAICSSYAIILAAAAW15gbCgAAABABtyRhgmAREACAQ8cgAASQcYAS1UD8fzwMOT5BJLgSAST/gAAAAAHUiTAACgFgQBIAIIAABJAAAgA1VtjAC1sAALoNhsAAAkSAAAAAAgAgAASQAAASJAD//gATAD5JJLgQASTjggEEgka2ADccegDgBtpAIIAIAAAdJEEW1hjAC1sAddddtigCgAAAAAAAAEnAAASQAAAAAAD//gAQYN9JJcSSAAD/gAAAgsGwjDADAC2gdtoAABBJBAMDhMsBAADABt2gALoAMCgCgAAAAFIgAADAAASQAEgAIJI/8gAQZtv//gC6gNgDggEEghmAjbAAgCjgAEAATxAIBCsAJMMJKQAbBuIgABD/gYUUEkAAAH8jgDjAACSQAEHbIIAkkgAQZtvj/gDLByOSAgEAAAMkCSABAC0AAGgCCCJJIBMDhAAIIAAABvWAADjzjDUUEEAAAFIgAADbbYSQAEgkoJDkngAABhv8DgAshyPTAgEAAABjgABDCC8AAEAQAARJABMdJf8JKDQABspgEAD/j/CgEEAAAAAADAAMxBKRAEGSJIDgDgAAABsf8AAAByOSAEgAAQAMAAAc8C2gBACAAACAAC0AAYAIIDQPhtsAGvAAb/ccggAAAIACACBmIIIIAEgAAAD//gAgiZMDgAAAANgAALgACSABiAQAAAAIJe8AAD+fz+TxDbAIKTQdhtsAGtgDDYJIAADBAMBASQMwIIJAABIMBgAN7AAkzJgAAAAQANj/8cIASSQAMSAAggEIKuugAAefyefxbbAAAAAAAAAEG1iCACSSDjgAMUMACAAAcMAAAIAMNsBh4YY4gAAAAACSAW0DjocCSSCANyAAgggoIAAAAAeTzyf9bHYBuSSSSSSEkECCACf+D/yAC6gD/gAAdhjAUIAMBgBh4YY4gAlpDAQQQUAD8dASSQcQAAADDDbBAAAAAAefzyTxbbYB57bbbbbAADgYV2e+D/yJ3fVqSAIAdhjAUBJsAAAN4aYYQABhDACSAW3DjDACSSAADbbbbDDAAAAAAD8QAAABbbYBsQA8gf8CeACCOuf+D//gC6gBJAAD8MYAW0AAAAQAbTnSQAhpAAQQQUDbbCjASSQcDYAAAAAAYAAAADYT/yujbDYBh1j/jgDj/gCCV2SSD/kgMUMCgSSQCgUQSSQRMDYMCc6CCAlhDAAAAUDDDDAACSAAAAf/jDDAZ5tsADYTzx1jYAYAMYI8jgfiebAAEkAAD/khAMBCgAAAUCQSSSSSMSRgDkASQAAAf8AAaYAAAC6gAQAAf/jgfDAAbbbYAD8T/yujCaUW2+UgDjjgAYEEEcAAAgBAAIAChtgCpUUTSSTRMbMAAAAAW0JIAcAATTgIIAAAD8AAcAfgfbDBZ5tsAD6SVUaCbbW0USQAAf8AAbEgEEACQyAIAH/+h5gUCAUQaSZyMRoEmAAAW0JIDgAAaYVBBDCKDiTYcIDgfDDBACAAAX6SIoYQaaUUUBBBINsAAYEEEkACAiJIkkkmhtipUAQQDTNxMPIEQQAANsJIfZJAQQIIIABFD+BhhVD/jAABYCCAADaSVUYQaSTrgBIBBMAAAAAAcCusAAAAACSShgUCG20QN5tyN/IEjCAC22gDgBADDDABAACKAARsIAIbbEBJJCQAf/eSCQb/4CCKABABINsW0AAADi2sADADAAAChipVm6wQN5txMPIEYQAAEnzkkZIBABdLaQUAdiQAAf///8ABW2CAd+SSSSTyCCDrgSBhBNACsDrj/iu0AAEEDASCgUChm23wN4ByMBoECAAQEnzkkBAAMMFLaQWi8PgeiySSSQQBUCAQf8AAAAD/iSANhgAAAMACthRHEgAAAAGEYYQCipQBm6zxgAMRNBMEQTaCHnznkBAACgZLaQUUdjgei////8QBUUACQBsBABAEiQBgMAD/8Akitjr7bASSAAEEDAfi0CgBm23xgAMSMIJoCabQH/z/kAAAAAMAAAUAcMUi2gAAASQBW0ACCBhhBBAgCCANhgDycAgW0AAHEpKSNgABAEECgQABtgTwNgBxMIIO2y4AAAABJIAAAAD/f8UAdgGiigAAAREkgAACQBsbIIbEiTEmAADyeAkgABtgABCSAMCSAAEgAAcgAAEkAAAAAIJCgKhhhjbD/8AAAAD7ccAAAa4ADLAAUSEAAAACAAAbbbbAADEgIDj/yAAjjgBrxBCAACSicCgccf8////f8f8f8f8cVKhthjAAkkkkgAD/f8AbAW0AhZAAACEAf/0CCAAAbbAAAmIIIAAAC0kgABhgBJSAABgIAMAAAAkkkgDAAAAAAAACgKhhhjbYAAAAAADvd8DMYa4cbLAAACEkDgAWQAAADa2gAkEkkAAD0CgQARt6QNhsBtgAYbbAMP8//gAAMMBhgJIC2i2ySSDD////gADvN8DAYABCBAAAACEAD8WiAAAADagUNsUAXbbCi20QQQAbQYYYABiSAYAYNhuSAIAhgAvjsAAC7C4QQCDABtttgABvNtgbAAAYcAAUACEADhJYYgkADagVgAWi0DAUCgACCAAAC222gBjiQYAAMMOaBBAACgBtjBAC7XASSCC222222kn8AAA4gCsMgAAW0CEBjgIbYEFJDaihgAUUUDWgcW20AAAAUSSQUBgSAff7gACSAYABgAgADBAC64ZgAWjbbf///kn3gADbAWhg8gcUUWawDhJYYAFEjYAANsUUUDAaADjgAAAUCbbaCgQSD///8EkEjDMMEEAADRACgABgMABtt2222kn+2jY4nasM8gcAW2IUBgMAAABJASSQAB0UUDAaAcccdcC0TJprQUCQD///8DgyHDCAAAFtnBACgABgOgUABttttpL3gDHAHZAAkgDbUWFYMBgbbbAkgQQQNsUAUPAaADjjjoACbuuv6CgAD8fj8ccEgagCtsMAMX4C2gNhsWgAAAD+SIIcT/b/kpKT8gDYYCAABhgAADFrASCQD/gABhgBgcccddjid2WV+CgDD/gf8AAbYAW0BgMYMX5JBAAAAAAcg8cfaJAASff///gAkgC7ACAkAAIAbbFbgDbABdAABgAQQDjjrpgCZ2SV6CgAYf//gADADADgBgMAMAZJAQQACAAAAAAfSIIQSTf///gbngC4YBtkAABAYbFrAAIAD9AAAMAhg8ccddiiZOytaC7AYD/8NMZKt4ACSAFtkSRJASQACAAQAQAfaJKeSf//+3bAkgCbABhlBJJABjAkgAIAQAAAYBkCAHjjrhiiDJ1rCCgbbAAAKoYCgYceSAAAD+fgAQQACAADbAQeSAAQT/+f/20AAACAABthBACANsAADgIFbYYAZhgDPcccddgUQZNYQUbNtgAANMBKtgCAcMMDf///AQQACAAAAAAANthhP/yT//gAAAB2gAkpBIAAAAEkgAg45YYAYMABtjjjrhiiiDPCSwANtgAAAbZABgcceW0D+TyfgHwCCAAAJAIAMABhd/+f/bSSSSBEBAggbAYEkAEAgAhG7TDbAMADPcccdtgAUQYQEEANt8kgg65KtgAAeCgb+SSf4HwCSAAlAIIDNthod/+f+SbbbbEApAgzAAYGEAEggEwfcZ7CRCAAADjjjgUAWiCagjANt88kg7YAAADACCgDfyT/AAWWWWUkgIIYYAAAf/+f/bAAAAEEJAAQYSYEkWgAAEiiijHCA+gB12gISQUUUATDAAbAAckggkEAAAbYCMMAb+f4AAEEEECCBeLf/EjXf/////gAAAEgJAMSTSYEAWoAEgcJIfbCSDDgUMIIecCigCgYAAAADAW20YAAAAYYCSSSSf+22sAMAAAABfqc+FK2/////6aZtgEEJBljYAYAAAIAEiipKiiQQAAAMUJISdttsAWKAAAAwQAUDbAAAD+rqASQADgAAUEEQCSAQeCEmJHXf////zzRxgEAgMssAAAACQIAEAcJIcICQEEcAkoINsUCsAAQSCQgyQAUAYAAAC+roMTwBgY84UAAQCCARSI44glt/////6aZtgAAAFlkDbASCCJBBACjCgBAIEgcEgIgMAUVgDYYQQQ0wQAUAYBBBi2pLDSQMMAcAUIIRiCBweAnEgB9v////zjQEkD0UAsgAACCCQAIKQScAcAKikH8kkkkNsWsNLDDQAQAjAAUCSBJNkmYHDCCNsYg4UEkRiSBwAAf8GltsAAAMACYhAcWgAEcySQQCCAACCSCCASAQNsbbbY++8V0IDDDAEkkgAAAAABBBkGAHbCCNsAAAAMABsANgBSDgUWSMAAcOATQhAD0UAAEySAACAQACQQQAEkkkOvYYbY++8UChIMAMEkkAAZYAACgAEmAHDAAAAAABE/yBhhhgBaDgUiKNsMNuQSZBJAAAAASSSAAAACAAAACCAACCNvbbbY++9sNsANhsEkkAAKIAACigGGTlgMf8IAIIE/yBsANgBSDgEWSMMAMOCTSBBCSAAAYAAAYAEmDYAAcQcAAQAXYADU++8NsBgMMNgEBgAZYAACgSQD8ANj//oIIBE/yBJAAABttgAC2sAMMPACaBJACSSQBgMAUZIiQYAABKSQCCAD7bbw3/8BgMMMABsEBgBtgAACi/+AD8NjjjocIIAkkVAUASQBgAyBKsMMMNJAwSQHgADAYAMCi5YggYAABbSQDjgAWi0EkBJtpBgMAAbFhhhhgACiz//wcBgPjjoDoBAAEVAUAQCBtggRKsMMBtAEihBgSAYABgBgUJYkHAAABKSQAgiRAMAANtptoADYAAAFtthtiAC23vvwAAAD//r/oIAAEVAUAQCBhggS2hsACBIggYAEAAAAYAMMMf8kEAAADgDgAECKAUABJOJpqEAGB2gEAAAAW0AACf+AAC2gf8JBIBAgEVJUASQBskyAkgEkSBEAipIDiAAABgNhh+cAAAccAAf8AgiRAFAABONNOEAGBioEAADa22gAB3xgkACgD7ZJbLAEgW0W0QCBhgADngECCAAAQIAGSAAAYAMAMf8AAAccAAAAAACKCgMABNxxxmGGB2oIf8DCyygABvNggAUAAYAIYBDjDjDjDjDhtgAAkgEGSQAAAJI//gAABgB29BAAAAAAYAAAD8Af4AQABNuONiCCBoJIkkDa22gABhhggAAAD4YAYDBtuAQkwwAAAAADbAEkCACDn/8n/gAAYAAX8IAAAAZZZZYsj8YfgCgBBBttsAQCSJID/8DCWWAABhFgkADcAfYAAbBtsAAbbAAbbAAA4gAAAAQQ8kkk/ySQARSW8IkgAADDDDAsgAYkkYAAIkBJBgAAAAIAgADYSQAABohgEAD8AcUAAAAMAADAAbbCc4AAQAAABfgTn8kknyeQUSKAAL/gAADDHDAsgAYkHgAAAggBBvsDABJBgAACACSABEgQEAAD/gAAAAcccSfyADYAiAACCABAAfiAAAAkkz/y0SRIAC2pIkAYAYAACAAiEgQAAg4IbgYAAYXNti4CACAAIgG0kAADjgQADkiCASfyAYDCAgzcQAJAAASQABt7bSeQUQBBDXABAgjDHDCSCSSQAJgAAghABgDDDABBgYAiACSBEAGgAAAACiaCjGCSASfyAANjmGD4QAAAW0AAfhgZKSSQAgIIIa4JAggAAACgDbbYAAAAAkBJDgAbYACjMAYCAACAgki0AAAAAAQIDyAQAAAAACgVAM9yCABAUUBAAAMSSSeAHEBBADXAAkDbeAkUCSSQAXBABAAYAPsDABBQQCgCSCSAUSSgYO2iigBZIAIBAAAAAAcBBgDGCAbAW0NtsABgAT/8AgAIAAAAAkg6T8kCgACAAchSRAAAAEkAAAYSAYwgAAACuwm3DO0UUUVJJBJBACRD/0CgQAYZVCTUAAWugBtgASeAHEW0AD8cAEEbiQhJDgQAAABBBAIIUWi0AUWwS0AAAAAV0QwDAN2iigBBIIIJACaAkhsCSQbaqgbbAAOu2ipIkQAIAgWSgAAcAEY4TggAACSQAACJKAIIAgAgAAAAAAAAf/8WgUUAZttgAAAAIAIBABSBJBJfgAYaqwTYBINu+igAEQBNBt2Sgj8dAAAAJACSSAAAAACQSAAAUkA0YbYYBgABgcBBAUUADBkkAASCQEgADjjhBBBfpJJJVSTHBdSC22pIEQBBBh20Ej8AAAABALD9fjDzgACCCABAUgg0YYAYAMAOScAQBgBjDBkAf8QQQgAAAEkBJBIAECIGqwTYhJTyiigEEQIAJt0A7EgJIAABbIDpLgCKAACACABAUgE0YAYYAMMPacYQYPsAYBkEc8QQQgAAACABABBAGQQFVQTHBBSCiipIkyAUBgUWEklJJAABAICSSADzgACACAIIUgA3YbYbABhjTcDbBcAf/pkkf8QAQEgAAccBABIAGCQE7rGltZ0hlaWdodD1nLmltYWdlTWV0cmljcyhpbWcpLmhlaWdodDusaW1nU2Nyb2xsPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSppbWdIZWlnaHQpO2cuY2xlYXIo1AEpLnNldEZvbnQo0QQ2eDE1KS5zZXRGb250QWxpZ24o0yzTKTtnLmRyYXdTdHJpbmcoRU5WLlZFUlNJT04r0QIgICtOUkYuZ2V0QWRkcmVzcygpLGcuZ2V0V2lkdGgoKS/UAizVqwApO2cuZHJhd0ltYWdlKGltZyzTLNQYKTuqZ2V0VmVyc2lvbihuYW1lLGZpbGUpe6xqPXMucmVhZEpTT04oZmlsZSzUASk7rHY9KNEGb2JqZWN0ir9qKT9qLnZlcnNpb246tTurdj8obmFtZSvRASArKHY/0QF2K3Y60QdVbmtub3duKSk60QNOTyArbmFtZTt9rGxvZ289RS50b0FycmF5QnVmZmVyKNHVPBwBAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAD/w+AAAAQAHA4hAAAAQAMAMhAAAAQAYBmhAAAAQAYBGiAAAAQAQCD/H74+R4wGDhoKJCSEwEDgoKJCT8wFDgoKJCSAwHDhoKJCSEQHj/H6I+R4YHmAAAACAAYEGAAABCAAMEMAAAA8AAHA4AAAAAAAD/wAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gKTusaW1hZ2VUb3A91Bg7qmRyYXdJbmZvKCl7Zy5yZXNldCgpLmNsZWFyUmVjdChCYW5nbGUuYXBwUmVjdCk7Zy5kcmF3SW1hZ2UobG9nbyxXLdQ8LNQYKTtnLnNldEZvbnQo0QM0eDYpLnNldEZvbnRBbGlnbijTLNMpLmRyYXdTdHJpbmco0QxCQU5HTEVKUy5DT00sVy3UHizUOCk7rGg91AgseT3UGC1oO2cuc2V0Rm9udCjRAzZ4OCkuc2V0Rm9udEFsaWduKNT/LNT/KTtnLmRyYXdTdHJpbmco0RNQb3dlcmVkIGJ5IEVzcHJ1aW5vLNMseZbUBCtoKTtnLmRyYXdTdHJpbmco0QhWZXJzaW9uICtFTlYuVkVSU0lPTizTLHmWaCk7Zy5kcmF3U3RyaW5nKNEHQ29tbWl0ICtFTlYuR0lUX0NPTU1JVCzTLHmWaCk7Z2V0VmVyc2lvbijRCkJvb3Rsb2FkZXIs0Qlib290LmluZm8pO2dldFZlcnNpb24o0QhMYXVuY2hlcizRC2xhdW5jaC5pbmZvKTtnZXRWZXJzaW9uKNEIU2V0dGluZ3Ms0QxzZXR0aW5nLmluZm8pO2cuZHJhd1N0cmluZyhNRU0udG90YWwr0QggSlMgVmFycyzTLHmWaCk7Zy5kcmF3U3RyaW5nKNEJU3RvcmFnZTogKyhyZXF1aXJlKNEHU3RvcmFnZSkuZ2V0RnJlZSgpktQKKSvRBmsgZnJlZSzTLHmWaCk7oyhFTlYuU1RPUkFHRSlnLmRyYXdTdHJpbmco0QkgICAgICAgICArKEVOVi5TVE9SQUdFktQKKSvRB2sgdG90YWws0yx5lmgpO6MoRU5WLlNQSUZMQVNIKWcuZHJhd1N0cmluZyjRC1NQSSBGbGFzaDogKyhFTlYuU1BJRkxBU0iS1AopK9EBayzTLHmWaCk7aW1hZ2VUb3A9eStoO2ltZ1Njcm9sbD1pbWdIZWlnaHQtaW1hZ2VUb3A7Zy5yZXNldCgpLnNldEZvbnQo0QQ2eDE1KS5zZXRGb250QWxpZ24o0yzTKTtnLmRyYXdTdHJpbmcoRU5WLlZFUlNJT04r0QIgICtOUkYuZ2V0QWRkcmVzcygpLGcuZ2V0V2lkdGgoKS/UAizVqwApO2RyYXdJbWFnZSgpO3NldEludGVydmFsKKooKXtkcmF3SW1hZ2UoKTtnLmZsaXAoKTtpbWdTY3JvbGw9KGltZ1Njcm9sbCvUASklaW1nSGVpZ2h0O30s1BQpO32qZHJhd0ltYWdlKCl7Zy5zZXRDbGlwUmVjdCjTLGltYWdlVG9wLFct1AEsSC3UDik7Zy5kcmF3SW1hZ2UoaW1nLNMsaW1hZ2VUb3AtaW1nU2Nyb2xsKTtnLmRyYXdJbWFnZShpbWcs0yxpbWFnZVRvcCtpbWdIZWlnaHQtaW1nU2Nyb2xsKTtnLnNldENsaXBSZWN0KNMs0yxXLdQBLEgt1AEpO31zZXRUaW1lb3V0KGRyYXdJbmZvLNXoAyk7QmFuZ2xlLnNldFVJKHttb2RlOtEGY3VzdG9tLGJhY2s6bG9hZH0pO////wQJAABhYm91dC5pbWc=");
  base64DecodeToExistingUint8Array(bufferView, 54656, "MDCI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVVVVVf7+/v7+/v7+/v4QEP7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/hAQEBD+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVVVVVVVVVVV/v7+/v7+/hAQEBD+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVVVVVVVVVVVVVf7+/v7+/v4QEP7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVVVVXmjeVVVVVVVVVVV/v7+EBAQEBD+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVV5o87OznlVVVVVVVVV/v7+EBAQEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVXnIzs7Ozsd5VVVVVVVVVf7+EBAQEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVV5o87Ozs7Ozs6jVVVVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVeaPOzs7Ozs7Ozs7Oo1VVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVWjyM7Ozs7Ozs7Ozs7OzlVVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVecfOzs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7OeXnOzs7Ozs55ec7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7OeXnOzs7Ozs55ec7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVzc7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVec7Ozs7Ozs7Ozs7Ozs7OeVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVT53Ozs7Ozs7Ozs7Ozs55T1VVVVVVVf7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVT095x87Ozs7Ozs7Ox3lPT1VVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVT09PxsbHx83Nx8fGxk9PT1VVVf7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVT09PxsbGxsbGxsbGxk9PT1VV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVjMPx8bGxsbGxsbGxw8zVlX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5lZQ8PgMbGxsbGxsbGgA8PZWX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZToPOc3GxsbGxsbNOQ86ZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZToPD87Nx8bGx83ODw86ZWVlZWX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWUPD4HOzs7Ozs5dDw9lZWVlZWVl/v7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZWVlZWU6Dw+kzs7OzqQPDzplZWVlZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZWVlZWVlEA8PXc7OXQ8PEGVlZWVlZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZWVlZWVlQQ8PDw8PDw8QQWVlZWVlZWVlZWX+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZWVlZWVlZWU6Dw8PDzplZWVlZWVlZWVlZWX+/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/qYAAABhYm91dC5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 56996, "eyJpZCI6ImFib3V0IiwibmFtZSI6IkFib3V0Iiwic3JjIjoiYWJvdXQuYXBwLmpzIiwiaWNvbiI6ImFib3V0LmltZyIsInNvcnRvcmRlciI6LTQsInZlcnNpb24iOiIwLjE1IiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJhYm91dC5pbmZvLGFib3V0LmFwcC5qcyxhYm91dC5pbWciff//CAEAAHdpZGxvY2sud2lkLmpz");
  base64DecodeToExistingUint8Array(bufferView, 57196, "QmFuZ2xlLm9uKNEEbG9jayyqKCl7V0lER0VUU1vRBGxvY2tdLndpZHRoPUJhbmdsZS5pc0xvY2tlZCgpP9QQOtQBO0JhbmdsZS5kcmF3V2lkZ2V0cygpO30pOwpXSURHRVRTW9EEbG9ja109e2FyZWE60QJ0bCxzb3J0b3JkZXI61Aosd2lkdGg6QmFuZ2xlLmlzTG9ja2VkKCk/1BA61AEsZHJhdzqqKHcpe6MoQmFuZ2xlLmlzTG9ja2VkKCkpZy5yZXNldCgpLmRyYXdJbWFnZSjRHw4QAR/g/8MDDAwwMMDH/7//+H/h/4f/P/z/8///3/4sdy54K9QBLHcueSvUBCk7fX07gQAAAHdpZGxvY2suaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 57492, "eyJpZCI6IndpZGxvY2siLCJuYW1lIjoiTG9jayBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDgiLCJ0YWdzIjoid2lkZ2V0LGxvY2siLCJmaWxlcyI6IndpZGxvY2suaW5mbyx3aWRsb2NrLndpZC5qcyJ9////NwMAAHdpZGJhdC53aWQuanM=");
  base64DecodeToExistingUint8Array(bufferView, 57656, "e0JhbmdsZS5vbijRCGNoYXJnaW5nLKooY2hhcmdpbmcpe6MoY2hhcmdpbmcpQmFuZ2xlLmJ1enooKTtXSURHRVRTW9EDYmF0XS5kcmF3KCk7Zy5mbGlwKCk7fSk7rWJhdHRlcnlJbnRlcnZhbD1CYW5nbGUuaXNMQ0RPbigpP3NldEludGVydmFsKCgpoldJREdFVFNb0QNiYXRdLmRyYXcoKSw2MDAwMCk6tztCYW5nbGUub24o0QhsY2RQb3dlciyqKG9uKXujKG9uKXtXSURHRVRTW9EDYmF0XS5kcmF3KCk7oyghYmF0dGVyeUludGVydmFsKWJhdHRlcnlJbnRlcnZhbD1zZXRJbnRlcnZhbCgoKaJXSURHRVRTW9EDYmF0XS5kcmF3KCksNjAwMDApO32ke6MoYmF0dGVyeUludGVydmFsKXtjbGVhckludGVydmFsKGJhdHRlcnlJbnRlcnZhbCk7YmF0dGVyeUludGVydmFsPbc7fX19KTtXSURHRVRTW9EDYmF0XT17YXJlYTrRAnRyLHdpZHRoOtQoLGRyYXc6qigpe6x4Pa8ueCx5Pa8ueTtnLnJlc2V0KCkuc2V0Q29sb3IoZy50aGVtZS5mZykuZmlsbFJlY3QoeCx5K9QCLHgr1CMseSvUFSkuY2xlYXJSZWN0KHgr1AIseSvUBCx4K9QhLHkr1BMpLmZpbGxSZWN0KHgr1CQseSvUCix4K9QnLHkr1A4pO6xiYXR0ZXJ5PUUuZ2V0QmF0dGVyeSgpO6MoYmF0dGVyeTzUFClnLnNldENvbG9yKNEEI2YwMCk7pKMoYmF0dGVyeTzUKClnLnNldENvbG9yKGcudGhlbWUuZGFyaz/RBCNmZjA60QQjZjgwKTukZy5zZXRDb2xvcijRBCMwZjApO2cuZmlsbFJlY3QoeCvUBCx5K9QGLHgr1AQrYmF0dGVyeSrUGy/UZCx5K9QRKTujKEJhbmdsZS5pc0NoYXJnaW5nKCkpZy5yZXNldCgpLmRyYXdJbWFnZSjRHRQKgQABwAAPAAD8AAfw+H/D/h8P4AA/AADwAAOALHgr1AgseSvUByk7fX07ff+KAAAAd2lkYmF0LmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 58512, "eyJpZCI6IndpZGJhdCIsIm5hbWUiOiJCYXR0ZXJ5IExldmVsIFdpZGdldCIsInR5cGUiOiJ3aWRnZXQiLCJ2ZXJzaW9uIjoiMC4xMiIsInRhZ3MiOiJ3aWRnZXQsYmF0dGVyeSIsImZpbGVzIjoid2lkYmF0LmluZm8sd2lkYmF0LndpZC5qcyJ9///DAQAAd2lkYnQud2lkLmpz");
  base64DecodeToExistingUint8Array(bufferView, 58684, "V0lER0VUU1vRCWJsdWV0b290aF09e2FyZWE60QJ0cix3aWR0aDrUDyxkcmF3OqooKXtnLnJlc2V0KCk7oyhOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWQpe6MoZy5nZXRCZ0NvbG9yKCmL1B8pe2cuc2V0Q29sb3Io0QQjMGZmKTt9pHtnLnNldENvbG9yKChnLmdldEJQUCgpPtQIKT/RBCMwN2Y6KGcudGhlbWUuZGFyaz/RBCMwZmY60QQjMDBmKSk7fX2ke2cuc2V0Q29sb3IoZy50aGVtZS5kYXJrP9EEIzY2NjrRBCM5OTkpO31nLmRyYXdJbWFnZSjRHwsUAQYA4BYCYEeI2TGsHwHAOA+DWMmxGCMEwLAcAwAs1AIrry54LNQCK68ueSk7fSxjaGFuZ2VkOqooKXtXSURHRVRTW9EJYmx1ZXRvb3RoXS5kcmF3KCk7fX07TlJGLm9uKNEHY29ubmVjdCxXSURHRVRTW9EJYmx1ZXRvb3RoXS5jaGFuZ2VkKTtOUkYub24o0QpkaXNjb25uZWN0LFdJREdFVFNb0QlibHVldG9vdGhdLmNoYW5nZWQpO/+FAAAAd2lkYnQuaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 59168, "eyJpZCI6IndpZGJ0IiwibmFtZSI6IkJsdWV0b290aCBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDkiLCJ0YWdzIjoid2lkZ2V0LGJsdWV0b290aCIsImZpbGVzIjoid2lkYnQuaW5mbyx3aWRidC53aWQuanMiff///wEBAAB3aWRpZC53aWQuanM=");
  base64DecodeToExistingUint8Array(bufferView, 59336, "KCgponuqZHJhdygpe6xpZD1OUkYuZ2V0QWRkcmVzcygpLnN1YnN0cigpLnN1YnN0cijUDCkuc3BsaXQo0QE6KTtnLnJlc2V0KCkuc2V0Q29sb3IoZy50aGVtZS5kYXJrP9EEIzBmZjrRBCMwMGYpLnNldEZvbnQo0QM2eDgs1AEpO2cuZHJhd1N0cmluZyhpZFvTXSyvLngr1AIsry55K9QELLQpO2cuZHJhd1N0cmluZyhpZFvUAV0sry54K9QCLK8ueSvUDiy0KTt9V0lER0VUU1vRBXdpZGlkXT17YXJlYTrRAnRyLHdpZHRoOtQQLGRyYXc6ZHJhd307fSkoKTv///+KAAAAd2lkaWQuaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 59628, "eyJpZCI6IndpZGlkIiwibmFtZSI6IkJsdWV0b290aCBJRCBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDMiLCJ0YWdzIjoid2lkZ2V0LGFkZHJlc3MsbWFjIiwiZmlsZXMiOiJ3aWRpZC5pbmZvLHdpZGlkLndpZC5qcyJ9//+qAAAAd2VsY29tZS5ib290Lmpz");
  base64DecodeToExistingUint8Array(bufferView, 59800, "KKooKXutcz1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0Qx3ZWxjb21lLmpzb24s1AEpoHt9O6MoIXMud2VsY29tZWQpe3NldFRpbWVvdXQoKCmie3JlcXVpcmUo0QdTdG9yYWdlKS53cml0ZSjRDHdlbGNvbWUuanNvbix7d2VsY29tZWQ6tH0pbG9hZCjRDndlbGNvbWUuYXBwLmpzKX0pfX0pKCn//1wWAAB3ZWxjb21lLmFwcC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 60004, "CqphbmltYXRlKHNlcSxwZXJpb2Qpe6xjPWcuZ2V0Q29sb3IoKTusaT1zZXRJbnRlcnZhbCiqKCl7oyhzZXEubGVuZ3RoKXusZj1zZXEuc2hpZnQoKTtnLnNldENvbG9yKGMpO6MoZilmKCk7faRjbGVhckludGVydmFsKGkpO30scGVyaW9kKTt9CqpmYWRlKGNvbCxjYWxsYmFjayl7rG490zuqZigpe9EDcmFtZy5zZXRDb2xvcihjb2wpO6corGk9bjtpPNXwADtpltQKKWcuZHJhd0xpbmUoaSzTLNMsaSkuZHJhd0xpbmUoaSzV8AAs1fAALGkpO2cuZmxpcCgpO26YO6MobjzUCilzZXRUaW1lb3V0KGYs0yk7pGNhbGxiYWNrKCk7fWYoKTt9CqxTQ0VORV9DT1VOVD3UCjsKqmdldFNjZW5lKG4pe6MoborTKauqKCl7Zy5yZXNldCgpLnNldEJnQ29sb3Io0ykuY2xlYXJSZWN0KNMs0yzVsAAs1bAAKTtnLnNldEZvbnQo0QQ2eDE1KTusbj3TO6xsPUJhbmdsZS5nZXRMb2dvKCk7rGltPWcuaW1hZ2VNZXRyaWNzKGwpO6xpPXNldEludGVydmFsKKooKXtuljAuMTtnLnNldENvbG9yKG4sbixuKTtnLmRyYXdJbWFnZShsLCjVsAAtaW0ud2lkdGgpL9QCLCjVsAAtaW0uaGVpZ2h0KS/UAik7oyhukdQBKXtjbGVhckludGVydmFsKGkpO3NldFRpbWVvdXQoKCmiZy5kcmF3U3RyaW5nKNEET3BlbizULCzUaCks1fQBKTtzZXRUaW1lb3V0KCgpomcuZHJhd1N0cmluZyjRCEhhY2thYmxlLNQsLNR0KSzV6AMpO3NldFRpbWVvdXQoKCmiZy5kcmF3U3RyaW5nKNELU21hcnQgV2F0Y2gs1Cws1YAAKSzV3AUpO319LNQyKTt9O6MoborUASmrqigpe6xpbWc9cmVxdWlyZSjRCmhlYXRzaHJpbmspLmRlY29tcHJlc3Mo0nUDptR4n/j/4gH+8H5wl+jOukVVoHZ8dt/n//n37OtgH9sHhwHp4H5xmkGiH72MRje/LL/7iIAEE7sPEgoAC+AlagIlIiMQErPxDwUYxAABwIHCj8N7nOl3uEqa6BEggnFjfM5nCkUil3gEq5KDAAQmC6QmBE4JxSEhIABiQmB8QmSXoQlCYRMdEwIlCAAIlNhYlOiO85nNEyMPEoZwIAAcsYIYmPXoYlMiKaFExX/u9VEqLBBOYrCH+czmtVqJyDEpiaCOYsgSYszmc3qtTEqMR7hzG8AlGmd1OQglOOY6aEgYlCmmZoJMCTBrnD6SaIEoU/zOUuolSjbnBJgqaCEoU5zOXX4RyQYBBzCS4X5zNDqqZCJiERJg5zBEoVJEoM1JgYlQjhMHc4JLEmZMEEp6ZIJgPzS4WTmZMVTILmFYAK+BmglCmd1JgUYJiPNEorABEIOZygDBm5MCiJMQlhMH8ByBXwIlBJgUxJiMd5nOTIzlBTAK+BAANVq4jPAAS/HJgJyCTATAEACC/B4S/IJgIlCYAgAPiS/Kn5yEYANTEyPc5niOQxMB/LlCOapyJJgbpBYAZzROQK/Gl0ATIWfEoZzBc6IlB6SYGgBJBJgpzSlhyH8EAh5MBTIjnCuIlOjjlHTAJzC/LmDTSSYIEoTABOYIlETSKYHXwIABOYM0yYmETSCYHEobnDOYqaBExu8TAwlEc4U5EoiaCmK+NTAolFEwX0TQzBMXwXiEpTBCAAomNEoS+EEo4mIYIImKEoS+EEpDoBEyUbEo3gEo4mJdAImIJY4lJEycdEoPOOBYmPuIlE+HcJYhKKTZ1fhYkB2EAhnNcYMuEhomMr8A3YABEoJyB5gjOAAYmHm9VgELEoJMBEoXAEyXzE45YBJgXwEqx1I+ByDOYJyVJw5yCgEB3cQGgJMWJwQnCu6/CgFBigDB13S/glVAAf1qomCglEoADB1QDBADEPEoNVqEAolEgEKolKErJMDYAJMD0lE0AmaEoNaAgJMCFIYAahV/IgIiDOTgABNYJMEOToiCIoJMCOTzfCN4RMBOTxsDJIRyfIwZMBKQZzfJgRyfOYZMBOUBzCJgNKOT5zDJgLoCADxKBOAIABOT6aCAARyfOYRyjOYRyjOYlKEsBzEEsBzEOUJzDOUIABOUiaDOURzCOUZzCEscKCiYKTusaW09Zy5pbWFnZU1ldHJpY3MoaW1nKTtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHI2ZmMDBmZik7rHk91bAALHNwZWVkPdQFO6piYWxsb29uKGNhbGxiYWNrKXt5l3NwZWVkO6x4PSjVsAAtaW0ud2lkdGgpL9QCO2cuZHJhd0ltYWdlKGltZyx4LHkpO2cuY2xlYXJSZWN0KHgseSvUUSx4K9RNLHkr1FErc3BlZWQpO6MoeT7UHilzZXRUaW1lb3V0KGJhbGxvb24s0yxjYWxsYmFjayk7pGNhbGxiYWNrKCk7fWZhZGUo0QcjZmYwMGZmLKooKXtiYWxsb29uKKooKXtnLnNldENvbG9yKNT/KS5zZXRGb250KNEGNngxNToyKS5zZXRGb250QWxpZ24o0yzTKTtnLmRyYXdTdHJpbmco0QhXZWxjb21lLizUWCzVggApO30pO30pO3NldFRpbWVvdXQoqigpe6xuPdM7rGk9c2V0SW50ZXJ2YWwoqigpe26W1AQ7Zy5zY3JvbGwo0yzU/Ck7oyhuPtWWACljbGVhckludGVydmFsKGkpO30s1BQpO30s1awNKTt9O6MoborUAimrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3Io0QcjZmZmZjAwKS5zZXRDb2xvcijTKS5jbGVhcigpO2cuc2V0Rm9udCjRBTEyeDIwKS5zZXRGb250QWxpZ24o0yzTKTuseD3URix5PdQZLGg91Bk7YW5pbWF0ZShbKCmiZy5kcmF3U3RyaW5nKNEEWW91cix4LHmWaCksKCmiZy5kcmF3U3RyaW5nKNEJQmFuZ2xlLmpzLHgseZZoKSwoKaJnLmRyYXdTdHJpbmco0QdoYXMgb25lLHgseZZoKSwoKaJnLmRyYXdTdHJpbmco0QZidXR0b24seCx5lmgpLCgpontnLnNldEZvbnQo0QcxMngyMDoyKS5zZXRGb250QWxpZ24o0yzTLNQBKS5kcmF3U3RyaW5nKNEFSEVSRSEs1ZYALNRYKTt9XSzVyAApO307oyhuitQDKauqKCl7Zy5yZXNldCgpO2cuc2V0QmdDb2xvcijRByMwMGZmZmYpLnNldENvbG9yKNMpLmNsZWFyKCk7Zy5zZXRGb250QWxpZ24o0yzTKS5zZXRGb250KNEGNngxNToyKTtnLmRyYXdTdHJpbmco0QVQcmVzcyzUWCzUKCkuc2V0Rm9udEFsaWduKNMs1P8pO2cuc2V0Rm9udCjRBTEyeDIwKTtnLmRyYXdTdHJpbmco0SNUbyB3YWtlIHRoZQpzY3JlZW4gdXAsIG9yIHRvCnNlbGVjdCzUWCzUPCk7fTujKG6K1AQpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHIzAwZmZmZikuc2V0Q29sb3Io0ykuY2xlYXIoKTtnLnNldEZvbnRBbGlnbijTLNMpLnNldEZvbnQo0QY2eDE1OjIpO2cuZHJhd1N0cmluZyjRCkxvbmcgUHJlc3Ms1Fgs1CgpLnNldEZvbnRBbGlnbijTLNT/KTtnLnNldEZvbnQo0QUxMngyMCk7Zy5kcmF3U3RyaW5nKNEXVG8gZ28gYmFjayB0bwp0aGUgY2xvY2ss1Fgs1DwpO307oyhuitQFKauqKCl7Zy5yZXNldCgpO2cuc2V0QmdDb2xvcijRByNmZjAwMDApLnNldENvbG9yKNMpLmNsZWFyKCk7Zy5zZXRGb250QWxpZ24o0yzTKS5zZXRGb250KNEFMTJ4MjApO2cuZHJhd1N0cmluZyjRVklmIEJhbmdsZS5qcyBldmVyCnN0b3BzLCBob2xkIHRoZQpidXR0b24gZm9yCnRlbiBzZWNvbmRzLgoKQmFuZ2xlLmpzIHdpbGwKdGhlbiByZWJvb3QuLNRYLNROKTt9O6MoborUBimrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3Io0QcjMDAwMGZmKS5zZXRDb2xvcijU/ykuY2xlYXIoKTtnLnNldEZvbnQo0QUxMngyMCkuc2V0Rm9udEFsaWduKNMs0yk7rHg91FgseT3U7CxoPdQ8O2FuaW1hdGUoWygpontnLmRyYXdTdHJpbmco0SBCYW5nbGUuanMgaGFzIGEKZnVsbCB0b3VjaHNjcmVlbix4LHmWaCk7fSzTLNMsKCmie2cuZHJhd1N0cmluZyjRLERyYWcgdXAgYW5kIGRvd24KdG8gc2Nyb2xsIGFuZAp0YXAgdG8gc2VsZWN0LHgseZZoKTt9LF0s1SwBKTt9O6MoborUBymrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3Io0QcjMDBmZjAwKS5zZXRDb2xvcijTKS5jbGVhcigpO2cuc2V0Rm9udCjRBTEyeDIwKS5zZXRGb250QWxpZ24o0yzTKTuseD3UWCx5PdTdLGg91FA7YW5pbWF0ZShbKCmie2cuZHJhd1N0cmluZyjRKUJhbmdsZS5qcyBjb21lcwp3aXRoIGEgZmV3CmFwcHMgaW5zdGFsbGVkLHgseZZoKTt9LNMs0ywoKaJ7Zy5kcmF3U3RyaW5nKNEkVG8gYWRkIG1vcmUsIHZpc2l0CmJhbmdsZWpzLmNvbS9hcHBzLHgseZZoKTt9LF0s1ZABKTt9O6MoborUCCmrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3Io0QcjZmYwMDAwKS5zZXRDb2xvcijTKS5jbGVhcigpO2cuc2V0Rm9udCjRBTEyeDIwKS5zZXRGb250QWxpZ24o0yzTKTuseD3UWDtnLmRyYXdTdHJpbmco0SBZb3UgY2FuIGFsc28gbWFrZQp5b3VyIG93biBhcHBzISx4LNQeKTtnLmRyYXdTdHJpbmco0RZDaGVjayBvdXQKYmFuZ2xlanMuY29tLHgs1YIAKTuscng90yxyeT3TO6pkcmF3KCl7cniWMC4xO3J5ljAuMTE7rHJjeD1NYXRoLmNvcyhyeCkscnN4PU1hdGguc2luKHJ4KSxyY3k9TWF0aC5jb3MocnkpLHJzeT1NYXRoLnNpbihyeSk7qnAoeCx5LHope6x0O3Q9eCpyY3kreipyc3k7ej16KnJjeS14KnJzeTt4PXQ7dD15KnJjeCt6KnJzeDt6PXoqcmN4LXkqcnN4O3k9dDt6ltQEO6tb1Fgr1DwqeC96LNROK9Q8Knkvel07faxhO6xzPdQeO2cuY2xlYXJSZWN0KNRYLXMs1E4tcyzUWCtzLNROK3MpO2E9cCjU/yzU/yzU/yk7Zy5tb3ZlVG8oYVvTXSxhW9QBXSk7YT1wKNQBLNT/LNT/KTtnLmxpbmVUbyhhW9NdLGFb1AFdKTthPXAo1AEs1AEs1P8pO2cubGluZVRvKGFb010sYVvUAV0pO2E9cCjU/yzUASzU/yk7Zy5saW5lVG8oYVvTXSxhW9QBXSk7YT1wKNT/LNT/LNT/KTtnLmxpbmVUbyhhW9NdLGFb1AFdKTthPXAo1P8s1P8s1AEpO2cubW92ZVRvKGFb010sYVvUAV0pO2E9cCjUASzU/yzUASk7Zy5saW5lVG8oYVvTXSxhW9QBXSk7YT1wKNQBLNQBLNQBKTtnLmxpbmVUbyhhW9NdLGFb1AFdKTthPXAo1P8s1AEs1AEpO2cubGluZVRvKGFb010sYVvUAV0pO2E9cCjU/yzU/yzUASk7Zy5saW5lVG8oYVvTXSxhW9QBXSk7YT1wKNT/LNT/LNT/KTtnLm1vdmVUbyhhW9NdLGFb1AFdKTthPXAo1P8s1P8s1AEpO2cubGluZVRvKGFb010sYVvUAV0pO2E9cCjUASzU/yzU/yk7Zy5tb3ZlVG8oYVvTXSxhW9QBXSk7YT1wKNQBLNT/LNQBKTtnLmxpbmVUbyhhW9NdLGFb1AFdKTthPXAo1AEs1AEs1P8pO2cubW92ZVRvKGFb010sYVvUAV0pO2E9cCjUASzUASzUASk7Zy5saW5lVG8oYVvTXSxhW9QBXSk7YT1wKNT/LNQBLNT/KTtnLm1vdmVUbyhhW9NdLGFb1AFdKTthPXAo1P8s1AEs1AEpO2cubGluZVRvKGFb010sYVvUAV0pO31zZXRJbnRlcnZhbChkcmF3LNQyKTt9O6MoborUCSmrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3Io0QcjZmZmZmZmKTtnLmNsZWFyKCk7Zy5zZXRGb250QWxpZ24o0yzTKTtnLnNldEZvbnQo0QUxMngyMCk7rHg91FgseT3UCixoPdQVO2FuaW1hdGUoWygpomcuZHJhd1N0cmluZyjRClRoYXQncyBpdCEseCx5lmgpLCgpontnLmRyYXdTdHJpbmco0QVQcmVzcyx4LHmWaCrUAik7Zy5kcmF3U3RyaW5nKNEKdGhlIGJ1dHRvbix4LHmWaCk7Zy5kcmF3U3RyaW5nKNEIdG8gc3RhcnQseCx5lmgpO2cuZHJhd1N0cmluZyjRCUJhbmdsZS5qcyx4LHmWaCk7fV0s1ZABKTt9faxzY2VuZU51bWJlcj3TO6ptb3ZlKGRpcil7oyhkaXI+055zY2VuZU51bWJlcivUAYpTQ0VORV9DT1VOVCmrO3NjZW5lTnVtYmVyPShzY2VuZU51bWJlcitkaXIpJVNDRU5FX0NPVU5UO6Moc2NlbmVOdW1iZXI80ylzY2VuZU51bWJlcj3TO2NsZWFySW50ZXJ2YWwoKTtnZXRTY2VuZShzY2VuZU51bWJlcikoKTujKHNjZW5lTnVtYmVyPtQBKXusbD1TQ0VORV9DT1VOVDunKKxpPdM7aTxsLdQCO2mYKXuseD3UWCsoaS0obC3UAikv1AIpKtQMO6MoaTxzY2VuZU51bWJlci3UASl7Zy5zZXRDb2xvcijU/ykuZmlsbENpcmNsZSh4LNWmACzUBCk7faR7Zy5zZXRDb2xvcijTKS5maWxsQ2lyY2xlKHgs1aYALNQEKTtnLnNldENvbG9yKNT/KS5kcmF3Q2lyY2xlKHgs1aYALNQEKTt9fX2jKHNjZW5lTnVtYmVyPFNDRU5FX0NPVU5ULdQBKXNldFRpbWVvdXQoqigpe21vdmUo1AEpO30s1YgTKTt9QmFuZ2xlLm9uKNEFc3dpcGUsZGlyom1vdmUoZGlyKSk7c2V0V2F0Y2goKCmie6Moc2NlbmVOdW1iZXKKU0NFTkVfQ09VTlQt1AEpbG9hZCgpO6Rtb3ZlKNQBKTt9LEJUTjEse3JlcGVhdDq0fSk7QmFuZ2xlLnNldExDRFRpbWVvdXQo0yk7QmFuZ2xlLnNldExvY2tlZCjTKTtCYW5nbGUuc2V0TENEUG93ZXIo1AEpO21vdmUo0yk71gEAAHdlbGNvbWUuc2V0dGluZ3MuanM=");
  base64DecodeToExistingUint8Array(bufferView, 65760, "KKooYmFjayl7rXNldHRpbmdzPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDHdlbGNvbWUuanNvbizUASmgcmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEMc2V0dGluZy5qc29uLNQBKaB7fUUuc2hvd01lbnUoeycnOnvRBXRpdGxlOtELV2VsY29tZSBBcHB9LNENUnVuIG5leHQgYm9vdDp7dmFsdWU6IXNldHRpbmdzLndlbGNvbWVkLG9uY2hhbmdlOnaicmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNEMd2VsY29tZS5qc29uLHt3ZWxjb21lZDohdn0pLH0s0QdSdW4gTm93OigpomxvYWQo0Q53ZWxjb21lLmFwcC5qcyks0RNUdXJuIG9mZiAmIHJ1biBuZXh0OigpontyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUo0Qx3ZWxjb21lLmpzb24se3dlbGNvbWVkOrV9KTtCYW5nbGUuc2V0TG9ja2VkKLQpO6MoQmFuZ2xlLnNvZnRPZmYoKSlCYW5nbGUuc29mdE9mZigpO6RCYW5nbGUub2ZmKCk7fSzRBjwgQmFjazpiYWNrLH0pfSn//wQJAAB3ZWxjb21lLmltZw==");
  base64DecodeToExistingUint8Array(bufferView, 66264, "MDCI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/szMzMzMzP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzMzMzMzMzMzM/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+zMzMzc7W1tbWzs3MzMaWlrq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzMzO1tfWzs3MzMzMzMzAlpa6urq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzNXX1s3MzMzMzMzMzMzMupa6urq6urr+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/szMztfWzczMzMzMzMzMzMzMxpaWurq6urq6/v7+/v7+/v7+/v7+/v7+/v7+YVtbf8zN1tbNzMzMzMzMzMzMzMzMzLqWurq6urq6uv7+/v7+/v7+/v7+/v7+/mFhYVtbqczO187MzMzMzMzMzMzMzMzMzMCWurq6urq6uv7+/v7+/v7+/v7+/v7+YWGGq6yHzMzV1szMzMzMzMzMzMzMzMzMzMaWlrq6urq6uv7+/v7+/v7+/v7+/v5hYYfWq1tbzMzWzszMzMzMzMzMzMzMzMzMzMyWlrq6urq6urr+/v7+/v7+/v7+/mFhh9erYVtbzMzWzczMzMzMzMzMzMzMzMzMzMyWlrq6urq6urr+/v7+/v7+/v7+/mGG16xhYVtbzMzVzMzMzMzMzMzMzMzMzMzMzMaWlrq6urq6urr+/v7+/v7+/v7+YWGs14ZhYVtbqMzOzMzMzMzMzMzMzMzMzMzMzMCWurq6urq6urr+/v7+/v7+/v7+YYXWrGFhYVtbf8zMzczMzMzMzMzMzMzMzMzMzMCWurq6urq6urr+/v7+/v7+/v7+YYbXh2FhYVtbW8zMzMzMzMzMzMzMzMzMzMzMzJaWurq6urq6uv7+/v7+/v7+/v7+YYbXhmFhYVtbW6jMzMzMzMzMzMzMzMzMzMzMxpaWurq6urq6uv7+/v7+/v7+/v7+YYbXhmFhYWFbW3/MzMzMzMzMzMzMzMzMzMzMupa6urq6urq6uv7+/v7+/v7+/v7+YWGyhmFhYWFbW1vMzMzMzMzMzMzMzMzMzMzGlpa6urq6urq6/v7+/v7+/v7+/v7+/mGGq2FhYWFhW1t/zMzMzMzMzMzMzMzMzMy6lrq6urq6urr+/v7+/v7+/v7+/v7+/mFhq2FhYWFhW1tbqMzMzMzMzMzMzMzMzMCWlrq6urq6uv7+/v7+/v7+/v7+/v7+/v5hhoZhYWFhYVtbW8zMzMzMzMzMzMzMxpaWurq6urq6/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYWFbW1vMzMzMzMzMzMzGlpa6urq6urr+/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYWFbW1tbqMzMzMzMzMaWlpa6urq6/v7+/v7+/v7+/v7+/v7+/v7+/v7+/mFhYWFhYWFhW1tbW3/MzMzM/v66urq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYVtbW/7GxsbG/paWlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lthYWFhYWFb/v7GxsbG/paWlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+YWFhW1tbW/7+pKT+/p6Xlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ltbW/7+iIj+/oiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ltbXP7+iIj+/oiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6BiP7+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiP7+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+iIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/uEAAAB3ZWxjb21lLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 68604, "eyJpZCI6IndlbGNvbWUiLCJuYW1lIjoiV2VsY29tZSIsInNyYyI6IndlbGNvbWUuYXBwLmpzIiwiaWNvbiI6IndlbGNvbWUuaW1nIiwidmVyc2lvbiI6IjAuMTQiLCJ0YWdzIjoic3RhcnQsd2VsY29tZSIsImZpbGVzIjoid2VsY29tZS5pbmZvLHdlbGNvbWUuYm9vdC5qcyx3ZWxjb21lLmFwcC5qcyx3ZWxjb21lLnNldHRpbmdzLmpzLHdlbGNvbWUuaW1nIiwiZGF0YSI6IndlbGNvbWUuanNvbiJ9////NgkAAG5vdGlmeQ==");
  base64DecodeToExistingUint8Array(bufferView, 68864, "rXBvcz3TLHNpemU90zsKrWlkPbY7Cq1oaWRlQ2FsbGJhY2s9tzsKrW92ZXJsYXlJbWFnZT23OwqqZml0V29yZHModGV4dCxyb3dzLHdpZHRoKXuud29yZHM9dGV4dC50cmltKCkuc3Vic3RyKNMscm93cyp3aWR0aCkuc3BsaXQoL1xzKy8pO61yb3c91AEsbGVuPdMsbGltaXQ9d2lkdGg7rXJlc3VsdD0iIjunKK13b3JkxndvcmRzKXujKChsZW4/bGVuK9QBOtMpK3dvcmQubGVuZ3RoPmxpbWl0KXujKHJvd5Fyb3dzKXtyZXN1bHSW0QMuLi47qDt9cmVzdWx0ltEBCjtsZW490ztyb3eYO6Mocm93i3Jvd3MpbGltaXSX1AM7fXJlc3VsdJYobGVuP9EBIDoiIikrd29yZDtsZW6WKGxlbj/UATrTKSt3b3JkLmxlbmd0aDt9q3Jlc3VsdDt9CmV4cG9ydHMuc2hvdz2qKG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc6B7fTujKG9wdGlvbnMub26LtylvcHRpb25zLm9uPbQ7aWQ9KNECaWS5b3B0aW9ucyk/b3B0aW9ucy5pZDq2O613PWcuZ2V0V2lkdGgoKTutdGV4dD1bXTtzaXplPW9wdGlvbnMuc2l6ZTujKG9wdGlvbnMuYm9keSl7rmJoPShzaXploNRQKS3UFCxtYXhSb3dzPU1hdGguZmxvb3IoKGJoLdQEKS/UCCksbWF4Q2hhcnM9TWF0aC5mbG9vcih3L9QGKS3UAjt0ZXh0PWZpdFdvcmRzKG9wdGlvbnMuYm9keSxtYXhSb3dzLG1heENoYXJzKTujKCFzaXplKXNpemU91BwrKHRleHQubWF0Y2goL1xuL2cpLmxlbmd0aCvUASkq1Ag7faRzaXplPdQUO6Moc2l6ZT7UUClzaXplPdRQO61nZz1HcmFwaGljcy5jcmVhdGVBcnJheUJ1ZmZlcih3LHNpemUs1BApO2dnLnNldEJnQ29sb3IoZy50aGVtZS5iZyk7b3ZlcmxheUltYWdlPXt3aWR0aDpnZy5nZXRXaWR0aCgpLGhlaWdodDpnZy5nZXRIZWlnaHQoKSxicHA61BAsYnVmZmVyOmdnLmJ1ZmZlcn07rXg90yx5PdMsaD1zaXplLGI9eStoLdQBLHI9eCt3LdQBO6Mob3B0aW9ucy5iZ0NvbG9yjbcpZ2cuc2V0QmdDb2xvcihvcHRpb25zLmJnQ29sb3IpO2dnLmNsZWFyUmVjdCh4LHkscixiKTujKG9wdGlvbnMudGl0bGWgb3B0aW9ucy5zcmMpe2dnLnNldENvbG9yKNEMdGl0bGVCZ0NvbG9yuW9wdGlvbnM/b3B0aW9ucy50aXRsZUJnQ29sb3I6Zy50aGVtZS5kYXJrP9QBOtXHOSkuZmlsbFJlY3QoeCx5LHIseSvUFCk7rnRpdGxlPW9wdGlvbnMudGl0bGWgb3B0aW9ucy5zcmM7Z2cuc2V0Q29sb3IoZy50aGVtZS5mZykuc2V0Rm9udEFsaWduKNT/LNT/LNMpLnNldEZvbnQo0QM2eDgs1AIpO2dnLmRyYXdTdHJpbmcodGl0bGUudHJpbSgpLnN1YnN0cmluZyjTLNQNKSx4K9QZLHkr1AMpO6Mob3B0aW9ucy50aXRsZZ5vcHRpb25zLnNyYyl7Z2cuc2V0Rm9udCjRAzZ4OCzUASkuc2V0Rm9udEFsaWduKNQBLNQBLNMpO2dnLmRyYXdTdHJpbmcob3B0aW9ucy5zcmMuc3Vic3RyaW5nKNMs1AopLGdnLmdldFdpZHRoKCkt1BcseSvUEik7fX15ltQUO2iX1BQ7oyhvcHRpb25zLmljb24pe61pPW9wdGlvbnMuaWNvbixpdztnZy5kcmF3SW1hZ2UoaSx4LHkr1AQpO6Mo0QZzdHJpbmeKv2kpaXc9aS5jaGFyQ29kZUF0KNMpO6Rpdz1pW9NdO3iWaXc7d5dpdzt9oyhvcHRpb25zLmJvZHkpe2dnLnNldENvbG9yKGcudGhlbWUuZmcpLnNldEZvbnQo0QM2eDgs1AEpLnNldEZvbnRBbGlnbijU/yzU/yzTKS5kcmF3U3RyaW5nKHRleHQseCvUBix5K9QEKTt9oyhvcHRpb25zLnJlbmRlcil7b3B0aW9ucy5yZW5kZXIoe3g6eCx5Onksdzp3LGg6aH0pO32jKG9wdGlvbnMub26eIShyZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QxzZXR0aW5nLmpzb24s1AEpoHt9KS5xdWlldCl7QmFuZ2xlLnNldExDRFBvd2VyKNQBKTt9qmFuaW0oKXtwb3OX1AI7oyhwb3M8LXNpemUpe3Bvcz0tc2l6ZTt9QmFuZ2xlLnNldExDRE92ZXJsYXkob3ZlcmxheUltYWdlLNMsLShwb3Mrc2l6ZSkpO6MocG9zPi1zaXplKXNldFRpbWVvdXQoYW5pbSzUDyk7fWFuaW0oKTtCYW5nbGUub24o0QV0b3VjaCxleHBvcnRzLmhpZGUpO6Mob3B0aW9ucy5vbkhpZGUpaGlkZUNhbGxiYWNrPW9wdGlvbnMub25IaWRlO307CmV4cG9ydHMuaGlkZT2qKG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc6B7fTujKNECaWS5b3B0aW9uc55vcHRpb25zLmlkjWlkKas7oyhoaWRlQ2FsbGJhY2spaGlkZUNhbGxiYWNrKHtpZDppZH0pO2hpZGVDYWxsYmFjaz23O2lkPbY7QmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFdG91Y2gsZXhwb3J0cy5oaWRlKTtFLnN0b3BFdmVudFByb3BhZ2F0aW9unkUuc3RvcEV2ZW50UHJvcGFnYXRpb24oKTuqYW5pbSgpe3Bvc5bUBDujKHBvcz7TKXtwb3M90ztvdmVybGF5SW1hZ2U9tztCYW5nbGUuc2V0TENET3ZlcmxheSgpO32kQmFuZ2xlLnNldExDRE92ZXJsYXkob3ZlcmxheUltYWdlLNMsLShwb3Mrc2l6ZSkpO6MocG9zPNMpc2V0VGltZW91dChhbmltLNQKKTt9YW5pbSgpO307//90AAAAbm90aWZ5LmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 71256, "eyJpZCI6Im5vdGlmeSIsIm5hbWUiOiJOb3RpZmljYXRpb25zIiwidHlwZSI6Im5vdGlmeSIsInZlcnNpb24iOiIwLjE0IiwidGFncyI6IndpZGdldCIsImZpbGVzIjoibm90aWZ5LmluZm8sbm90aWZ5In0EEwAAaGVhbHRoLmFwcC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 71404, "rXNldHRpbmdzOwqubXlwcm9maWxlPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDm15cHJvZmlsZS5qc29uLNQBKaB7fTsKqm1lbnVNYWluKCl7RS5zaG93TWVudSh7IiI6e3RpdGxlOtEPSGVhbHRoIFRyYWNraW5nfSzRBjwgQmFjazooKaJsb2FkKCks0Q1TdGVwIENvdW50aW5nOigpom1lbnVTdGVwQ291bnQoKSzRCE1vdmVtZW50Oigpom1lbnVNb3ZlbWVudCgpLNEKSGVhcnQgUmF0ZTooKaJtZW51SFJNKCks0QdCYXR0ZXJ5Oigpom1lbnVCYXR0ZXJ5KCks0QtUZW1wZXJhdHVyZTooKaJtZW51VGVtcGVyYXR1cmUoKSzRCFNldHRpbmdzOigpomV2YWwocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0RJoZWFsdGguc2V0dGluZ3MuanMpKSgoKaJ7bG9hZFNldHRpbmdzKCk7bWVudU1haW4oKTt9KX0pO30Kqm1lbnVTdGVwQ291bnQoKXuubWVudT17IiI6e3RpdGxlOtEFU3RlcHN9LNEGPCBCYWNrOigpom1lbnVNYWluKCks0QhwZXIgaG91cjooKaJzaG93R3JhcGgoe2lkOtEMc3RlcHNQZXJIb3VyLHJhbmdlOtEEaG91cixmaWVsZDrRBXN0ZXBzLGJhY2s6bWVudVN0ZXBDb3VudH0pLNEHcGVyIGRheTooKaJ7c2hvd0dyYXBoKHtpZDrRDHN0ZXBzUGVySG91cixyYW5nZTrRA2RheSxmaWVsZDrRBXN0ZXBzLGJhY2s6bWVudVN0ZXBDb3VudH0pZHJhd0hvcml6b250YWxMaW5lKHNldHRpbmdzLnN0ZXBHb2FsKTt9fTujKG15cHJvZmlsZS5zdHJpZGVMZW5ndGgpe21lbnVb0QhkaXN0YW5jZV09KCmibWVudURpc3RhbmNlKCk7fUUuc2hvd01lbnUobWVudSk7fQqqbWVudURpc3RhbmNlKCl7rmRpc3RNdWx0PXBhcnNlRmxvYXQocmVxdWlyZSjRBmxvY2FsZSkuZGlzdGFuY2UobXlwcm9maWxlLnN0cmlkZUxlbmd0aCzUAikpO0Uuc2hvd01lbnUoeyIiOnt0aXRsZTrRCERpc3RhbmNlfSzRBjwgQmFjazooKaJtZW51U3RlcENvdW50KCks0QhwZXIgaG91cjooKaJzaG93R3JhcGgoe2lkOtEMc3RlcHNQZXJIb3VyLHJhbmdlOtEEaG91cixmaWVsZDrRBXN0ZXBzLG11bHQ6ZGlzdE11bHQsYmFjazptZW51RGlzdGFuY2V9KSzRB3BlciBkYXk6KCmie3Nob3dHcmFwaCh7aWQ60QtzdGVwc1BlckRheSxyYW5nZTrRA2RheSxmaWVsZDrRBXN0ZXBzLG11bHQ6ZGlzdE11bHQsYmFjazptZW51RGlzdGFuY2V9KWRyYXdIb3Jpem9udGFsTGluZShzZXR0aW5ncy5zdGVwR29hbCooZGlzdE11bHSg1AEpKTt9fSk7fQqqbWVudU1vdmVtZW50KCl7RS5zaG93TWVudSh7IiI6e3RpdGxlOtEITW92ZW1lbnR9LNEGPCBCYWNrOigpom1lbnVNYWluKCks0QhwZXIgaG91cjooKaJzaG93R3JhcGgoe2lkOtEPbW92ZW1lbnRQZXJIb3VyLHJhbmdlOtEEaG91cixmaWVsZDrRCG1vdmVtZW50LGF2ZXJhZ2U6tCxiYWNrOm1lbnVNb3ZlbWVudH0pLNEHcGVyIGRheTooKaJzaG93R3JhcGgoe2lkOtEObW92ZW1lbnRQZXJEYXkscmFuZ2U60QNkYXksZmllbGQ60Qhtb3ZlbWVudCxhdmVyYWdlOrQsYmFjazptZW51TW92ZW1lbnR9KSx9KTt9CqptZW51SFJNKCl7RS5zaG93TWVudSh7IiI6e3RpdGxlOtEKSGVhcnQgUmF0ZX0s0QY8IEJhY2s6KCmibWVudU1haW4oKSzRCHBlciBob3VyOigponNob3dHcmFwaCh7aWQ60Qpocm1QZXJIb3VyLHJhbmdlOtEEaG91cixmaWVsZDrRA2JwbSxpZ25vcmVaZXJvOrQsYXZlcmFnZTq0LGJhY2s6bWVudUhSTX0pLNEHcGVyIGRheTooKaJzaG93R3JhcGgoe2lkOtEJaHJtUGVyRGF5LHJhbmdlOtEDZGF5LGZpZWxkOtEDYnBtLGlnbm9yZVplcm86tCxhdmVyYWdlOrQsYmFjazptZW51SFJNfSksfSk7fQqqbWVudUJhdHRlcnkoKXtFLnNob3dNZW51KHsiIjp7dGl0bGU60QdCYXR0ZXJ5fSzRBjwgQmFjazooKaJtZW51TWFpbigpLNEIcGVyIGhvdXI6KCmic2hvd0dyYXBoKHtpZDrRCmJhdFBlckhvdXIscmFuZ2U60QRob3VyLGZpZWxkOtEHYmF0dGVyeSxhdmVyYWdlOrQsYmFjazptZW51QmF0dGVyeX0pLNEHcGVyIGRheTooKaJzaG93R3JhcGgoe2lkOtEJYmF0UGVyRGF5LHJhbmdlOtEDZGF5LGZpZWxkOtEHYmF0dGVyeSxhdmVyYWdlOrQsYmFjazptZW51QmF0dGVyeX0pLH0pO30Kqm1lbnVUZW1wZXJhdHVyZSgpe0Uuc2hvd01lbnUoeyIiOnt0aXRsZTrRC1RlbXBlcmF0dXJlfSzRBjwgQmFjazooKaJtZW51TWFpbigpLNEIcGVyIGhvdXI6KCmic2hvd0dyYXBoKHtpZDrRCmJhdFBlckhvdXIscmFuZ2U60QRob3VyLGZpZWxkOtELdGVtcGVyYXR1cmUsYXZlcmFnZTq0LGJhY2s6bWVudVRlbXBlcmF0dXJlfSks0QdwZXIgZGF5OigponNob3dHcmFwaCh7aWQ60QliYXRQZXJEYXkscmFuZ2U60QNkYXksZmllbGQ60Qt0ZW1wZXJhdHVyZSxhdmVyYWdlOrQsYmFjazptZW51VGVtcGVyYXR1cmV9KSx9KTt9CqpzaG93R3JhcGgob3B0aW9ucyl7RS5zaG93TWVzc2FnZSjRCkxvYWRpbmcuLi4pO2N1cnJlbnRfc2VsZWN0aW9uPW9wdGlvbnMuaWQ7rGRhdGEsY250LHRpdGxlO6Mob3B0aW9ucy5yYW5nZYrRBGhvdXIpe3RpdGxlPdEESE9VUjtkYXRhPbhVaW50MTZBcnJheSjUGCk7Y250PbhVaW50OEFycmF5KNQYKTtyZXF1aXJlKNEGaGVhbHRoKS5yZWFkRGF5KLhEYXRlKCksaKJ7ZGF0YVtoLmhyXZZoW29wdGlvbnMuZmllbGRdO6MoIW9wdGlvbnMuaWdub3JlWmVyb6BoW29wdGlvbnMuZmllbGRdKWNudFtoLmhyXZg7fSk7faSjKG9wdGlvbnMucmFuZ2WK0QNkYXkpe3RpdGxlPdEDREFZO6xkYXRhPbhVaW50MTZBcnJheSjUICk7rGNudD24VWludDhBcnJheSjUICk7cmVxdWlyZSjRBmhlYWx0aCkucmVhZERhaWx5U3VtbWFyaWVzKLhEYXRlKCksaKJ7ZGF0YVtoLmRheV2WaFtvcHRpb25zLmZpZWxkXTujKCFvcHRpb25zLmlnbm9yZVplcm+gaFtvcHRpb25zLmZpZWxkXSljbnRbaC5kYXldmDt9KTusZGF5PSi4RGF0ZSgpKS5nZXREYXRlKCk7oyhkYXRhW2RheV2L0yl7ZGF0YVtkYXldPUJhbmdsZS5nZXRIZWFsdGhTdGF0dXMo0QNkYXkpW29wdGlvbnMuZmllbGRdO6MoIW9wdGlvbnMuaWdub3JlWmVyb6BkYXRhW2RheV0pY250W2RheV2YO319pLC4RXJyb3Io0Q1Vbmtub3duIHJhbmdlKTujKG9wdGlvbnMuYXZlcmFnZSlkYXRhLmZvckVhY2goKGQsaSmiZGF0YVtpXT1kL2NudFtpXSswLjUpO6Mob3B0aW9ucy5tdWx0jbcpe2RhdGEuZm9yRWFjaCgoZCxpKaJkYXRhW2ldPWQqb3B0aW9ucy5tdWx0KzAuNSk7fXNldEJ1dHRvbihvcHRpb25zLmJhY2ssb3B0aW9ucy5tdWx0KTtiYXJDaGFydCh0aXRsZSxkYXRhLG9wdGlvbnMubXVsdCk7fQqudz1nLmdldFdpZHRoKCk7Cq5oPWcuZ2V0SGVpZ2h0KCk7Cq5iYXJfYm90PdWMADsKrGRhdGFfbGVuOwqsY2hhcnRfaW5kZXg7CqxjaGFydF9tYXhfZGF0dW07CqxjaGFydF9sYWJlbDsKrGNoYXJ0X2RhdGE7CqxjdXJyZW50X3NlbGVjdGlvbjsKqm1heChhcnIpe6xtPS1JbmZpbml0eTunKKxpPdM7aTxhcnIubGVuZ3RoO2mYKaMoYXJyW2ldPm0pbT1hcnJbaV07q207fQqqZ2V0X2RhdGFfbGVuZ3RoKGFycil7rG5sZW49YXJyLmxlbmd0aDunKKxpPWFyci5sZW5ndGgt1AE7aT7TnmFycltpXYrTO2mZKW5sZW6ZO6tubGVuO30KqmJhckNoYXJ0KGxhYmVsLGR0KXtkYXRhX2xlbj1nZXRfZGF0YV9sZW5ndGgoZHQpO2NoYXJ0X2luZGV4PU1hdGgubWF4KGRhdGFfbGVuLdQFLNT7KTtjaGFydF9tYXhfZGF0dW09bWF4KGR0KTtjaGFydF9sYWJlbD1sYWJlbDtjaGFydF9kYXRhPWR0O2RyYXdCYXJDaGFydCgpO30KqmRyYXdCYXJDaGFydCgpe65iYXJfd2lkdGg9KHct1AIpL9QJO6xiYXJfdG9wO6xiYXI7Zy5yZXNldCgpLmNsZWFyUmVjdCjTLNQYLHcsaCk7pyhiYXI91AE7YmFyPNQKO2Jhcpgpe6MoYmFyitQFKXtnLnNldEZvbnQo0QM2eDgs1AIpLnNldEZvbnRBbGlnbijTLNT/KS5zZXRDb2xvcihnLnRoZW1lLmZnKTtnLmRyYXdTdHJpbmcoY2hhcnRfbGFiZWwr0QEgKyhjaGFydF9pbmRleCtiYXIt1AEpK9EDICAgK2NoYXJ0X2RhdGFbY2hhcnRfaW5kZXgrYmFyLdQBXSxnLmdldFdpZHRoKCkv1AIs1ZYAKTtnLnNldENvbG9yKNEEIzAwZik7faR7Zy5zZXRDb2xvcijRBCMwZmYpO32jKChjaGFydF9pbmRleCtiYXIt1AEpkdOeKGNoYXJ0X2luZGV4K2Jhci3UASk8ZGF0YV9sZW6eY2hhcnRfbWF4X2RhdHVtPtMpYmFyX3RvcD1iYXJfYm90LdRkKihjaGFydF9kYXRhW2NoYXJ0X2luZGV4K2Jhci3UAV0pL2NoYXJ0X21heF9kYXR1bTukYmFyX3RvcD1iYXJfYm90O2cuZmlsbFJlY3Qo1AErKGJhci3UASkqYmFyX3dpZHRoLGJhcl9ib3Qs1AErYmFyKmJhcl93aWR0aCxiYXJfdG9wKTtnLnNldENvbG9yKGcudGhlbWUuZmcpLmRyYXdSZWN0KNQBKyhiYXIt1AEpKmJhcl93aWR0aCxiYXJfYm90LNQBK2JhcipiYXJfd2lkdGgsYmFyX3RvcCk7fX0KqmRyYXdIb3Jpem9udGFsTGluZSh2YWx1ZSl7rnRvcD1iYXJfYm90LdRkKnZhbHVlL2NoYXJ0X21heF9kYXR1bTtnLnNldENvbG9yKGcudGhlbWUuZmcpLmRyYXdMaW5lKNMsdG9wLGcuZ2V0V2lkdGgoKSx0b3ApO30KqnNldEJ1dHRvbihmbixtdWx0KXtCYW5nbGUuc2V0VUkoe21vZGU60QZjdXN0b20sYmFjazpmbixzd2lwZToobHIsdWQponujKGxyitQBKXtjaGFydF9pbmRleD1NYXRoLm1heCgoY2hhcnRfbGFiZWyK0QNEQVkpP9T9OtT8LGNoYXJ0X2luZGV4LdQBKTt9pKMobHI80yl7Y2hhcnRfaW5kZXg9TWF0aC5taW4oZGF0YV9sZW4t1AUsY2hhcnRfaW5kZXgr1AEpO32ke6tmbigpO31kcmF3QmFyQ2hhcnQoKTujKGN1cnJlbnRfc2VsZWN0aW9uitELc3RlcHNQZXJEYXkpe2RyYXdIb3Jpem9udGFsTGluZShzZXR0aW5ncy5zdGVwR29hbCoobXVsdKDUASkpO319fSk7fQqqbG9hZFNldHRpbmdzKCl7c2V0dGluZ3M9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNELaGVhbHRoLmpzb24s1AEpoHt9O30KQmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwpsb2FkU2V0dGluZ3MoKTsKbWVudU1haW4oKTtMAgAAaGVhbHRoLmltZw==");
  base64DecodeToExistingUint8Array(bufferView, 76304, "MDDCAP//4Pn//zv/");
  base64DecodeToExistingUint8Array(bufferView, 76402, "AVVQAAAFVUAAAAAAFVVVAABVVVQAAAAAVVVVQAFVVVoAAAABVVVVUAVVVWqAAAAFVVVVVBVVVeqgAAAVVVVVVVVVV6q0AAAVVVVVVVVVXqrUAABVVVVVVVVVeqtVAABVVVVVVVVV6q1VAABVVXrVVVVXqrVVAABVVWq1VVVeqtVVAABVVWqtVVV6q1VVAABVVXqrVVXqrVVVAABVVV6q1VeqtVVVAAAVVVeqtV6q1VVUAAAVVVXqrXqrVVVUAAAFVVV6q+qtVVVQAAABVVVeqqq1VVVAAAAAVVVXqqrVVVUAAAAAFVVV6qtVVVQAAAAABVVVeq1VVVAAAAAAAVVVXrVVVUAAAAAAAFVVV9VVVQAAAAAAABVVVVVVVAAAAAAAAAVVVVVVUAAAAAAAAAFVVVVVQAAAAAAAAABVVVVVAAAAAAAAAAAVVVVUAAAAAAAAAAAFVVVQAAAAAAAAAAABVVVA");
  base64DecodeToExistingUint8Array(bufferView, 76765, "VVU=");
  base64DecodeToExistingUint8Array(bufferView, 76777, "FVQ=");
  base64DecodeToExistingUint8Array(bufferView, 76789, "BVA=");
  base64DecodeToExistingUint8Array(bufferView, 76801, "AUA=");
  base64DecodeToExistingUint8Array(bufferView, 76892, "UAgAAGhlYWx0aC5ib290Lmpz");
  base64DecodeToExistingUint8Array(bufferView, 76924, "e2xldCBhPTB8KHJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkSlNPTigiaGVhbHRoLmpzb24iLDEpfHx7fSkuaHJtO2lmKDE9PWF8fDI9PWEpe2xldCBkPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtCYW5nbGUuaXNDaGFyZ2luZygpfHwxMDA+QmFuZ2xlLmdldEhlYWx0aFN0YXR1cygibGFzdCIpLm1vdmVtZW50JiYuOTk8TWF0aC5hYnMoQmFuZ2xlLmdldEFjY2VsKCkueil8fChCYW5nbGUuc2V0SFJNUG93ZXIoMSwiaGVhbHRoIiksc2V0VGltZW91dCgoKT0+e0JhbmdsZS5zZXRIUk1Qb3dlcigwLCJoZWFsdGgiKX0sNkU0KmEpKX1jKCk7MT09YSYmKHNldFRpbWVvdXQoYywyRTUpLHNldFRpbWVvdXQoYyw0RTUpKX07QmFuZ2xlLm9uKCJoZWFsdGgiLGQpO0JhbmdsZS5vbigiSFJNIixiPT57OTA8Yi5jb25maWRlbmNlJiYxPk1hdGguYWJzKEJhbmdsZS5nZXRIZWFsdGhTdGF0dXMoKS5icG0tYi5icG0pJiZCYW5nbGUuc2V0SFJNUG93ZXIoMCwKImhlYWx0aCIpfSk7OTA+QmFuZ2xlLmdldEhlYWx0aFN0YXR1cygpLmJwbUNvbmZpZGVuY2UmJmQoKX1lbHNlIEJhbmdsZS5zZXRIUk1Qb3dlcighIWEsImhlYWx0aCIpfUJhbmdsZS5vbigiaGVhbHRoIixhPT57KEJhbmdsZS5nZXRQcmVzc3VyZT9CYW5nbGUuZ2V0UHJlc3N1cmUoKTpQcm9taXNlLnJlc29sdmUoe30pKS50aGVuKGQ9PntPYmplY3QuYXNzaWduKGEsZCk7ZD1uZXcgRGF0ZShEYXRlLm5vdygpLTU5RTQpO2lmKGEmJjA8YS5zdGVwcyl7dmFyIGI9cmVxdWlyZSgiU3RvcmFnZSIpLnJlYWRKU09OKCJoZWFsdGguanNvbiIsMSl8fHt9LGM9QmFuZ2xlLmdldEhlYWx0aFN0YXR1cygiZGF5Iikuc3RlcHM7Yi5zdGVwR29hbE5vdGlmaWNhdGlvbiYmMDxiLnN0ZXBHb2FsJiZjPj1iLnN0ZXBHb2FsJiYoYz0obmV3IERhdGUoRGF0ZS5ub3coKSkpLnRvSVNPU3RyaW5nKCkuc3BsaXQoIlQiKVswXSwhYi5zdGVwR29hbE5vdGlmaWNhdGlvbkRhdGV8fGIuc3RlcEdvYWxOb3RpZmljYXRpb25EYXRlPApjKSYmKEJhbmdsZS5idXp6KDIwMCwuNSkscmVxdWlyZSgibm90aWZ5Iikuc2hvdyh7dGl0bGU6Yi5zdGVwR29hbCsiIHN0ZXBzIixib2R5OiJZb3UgcmVhY2hlZCB5b3VyIHN0ZXAgZ29hbCEiLGljb246YXRvYigiREF5QkFCbUQ2QmFCTUFzQThCQ0JDQkNCQ0E4QUFBPT0iKX0pLGIuc3RlcEdvYWxOb3RpZmljYXRpb25EYXRlPWMscmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlSlNPTigiaGVhbHRoLmpzb24iLGIpKX12YXIgZz1mdW5jdGlvbihmKXtyZXR1cm4gMTQ1KihmLmdldERhdGUoKS0xKSs2KmYuZ2V0SG91cnMoKSsoMHw2KmYuZ2V0TWludXRlcygpLzYwKX0oZCk7ZD1mdW5jdGlvbihmKXtyZXR1cm4iaGVhbHRoLSIrZi5nZXRGdWxsWWVhcigpKyItIisoZi5nZXRNb250aCgpKzEpKyIucmF3In0oZCk7Yz1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChkKTtpZih2b2lkIDAhPT1jKXtiPXJlcXVpcmUoImhlYWx0aCIpLmdldERlY29kZXIoYyk7dmFyIGU9Yy5zdWJzdHIoOCtnKmIuciwKYi5yKTtpZihlIT1iLmNscil7cHJpbnQoIkhFQUxUSCBFUlI6IEFscmVhZHkgd3JpdHRlbiEiKTtyZXR1cm59fWVsc2UgYj1yZXF1aXJlKCJoZWFsdGgiKS5nZXREZWNvZGVyKCJIRUFMVEgyIikscmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlKGQsIkhFQUxUSDJceDAwIiwwLDgrNDQ5NSpiLnIpO3ZhciBoPTgrZypiLnI7cmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlKGQsYi5lbmNvZGUoYSksaCk7aWYoMTQzPT1nJTE0NSlpZihnPWgrYi5yLGMuc3Vic3RyKGcsYi5yKSE9Yi5jbHIpcHJpbnQoIkhFQUxUSCBFUlI6IERhaWx5IHN1bW1hcnkgYWxyZWFkeSB3cml0dGVuISIpO2Vsc2V7YT17c3RlcHM6MCxicG06MCxtb3ZlbWVudDowLG1vdkNudDowLGJwbUNudDowfTtmb3IodmFyIGs9MDsxNDQ+aztrKyspZT1jLnN1YnN0cihoLGIuciksZSE9Yi5jbHImJihlPWIuZGVjb2RlKGUpLGEuc3RlcHMrPWUuc3RlcHMsYS5icG0rPWUuYnBtLGEubW92ZW1lbnQrPWUubW92ZW1lbnQsYS5tb3ZDbnQrKywKZS5icG0mJmEuYnBtQ250KyspLGgtPWIucjthLmJwbUNudCYmKGEuYnBtLz1hLmJwbUNudCk7YS5tb3ZDbnQmJihhLm1vdmVtZW50Lz1hLm1vdkNudCk7cmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlKGQsYi5lbmNvZGUoYSksZyl9fSl9KU4KAABoZWFsdGg=");
  base64DecodeToExistingUint8Array(bufferView, 79084, "ZnVuY3Rpb24gayhiKXtyZXR1cm4iaGVhbHRoLSIrYi5nZXRGdWxsWWVhcigpKyItIisoYi5nZXRNb250aCgpKzEpKyIucmF3In1mdW5jdGlvbiBsKGIpe3JldHVybiAxNDUqKGIuZ2V0RGF0ZSgpLTEpKzYqYi5nZXRIb3VycygpKygwfDYqYi5nZXRNaW51dGVzKCkvNjApfWV4cG9ydHMuQUNUSVZJVFk9IlVOS05PV04gTk9UX1dPUk4gV0FMS0lORyBFWEVSQ0lTRSBMSUdIVF9TTEVFUCBERUVQX1NMRUVQIi5zcGxpdCgiICIpO2V4cG9ydHMuZ2V0RGVjb2Rlcj1mdW5jdGlvbihiKXtyZXR1cm4iSEVBTFRIMiI9PWIuc3Vic3RyKDAsNyk/e3I6MTAsY2xyOiJceGZmXHhmZlx4ZmZceGZmXHhmZlx4ZmZceGZmXHhmZlx4ZmZceGZmIixkZWNvZGU6YT0+eyJyYW0iO2E9YS5jaGFyQ29kZUF0LmJpbmQoYSk7YT17c3RlcHM6YSgwKTw8OHxhKDEpLGJwbU1pbjphKDIpLGJwbU1heDphKDMpLG1vdmVtZW50OjgqYSg0KSwKYmF0dGVyeTphKDUpJjEyNyxpc0NoYXJnaW5nOiEhKGEoNSkmMTI4KSx0ZW1wZXJhdHVyZTphKDYpLzIsYWx0aXR1ZGU6KGEoNykmMzEpPDw4fGEoOCksYWN0aXZpdHk6ZXhwb3J0cy5BQ1RJVklUWVthKDcpPj41XX07ODA8YS50ZW1wZXJhdHVyZSYmKGEudGVtcGVyYXR1cmUtPTEyOCk7YS5icG09KGEuYnBtTWluK2EuYnBtTWF4KS8yOzc1MDA8YS5hbHRpdHVkZSYmKGEuYWx0aXR1ZGUtPTgxOTIpO3JldHVybiBhfSxlbmNvZGU6YT0+eyJyYW0iO3ZhciBjPWEuYWx0aXR1ZGUmODE5MTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShhLnN0ZXBzPj44LGEuc3RlcHMmMjU1LGEuYnBtTWlufHxhLmJwbSxhLmJwbU1heHx8YS5icG0sTWF0aC5taW4oYS5tb3ZlbWVudD4+MywyNTUpLEUuZ2V0QmF0dGVyeSgpfChCYW5nbGUuaXNDaGFyZ2luZygpJiYxMjgpLDB8TWF0aC5yb3VuZCgyKmEudGVtcGVyYXR1cmUpLGM+Pjh8TWF0aC5tYXgoMCxleHBvcnRzLkFDVElWSVRZLmluZGV4T2YoYS5hY3Rpdml0eSkpPDwKNSxjJjI1NSwwKX19OntyOjQsY2xyOiJceGZmXHhmZlx4ZmZceGZmIixkZWNvZGU6YT0+eyJyYW0iO3JldHVybntzdGVwczphLmNoYXJDb2RlQXQoMCk8PDh8YS5jaGFyQ29kZUF0KDEpLGJwbTphLmNoYXJDb2RlQXQoMiksYnBtTWluOmEuY2hhckNvZGVBdCgyKSxicG1NYXg6YS5jaGFyQ29kZUF0KDIpLG1vdmVtZW50OjgqYS5jaGFyQ29kZUF0KDMpfX0sZW5jb2RlOmE9PnsicmFtIjtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShhLnN0ZXBzPj44LGEuc3RlcHMmMjU1LGEuYnBtLE1hdGgubWluKGEubW92ZW1lbnQ+PjMsMjU1KSl9fX07ZXhwb3J0cy5yZWFkQWxsUmVjb3Jkcz1mdW5jdGlvbihiLGEpe2I9ayhiKTtiPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkKGIpO2lmKHZvaWQgMCE9PWIpZm9yKHZhciBjPWV4cG9ydHMuZ2V0RGVjb2RlcihiKSxkPXt9LGU9OCxmPTA7MzE+ZjtmKyspe2QuZGF5PWYrMTtmb3IodmFyIGc9MDsyND5nO2crKyl7ZC5ocj1nO2Zvcih2YXIgaD0KMDs2Pmg7aCsrKXtkLm1pbj0xMCpoO3ZhciBtPWIuc3Vic3RyKGUsYy5yKTttIT1jLmNsciYmYShPYmplY3QuYXNzaWduKGMuZGVjb2RlKG0pLGQpKTtlKz1jLnJ9fWUrPWMucn19O2V4cG9ydHMucmVhZEZ1bGxEYXRhYmFzZT1mdW5jdGlvbihiKXtyZXF1aXJlKCJTdG9yYWdlIikubGlzdCgvaGVhbHRoLVswLTldKy1bMC05XSsucmF3LykuZm9yRWFjaChhPT57YT1hLnNwbGl0KCItIik7dmFyIGM9cGFyc2VJbnQoYVsxXSwxMCksZD1wYXJzZUludChhWzJdLnJlcGxhY2UoIi5yYXciLCIiKSwxMCktMTtleHBvcnRzLnJlYWRBbGxSZWNvcmRzKG5ldyBEYXRlKGMsZCwxKSxlPT57InJhbSI7ZS5kYXRlPW5ldyBEYXRlKGMsZCxlLmRheSxlLmhyLGUubWluKTtiKGUpfSl9KX07ZXhwb3J0cy5yZWFkQWxsUmVjb3Jkc1NpbmNlPWZ1bmN0aW9uKGIsYSl7Zm9yKHZhciBjPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGQ9bmV3IERhdGUoYi50b0lTT1N0cmluZygpLnN1YnN0cigwLDEwKSk7ZC5nZXRUaW1lKCk8PQpjOylleHBvcnRzLnJlYWREYXkoZCxlPT57InJhbSI7ZS5kYXRlPW5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSxkLmdldE1vbnRoKCksZC5nZXREYXRlKCksZS5ocixlLm1pbik7YShlKX0pLGQuc2V0RGF0ZShkLmdldERhdGUoKSsxKX07ZXhwb3J0cy5yZWFkRGFpbHlTdW1tYXJpZXM9ZnVuY3Rpb24oYixhKXtsKGIpO2I9ayhiKTtiPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkKGIpO2lmKHZvaWQgMCE9PWIpZm9yKHZhciBjPWV4cG9ydHMuZ2V0RGVjb2RlcihiKSxkPTgrMTQ0KmMucixlPTA7MzE+ZTtlKyspe3ZhciBmPWIuc3Vic3RyKGQsYy5yKTtmIT1jLmNsciYmYShPYmplY3QuYXNzaWduKGMuZGVjb2RlKGYpLHtkYXk6ZSsxfSkpO2QrPTE0NSpjLnJ9fTtleHBvcnRzLnJlYWREYXk9ZnVuY3Rpb24oYixhKXtsKGIpO3ZhciBjPWsoYik7Yz1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChjKTtpZih2b2lkIDAhPT1jKXt2YXIgZD1leHBvcnRzLmdldERlY29kZXIoYyksZT17fTtiPTgrMTQ1KgpkLnIqKGIuZ2V0RGF0ZSgpLTEpO2Zvcih2YXIgZj0wOzI0PmY7ZisrKXtlLmhyPWY7Zm9yKHZhciBnPTA7Nj5nO2crKyl7ZS5taW49MTAqZzt2YXIgaD1jLnN1YnN0cihiLGQucik7aCE9ZC5jbHImJmEoT2JqZWN0LmFzc2lnbihkLmRlY29kZShoKSxlKSk7Yis9ZC5yfX19ff//vAIAAGhlYWx0aC5zZXR0aW5ncy5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 81756, "KKooYmFjayl7rHNldHRpbmdzPU9iamVjdC5hc3NpZ24oe2hybTrTLHN0ZXBHb2FsOtUQJyxzdGVwR29hbE5vdGlmaWNhdGlvbjq1fSxyZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QtoZWFsdGguanNvbiy0KaB7fSk7qnNldFNldHRpbmdzKCl7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlSlNPTijRC2hlYWx0aC5qc29uLHNldHRpbmdzKTt9RS5zaG93TWVudSh7IiI6e3RpdGxlOtEPSGVhbHRoIFRyYWNraW5nfSzRBjwgQmFjazooKaJiYWNrKCks0QxIUk0gSW50ZXJ2YWw6e3ZhbHVlOnNldHRpbmdzLmhybSxtaW460yxtYXg61AMsZm9ybWF0OnaiW9EDT2ZmLNEFMyBtaW4s0QYxMCBtaW4s0QZBbHdheXNdW3ZdLG9uY2hhbmdlOnaie3NldHRpbmdzLmhybT12O3NldFNldHRpbmdzKCk7fX0s0Q9EYWlseSBTdGVwIEdvYWw6e3ZhbHVlOnNldHRpbmdzLnN0ZXBHb2FsLG1pbjrTLG1heDrVIE4sc3RlcDrV+gAsb25jaGFuZ2U6dqJ7c2V0dGluZ3Muc3RlcEdvYWw9djtzZXRTZXR0aW5ncygpO319LNEWU3RlcCBHb2FsIE5vdGlmaWNhdGlvbjp7dmFsdWU60RRzdGVwR29hbE5vdGlmaWNhdGlvbrlzZXR0aW5ncz9zZXR0aW5ncy5zdGVwR29hbE5vdGlmaWNhdGlvbjq1LG9uY2hhbmdlOigpontzZXR0aW5ncy5zdGVwR29hbE5vdGlmaWNhdGlvbj0hc2V0dGluZ3Muc3RlcEdvYWxOb3RpZmljYXRpb247c2V0U2V0dGluZ3MoKTt9fSx9KTt9KeMAAABoZWFsdGguaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 82488, "eyJpZCI6ImhlYWx0aCIsIm5hbWUiOiJIZWFsdGgiLCJzcmMiOiJoZWFsdGguYXBwLmpzIiwiaWNvbiI6ImhlYWx0aC5pbWciLCJ2ZXJzaW9uIjoiMC4zNyIsInRhZ3MiOiJ0b29sLHN5c3RlbSxoZWFsdGgiLCJmaWxlcyI6ImhlYWx0aC5pbmZvLGhlYWx0aC5hcHAuanMsaGVhbHRoLmltZyxoZWFsdGguYm9vdC5qcyxoZWFsdGgsaGVhbHRoLnNldHRpbmdzLmpzIiwiZGF0YSI6ImhlYWx0aC5qc29uIn3/DFgAAHNldHRpbmcuYXBwLmpz");
  base64DecodeToExistingUint8Array(bufferView, 82748, "TW9kdWxlcy5hZGRDYWNoZWQo0Qx3aWRnZXRfdXRpbHMsqigpe2V4cG9ydHMub2Zmc2V0PdM7ZXhwb3J0cy5oaWRlPaooKXtleHBvcnRzLmNsZWFudXAoKTujKGdsb2JhbC5XSURHRVRTKXtnLnJlc2V0KCk7pyisYcZnbG9iYWwuV0lER0VUUyl7oyhhLl9kcmF3Kag7YS5fZHJhdz1hLmRyYXc7YS5kcmF3PSgpont9O2EuX2FyZWE9YS5hcmVhO2EuYXJlYT0iIjvA04xhLnieZy5jbGVhclJlY3QoYS54LGEueSxhLngrYS53aWR0aC3UASxhLnkr1BcpfX19O2V4cG9ydHMuc2hvdz2qKCl7ZXhwb3J0cy5jbGVhbnVwKCk7oyhnbG9iYWwuV0lER0VUUymnKKxhxmdsb2JhbC5XSURHRVRTKXujKCFhLl9kcmF3Kag7YS5kcmF3PWEuX2RyYXc7YS5hcmVhPWEuX2FyZWE7vmEuX2RyYXc7vmEuX2FyZWE7YS5kcmF3KGEpfX07ZXhwb3J0cy5jbGVhbnVwT3ZlcmxheT2qKCl7ZXhwb3J0cy5vZmZzZXQ91Og7QmFuZ2xlLnNldExDRE92ZXJsYXmeQmFuZ2xlLnNldExDRE92ZXJsYXkowNMse2lkOtEMd2lkZ2V0X3V0aWxzfSk7vmV4cG9ydHMuYXV0b2hpZGU7vkJhbmdsZS5hcHBSZWN0O2V4cG9ydHMuYW5pbUludGVydmFsnihjbGVhckludGVydmFsKGV4cG9ydHMuYW5pbUludGVydmFsKSy+ZXhwb3J0cy5hbmltSW50ZXJ2YWwpO2V4cG9ydHMuaGlkZVRpbWVvdXSeKGNsZWFyVGltZW91dChleHBvcnRzLmhpZGVUaW1lb3V0KSy+ZXhwb3J0cy5oaWRlVGltZW91dCl9O2V4cG9ydHMuY2xlYW51cD2qKCl7ZXhwb3J0cy5jbGVhbnVwT3ZlcmxheSgpO75leHBvcnRzLm9mZnNldDtleHBvcnRzLnN3aXBlSGFuZGxlcp4oQmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFc3dpcGUsZXhwb3J0cy5zd2lwZUhhbmRsZXIpLL5leHBvcnRzLnN3aXBlSGFuZGxlcik7ZXhwb3J0cy5vcmlnRHJhd54oQmFuZ2xlLmRyYXdXaWRnZXRzPWV4cG9ydHMub3JpZ0RyYXcsvmV4cG9ydHMub3JpZ0RyYXcpfTtleHBvcnRzLnN3aXBlT249qihhKXuqaygpe65kPWV4cG9ydHMub2Zmc2V0O0JhbmdsZS5hcHBSZWN0Lnk9ZCvUGDtCYW5nbGUuYXBwUmVjdC5oPdQBK0JhbmdsZS5hcHBSZWN0LnkyLUJhbmdsZS5hcHBSZWN0Lnk7QmFuZ2xlLnNldExDRE92ZXJsYXmeKNToPGQ/QmFuZ2xlLnNldExDRE92ZXJsYXkoYizTLGQse2lkOtEMd2lkZ2V0X3V0aWxzLHJlbW92ZTooKaJ7cmVxdWlyZSjRDHdpZGdldF91dGlscykuY2xlYW51cE92ZXJsYXkoKX19KTpCYW5nbGUuc2V0TENET3ZlcmxheSjA0yx7aWQ60Qx3aWRnZXRfdXRpbHN9KSl9qmgoZCxmKXtleHBvcnRzLmFuaW1JbnRlcnZhbJ5jbGVhckludGVydmFsKGV4cG9ydHMuYW5pbUludGVydmFsKTtleHBvcnRzLmFuaW1JbnRlcnZhbD1zZXRJbnRlcnZhbCiqKCl7ZXhwb3J0cy5vZmZzZXSWZDutZT0h1AE70zxkntOOZXhwb3J0cy5vZmZzZXQ/KGU9IdMsZXhwb3J0cy5vZmZzZXQ90yk60z5kni3UFz5leHBvcnRzLm9mZnNldJ4oZT0h0yxleHBvcnRzLm9mZnNldD3U6Ck7ZZ4oY2xlYXJJbnRlcnZhbChleHBvcnRzLmFuaW1JbnRlcnZhbCksvmV4cG9ydHMuYW5pbUludGVydmFsLGaeZigpKTtrKCl9LNQyKX2jKNQCjXByb2Nlc3MuZW52LkhXVkVSU0lPTimrZXhwb3J0cy5oaWRlKCk7ZXhwb3J0cy5jbGVhbnVwKCk7oyhnbG9iYWwuV0lER0VUUyl7ZXhwb3J0cy5hdXRvaGlkZT3A04thP9XQBzphO0JhbmdsZS5hcHBSZWN0PXt4OtMseTrTLHc6Zy5nZXRXaWR0aCgpLGg6Zy5nZXRIZWlnaHQoKSx4MjpnLmdldFdpZHRoKCkt1AEseTI6Zy5nZXRIZWlnaHQoKS3UAX07rGI9R3JhcGhpY3MuY3JlYXRlQXJyYXlCdWZmZXIoZy5nZXRXaWR0aCgpLNQaLNQQLHttc2I6IdN9KTtiLnRoZW1lPWcudGhlbWU7Yi5fcmVzZXQ9Yi5yZXNldDtiLnJlc2V0PaooKXurry5fcmVzZXQoKS5zZXRDb2xvcihnLnRoZW1lLmZnKS5zZXRCZ0NvbG9yKGcudGhlbWUuYmcpfTtiLnJlc2V0KCkuY2xlYXJSZWN0KNMs0yxiLmdldFdpZHRoKCks1BcpLmZpbGxSZWN0KNMs1BgsYi5nZXRXaWR0aCgpLNQZKTusbD1nO2V4cG9ydHMub2Zmc2V0PdToO6corGPGZ2xvYmFsLldJREdFVFMpYy5fZHJhd6AoYy5fZHJhdz1jLmRyYXcsYy5kcmF3PaooKXtnPWI7ry5fZHJhdyivKTtnPWw7LdQYPGV4cG9ydHMub2Zmc2V0nmsoKX0sYy5fYXJlYT1jLmFyZWEsYy5hcmVhLnN0YXJ0c1dpdGgo0QFiKZ4oYy5hcmVhPdEBdCtjLmFyZWEuc3Vic3RyKNQBKSkpO2V4cG9ydHMub3JpZ0RyYXc9QmFuZ2xlLmRyYXdXaWRnZXRzO0JhbmdsZS5kcmF3V2lkZ2V0cz0oKaJ7Zz1iO2V4cG9ydHMub3JpZ0RyYXcoKTtnPWx9O2V4cG9ydHMuc3dpcGVIYW5kbGVyPaooZCxmKXtleHBvcnRzLmhpZGVUaW1lb3V0nihjbGVhclRpbWVvdXQoZXhwb3J0cy5oaWRlVGltZW91dCksvmV4cG9ydHMuaGlkZVRpbWVvdXQpO61lO9M8ZXhwb3J0cy5hdXRvaGlkZZ4oZT2qKCl7ZXhwb3J0cy5oaWRlVGltZW91dD1zZXRUaW1lb3V0KKooKXtoKNT8KX0sZXhwb3J0cy5hdXRvaGlkZSl9KTvTPGae0z5leHBvcnRzLm9mZnNldJ5oKNQELGUpO9M+Zp4t1Bg8ZXhwb3J0cy5vZmZzZXSeaCjU/Cl9O0JhbmdsZS5vbijRBXN3aXBlLGV4cG9ydHMuc3dpcGVIYW5kbGVyKTtCYW5nbGUuZHJhd1dpZGdldHMoKX19fSk7Ck1vZHVsZXMuYWRkQ2FjaGVkKNEKZGF0ZV91dGlscyyqKCl7ZXhwb3J0cy5kb3c9KGMsYSmie6xiPXJlcXVpcmUo0QZsb2NhbGUpLmRvdyh7Z2V0RGF5OigpoihjfNMpJdQHfSxhKS5zbGljZSjTLNQCimE/1AE61GQpO6vUAophP2IudG9VcHBlckNhc2UoKTpifTtleHBvcnRzLmRvd3M9KGMsYSmie6corGI9W10sZD3TO9QHPmQ7ZJgpYi5wdXNoKGV4cG9ydHMuZG93KGQrKGOg0yksYSkpO6vUAophP2IubWFwKGWiZS50b1VwcGVyQ2FzZSgpKTpifTtleHBvcnRzLm1vbnRoPShjLGEponusYj1yZXF1aXJlKNEGbG9jYWxlKS5tb250aCh7Z2V0TW9udGg6KCmiKNQLKyhjfNMpKSXUDH0sYSkuc2xpY2Uo0yzUAophP9QBOtRkKTur1AKKYT9iLnRvVXBwZXJDYXNlKCk6Yn07ZXhwb3J0cy5tb250aHM9Y6J7pyisYT1bXSxiPXJlcXVpcmUo0QZsb2NhbGUpLGQ90zvUDD5kO2SYKWEucHVzaChiLm1vbnRoKHtnZXRNb250aDooKaJkfSxjKS5zbGljZSjTLNQCimM/1AE61GQpKTur1AKKYz9hLm1hcChlomUudG9VcHBlckNhc2UoKSk6YX19KTsKQmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwquQkFOR0xFSlMyPXByb2Nlc3MuZW52LkhXVkVSU0lPTorUAjsKrnN0b3JhZ2U9cmVxdWlyZSjRB1N0b3JhZ2UpOwqtc2V0dGluZ3M7Cq5zY3JvbGxzPVtdOwqtbWVudVNjcm9sbGVyOwqqdXBkYXRlU2V0dGluZ3MoKXtzdG9yYWdlLndyaXRlKNEMc2V0dGluZy5qc29uLHNldHRpbmdzKTt9CqpwdXNoTWVudShtZW51KXujKG1lbnVTY3JvbGxlcilzY3JvbGxzLnB1c2gobWVudVNjcm9sbGVyLnNjcm9sbCk7oyhtZW51KXuubT1FLnNob3dNZW51KG1lbnUpO21lbnVTY3JvbGxlcj1tLnNjcm9sbGVyO6ttO319CqpyZXN0b3JlTWVudShtZW51KXujKCFtZW51WyIiXSltZW51WyIiXT17fTujKG1lbnVTY3JvbGxlciltZW51WyIiXS5zY3JvbGw9bWVudVNjcm9sbGVyLnNjcm9sbDttZW51U2Nyb2xsZXI9RS5zaG93TWVudShtZW51KS5zY3JvbGxlcjt9Cqpwb3BNZW51KG1lbnUpe6MoIW1lbnVbIiJdKW1lbnVbIiJdPXt9O21lbnVbIiJdLnNjcm9sbD1zY3JvbGxzLnBvcCgpfNM7rm09RS5zaG93TWVudShtZW51KTttZW51U2Nyb2xsZXI9bS5zY3JvbGxlcjurbTt9Cqp1cGRhdGVPcHRpb25zKCl7rG89c2V0dGluZ3Mub3B0aW9uczujKEJBTkdMRUpTMil7oyghKG8ud2FrZU9uQlROMaBvLndha2VPbkZhY2VVcKBvLndha2VPblRvdWNooG8ud2FrZU9uRG91YmxlVGFwoG8ud2FrZU9uVHdpc3QpKXtvLndha2VPbkJUTjE9tDt9faR7oyghKG8ud2FrZU9uQlROMaBvLndha2VPbkJUTjKgby53YWtlT25CVE4zoG8ud2FrZU9uRmFjZVVwoG8ud2FrZU9uVG91Y2igby53YWtlT25Ud2lzdCkpby53YWtlT25CVE4yPbQ7fXVwZGF0ZVNldHRpbmdzKCk7QmFuZ2xlLnNldE9wdGlvbnMobyl9CqpyZXNldFNldHRpbmdzKCl7c2V0dGluZ3M9e2JsZTq0LGJsZXJlcGw6tCxsb2c6tSxxdWlldDrTLHRpbWVvdXQ61AosdmlicmF0ZTq0LGJlZXA6QkFOR0xFSlMyP7Q60QN2aWIsdGltZXpvbmU60yxISUQ6tSxjbG9jazq2LNEGMTJob3VyOrUsZmlyc3REYXlPZldlZWs60yxicmlnaHRuZXNzOtQBLG9wdGlvbnM6e3dha2VPbkJUTjE6tCx3YWtlT25CVE4yOrQsd2FrZU9uQlROMzq0LHdha2VPbkZhY2VVcDq1LHdha2VPblRvdWNoOrUsd2FrZU9uVHdpc3Q6tSx0d2lzdFRocmVzaG9sZDo4MTkuMix0d2lzdE1heFk61eD8LHR3aXN0VGltZW91dDrV6AN9LH07dXBkYXRlU2V0dGluZ3MoKTt9CnNldHRpbmdzPXN0b3JhZ2UucmVhZEpTT04o0QxzZXR0aW5nLmpzb24s1AEpOwqjKCjRBm9iamVjdIy/c2V0dGluZ3MpoCjRBm9iamVjdIy/c2V0dGluZ3Mub3B0aW9ucykpCnJlc2V0U2V0dGluZ3MoKTsKqm1haW5NZW51KCl7rm1haW5tZW51PXsnJzp70QV0aXRsZTrRCFNldHRpbmdzfSzRBjwgQmFjazooKaJsb2FkKCks0QRBcHBzOigponB1c2hNZW51KGFwcFNldHRpbmdzTWVudSgpKSzRBlN5c3RlbTooKaJwdXNoTWVudShzeXN0ZW1NZW51KCkpLNEJQmx1ZXRvb3RoOigponB1c2hNZW51KEJMRU1lbnUoKSks0QZBbGVydHM6KCmicHVzaE1lbnUoYWxlcnRzTWVudSgpKSzRBVV0aWxzOigponB1c2hNZW51KHV0aWxNZW51KCkpfTurbWFpbm1lbnU7fQqqc3lzdGVtTWVudSgpe65tYWlubWVudT17Jyc6e9EFdGl0bGU60QZTeXN0ZW19LNEGPCBCYWNrOigponBvcE1lbnUobWFpbk1lbnUoKSks0QVUaGVtZTooKaJzaG93VGhlbWVNZW51KCks0QNMQ0Q6KCmicHVzaE1lbnUoTENETWVudSgpKSzRBkxvY2FsZTooKaJwdXNoTWVudShsb2NhbGVNZW51KCkpLNEFQ2xvY2s6KCmicHVzaE1lbnUoY2xvY2tNZW51KCkpLNEITGF1bmNoZXI6KCmicHVzaE1lbnUobGF1bmNoZXJNZW51KCkpLNELRGF0ZSAmIFRpbWU6KCmicHVzaE1lbnUoc2V0VGltZU1lbnUoKSl9O6MoQmFuZ2xlLmdldFByZXNzdXJlKW1haW5tZW51W9EIQWx0aXR1ZGVdPSgponB1c2hNZW51KHNob3dBbHRpdHVkZSgpKTurbWFpbm1lbnU7fQqqYWxlcnRzTWVudSgpe6xiZWVwTWVudUl0ZW07oyhCQU5HTEVKUzIpe2JlZXBNZW51SXRlbT17dmFsdWU6c2V0dGluZ3MuYmVlcIy1LG9uY2hhbmdlOnaie3NldHRpbmdzLmJlZXA9djt1cGRhdGVTZXR0aW5ncygpO6Moc2V0dGluZ3MuYmVlcCl7YW5hbG9nV3JpdGUoVklCUkFURSwwLjEse2ZyZXE61dAHfSk7c2V0VGltZW91dCgoKaJWSUJSQVRFLnJlc2V0KCks1cgAKTt9fX07faR7rGJlZXBWPVu1LLQs0QN2aWJdO6xiZWVwTj1b0QNPZmYs0QVQaWV6byzRB1ZpYnJhdGVdO2JlZXBNZW51SXRlbT17dmFsdWU6TWF0aC5tYXgo03xiZWVwVi5pbmRleE9mKHNldHRpbmdzLmJlZXApLNMpLG1pbjrTLG1heDpiZWVwVi5sZW5ndGgt1AEsZm9ybWF0OnaiYmVlcE5bdl0sb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYmVlcD1iZWVwVlt2XTujKHaK1AEpe2FuYWxvZ1dyaXRlKEQxOCwwLjUse2ZyZXE61dAHfSk7c2V0VGltZW91dCgoKaJEMTgucmVzZXQoKSzVyAApO32koyh2itQCKXthbmFsb2dXcml0ZShWSUJSQVRFLDAuMSx7ZnJlcTrV0Ad9KTtzZXRUaW1lb3V0KCgpolZJQlJBVEUucmVzZXQoKSzVyAApO311cGRhdGVTZXR0aW5ncygpO319O32ubWFpbm1lbnU9eycnOnvRBXRpdGxlOtEGQWxlcnRzfSzRBjwgQmFjazooKaJwb3BNZW51KG1haW5NZW51KCkpLNEEQmVlcDpiZWVwTWVudUl0ZW0s0QlWaWJyYXRpb246e3ZhbHVlOnNldHRpbmdzLnZpYnJhdGUsb25jaGFuZ2U6KCmie3NldHRpbmdzLnZpYnJhdGU9IXNldHRpbmdzLnZpYnJhdGU7dXBkYXRlU2V0dGluZ3MoKTujKHNldHRpbmdzLnZpYnJhdGUpe1ZJQlJBVEUud3JpdGUo1AEpO3NldFRpbWVvdXQoKCmiVklCUkFURS53cml0ZSjTKSzUCik7fX19LNEKUXVpZXQgTW9kZTp7dmFsdWU6KHNldHRpbmdzLnF1aWV0fNMpJdQDLG1pbjrTLG1heDrUAixmb3JtYXQ6dqJb0QNPZmYs0QZBbGFybXMs0QZTaWxlbnRdW3ZdLG9uY2hhbmdlOnaie3NldHRpbmdzLnF1aWV0PXYl1AM7dXBkYXRlU2V0dGluZ3MoKTt1cGRhdGVPcHRpb25zKCk7oyjRB3Ftc2NoZWS5V0lER0VUUylXSURHRVRTW9EHcW1zY2hlZF0uZHJhdygpO30sfX07q21haW5tZW51O30KqkJMRU1lbnUoKXusaGlkVj1btSzRB2tibWVkaWEs0QJrYizRA2NvbSzRA2pveV07rGhpZE49W9EDT2ZmLNEMS2JyZCAmIE1lZGlhLNEES2JyZCzRDEticmQgJiBNb3VzZSzRCEpveXN0aWNrXTuscHJpdmFjeT1b0QNPZmYs0QlTaG93IG5hbWUs0QlIaWRlIG5hbWVdO6xtZW51PXsnJzp70QV0aXRsZTrRCUJsdWV0b290aH0s0QY8IEJhY2s6KCmicG9wTWVudShtYWluTWVudSgpKSzREE1ha2UgQ29ubmVjdGFibGU6KCmibWFrZUNvbm5lY3RhYmxlKCks0QNCTEU6e3ZhbHVlOnNldHRpbmdzLmJsZSxvbmNoYW5nZTooKaJ7c2V0dGluZ3MuYmxlPSFzZXR0aW5ncy5ibGU7dXBkYXRlU2V0dGluZ3MoKTt9fSzRDFByb2dyYW1tYWJsZTp7dmFsdWU6c2V0dGluZ3MuYmxlcmVwbCxvbmNoYW5nZTooKaJ7c2V0dGluZ3MuYmxlcmVwbD0hc2V0dGluZ3MuYmxlcmVwbDt1cGRhdGVTZXR0aW5ncygpO319LNEDSElEOnt2YWx1ZTpNYXRoLm1heCjTLNN8aGlkVi5pbmRleE9mKHNldHRpbmdzLkhJRCkpLG1pbjrTLG1heDpoaWROLmxlbmd0aC3UASxmb3JtYXQ6dqJoaWROW3ZdLG9uY2hhbmdlOnaie3NldHRpbmdzLkhJRD1oaWRWW3ZdO3VwZGF0ZVNldHRpbmdzKCk7fX0s0QdQYXNza2V5Ont2YWx1ZTpzZXR0aW5ncy5wYXNza2V5P3NldHRpbmdzLnBhc3NrZXk60QRub25lLG9uY2hhbmdlOigponNldFRpbWVvdXQoKCmicHVzaE1lbnUocGFzc2tleU1lbnUoKSkpfSzRCVdoaXRlbGlzdDp7dmFsdWU6KChzZXR0aW5ncy53aGl0ZWxpc3RfZGlzYWJsZWSgIXNldHRpbmdzLndoaXRlbGlzdCk/0QNPZmY60QJPbikrKHNldHRpbmdzLndoaXRlbGlzdD/RAiAoK3NldHRpbmdzLndoaXRlbGlzdC5sZW5ndGgr0QEpOiIiKSxvbmNoYW5nZTooKaJzZXRUaW1lb3V0KCgponB1c2hNZW51KHdoaXRlbGlzdE1lbnUoKSkpfX07oyhCQU5HTEVKUzIpbWVudVvRB1ByaXZhY3ldPXttaW460yxtYXg6cHJpdmFjeS5sZW5ndGgt1AEsZm9ybWF0OnaicHJpdmFjeVt2XSx2YWx1ZTooKCmie6Moc2V0dGluZ3MuYmxlcHJpdmFjeZ5zZXR0aW5ncy5ibGVuYW1li7Upq9QCO6Moc2V0dGluZ3MuYmxlcHJpdmFjeSmr1AE7q9M7fSkoKSxvbmNoYW5nZTp2ontzZXR0aW5ncy5ibGVwcml2YWN5PdM7vnNldHRpbmdzLmJsZW5hbWU7uyh2KXu80zqoO7zUATpzZXR0aW5ncy5ibGVwcml2YWN5PdQBO6g7vNQCOnNldHRpbmdzLmJsZXByaXZhY3k91AE7c2V0dGluZ3MuYmxlbmFtZT21O6g7fXVwZGF0ZVNldHRpbmdzKCk7fX07q21lbnU7fQqqc2hvd1RoZW1lTWVudShwb3Ape6pjbCh4KXurZy5zZXRDb2xvcih4KS5nZXRDb2xvcigpO32qdXBkKHRoKXtnLnRoZW1lPXRoO3NldHRpbmdzLnRoZW1lPXRoO3VwZGF0ZVNldHRpbmdzKCk7vmcucmVzZXQ7Zy5fcmVzZXQ9Zy5yZXNldDtnLnJlc2V0Paoobil7q2cuX3Jlc2V0KCkuc2V0Q29sb3IodGguZmcpLnNldEJnQ29sb3IodGguYmcpO307Zy5jbGVhcj2qKG4pe6MobilnLnJlc2V0KCk7q2cuY2xlYXJSZWN0KNMs0yxnLmdldFdpZHRoKCksZy5nZXRIZWlnaHQoKSk7fTtnLmNsZWFyKNQBKTtCYW5nbGUuZHJhd1dpZGdldHMoKTttLmRyYXcoKTt9rHRoZW1lc01lbnU9eycnOnt0aXRsZTrRBVRoZW1lfSzRBjwgQmFjazooKaJwb3BNZW51KHN5c3RlbU1lbnUoKSks0QdEYXJrIEJXOigpont1cGQoe2ZnOmNsKNEEI2ZmZiksYmc6Y2wo0QQjMDAwKSxmZzI6Y2wo0QQjZmZmKSxiZzI6Y2wo0QQjMDA0KSxmZ0g6Y2wo0QQjZmZmKSxiZ0g6Y2wo0QQjMDBmKSxkYXJrOrR9KTt9LNEITGlnaHQgQlc6KCmie3VwZCh7Zmc6Y2wo0QQjMDAwKSxiZzpjbCjRBCNmZmYpLGZnMjpjbCjRBCMwMDApLGJnMjpjbCjRBCNjZmYpLGZnSDpjbCjRBCMwMDApLGJnSDpjbCjRBCMwZmYpLGRhcms6tX0pO319O3N0b3JhZ2UubGlzdCgvXi4qXC50aGVtZSQvKS5mb3JFYWNoKG6ie61uZXdUaGVtZT1zdG9yYWdlLnJlYWRKU09OKG4pO3RoZW1lc01lbnVbbmV3VGhlbWUubmFtZT9uZXdUaGVtZS5uYW1lOm5dPSgpont1cGQoe2ZnOmNsKG5ld1RoZW1lLmZnKSxiZzpjbChuZXdUaGVtZS5iZyksZmcyOmNsKG5ld1RoZW1lLmZnMiksYmcyOmNsKG5ld1RoZW1lLmJnMiksZmdIOmNsKG5ld1RoZW1lLmZnSCksYmdIOmNsKG5ld1RoZW1lLmJnSCksZGFyazpuZXdUaGVtZS5kYXJrfSk7fTt9KTt0aGVtZXNNZW51W9EJQ3VzdG9taXplXT0oKaJzaG93Q3VzdG9tVGhlbWVNZW51KCk7rG09KHBvcD9wb3BNZW51OnB1c2hNZW51KSh0aGVtZXNNZW51KTuqc2hvd0N1c3RvbVRoZW1lTWVudSgpe6pzZXRUKHQsdil7rXRoPWcudGhlbWU7dGhbdF09djujKHSL0QJiZyl7dGhb0QRkYXJrXT0odotjbCjRBCMwMDApKTt9dXBkKHRoKTt9rXJnYj17fTtyZ2Jb0QVibGFja1090QQjMDAwO3JnYlvRBXdoaXRlXT3RBCNmZmY7cmdiW9EDcmVkXT3RBCNmMDA7cmdiW9EFZ3JlZW5dPdEEIzBmMDtyZ2Jb0QRibHVlXT3RBCMwMGY7cmdiW9EEY3lhbl090QQjMGZmO3JnYlvRB21hZ2VudGFdPdEEI2YwZjtyZ2Jb0QZ5ZWxsb3ddPdEEI2ZmMDujKCFCQU5HTEVKUzIpe3JnYlvRBm9yYW5nZV090QcjZmY3ZjAwO3JnYlvRBnB1cnBsZV090QcjN2YwMGZmO3JnYlvRBGdyZXldPdEHIzdmN2Y3Zjt9rWNvbG9ycz1bXSxuYW1lcz1bXTunKK5juXJnYil7bmFtZXMucHVzaChjKTtjb2xvcnMucHVzaChjbChyZ2JbY10pKTt9rW1lbnU9eycnOnt0aXRsZTrRDEN1c3RvbSBUaGVtZX0s0QY8IEJhY2s6KCmic2hvd1RoZW1lTWVudSjUASl9O65sYWJlbHM9e2ZnOtEKRm9yZWdyb3VuZCxiZzrRCkJhY2tncm91bmQsZmcyOtEMRm9yZWdyb3VuZCAyLGJnMjrRDEJhY2tncm91bmQgMixmZ0g60QxIaWdobGlnaHQgRkcsYmdIOtEMSGlnaGxpZ2h0IEJHLH07W9ECZmcs0QJiZyzRA2ZnMizRA2JnMizRA2ZnSCzRA2JnSF0uZm9yRWFjaCh0onttZW51W2xhYmVsc1t0XV09e21pbjrTLG1heDpjb2xvcnMubGVuZ3RoLdQBLHdyYXA6tCx2YWx1ZTpNYXRoLm1heChjb2xvcnMuaW5kZXhPZihnLnRoZW1lW3RdKSzTKSxmb3JtYXQ6dqJuYW1lc1t2XSxvbmNoYW5nZTqqKHYpe6xjPWNvbG9yc1t2XTujKHSL0QJmZ55nLnRoZW1lLmJni2Mpc2V0VCjRAmJnLGcudGhlbWUuZmcpO6ModIvRAmJnnmcudGhlbWUuZmeLYylzZXRUKNECZmcsZy50aGVtZS5iZyk7c2V0VCh0LGMpO30sfTt9KTttPXB1c2hNZW51KG1lbnUpO319CqpwYXNza2V5TWVudSgpe6xtZW51PXvRBjwgQmFjazooKaJwb3BNZW51KEJMRU1lbnUoKSks0QdEaXNhYmxlOigpontzZXR0aW5ncy5wYXNza2V5Pbc7dXBkYXRlU2V0dGluZ3MoKTtwb3BNZW51KEJMRU1lbnUoKSk7fX07oyghc2V0dGluZ3MucGFzc2tleaBzZXR0aW5ncy5wYXNza2V5Lmxlbmd0aIzUBil7c2V0dGluZ3MucGFzc2tleT3RBjEyMzQ1Njt1cGRhdGVTZXR0aW5ncygpO32nKKxpPdM7aTzUBjtpmCkoqihpKXttZW51W2BEaWdpdCAke2krMX1gXT17dmFsdWU603xzZXR0aW5ncy5wYXNza2V5W2ldLG1pbjrTLG1heDrUCSxvbmNoYW5nZTp2onuscD1zZXR0aW5ncy5wYXNza2V5LnNwbGl0KCIiKTtwW2ldPXY7c2V0dGluZ3MucGFzc2tleT1wLmpvaW4oIiIpO3VwZGF0ZVNldHRpbmdzKCk7fX07fSkoaSk7q21lbnU7fQqqd2hpdGVsaXN0TWVudSgpe6xtZW51PXvRBjwgQmFjazooKaJwb3BNZW51KEJMRU1lbnUoKSksfTujKHNldHRpbmdzLndoaXRlbGlzdF9kaXNhYmxlZCl7bWVudVvRBkVuYWJsZV09KCmie75zZXR0aW5ncy53aGl0ZWxpc3RfZGlzYWJsZWQ7dXBkYXRlU2V0dGluZ3MoKTtwb3BNZW51KEJMRU1lbnUoKSk7fTt9pHttZW51W9EHRGlzYWJsZV09KCmie3NldHRpbmdzLndoaXRlbGlzdF9kaXNhYmxlZD20O3VwZGF0ZVNldHRpbmdzKCk7cG9wTWVudShCTEVNZW51KCkpO307faMoc2V0dGluZ3Mud2hpdGVsaXN0KXNldHRpbmdzLndoaXRlbGlzdC5mb3JFYWNoKKooZCl7bWVudVtkLnN1YnN0cijTLNQRKV09qigpe0Uuc2hvd1Byb21wdCjRB1JlbW92ZQorZCkudGhlbigodimie6Modil7c2V0dGluZ3Mud2hpdGVsaXN0LnNwbGljZShzZXR0aW5ncy53aGl0ZWxpc3QuaW5kZXhPZihkKSzUASk7dXBkYXRlU2V0dGluZ3MoKTt9c2V0VGltZW91dCgoKaJyZXN0b3JlTWVudSh3aGl0ZWxpc3RNZW51KCkpLNQyKTt9KTt9fSk7bWVudVvRCkFkZCBEZXZpY2VdPaooKXtFLnNob3dBbGVydCjRIkNvbm5lY3QgZGV2aWNlCnRvIGFkZCB0bwp3aGl0ZWxpc3Qs0QlXaGl0ZWxpc3QpLnRoZW4oqigpe05SRi5yZW1vdmVBbGxMaXN0ZW5lcnMo0Qdjb25uZWN0KTtyZXN0b3JlTWVudSh3aGl0ZWxpc3RNZW51KCkpO30pO05SRi5yZW1vdmVBbGxMaXN0ZW5lcnMo0Qdjb25uZWN0KTtOUkYub24o0Qdjb25uZWN0LKooYWRkcil7oyghc2V0dGluZ3Mud2hpdGVsaXN0KXNldHRpbmdzLndoaXRlbGlzdD1bXTu+c2V0dGluZ3Mud2hpdGVsaXN0X2Rpc2FibGVkO6MoTlJGLnJlc29sdmVBZGRyZXNzjbcpe61yZXNvbHZlZEFkZHI9TlJGLnJlc29sdmVBZGRyZXNzKGFkZHIpO6MocmVzb2x2ZWRBZGRyjbcpe2FkZHI9cmVzb2x2ZWRBZGRyK9ELIChyZXNvbHZlZCk7fX1zZXR0aW5ncy53aGl0ZWxpc3QucHVzaChhZGRyKTt1cGRhdGVTZXR0aW5ncygpO05SRi5yZW1vdmVBbGxMaXN0ZW5lcnMo0Qdjb25uZWN0KTtyZXN0b3JlTWVudSh3aGl0ZWxpc3RNZW51KCkpO30pO307q21lbnU7fQqqTENETWVudSgpe6pnVG9JbnRlcm5hbChnKXurZyrVACA7fappbnRlcm5hbFRvRyh1KXurdS/VACA7faxyb3ROYW1lcz1b0QJObyzRCVJvdGF0ZSBDVyzRC0xlZnQgSGFuZGVkLNEKUm90YXRlIENDVyzRBk1pcnJvcl07rmxjZE1lbnU9eycnOnvRBXRpdGxlOtEDTENEfSzRBjwgQmFjazooKaJwb3BNZW51KHN5c3RlbU1lbnUoKSksfTujKEJBTkdMRUpTMilPYmplY3QuYXNzaWduKGxjZE1lbnUse9EJQ2FsaWJyYXRlOigponNob3dUb3VjaHNjcmVlbkNhbGlicmF0aW9uKCl9KTtPYmplY3QuYXNzaWduKGxjZE1lbnUse9EOTENEIEJyaWdodG5lc3M6e3ZhbHVlOnNldHRpbmdzLmJyaWdodG5lc3MsbWluOkJBTkdMRUpTMj/TOjAuMSxtYXg61AEsc3RlcDowLjEsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYnJpZ2h0bmVzcz12Pz/UATt1cGRhdGVTZXR0aW5ncygpO0JhbmdsZS5zZXRMQ0RCcmlnaHRuZXNzKHNldHRpbmdzLmJyaWdodG5lc3MpO319LNELTENEIFRpbWVvdXQ6e3ZhbHVlOnNldHRpbmdzLnRpbWVvdXQsbWluOtMsbWF4OtQ8LHN0ZXA61AUsb25jaGFuZ2U6dqJ7c2V0dGluZ3MudGltZW91dD3TfHY7dXBkYXRlU2V0dGluZ3MoKTtCYW5nbGUuc2V0TENEVGltZW91dChzZXR0aW5ncy50aW1lb3V0KTt9fSzRBlJvdGF0ZTp7dmFsdWU603xzZXR0aW5ncy5yb3RhdGUsbWluOtMsbWF4OnJvdE5hbWVzLmxlbmd0aC3UASxmb3JtYXQ6dqJyb3ROYW1lc1t2XSxvbmNoYW5nZTp2ontzZXR0aW5ncy5yb3RhdGU903x2O3VwZGF0ZVNldHRpbmdzKCk7Zy5zZXRSb3RhdGlvbihzZXR0aW5ncy5yb3RhdGUm1AMsc2V0dGluZ3Mucm90YXRlktQCKS5jbGVhcigpO0JhbmdsZS5kcmF3V2lkZ2V0cygpO319fSk7oyhCQU5HTEVKUzIpe09iamVjdC5hc3NpZ24obGNkTWVudSx70Q5XYWtlIG9uIEJ1dHRvbjp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjEsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMT0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4xO3VwZGF0ZU9wdGlvbnMoKTt9fSzRC1dha2Ugb24gVGFwOnt2YWx1ZTohIXNldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2gsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2g9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2g7dXBkYXRlT3B0aW9ucygpO319fSk7oyhwcm9jZXNzLmVudi5WRVJTSU9OLnJlcGxhY2Uo0QF2LNMpkdXkBylPYmplY3QuYXNzaWduKGxjZE1lbnUse9ESV2FrZSBvbiBEb3VibGUgVGFwOnt2YWx1ZTohIXNldHRpbmdzLm9wdGlvbnMud2FrZU9uRG91YmxlVGFwLG9uY2hhbmdlOigpontzZXR0aW5ncy5vcHRpb25zLndha2VPbkRvdWJsZVRhcD0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25Eb3VibGVUYXA7dXBkYXRlT3B0aW9ucygpO319fSk7faRPYmplY3QuYXNzaWduKGxjZE1lbnUse9EMV2FrZSBvbiBCVE4xOnt2YWx1ZTohIXNldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMSxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4xPSFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjE7dXBkYXRlT3B0aW9ucygpO319LNEMV2FrZSBvbiBCVE4yOnt2YWx1ZTohIXNldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMixvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4yPSFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjI7dXBkYXRlT3B0aW9ucygpO319LNEMV2FrZSBvbiBCVE4zOnt2YWx1ZTohIXNldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMyxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4zPSFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjM7dXBkYXRlT3B0aW9ucygpO319LNENV2FrZSBvbiBUb3VjaDp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPblRvdWNoLG9uY2hhbmdlOigpontzZXR0aW5ncy5vcHRpb25zLndha2VPblRvdWNoPSFzZXR0aW5ncy5vcHRpb25zLndha2VPblRvdWNoO3VwZGF0ZU9wdGlvbnMoKTt9fX0pO09iamVjdC5hc3NpZ24obGNkTWVudSx70Q5XYWtlIG9uIEZhY2VVcDp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPbkZhY2VVcCxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25GYWNlVXA9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uRmFjZVVwO3VwZGF0ZU9wdGlvbnMoKTt9fSzRDVdha2Ugb24gVHdpc3Q6e3ZhbHVlOiEhc2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ud2lzdCxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ud2lzdD0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ud2lzdDt1cGRhdGVPcHRpb25zKCk7fX0s0Q9Ud2lzdCBUaHJlc2hvbGQ6e3ZhbHVlOmludGVybmFsVG9HKHNldHRpbmdzLm9wdGlvbnMudHdpc3RUaHJlc2hvbGQpLG1pbjotMC41LG1heDowLjUsc3RlcDowLjAxLG9uY2hhbmdlOnaie3NldHRpbmdzLm9wdGlvbnMudHdpc3RUaHJlc2hvbGQ9Z1RvSW50ZXJuYWwodqAwLjEpO3VwZGF0ZU9wdGlvbnMoKTt9fSzRC1R3aXN0IE1heCBZOnt2YWx1ZTpzZXR0aW5ncy5vcHRpb25zLnR3aXN0TWF4WSxtaW461ST6LG1heDrV3AUsc3RlcDrUZCxvbmNoYW5nZTp2ontzZXR0aW5ncy5vcHRpb25zLnR3aXN0TWF4WT12oC3VIAM7dXBkYXRlT3B0aW9ucygpO319LNENVHdpc3QgVGltZW91dDp7dmFsdWU6c2V0dGluZ3Mub3B0aW9ucy50d2lzdFRpbWVvdXQsbWluOtMsbWF4OtXQByxzdGVwOtRkLG9uY2hhbmdlOnaie3NldHRpbmdzLm9wdGlvbnMudHdpc3RUaW1lb3V0PXag1egDO3VwZGF0ZU9wdGlvbnMoKTt9fX0pO6tsY2RNZW51fQqqbG9jYWxlTWVudSgpe65sb2NhbGVtZW51PXsnJzp70QV0aXRsZTrRBkxvY2FsZX0s0QY8IEJhY2s6KCmicG9wTWVudShzeXN0ZW1NZW51KCkpLNEJVGltZSBab25lOnt2YWx1ZTpzZXR0aW5ncy50aW1lem9uZSxmb3JtYXQ6dqIodj7TP9EBKzoiIikrdixtaW461PUsbWF4OtQNLHN0ZXA6MC41LG9uY2hhbmdlOnaie3NldHRpbmdzLnRpbWV6b25lPXag0zt1cGRhdGVTZXR0aW5ncygpO319LNELVGltZSBGb3JtYXQ6e3ZhbHVlOiEhc2V0dGluZ3Nb0QYxMmhvdXJdLGZvcm1hdDp2onY/0QMxMmg60QMyNGgsb25jaGFuZ2U6dqJ7c2V0dGluZ3Nb0QYxMmhvdXJdPXY7dXBkYXRlU2V0dGluZ3MoKTt9fSzRDVN0YXJ0IFdlZWsgT246e3ZhbHVlOnNldHRpbmdzW9EOZmlyc3REYXlPZldlZWtdoNMsbWluOtMsbWF4OtQBLGZvcm1hdDp2onJlcXVpcmUo0QpkYXRlX3V0aWxzKS5kb3codizUASksb25jaGFuZ2U6dqJ7c2V0dGluZ3Nb0Q5maXJzdERheU9mV2Vla109djt1cGRhdGVTZXR0aW5ncygpO30sfX07q2xvY2FsZW1lbnU7fQqqdXRpbE1lbnUoKXusbWVudT17Jyc6e9EFdGl0bGU60QlVdGlsaXRpZXN9LNEGPCBCYWNrOigponBvcE1lbnUobWFpbk1lbnUoKSks0QVEZWJ1Zzp7dmFsdWU6RS5jbGlwKNN8c2V0dGluZ3MubG9nLNMs1AMpLG1pbjrTLG1heDrUAyxmb3JtYXQ6dqJb0QNPZmYs0QdEaXNwbGF5LNEDTG9nLNEEQm90aF1bRS5jbGlwKNN8dizTLNQDKV0sb25jaGFuZ2U6dqJ7c2V0dGluZ3MubG9nPXY7dXBkYXRlU2V0dGluZ3MoKTt9fSzRD0NvbXBhY3QgU3RvcmFnZTooKaJ7RS5zaG93TWVzc2FnZSjRI0NvbXBhY3RpbmcuLi4KVGFrZXMgYXBwcm94CjEgbWludXRlLHt0aXRsZTrRB1N0b3JhZ2V9KTtzdG9yYWdlLmNvbXBhY3QoKTtyZXN0b3JlTWVudSh1dGlsTWVudSgpKTt9LNEQUmV3cml0ZSBTZXR0aW5nczooKaJ7c3RvcmFnZS53cml0ZSjRBi5ib290MCzRL2V2YWwocmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoJ2Jvb3R1cGRhdGUuanMnKSk7KTtsb2FkKNEOc2V0dGluZy5hcHAuanMpO30s0Q9GbGF0dGVuIEJhdHRlcnk6KCmie0Uuc2hvd01lc3NhZ2Uo0UZGbGF0dGVuaW5nIGJhdHRlcnkgLSB0aGlzIGNhbiB0YWtlIGhvdXJzLgpMb25nLXByZXNzIGJ1dHRvbiB0byBjYW5jZWwuKTtCYW5nbGUuc2V0TENEVGltZW91dCjTKTtCYW5nbGUuc2V0TENEUG93ZXIo1AEpO0JhbmdsZS5zZXRMQ0RCcmlnaHRuZXNzKNQBKTujKEJhbmdsZS5zZXRHUFNQb3dlcilCYW5nbGUuc2V0R1BTUG93ZXIo1AEs0QRmbGF0KTujKEJhbmdsZS5zZXRIUk1Qb3dlcilCYW5nbGUuc2V0SFJNUG93ZXIo1AEs0QRmbGF0KTujKEJhbmdsZS5zZXRDb21wYXNzUG93ZXIpQmFuZ2xlLnNldENvbXBhc3NQb3dlcijUASzRBGZsYXQpO6MoQmFuZ2xlLnNldEJhcm9tZXRlclBvd2VyKUJhbmdsZS5zZXRCYXJvbWV0ZXJQb3dlcijUASzRBGZsYXQpO3NldEludGVydmFsKKooKXusaT3V6AM7pihpmSk7fSzUASk7fX07rmJhY2s9KCmie3Jlc3RvcmVNZW51KHV0aWxNZW51KCkpO307oyhCQU5HTEVKUzIpbWVudVvREUNhbGlicmF0ZSBCYXR0ZXJ5XT0oKaJ7RS5zaG93UHJvbXB0KNEdSXMgdGhlIGJhdHRlcnkgZnVsbHkgY2hhcmdlZD8se3RpdGxlOtEJQ2FsaWJyYXRlLGJhY2t9KS50aGVuKG9ronujKG9rKXuscz1zdG9yYWdlLnJlYWRKU09OKNEMc2V0dGluZy5qc29uKTtzLmJhdEZ1bGxWb2x0YWdlPShhbmFsb2dSZWFkKEQzKSthbmFsb2dSZWFkKEQzKSthbmFsb2dSZWFkKEQzKSthbmFsb2dSZWFkKEQzKSkv1AQ7c3RvcmFnZS53cml0ZUpTT04o0QxzZXR0aW5nLmpzb24scyk7RS5zaG93QWxlcnQo0QtDYWxpYnJhdGVkISkudGhlbigoKaJsb2FkKNEOc2V0dGluZy5hcHAuanMpKTt9pHtFLnNob3dBbGVydCjRMVBsZWFzZSBjaGFyZ2UgQmFuZ2xlLmpzIGZvciAzIGhvdXJzIGFuZCB0cnkgYWdhaW4pLnRoZW4oYmFjayk7fX0pO307bWVudVvRDlJlc2V0IFNldHRpbmdzXT0oKaJ7RS5zaG93UHJvbXB0KNESUmVzZXQgdG8gRGVmYXVsdHM/LHt0aXRsZTrRCFNldHRpbmdzLGJhY2t9KS50aGVuKCh2KaJ7oyh2KXtFLnNob3dNZXNzYWdlKNEJUmVzZXR0aW5nKTtyZXNldFNldHRpbmdzKCk7c2V0VGltZW91dCgoKaJwb3BNZW51KG1haW5NZW51KCkpLNQyKTt9pHJlc3RvcmVNZW51KHV0aWxNZW51KCkpO30pO307bWVudVvRCFR1cm4gT2ZmXT0oKaJ7RS5zaG93UHJvbXB0KNEqQXJlIHlvdSBzdXJlPyBBbGFybXMgYW5kIHRpbWVycyB3b24ndCBmaXJlLHt0aXRsZTrRCFR1cm4gT2ZmLGJhY2t9KS50aGVuKChjb25maXJtZWQponujKGNvbmZpcm1lZCl7RS5zaG93TWVzc2FnZSjRDlNlZSB5b3UKbGF0ZXIhLNEHR29vZGJ5ZSk7c2V0VGltZW91dCgoKaJ7RS5zaG93TWVzc2FnZSgpO2cuY2xlYXIotCk7QmFuZ2xlLnNvZnRPZmY/QmFuZ2xlLnNvZnRPZmYoKTpCYW5nbGUub2ZmKCk7fSzVxAkpO32ke3Jlc3RvcmVNZW51KHV0aWxNZW51KCkpO319KTt9O6MoQmFuZ2xlLmZhY3RvcnlSZXNldCl7bWVudVvRDUZhY3RvcnkgUmVzZXRdPSgpontFLnNob3dQcm9tcHQo0RxUaGlzIHdpbGwgcmVtb3ZlIGV2ZXJ5dGhpbmchLHt0aXRsZTrRDUZhY3RvcnkgUmVzZXQsYmFja30pLnRoZW4oKHYponujKHYpe6xuPSgoTWF0aC5yYW5kb20oKSrUBCkm1AMpK9QBO0Uuc2hvd1Byb21wdCjRGVRvIGNvbmZpcm0sIHBsZWFzZSBwcmVzcyArbix7dGl0bGU60Q1GYWN0b3J5IFJlc2V0LGJ1dHRvbnM6e9EBMTrUASzRATI61AIs0QEzOtQDLNEBNDrUBH0sYmFja30pLnRoZW4oqih2KXujKHaKbil7RS5zaG93TWVzc2FnZSgpO1Rlcm1pbmFsLnNldENvbnNvbGUoKTtCYW5nbGUuZmFjdG9yeVJlc2V0KCk7faR7YmFjaygpO319KTt9pGJhY2soKTt9KTt9fattZW51O30Kqm1ha2VDb25uZWN0YWJsZSgpe7F7TlJGLndha2UoKTt9Y2F0Y2goZSl7fUJsdWV0b290aC5zZXRDb25zb2xlKNQBKTtOUkYuaWdub3JlV2hpdGVsaXN0PdQBO6xuYW1lPdEKQmFuZ2xlLmpzICtOUkYuZ2V0QWRkcmVzcygpLnN1YnN0cijU+ykucmVwbGFjZSjRATosIiIpO0Uuc2hvd1Byb21wdChuYW1lK9ESClN0YXkgQ29ubmVjdGFibGU/LHt0aXRsZTrRC0Nvbm5lY3RhYmxlfSkudGhlbihyonujKHNldHRpbmdzLmJsZYxyKXtzZXR0aW5ncy5ibGU9cjt1cGRhdGVTZXR0aW5ncygpO32jKCFyKbF7TlJGLnNsZWVwKCk7fWNhdGNoKGUpe32+TlJGLmlnbm9yZVdoaXRlbGlzdDtyZXN0b3JlTWVudShCTEVNZW51KCkpO30pO30KqmNsb2NrTWVudSgpe6xjbG9ja0FwcHM9c3RvcmFnZS5saXN0KC9cLmluZm8kLykubWFwKGFwcKJ7rGE9c3RvcmFnZS5yZWFkSlNPTihhcHAs1AEpO6soYZ5hLnR5cGWK0QVjbG9jayk/YTq3fSkuZmlsdGVyKGFwcKJhcHApLnNvcnQoKGEsYimiYS5zb3J0b3JkZXItYi5zb3J0b3JkZXIpO65iYWNrPSgponBvcE1lbnUoc3lzdGVtTWVudSgpKTuuY2xvY2tNZW51PXsnJzp70QV0aXRsZTrRDFNlbGVjdCBDbG9jayx9LNEGPCBCYWNrOmJhY2ssfTtjbG9ja0FwcHMuZm9yRWFjaCgoYXBwLGluZGV4KaJ7rGxhYmVsPWFwcC5uYW1lO6MoKCFzZXR0aW5ncy5jbG9ja55pbmRleIvTKaAoc2V0dGluZ3MuY2xvY2uLYXBwLnNyYykpe2xhYmVsPdECKiArbGFiZWw7fWNsb2NrTWVudVtsYWJlbF09KCmie3NldHRpbmdzLmNsb2NrPWFwcC5zcmM7c2V0dGluZ3MuY2xvY2tIYXNXaWRnZXRzPXN0b3JhZ2UucmVhZChhcHAuc3JjKS5pbmNsdWRlcyjREkJhbmdsZS5sb2FkV2lkZ2V0cyk7dXBkYXRlU2V0dGluZ3MoKTtiYWNrKCk7fTt9KTujKGNsb2NrQXBwcy5sZW5ndGiL0yl7Y2xvY2tNZW51W9EPTm8gQ2xvY2tzIEZvdW5kXT0oKaJ7fTt9q2Nsb2NrTWVudTt9CqpsYXVuY2hlck1lbnUoKXusbGF1bmNoZXJBcHBzPXN0b3JhZ2UubGlzdCgvXC5pbmZvJC8pLm1hcChhcHCie6xhPXN0b3JhZ2UucmVhZEpTT04oYXBwLNQBKTurKGGeYS50eXBlitEGbGF1bmNoKT9hOrd9KS5maWx0ZXIoYXBwomFwcCkuc29ydCgoYSxiKaJhLnNvcnRvcmRlci1iLnNvcnRvcmRlcik7rmJhY2s9KCmicG9wTWVudShzeXN0ZW1NZW51KCkpO65sYXVuY2hlck1lbnU9eycnOnvRBXRpdGxlOtEPU2VsZWN0IExhdW5jaGVyLH0s0QY8IEJhY2s6YmFjayx9O2xhdW5jaGVyQXBwcy5mb3JFYWNoKChhcHAsaW5kZXgponusbGFiZWw9YXBwLm5hbWU7oygoIXNldHRpbmdzLmxhdW5jaGVynmluZGV4i9MpoChzZXR0aW5ncy5sYXVuY2hlcothcHAuc3JjKSl7bGFiZWw90QIqICtsYWJlbDt9bGF1bmNoZXJNZW51W2xhYmVsXT0oKaJ7c2V0dGluZ3MubGF1bmNoZXI9YXBwLnNyYzt1cGRhdGVTZXR0aW5ncygpO2JhY2soKTt9O30pO6MobGF1bmNoZXJBcHBzLmxlbmd0aIvTKXtsYXVuY2hlck1lbnVb0RJObyBMYXVuY2hlcnMgRm91bmRdPSgpont9O32rbGF1bmNoZXJNZW51O30KqnNldFRpbWVNZW51KCl7rWQ9uERhdGUoKTuudGltZW1lbnU9eycnOnvRBXRpdGxlOtELRGF0ZSAmIFRpbWV9LNEGPCBCYWNrOqooKXtzZXRUaW1lKGQuZ2V0VGltZSgpL9XoAyk7cG9wTWVudShzeXN0ZW1NZW51KCkpO30s0QNEYXk6e3ZhbHVlOmQuZ2V0RGF0ZSgpLG9uY2hhbmdlOqoodil7ry52YWx1ZT0oKHYr1B4pJdQfKSvUATtkLnNldERhdGUory52YWx1ZSk7fX0s0QVNb250aDp7dmFsdWU6ZC5nZXRNb250aCgpK9QBLGZvcm1hdDp2onJlcXVpcmUo0QpkYXRlX3V0aWxzKS5tb250aCh2KSxvbmNoYW5nZTqqKHYpe68udmFsdWU9KCh2K9QLKSXUDCkr1AE7ZC5zZXRNb250aCivLnZhbHVlLdQBKTt9fSzRBFllYXI6e3ZhbHVlOmQuZ2V0RnVsbFllYXIoKSxtaW461eMHLG1heDrVNAgsb25jaGFuZ2U6qih2KXtkLnNldEZ1bGxZZWFyKHYpO319LNEESG91cjp7dmFsdWU6ZC5nZXRIb3VycygpLG9uY2hhbmdlOqoodil7ry52YWx1ZT0odivUGCkl1Bg7ZC5zZXRIb3VycyivLnZhbHVlKTt9fSzRBk1pbnV0ZTp7dmFsdWU6ZC5nZXRNaW51dGVzKCksb25jaGFuZ2U6qih2KXuvLnZhbHVlPSh2K9Q8KSXUPDtkLnNldE1pbnV0ZXMory52YWx1ZSk7fX0s0QZTZWNvbmQ6e3ZhbHVlOmQuZ2V0U2Vjb25kcygpLG9uY2hhbmdlOqoodil7ry52YWx1ZT0odivUPCkl1Dw7ZC5zZXRTZWNvbmRzKK8udmFsdWUpO319fTurdGltZW1lbnU7fQqqYXBwU2V0dGluZ3NNZW51KCl7rWFwcG1lbnU9eycnOnvRBXRpdGxlOtEMQXBwIFNldHRpbmdzfSzRBjwgQmFjazooKaJwb3BNZW51KG1haW5NZW51KCkpLH2uYXBwcz1zdG9yYWdlLmxpc3QoL1wuc2V0dGluZ3NcLmpzJC8pLm1hcChzonMuc3Vic3RyKNMscy5sZW5ndGgt1AwpKS5tYXAoaWSie65hPXN0b3JhZ2UucmVhZEpTT04oaWQr0QUuaW5mbyzUASmge25hbWU6aWR9O6t7aWQ6aWQsbmFtZTphLm5hbWUsc29ydG9yZGVyOmEuc29ydG9yZGVyfTt9KS5zb3J0KChhLGIponuubj0o03xhLnNvcnRvcmRlciktKNN8Yi5zb3J0b3JkZXIpO6MobimrbjujKGEubmFtZTxiLm5hbWUpqy3UATujKGEubmFtZT5iLm5hbWUpq9QBO6vTO30poyhhcHBzLmxlbmd0aIvTKXthcHBtZW51W9ETTm8gYXBwIGhhcyBzZXR0aW5nc109KCmie307fWFwcHMuZm9yRWFjaCiqKGFwcCl7YXBwbWVudVthcHAubmFtZV09KCmie3Nob3dBcHBTZXR0aW5ncyhhcHApfTt9KathcHBtZW51O30KqnNob3dBcHBTZXR0aW5ncyhhcHApe65iYWNrPSgponBvcE1lbnUoYXBwU2V0dGluZ3NNZW51KCkpO65zaG93RXJyb3I9bXNnontFLnNob3dNZXNzYWdlKGAke2FwcC5uYW1lfTpcbiR7bXNnfSFcblxuQlROMSB0byBnbyBiYWNrYCk7c2V0V2F0Y2goYmFjayxCVE4xLHtyZXBlYXQ6tX0pO32tYXBwU2V0dGluZ3M9c3RvcmFnZS5yZWFkKGFwcC5pZCvRDC5zZXR0aW5ncy5qcyk7sXthcHBTZXR0aW5ncz1ldmFsKGFwcFNldHRpbmdzKTt9Y2F0Y2goZSl7Y29uc29sZS5sb2coYCR7YXBwLm5hbWV9IHNldHRpbmdzIGVycm9yOmAsZSk7q3Nob3dFcnJvcijREUVycm9yIGluIHNldHRpbmdzKTt9oyi/YXBwU2V0dGluZ3ON0QhmdW5jdGlvbil7q3Nob3dFcnJvcijREEludmFsaWQgc2V0dGluZ3MpO32xe3B1c2hNZW51KCk7YXBwU2V0dGluZ3MoYmFjayk7fWNhdGNoKGUpe2NvbnNvbGUubG9nKGAke2FwcC5uYW1lfSBzZXR0aW5ncyBlcnJvcjpgLGUpO6tzaG93RXJyb3Io0RFFcnJvciBpbiBzZXR0aW5ncyk7fX0KqnNob3dUb3VjaHNjcmVlbkNhbGlicmF0aW9uKCl7QmFuZ2xlLnNldFVJKCk7cmVxdWlyZSjRDHdpZGdldF91dGlscykuaGlkZSgpO0JhbmdsZS5zZXRPcHRpb25zKHt0b3VjaFgxOtMsdG91Y2hZMTrTLHRvdWNoWDI6Zy5nZXRXaWR0aCgpLHRvdWNoWTI6Zy5nZXRIZWlnaHQoKX0pO6xQPdQgO6xjb3JuZXJzPVtbUCxQXSxbZy5nZXRXaWR0aCgpLVAsUF0sW2cuZ2V0V2lkdGgoKS1QLGcuZ2V0SGVpZ2h0KCktUF0sW1AsZy5nZXRIZWlnaHQoKS1QXSxdO6xjdXJyZW50Q29ybmVyPdM7rGN1cnJlbnRUcnk90zuscHQ9e3gxOtMseTE60yx4MjrTLHkyOtN9O6pzaG93VGFwU3BvdCgpe6xzcG90PWNvcm5lcnNbY3VycmVudENvcm5lcl07Zy5jbGVhcijUASk7Zy5kcmF3TGluZShzcG90W9NdLdQgLHNwb3Rb1AFdLHNwb3Rb010r1CAsc3BvdFvUAV0pO2cuZHJhd0xpbmUoc3BvdFvTXSxzcG90W9QBXS3UICxzcG90W9NdLHNwb3Rb1AFdK9QgKTtnLmRyYXdDaXJjbGUoc3BvdFvTXSxzcG90W9QBXSzUECk7rHRhcHNMZWZ0PSjUAi1jdXJyZW50VHJ5KSrUBCso1AQtY3VycmVudENvcm5lcik7Zy5zZXRGb250KNEFNng4OjIpLnNldEZvbnRBbGlnbijTLNMpLmRyYXdTdHJpbmcodGFwc0xlZnQr0QsgdGFwcwp0byBnbyxnLmdldFdpZHRoKCkv1AIsZy5nZXRIZWlnaHQoKS/UAik7fapjYWxjQ2FsaWJyYXRpb24oKXtnLmNsZWFyKNQBKTtwdC54MZvUBjtwdC55MZvUBjtwdC54MpvUBjtwdC55MpvUBjusY2FsaWI9e3gxOk1hdGgucm91bmQocHQueDEtKHB0LngyLXB0LngxKSpQLyhnLmdldFdpZHRoKCktUCrUAikpLHkxOk1hdGgucm91bmQocHQueTEtKHB0LnkyLXB0LnkxKSpQLyhnLmdldEhlaWdodCgpLVAq1AIpKSx4MjpNYXRoLnJvdW5kKHB0LngyKyhwdC54Mi1wdC54MSkqUC8oZy5nZXRXaWR0aCgpLVAq1AIpKSx5MjpNYXRoLnJvdW5kKHB0LnkyKyhwdC55Mi1wdC55MSkqUC8oZy5nZXRIZWlnaHQoKS1QKtQCKSl9O6xkeD1jYWxpYi54Mi1jYWxpYi54MTusZHk9Y2FsaWIueTItY2FsaWIueTE7oyhkeDzUZKBkeD7VGAGgZHk81GSgZHk+1RgBKXtnLnNldEZvbnQo0QU2eDg6Mikuc2V0Rm9udEFsaWduKNMs0ykuZHJhd1N0cmluZyjRHk91dCBvZiBSYW5nZS4KUGxlYXNlCnRyeSBhZ2FpbixnLmdldFdpZHRoKCkv1AIsZy5nZXRIZWlnaHQoKS/UAik7faR7QmFuZ2xlLnNldE9wdGlvbnMoe3RvdWNoWDE6Y2FsaWIueDEsdG91Y2hZMTpjYWxpYi55MSx0b3VjaFgyOmNhbGliLngyLHRvdWNoWTI6Y2FsaWIueTJ9KTuscz1zdG9yYWdlLnJlYWRKU09OKNEMc2V0dGluZy5qc29uLNQBKaB7fTtzLnRvdWNoPWNhbGliO3N0b3JhZ2Uud3JpdGVKU09OKNEMc2V0dGluZy5qc29uLHMpO2cuc2V0Rm9udCjRBTZ4ODoyKS5zZXRGb250QWxpZ24o0yzTKS5kcmF3U3RyaW5nKNELQ2FsaWJyYXRlZCEsZy5nZXRXaWR0aCgpL9QCLGcuZ2V0SGVpZ2h0KCkv1AIpO31zZXRUaW1lb3V0KCgponJlc3RvcmVNZW51KExDRE1lbnUoKSks1fQBKTt9qnRvdWNoSGFuZGxlcihfLGUpe0Uuc3RvcEV2ZW50UHJvcGFnYXRpb26eRS5zdG9wRXZlbnRQcm9wYWdhdGlvbigpO6xzcG90PWNvcm5lcnNbY3VycmVudENvcm5lcl07oyhzcG90W9NdKtQCPGcuZ2V0V2lkdGgoKSlwdC54MZZlLng7pHB0LngylmUueDujKHNwb3Rb1AFdKtQCPGcuZ2V0SGVpZ2h0KCkpcHQueTGWZS55O6RwdC55MpZlLnk7Y3VycmVudENvcm5lcpg7oyhjdXJyZW50Q29ybmVykWNvcm5lcnMubGVuZ3RoKXtjdXJyZW50Q29ybmVyPdM7Y3VycmVudFRyeZg7oyhjdXJyZW50VHJ5itQDKXtCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QV0b3VjaCx0b3VjaEhhbmRsZXIpO6tjYWxjQ2FsaWJyYXRpb24oKTt9fXNob3dUYXBTcG90KCk7fUJhbmdsZS5wcmVwZW5kTGlzdGVuZXI/QmFuZ2xlLnByZXBlbmRMaXN0ZW5lcijRBXRvdWNoLHRvdWNoSGFuZGxlcik6QmFuZ2xlLm9uKNEFdG91Y2gsdG91Y2hIYW5kbGVyKTtzaG93VGFwU3BvdCgpO30KqnNob3dBbHRpdHVkZSgpe6pvblByZXNzdXJlKHByZXNzdXJlKXttZW51UHJlc3N1cmUudmFsdWU9TWF0aC5yb3VuZChwcmVzc3VyZS5wcmVzc3VyZSkudG9TdHJpbmcoKTttZW51QWx0aXR1ZGUudmFsdWU9TWF0aC5yb3VuZChwcmVzc3VyZS5hbHRpdHVkZSkudG9TdHJpbmcoKTttLmRyYXcoKTt9qmFsdGl0dWRlRG9uZSgpe3NldHRpbmdzLnNlYUxldmVsUHJlc3N1cmU9c2VhTGV2ZWxQcmVzc3VyZTt1cGRhdGVTZXR0aW5ncygpO31CYW5nbGUuc2V0QmFyb21ldGVyUG93ZXIo1AEs0QhzZXR0aW5ncyk7QmFuZ2xlLm9uKNEIcHJlc3N1cmUsb25QcmVzc3VyZSk7RS5vbijRBGtpbGwsYWx0aXR1ZGVEb25lKTusc2VhTGV2ZWxQcmVzc3VyZT1CYW5nbGUuZ2V0T3B0aW9ucygpLnNlYUxldmVsUHJlc3N1cmU7oyghaXNGaW5pdGUoc2VhTGV2ZWxQcmVzc3VyZSkpc2VhTGV2ZWxQcmVzc3VyZT0xMDEzLjI1O6xtZW51UHJlc3N1cmU9e3ZhbHVlOtEBLX07rG1lbnVBbHRpdHVkZT17dmFsdWU60QEtfTusbT1FLnNob3dNZW51KHsiIjp7dGl0bGU60QhBbHRpdHVkZSxiYWNrOigpontCYW5nbGUuc2V0QmFyb21ldGVyUG93ZXIo0yzRCHNldHRpbmdzKTtCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QhwcmVzc3VyZSxvblByZXNzdXJlKTtFLnJlbW92ZUxpc3RlbmVyKNEEa2lsbCxhbHRpdHVkZURvbmUpO2FsdGl0dWRlRG9uZSgpO3BvcE1lbnUoc3lzdGVtTWVudSgpKTt9fSzRDlByZXNzdXJlIChoUGEpOm1lbnVQcmVzc3VyZSzRDEFsdGl0dWRlIChtKTptZW51QWx0aXR1ZGUs0QlBZGp1c3QgdXA6qigpe0JhbmdsZS5idXp6KNRQKTtzZWFMZXZlbFByZXNzdXJlmDtCYW5nbGUuc2V0T3B0aW9ucyh7c2VhTGV2ZWxQcmVzc3VyZX0pO30s0QtBZGp1c3QgZG93bjqqKCl7QmFuZ2xlLmJ1enoo1FApO3NlYUxldmVsUHJlc3N1cmWZO0JhbmdsZS5zZXRPcHRpb25zKHtzZWFMZXZlbFByZXNzdXJlfSk7fSzRC1NldCBEZWZhdWx0OqooKXtCYW5nbGUuYnV6eigpO3NlYUxldmVsUHJlc3N1cmU9MTAxMy4yNTtCYW5nbGUuc2V0T3B0aW9ucyh7c2VhTGV2ZWxQcmVzc3VyZX0pO319KTt9CnB1c2hNZW51KG1haW5NZW51KCkpO0wCAABzZXR0aW5nLmltZw==");
  base64DecodeToExistingUint8Array(bufferView, 105320, "MDDCAP//8WPMQm9T");
  base64DecodeToExistingUint8Array(bufferView, 105384, "AVVVQAAAAAAAAAAAAVVVQAAAAAAAAAAAAVVVUAAAAAAAAAAAAVVVUAAAAAAAAAAABVVVUAAAAAAAAAAABVVVUAAAAAAAABAABVVVUAAFAAAAAFUAVVVVVQBVAAAAAVVRVVVVVUVVQAAAAVVVVfqvVVVVUAAABVVVXqqqtVVVUAAAFVVV6qqqq1VVVAAAFVVXqqqqqtVVVAAAVVVeqqqqqrVVVQAAVVVaqqqqqqVVVQAAVVV6qqqqqq1VVQAAFVVqqqAKqqlVVAAAAVXqqgAAqqtVQAAAAFXqqgAAqqtVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAAFXqqgAAqqtVAAAAAVXqqgAAqqtVQAAAFVVqqqAKqqlVVAAAVVV6qqqqqq1VVQAAVVVaqqqqqqVVVQAAVVVeqqqqqrVVVQAAFVVXqqqqqtVVVAAAFVVV6qqqq1VVVAAABVVVXqqqtVVVUAAABVVVVfqvVVVVQAAAAVVRVVVVVUVVQAAAAFUAVVVVVQBVAAAAAFAABVVVUAAEAAAAAAAABVVVUAAAAAAAAAAABVVVUAAAAAAAAAAABVVVQAAAAAAAAAAABVVVQAAAAAAAAAAAAVVVQAAAAAAAAAAAAVVVQA==");
  base64DecodeToExistingUint8Array(bufferView, 105908, "TwEAAHNldHRpbmcuanNvbg==");
  base64DecodeToExistingUint8Array(bufferView, 105940, "eyJibGUiOnRydWUsImJsZXJlcGwiOnRydWUsImxvZyI6ZmFsc2UsInRpbWVvdXQiOjEwLCJ2aWJyYXRlIjp0cnVlLCJiZWVwIjoidmliIiwidGltZXpvbmUiOjAsIkhJRCI6ZmFsc2UsImNsb2NrIjpudWxsLCIxMmhvdXIiOmZhbHNlLCJicmlnaHRuZXNzIjoxLCJvcHRpb25zIjp7Indha2VPbkJUTjEiOnRydWUsIndha2VPbkJUTjIiOnRydWUsIndha2VPbkJUTjMiOnRydWUsIndha2VPbkZhY2VVcCI6ZmFsc2UsIndha2VPblRvdWNoIjpmYWxzZSwid2FrZU9uVHdpc3QiOmZhbHNlLCJ0d2lzdFRocmVzaG9sZCI6ODE5LjIsInR3aXN0TWF4WSI6LTgwMCwidHdpc3RUaW1lb3V0IjoxMDAwfX3/ywAAAHNldHRpbmcuaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 106308, "eyJpZCI6InNldHRpbmciLCJuYW1lIjoiU2V0dGluZ3MiLCJzcmMiOiJzZXR0aW5nLmFwcC5qcyIsImljb24iOiJzZXR0aW5nLmltZyIsInNvcnRvcmRlciI6LTUsInZlcnNpb24iOiIwLjgyIiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJzZXR0aW5nLmluZm8sc2V0dGluZy5hcHAuanMsc2V0dGluZy5pbWciLCJkYXRhIjoic2V0dGluZy5qc29uIn3/cRIAAGxhdW5jaC5hcHAuanM=");
  base64DecodeToExistingUint8Array(bufferView, 106544, "TW9kdWxlcy5hZGRDYWNoZWQo0Qx3aWRnZXRfdXRpbHMsqigpe2V4cG9ydHMub2Zmc2V0PdM7ZXhwb3J0cy5oaWRlPaooKXtleHBvcnRzLmNsZWFudXAoKTujKGdsb2JhbC5XSURHRVRTKXtnLnJlc2V0KCk7pyisYcZnbG9iYWwuV0lER0VUUyl7oyhhLl9kcmF3Kag7YS5fZHJhdz1hLmRyYXc7YS5kcmF3PSgpont9O2EuX2FyZWE9YS5hcmVhO2EuYXJlYT0iIjvA04xhLnieZy5jbGVhclJlY3QoYS54LGEueSxhLngrYS53aWR0aC3UASxhLnkr1BcpfX19O2V4cG9ydHMuc2hvdz2qKCl7ZXhwb3J0cy5jbGVhbnVwKCk7oyhnbG9iYWwuV0lER0VUUymnKKxhxmdsb2JhbC5XSURHRVRTKXujKCFhLl9kcmF3Kag7YS5kcmF3PWEuX2RyYXc7YS5hcmVhPWEuX2FyZWE7vmEuX2RyYXc7vmEuX2FyZWE7YS5kcmF3KGEpfX07ZXhwb3J0cy5jbGVhbnVwT3ZlcmxheT2qKCl7ZXhwb3J0cy5vZmZzZXQ91Og7QmFuZ2xlLnNldExDRE92ZXJsYXmeQmFuZ2xlLnNldExDRE92ZXJsYXkowNMse2lkOtEMd2lkZ2V0X3V0aWxzfSk7vmV4cG9ydHMuYXV0b2hpZGU7vkJhbmdsZS5hcHBSZWN0O2V4cG9ydHMuYW5pbUludGVydmFsnihjbGVhckludGVydmFsKGV4cG9ydHMuYW5pbUludGVydmFsKSy+ZXhwb3J0cy5hbmltSW50ZXJ2YWwpO2V4cG9ydHMuaGlkZVRpbWVvdXSeKGNsZWFyVGltZW91dChleHBvcnRzLmhpZGVUaW1lb3V0KSy+ZXhwb3J0cy5oaWRlVGltZW91dCl9O2V4cG9ydHMuY2xlYW51cD2qKCl7ZXhwb3J0cy5jbGVhbnVwT3ZlcmxheSgpO75leHBvcnRzLm9mZnNldDtleHBvcnRzLnN3aXBlSGFuZGxlcp4oQmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFc3dpcGUsZXhwb3J0cy5zd2lwZUhhbmRsZXIpLL5leHBvcnRzLnN3aXBlSGFuZGxlcik7ZXhwb3J0cy5vcmlnRHJhd54oQmFuZ2xlLmRyYXdXaWRnZXRzPWV4cG9ydHMub3JpZ0RyYXcsvmV4cG9ydHMub3JpZ0RyYXcpfTtleHBvcnRzLnN3aXBlT249qihhKXuqaygpe65kPWV4cG9ydHMub2Zmc2V0O0JhbmdsZS5hcHBSZWN0Lnk9ZCvUGDtCYW5nbGUuYXBwUmVjdC5oPdQBK0JhbmdsZS5hcHBSZWN0LnkyLUJhbmdsZS5hcHBSZWN0Lnk7QmFuZ2xlLnNldExDRE92ZXJsYXmeKNToPGQ/QmFuZ2xlLnNldExDRE92ZXJsYXkoYizTLGQse2lkOtEMd2lkZ2V0X3V0aWxzLHJlbW92ZTooKaJ7cmVxdWlyZSjRDHdpZGdldF91dGlscykuY2xlYW51cE92ZXJsYXkoKX19KTpCYW5nbGUuc2V0TENET3ZlcmxheSjA0yx7aWQ60Qx3aWRnZXRfdXRpbHN9KSl9qmgoZCxmKXtleHBvcnRzLmFuaW1JbnRlcnZhbJ5jbGVhckludGVydmFsKGV4cG9ydHMuYW5pbUludGVydmFsKTtleHBvcnRzLmFuaW1JbnRlcnZhbD1zZXRJbnRlcnZhbCiqKCl7ZXhwb3J0cy5vZmZzZXSWZDutZT0h1AE70zxkntOOZXhwb3J0cy5vZmZzZXQ/KGU9IdMsZXhwb3J0cy5vZmZzZXQ90yk60z5kni3UFz5leHBvcnRzLm9mZnNldJ4oZT0h0yxleHBvcnRzLm9mZnNldD3U6Ck7ZZ4oY2xlYXJJbnRlcnZhbChleHBvcnRzLmFuaW1JbnRlcnZhbCksvmV4cG9ydHMuYW5pbUludGVydmFsLGaeZigpKTtrKCl9LNQyKX2jKNQCjXByb2Nlc3MuZW52LkhXVkVSU0lPTimrZXhwb3J0cy5oaWRlKCk7ZXhwb3J0cy5jbGVhbnVwKCk7oyhnbG9iYWwuV0lER0VUUyl7ZXhwb3J0cy5hdXRvaGlkZT3A04thP9XQBzphO0JhbmdsZS5hcHBSZWN0PXt4OtMseTrTLHc6Zy5nZXRXaWR0aCgpLGg6Zy5nZXRIZWlnaHQoKSx4MjpnLmdldFdpZHRoKCkt1AEseTI6Zy5nZXRIZWlnaHQoKS3UAX07rGI9R3JhcGhpY3MuY3JlYXRlQXJyYXlCdWZmZXIoZy5nZXRXaWR0aCgpLNQaLNQQLHttc2I6IdN9KTtiLnRoZW1lPWcudGhlbWU7Yi5fcmVzZXQ9Yi5yZXNldDtiLnJlc2V0PaooKXurry5fcmVzZXQoKS5zZXRDb2xvcihnLnRoZW1lLmZnKS5zZXRCZ0NvbG9yKGcudGhlbWUuYmcpfTtiLnJlc2V0KCkuY2xlYXJSZWN0KNMs0yxiLmdldFdpZHRoKCks1BcpLmZpbGxSZWN0KNMs1BgsYi5nZXRXaWR0aCgpLNQZKTusbD1nO2V4cG9ydHMub2Zmc2V0PdToO6corGPGZ2xvYmFsLldJREdFVFMpYy5fZHJhd6AoYy5fZHJhdz1jLmRyYXcsYy5kcmF3PaooKXtnPWI7ry5fZHJhdyivKTtnPWw7LdQYPGV4cG9ydHMub2Zmc2V0nmsoKX0sYy5fYXJlYT1jLmFyZWEsYy5hcmVhLnN0YXJ0c1dpdGgo0QFiKZ4oYy5hcmVhPdEBdCtjLmFyZWEuc3Vic3RyKNQBKSkpO2V4cG9ydHMub3JpZ0RyYXc9QmFuZ2xlLmRyYXdXaWRnZXRzO0JhbmdsZS5kcmF3V2lkZ2V0cz0oKaJ7Zz1iO2V4cG9ydHMub3JpZ0RyYXcoKTtnPWx9O2V4cG9ydHMuc3dpcGVIYW5kbGVyPaooZCxmKXtleHBvcnRzLmhpZGVUaW1lb3V0nihjbGVhclRpbWVvdXQoZXhwb3J0cy5oaWRlVGltZW91dCksvmV4cG9ydHMuaGlkZVRpbWVvdXQpO61lO9M8ZXhwb3J0cy5hdXRvaGlkZZ4oZT2qKCl7ZXhwb3J0cy5oaWRlVGltZW91dD1zZXRUaW1lb3V0KKooKXtoKNT8KX0sZXhwb3J0cy5hdXRvaGlkZSl9KTvTPGae0z5leHBvcnRzLm9mZnNldJ5oKNQELGUpO9M+Zp4t1Bg8ZXhwb3J0cy5vZmZzZXSeaCjU/Cl9O0JhbmdsZS5vbijRBXN3aXBlLGV4cG9ydHMuc3dpcGVIYW5kbGVyKTtCYW5nbGUuZHJhd1dpZGdldHMoKX19fSk7e61zPXJlcXVpcmUo0QdTdG9yYWdlKTutc2V0dGluZ3M9T2JqZWN0LmFzc2lnbih7c2hvd0Nsb2Nrczq0LGZ1bGxzY3JlZW46tSxoZWlnaHQ61DR9LHMucmVhZEpTT04o0QtsYXVuY2guanNvbiy0KaB7fSk7rWZvbnQ9c2V0dGluZ3MuZm9udDujKCFmb250oGZvbnSK0QZWZWN0b3Ipe61mb250cz1nLmdldEZvbnRzKCk7Zm9udD1mb250cy5pbmNsdWRlcyjRBTEyeDIwKT/RBTEyeDIwOtEFNng4OjI7oyhmb250cy5pbmNsdWRlcyjRAjIyKSlmb250PdECMjI7fa1oZWlnaHQ903xNYXRoLm1heChzZXR0aW5ncy5oZWlnaHQs1AwpLHBhZD3UAjutaW1nc2l6ZT1oZWlnaHQtcGFkKtQCLGltZ3NjYWxlPWltZ3NpemUv1DA7oyghc2V0dGluZ3MuZnVsbHNjcmVlbil7QmFuZ2xlLmxvYWRXaWRnZXRzKCk7faSjKGdsb2JhbC5XSURHRVRTKXtyZXF1aXJlKNEMd2lkZ2V0X3V0aWxzKS5oaWRlKCk7fXutUj1CYW5nbGUuYXBwUmVjdCxtaWQ9aGVpZ2h0L9QCLHRoPWcuc2V0Rm9udChmb250KS5zdHJpbmdNZXRyaWNzKNEBWCkuaGVpZ2h0L9QCO2cucmVzZXQoKS5jbGVhclJlY3QoUikuc2V0Q29sb3Io0QQjODg4KTunKKx5PVIueTt5PFIueTI7eZZoZWlnaHQpe2cuZHJhd1JlY3QocGFkKtQCLHkrcGFkKtQCLGltZ3NpemUtcGFkLHkraW1nc2l6ZS1wYWQpLmRyYXdSZWN0KGltZ3NpemUrcGFkKtQCLHkrbWlkLXRoLFIueTItUi53L9QDLHkrbWlkK3RoKTt9Zy5mbGlwKCk7fa1sYXVuY2hDYWNoZT1zLnJlYWRKU09OKNERbGF1bmNoLmNhY2hlLmpzb24stCmge307rWxhdW5jaEhhc2g9cmVxdWlyZSjRB1N0b3JhZ2UpLmhhc2goL1wuaW5mby8pO6MobGF1bmNoQ2FjaGUuaGFzaIxsYXVuY2hIYXNoKXtsYXVuY2hDYWNoZT17aGFzaDpsYXVuY2hIYXNoLGFwcHM6cy5saXN0KC9cLmluZm8kLykubWFwKGFwcKJ7rGE9cy5yZWFkSlNPTihhcHAs1AEpO6thnntuYW1lOmEubmFtZSx0eXBlOmEudHlwZSxpY29uOmEuaWNvbixzb3J0b3JkZXI6YS5zb3J0b3JkZXIsc3JjOmEuc3JjfTt9KS5maWx0ZXIoYXBwomFwcJ4oYXBwLnR5cGWK0QNhcHCgKGFwcC50eXBlitEFY2xvY2uec2V0dGluZ3Muc2hvd0Nsb2NrcymgIWFwcC50eXBlKSkuc29ydCgoYSxiKaJ7rG49KNN8YS5zb3J0b3JkZXIpLSjTfGIuc29ydG9yZGVyKTujKG4pq247oyhhLm5hbWU8Yi5uYW1lKast1AE7oyhhLm5hbWU+Yi5uYW1lKavUATur0zt9KX07cy53cml0ZUpTT04o0RFsYXVuY2guY2FjaGUuanNvbixsYXVuY2hDYWNoZSk7fa1hcHBzPWxhdW5jaENhY2hlLmFwcHM7rmRyYXdNZW51PSgpontFLnNob3dTY3JvbGxlcih7aDpoZWlnaHQsYzphcHBzLmxlbmd0aCxkcmF3OihpLHIponusYXBwPWFwcHNbaV07oyghYXBwKas7Zy5jbGVhclJlY3Qocikuc2V0Rm9udChmb250KS5zZXRGb250QWxpZ24o1P8s0ykuZHJhd1N0cmluZyhhcHAubmFtZSxpbWdzaXplK3BhZCrUAixyLnkr1AIrci5oL9QCKTujKGFwcC5pY29uKXujKCFhcHAuaW1nKWFwcC5pbWc9cy5yZWFkKGFwcC5pY29uKTuxe2cuZHJhd0ltYWdlKGFwcC5pbWcscGFkLHIueStwYWQse3NjYWxlOmltZ3NjYWxlfSk7fWNhdGNoKGUpe319fSxzZWxlY3Q6aaJ7rGFwcD1hcHBzW2ldO6MoIWFwcCmrO6MoIWFwcC5zcmOgcmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQoYXBwLnNyYymLtyl7RS5zaG93U2Nyb2xsZXIoKTtFLnNob3dNZXNzYWdlKNEUQXBwIFNvdXJjZQpOb3QgZm91bmQpO3NldFRpbWVvdXQoZHJhd01lbnUs1dAHKTt9pHtsb2FkKGFwcC5zcmMpO319LGJhY2s6QmFuZ2xlLnNob3dDbG9jayxyZW1vdmU6KCmie6MobG9ja1RpbWVvdXQpY2xlYXJUaW1lb3V0KGxvY2tUaW1lb3V0KTtCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QRsb2NrLGxvY2tIYW5kbGVyKTujKGdsb2JhbC5XSURHRVRTKXJlcXVpcmUo0Qx3aWRnZXRfdXRpbHMpLnNob3coKTt9fSk7Zy5mbGlwKCk7QmFuZ2xlLnNldExvY2tlZCi1KTutbG9ja1RpbWVvdXQ7rWxvY2tIYW5kbGVyPaoobG9ja2VkKXujKGxvY2tUaW1lb3V0KWNsZWFyVGltZW91dChsb2NrVGltZW91dCk7bG9ja1RpbWVvdXQ9tzujKGxvY2tlZClsb2NrVGltZW91dD1zZXRUaW1lb3V0KEJhbmdsZS5zaG93Q2xvY2ss1RAnKTt9O0JhbmdsZS5vbijRBGxvY2ssbG9ja0hhbmRsZXIpO307ZHJhd01lbnUoKTujKCFzZXR0aW5ncy5mdWxsc2NyZWVuKUJhbmdsZS5kcmF3V2lkZ2V0cygpO33///9nBAAAbGF1bmNoLnNldHRpbmdzLmpz");
  base64DecodeToExistingUint8Array(bufferView, 111300, "KKooYmFjayl7rXNldHRpbmdzPU9iamVjdC5hc3NpZ24oe3Nob3dDbG9ja3M6tCxmdWxsc2NyZWVuOrUsaGVpZ2h0OtQ0fSxyZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QtsYXVuY2guanNvbiy0KaB7fSk7rWZvbnRzPWcuZ2V0Rm9udHMoKS5maWx0ZXIoZqJmjNEGVmVjdG9yKTunKKxmPdQKO2Y81BQ7ZpgpZm9udHMucHVzaCjRBlZlY3RvcitmKTutZGVmYXVsdGZvbnQ9Zm9udHMuaW5jbHVkZXMo0QUxMngyMCk/0QUxMngyMDrRBTZ4ODoyO6MoZm9udHMuaW5jbHVkZXMo0QIyMikpZGVmYXVsdGZvbnQ90QIyMjutaGVpZ2h0cz1b1Bws1Cgs1DQs1EAs1ExdO6pzYXZlKCl7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNELbGF1bmNoLmpzb24sc2V0dGluZ3MpO32qY2xlYXJDYWNoZSgpe3JlcXVpcmUo0QdTdG9yYWdlKS5lcmFzZSjREWxhdW5jaC5jYWNoZS5qc29uKTt9rmFwcE1lbnU9eyIiOnvRBXRpdGxlOtEITGF1bmNoZXJ9LNEGPCBCYWNrOmJhY2ss0QRGb250Ont2YWx1ZTpmb250cy5pbmNsdWRlcyhzZXR0aW5ncy5mb250KT9mb250cy5pbmRleE9mKHNldHRpbmdzLmZvbnQpOmZvbnRzLmluZGV4T2YoZGVmYXVsdGZvbnQpLG1pbjrTLG1heDpmb250cy5sZW5ndGgt1AEsc3RlcDrUASx3cmFwOrQsb25jaGFuZ2U6KG0pontzZXR0aW5ncy5mb250PWZvbnRzW21dO3NhdmUoKTt9LGZvcm1hdDp2omZvbnRzW3ZdfSzRBkhlaWdodDp7dmFsdWU6aGVpZ2h0cy5pbmNsdWRlcyhzZXR0aW5ncy5oZWlnaHQpP2hlaWdodHMuaW5kZXhPZihzZXR0aW5ncy5oZWlnaHQpOmhlaWdodHMuaW5kZXhPZijUNCksbWluOtMsbWF4OmhlaWdodHMubGVuZ3RoLdQBLHN0ZXA61AEsd3JhcDq0LGZvcm1hdDp2omhlaWdodHNbdl0r0QJweCxvbmNoYW5nZToobSmie3NldHRpbmdzLmhlaWdodD1oZWlnaHRzW21dO3NhdmUoKTt9fSzRC1Nob3cgQ2xvY2tzOnt2YWx1ZTohIXNldHRpbmdzLnNob3dDbG9ja3Msb25jaGFuZ2U6KG0pontzZXR0aW5ncy5zaG93Q2xvY2tzPW07c2F2ZSgpO2NsZWFyQ2FjaGUoKTt9fSzRCkZ1bGxzY3JlZW46e3ZhbHVlOiEhc2V0dGluZ3MuZnVsbHNjcmVlbixvbmNoYW5nZToobSmie3NldHRpbmdzLmZ1bGxzY3JlZW49bTtzYXZlKCk7fX19O0Uuc2hvd01lbnUoYXBwTWVudSk7fSn/5AAAAGxhdW5jaC5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 112460, "eyJpZCI6ImxhdW5jaCIsIm5hbWUiOiJMYXVuY2hlciIsInR5cGUiOiJsYXVuY2giLCJzcmMiOiJsYXVuY2guYXBwLmpzIiwic29ydG9yZGVyIjotMTAsInZlcnNpb24iOiIwLjI1IiwidGFncyI6InRvb2wsc3lzdGVtLGxhdW5jaGVyIiwiZmlsZXMiOiJsYXVuY2guaW5mbyxsYXVuY2guYXBwLmpzLGxhdW5jaC5zZXR0aW5ncy5qcyIsImRhdGEiOiJsYXVuY2guanNvbixsYXVuY2guY2FjaGUuanNvbiJ96gIAAHNjaGVkLmJvb3QuanM=");
  base64DecodeToExistingUint8Array(bufferView, 112720, "KKooKXujKEJhbmdsZS5TQ0hFRCl7Y2xlYXJUaW1lb3V0KEJhbmdsZS5TQ0hFRCk7vkJhbmdsZS5TQ0hFRDt9vkUuc2V0VGltZVpvbmU7rGFsYXJtcz1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QpzY2hlZC5qc29uLNQBKaBbXTusdGltZT24RGF0ZSgpO6xjdXJyZW50VGltZT0odGltZS5nZXRIb3VycygpKjM2MDAwMDApKyh0aW1lLmdldE1pbnV0ZXMoKSo2MDAwMCkrKHRpbWUuZ2V0U2Vjb25kcygpKtXoAyk7rGQ9dGltZS5nZXREYXRlKCk7rGFjdGl2ZT1hbGFybXMuZmlsdGVyKGGiYS5vbp4oYS5sYXN0jGQpnihhLnQrNjAwMDA+Y3VycmVudFRpbWUpnihhLmRvd5J0aW1lLmdldERheSgpJtQBKZ4oIWEuZGF0ZaBhLmRhdGWKdGltZS50b0xvY2FsSVNPU3RyaW5nKCkuc3Vic3RyKNMs1AopKSk7oyhhY3RpdmUubGVuZ3RoKXthY3RpdmU9YWN0aXZlLnNvcnQoKGEsYimiYS50LWIudCk7rHQ9YWN0aXZlW9NdLnQtY3VycmVudFRpbWU7oyh0PNXoAyl0PdXoAztCYW5nbGUuU0NIRUQ9c2V0VGltZW91dChhY3RpdmVb010uanOg0RBsb2FkKCJzY2hlZC5qcyIpLHQpO6x0ej1FLnNldFRpbWVab25lO0Uuc2V0VGltZVpvbmU9qih6KXt0eih6KTtldmFsKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKNENc2NoZWQuYm9vdC5qcykpO307faR7QmFuZ2xlLlNDSEVEPXNldFRpbWVvdXQo0S5ldmFsKHJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkKCJzY2hlZC5ib290LmpzIikpLDg2NDAwMDAwLWN1cnJlbnRUaW1lKTt9fSkoKTv///sUAABzY2hlZC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 113500, "TW9kdWxlcy5hZGRDYWNoZWQo0Qp0aW1lX3V0aWxzLKooKXuqZChhKXure2Q6YS5koNMsaDphLmig0yxtOmEubaDTLHM6YS5zoNN9fWV4cG9ydHMuZW5jb2RlVGltZT1honthPWQoYSk7qzg2NEU1KmEuZCszNkU1KmEuaCs2RTQqYS5tK9XoAyphLnN9O2V4cG9ydHMuZGVjb2RlVGltZT1honujKNEGbnVtYmVyjb9hKbDRHE9ubHkgYSBudW1iZXIgY2FuIGJlIGRlY29kZWQ7rGM9TWF0aC5mbG9vcihhLzg2NEU1KTthlzg2NEU1KmM7rGI9TWF0aC5mbG9vcihhLzM2RTUpO2GXMzZFNSpiO6xlPU1hdGguZmxvb3IoYS82RTQpO6t7ZDpjLGg6YixtOmUsczpNYXRoLmZsb29yKChhLTZFNCplKS/V6AMpfX07ZXhwb3J0cy5mb3JtYXRUaW1lPWGie2E9ZCjRBm9iamVjdIu/YT9hOmV4cG9ydHMuZGVjb2RlVGltZShhKSk7YS5oltQYKmEuZDurYS5oK9EBOiso0QEwK2EubSkuc3Vic3RyKNT+KX07ZXhwb3J0cy5mb3JtYXREdXJhdGlvbj0oYSxjKaJ7Yz1joCHUATusYj0iIjthPWQo0QZvYmplY3SLv2E/YTpleHBvcnRzLmRlY29kZVRpbWUoYSkpO9M8YS5knihilmEuZCvRAmQgKTvTPGEuaJ4oYpZhLmgr0QJoICk70zxhLm2eKGKWYS5tK9ECbSApO9M8YS5znihilmEucyvRAXMpO2I9Yi50cmltKCk7q2M/Yi5yZXBsYWNlKNEBICwiIik6Yn07ZXhwb3J0cy5nZXRDdXJyZW50VGltZU1pbGxpcz0oKaJ7rGE9uERhdGU7q9XoAyoo1RAOKmEuZ2V0SG91cnMoKSvUPCphLmdldE1pbnV0ZXMoKSthLmdldFNlY29uZHMoKSl9fSk7Ck1vZHVsZXMuYWRkQ2FjaGVkKNEEYnV6eiyqKCl7ZXhwb3J0cy5wYXR0ZXJuPWOiuFByb21pc2UoZKJ7qmEoKXujKCIiimMpq2QoKTusYj1jW9NdO2M9Yy5zdWJzdHIo1AEpO9EBLopiP0JhbmdsZS5idXp6KNRkLC4yNSkudGhlbigoKaJzZXRUaW1lb3V0KGEs1GQpKTrRASyKYj9CYW5nbGUuYnV6eijVyAAsLjI1KS50aGVuKCgponNldFRpbWVvdXQoYSzUZCkpOtEBLYpiP0JhbmdsZS5idXp6KNX0ASwuMjUpLnRoZW4oKCmic2V0VGltZW91dChhLNRkKSk60QE6imI/QmFuZ2xlLmJ1enoo1GQs1AEpLnRoZW4oKCmic2V0VGltZW91dChhLNRkKSk60QE7imI/QmFuZ2xlLmJ1enoo1cgALNQBKS50aGVuKCgponNldFRpbWVvdXQoYSzUZCkpOtEBPYpiP0JhbmdsZS5idXp6KNX0ASzUASkudGhlbigoKaJzZXRUaW1lb3V0KGEs1GQpKTpzZXRUaW1lb3V0KGEs1GQpfWEoKX0pfSk7CqMoQmFuZ2xlLlNDSEVEKXtjbGVhckludGVydmFsKEJhbmdsZS5TQ0hFRCk7vkJhbmdsZS5TQ0hFRDt9Cqpmb3JtYXRNUyhtcyl7oyhtczw2MDAwMCl7q01hdGgucm91bmQobXMv1egDKSvRAXM7faR7q01hdGgucm91bmQobXMvNjAwMDApK9EBbTt9fQqqc2hvd1Nub296ZU1lbnUoYWxhcm0pe0JhbmdsZS5idXp6KNQoKTuqb25Tbm9vemUoc25vb3plVGltZSl7oyhhbGFybS5vdIu3KXthbGFybS5vdD1hbGFybS50O32tdGltZT24RGF0ZSgpO61jdXJyZW50VGltZT0odGltZS5nZXRIb3VycygpKjM2MDAwMDApKyh0aW1lLmdldE1pbnV0ZXMoKSo2MDAwMCkrKHRpbWUuZ2V0U2Vjb25kcygpKtXoAyk7YWxhcm0udD1jdXJyZW50VGltZStzbm9vemVUaW1lO2FsYXJtLnScODY0MDAwMDA7QmFuZ2xlLmVtaXQo0QthbGFybVNub296ZSxhbGFybSk7cmVxdWlyZSjRBXNjaGVkKS5zZXRBbGFybXMoYWxhcm1zKTtsb2FkKCk7faMoYWxhcm0udGltZXIpe610aW1lckxlbmd0aD1hbGFybS50aW1lcq1idXR0b25zPXvRAzE1czrUDyzRAzMwczrUHizRAjFtOtQ8LNECMm061Hgs0QI1bTrVaAF9O61mb3JtYXR0ZWRMZW5ndGg9Zm9ybWF0TVModGltZXJMZW5ndGgpK9EBKjtidXR0b25zW2Zvcm1hdHRlZExlbmd0aF09TWF0aC5yb3VuZCh0aW1lckxlbmd0aC/V6AMpO0Uuc2hvd1Byb21wdCjRFENob29zZSBzbm9vemUgbGVuZ3RoLHt0aXRsZTrRDlNub296ZSBPcHRpb25zLGJ1dHRvbnN9KS50aGVuKHNub296ZVRpbWWib25Tbm9vemUoc25vb3plVGltZSrV6AMpKTt9pHtFLnNob3dQcm9tcHQo0RRDaG9vc2Ugc25vb3plIGxlbmd0aCx7dGl0bGU60Q5Tbm9vemUgT3B0aW9ucyxidXR0b25zOnvRAjFtOtQBLNECMm061AIs0QI1bTrUBSzRAzEwbTrUCn19KS50aGVuKHNub296ZVRpbWWib25Tbm9vemUoc25vb3plVGltZSo2MDAwMCkpO319CqpzaG93QWxhcm0oYWxhcm0pe65hbGFybUluZGV4PWFsYXJtcy5pbmRleE9mKGFsYXJtKTuuc2V0dGluZ3M9cmVxdWlyZSjRBXNjaGVkKS5nZXRTZXR0aW5ncygpO61tZXNzYWdlPSIiO21lc3NhZ2WWYWxhcm0udGltZXI/cmVxdWlyZSjRCnRpbWVfdXRpbHMpLmZvcm1hdER1cmF0aW9uKGFsYXJtLnRpbWVyKTpyZXF1aXJlKNEKdGltZV91dGlscykuZm9ybWF0VGltZShhbGFybS50KTujKGFsYXJtLm1zZyl7bWVzc2FnZZbRAQorYWxhcm0ubXNnO32ke21lc3NhZ2U9KGFsYXJtLnRpbWVyP9KZAQAkLMIA//9970XBhyEAAAAVVVQAAAAAAAAVVVQAAAAAAAAVVVQAAAAAAAAVVVQAAAAAAAAVVVQAAAAAAAAVVVQAAAAAAAAD/8AAAAAAAAAD/8AAAAAAAAAKqqADwAAAAAKqqqqD/AAAACqqqqqr/wAAAqqqqqqqv8AACqqqpVqqr8AAKqqqpVWqqwAAqqqqpVVaqgACqqqqpVVWqoACqmqqpVVVqoAKqVqqpVVVaqAKpVqqpVVVWqAqpVeqpVVVWqgqlVX6pVVVVqgqlVX+pVVVVqiqVVV/5VVVVaqqVVVf/lVVVaqqVVVf/5VVVaqqVVVX69VVVaqqVVVX69VVVaqqVVVW/5VVVaqqVVVVvlVVVaqqVVVVVVVVVaoqlVVVVVVVVqgqlVVVVVVVVqgqpVVVVVVVWqgKpVVVVVVVWqAKqVVVVVVVaqACqlVVVVVVqoACqpVVVVVWqoAAqqVVVVVaqgAAKqpVVVWqqAAACqqlVVqqoAAAAqqqqqqqgAAAACqqqqqoAAAAAAKqqqqAAAAAAAAKqqAAAAA60vwBAC0swgF97///RcEpMlVVVVVVf9VVVVVVVVX/9VVf9VVf/1VVV///1Vf9VX///VVX///VWqqlV///1Vf//9aqqqqpf//9V///2qqqqqqn///V///6qqqqqqr///X//+qqoAAKqqv//3//6qoAAAAKqr//3//qqAAAAAAqq//3/+qoAADwAAKqv/3/+qgAADwAACqv/3/aqAAADwAAAqp/19qoAAADwAAAKqfV1qgAAADwAAACqXVWqgAAADwAAACqlVWqAAAADwAAAAqlVWqAAAADwAAAAqlVWqAAAADwAAAAqlVaoAAAADwAAAAKpVaoAAAADwAAAAKpVaoAAAADwAAAAKpVaoAAAAOsAAAAKpVaoAAAAOsAAAAKpVaoAAAAL/AAAAKpVaoAAAAgPwAAAKpVaoAAACAD8AAAKpVWqAAAIAA/AAAqlVWqAAAgAAPwAAqlVWqAACAAADwAAqlVWqgAIAAAAAACqlVVqgAgAAAAAACqVVVqoAAAAAAAAKqVVVaqAAAAAAAAqpVVVWqgAAAAAACqlVVVWqoAAAAAAKqlVVVVqqAAAAAAqqVVVVVaqoAAAAKqpVVVVVeqqoAAKqqtVVVVV/6qqqqqqr/VVVVX/2qqqqqqn/1VVVf/VaqqqqpV/9VVVf9VVWqqlVVf9VVVf1VVVVVVVVX9VSkr0QEgK21lc3NhZ2V9QmFuZ2xlLmxvYWRXaWRnZXRzKCk7QmFuZ2xlLmRyYXdXaWRnZXRzKCk7rWJ1enpDb3VudD1zZXR0aW5ncy5idXp6Q291bnQ7RS5zaG93UHJvbXB0KG1lc3NhZ2Use3RpdGxlOmFsYXJtLnRpbWVyP9EGVElNRVIhOtEGQUxBUk0hLGJ1dHRvbnM6e9EGU25vb3plOtQBLNEEU3RvcDrUAn0sYnV0dG9uc0xvbmc6e9EGU25vb3plOtQDfSx9KS50aGVuKKooc2xlZXApe2J1enpDb3VudD3TO6Moc2xlZXCK1AMpe3Nob3dTbm9vemVNZW51KGFsYXJtKTurO32jKHNsZWVwitQBKXujKGFsYXJtLm90i7cpe2FsYXJtLm90PWFsYXJtLnQ7fa10aW1lPbhEYXRlKCk7rWN1cnJlbnRUaW1lPSh0aW1lLmdldEhvdXJzKCkqMzYwMDAwMCkrKHRpbWUuZ2V0TWludXRlcygpKjYwMDAwKSsodGltZS5nZXRTZWNvbmRzKCkq1egDKTthbGFybS50PWN1cnJlbnRUaW1lK3NldHRpbmdzLmRlZmF1bHRTbm9vemVNaWxsaXM7YWxhcm0udJw4NjQwMDAwMDtCYW5nbGUuZW1pdCjRC2FsYXJtU25vb3plLGFsYXJtKTt9pHutZGVsPWFsYXJtLmRlbIu3P3NldHRpbmdzLmRlZmF1bHREZWxldGVFeHBpcmVkVGltZXJzOmFsYXJtLmRlbDujKGRlbCl7YWxhcm1zLnNwbGljZShhbGFybUluZGV4LNQBKTt9pHujKGFsYXJtLmRhdGWeYWxhcm0ucnApe3NldE5leHRSZXBlYXREYXRlKGFsYXJtKTt9pKMoIWFsYXJtLnRpbWVyKXthbGFybS5sYXN0PbhEYXRlKCkuZ2V0RGF0ZSgpO32jKGFsYXJtLm90jbcpe2FsYXJtLnQ9YWxhcm0ub3Q7vmFsYXJtLm90O32jKCFhbGFybS5ycCl7YWxhcm0ub249tTt9fUJhbmdsZS5lbWl0KNEMYWxhcm1EaXNtaXNzLGFsYXJtKTt9cmVxdWlyZSjRBXNjaGVkKS5zZXRBbGFybXMoYWxhcm1zKTtsb2FkKCk7fSk7qmJ1enooKXujKHNldHRpbmdzLnVubG9ja0F0QnV6eil7QmFuZ2xlLnNldExvY2tlZCi1KTt9rnBhdHRlcm49YWxhcm0udmlicmF0ZaAoYWxhcm0udGltZXI/c2V0dGluZ3MuZGVmYXVsdFRpbWVyUGF0dGVybjpzZXR0aW5ncy5kZWZhdWx0QWxhcm1QYXR0ZXJuKTtyZXF1aXJlKNEEYnV6eikucGF0dGVybihwYXR0ZXJuKS50aGVuKCgponujKGJ1enpDb3VudIq2oGJ1enpDb3VudJkpe3NldFRpbWVvdXQoYnV6eixzZXR0aW5ncy5idXp6SW50ZXJ2YWxNaWxsaXMpO32koyhhbGFybS5hcyl7YnV6ekNvdW50PXNldHRpbmdzLmJ1enpDb3VudDtzZXRUaW1lb3V0KGJ1enosc2V0dGluZ3MuZGVmYXVsdFNub296ZU1pbGxpcyk7fX0pO32qc2V0TmV4dFJlcGVhdERhdGUoYWxhcm0pe61kYXRlPbhEYXRlKGFsYXJtLmRhdGUpO61ycD1hbGFybS5ycDujKHJwi7Qpe2RhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSvUASk7faS7KHJwLmludGVydmFsKXu80QNkYXk6ZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpK3JwLm51bSk7qDu80QR3ZWVrOmRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSsocnAubnVtKtQHKSk7qDu80QVtb250aDqjKCFhbGFybS5vZClhbGFybS5vZD1kYXRlLmdldERhdGUoKTtkYXRlPbhEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSxkYXRlLmdldE1vbnRoKCkrcnAubnVtLGFsYXJtLm9kKTujKGRhdGUuZ2V0RGF0ZSgpjGFsYXJtLm9kKWRhdGUuc2V0RGF0ZSjTKTuoO7zRBHllYXI6oyghYWxhcm0ub2QpYWxhcm0ub2Q9ZGF0ZS5nZXREYXRlKCk7ZGF0ZT24RGF0ZShkYXRlLmdldEZ1bGxZZWFyKCkrcnAubnVtLGRhdGUuZ2V0TW9udGgoKSxhbGFybS5vZCk7oyhkYXRlLmdldERhdGUoKYxhbGFybS5vZClkYXRlLnNldERhdGUo0yk7qDu9OmNvbnNvbGUubG9nKGBzY2hlZDogdW5rbm93biByZXBlYXQgJyR7SlNPTi5zdHJpbmdpZnkocnApfSdgKTuoO31hbGFybS5kYXRlPWRhdGUudG9Mb2NhbElTT1N0cmluZygpLnNsaWNlKNMs1AopO32jKChyZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QxzZXR0aW5nLmpzb24s1AEpoHt9KS5xdWlldD7UASmrO2J1enooKTt9rWFsYXJtcz1yZXF1aXJlKNEFc2NoZWQpLmdldEFsYXJtcygpO61hY3RpdmU9cmVxdWlyZSjRBXNjaGVkKS5nZXRBY3RpdmVBbGFybXMoYWxhcm1zKTujKGFjdGl2ZS5sZW5ndGgpe3Nob3dBbGFybShhY3RpdmVb010pO32ke3NldFRpbWVvdXQobG9hZCzUZCk7ff+EBAAAc2NoZWQuaW1n");
  base64DecodeToExistingUint8Array(bufferView, 118904, "MDCEBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmERFmZmZmZmZmZmZmZmZmZmYRERFmZmZmERFmZmZmERERZmZmZmZmZhERERERZmZmERFmZmYREREREWZmZmZmYREREREWZmbMzMzMZmZhERERERZmZmZmERERERFmzMzMzMzMzMxmERERERFmZmZhERERERbMzMzMzMzMzMzMYREREREWZmZhERERERzMzMzMzMzMzMzMwREREREWZmYRERERFMzMzEQz//8zRMzMzEERERERZmYRERERTMzMQ////////zTMzMQRERERZmYREREUzMzD//////////88zMxBERERZmYRERFMzMQ/////8A/////zTMzEERERZmYRERHMzE//////8A//////9MzMERERZmYREWzMxP//////8A///////0zMxhERZmZhFszMw///////8A///////zzMzGEWZmZhZszMP///////8A////////PMzGYWZmZmbMzE////////8A////////9MzMZmZmZmbMzD////////8A////////88zMZmZmZmbMxP////////8A/////////0zMZmZmZmbMxP////////8A/////////0zMZmZmZmzMw/////////8A/////////zzMxmZmZmzMw/////////8A/////////zzMxmZmZmzMz/////////MAP/////////zMxmZmZmzMz/////////BVD/////////zMxmZmZmzMz/////////BVA/////////zMxmZmZmzMz////////zQAAD////////zMxmZmZmzMw///////80PzAAP//////zzMxmZmZmzMw///////ND//MAA//////zzMxmZmZmbMxP/////zQ///8wAD/////0zMZmZmZmbMxP////80P////zAAP////0zMZmZmZmbMzD////ND//////MC////88zMZmZmZmbMzE///zQ///////8/////9MzMZmZmZmZszMP/80P/////////////PMzGZmZmZmZszMw//z/////////////zzMzGZmZmZmZmzMxP///////////////0zMxmZmZmZmZmbMzE//////////////9MzMZmZmZmZmZmbMzMQ////////////zTMzMZmZmZmZmZmZszMzD//////////88zMzGZmZmZmZmZmZmzMzMQ////////zTMzMxmZmZmZmZmZmZmFMzMzEQz//8zRMzMzEFmZmZmZmZmZmZhERzMzMzMzMzMzMzMwREWZmZmZmZmZmYRERbMzMzMzMzMzMzMYRERZmZmZmZmZmEREWZmzMzMzMzMzMxmZhERFmZmZmZmZmERFmZmZmbMzMzMZmZmZmERFmZmZmZmZmERZmZmZmZmZmZmZmZmZmYRFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZhoMAABzY2hlZA==");
  base64DecodeToExistingUint8Array(bufferView, 120092, "TW9kdWxlcy5hZGRDYWNoZWQo0Qp0aW1lX3V0aWxzLKooKXuqZChhKXure2Q6YS5koNMsaDphLmig0yxtOmEubaDTLHM6YS5zoNN9fWV4cG9ydHMuZW5jb2RlVGltZT1honthPWQoYSk7qzg2NEU1KmEuZCszNkU1KmEuaCs2RTQqYS5tK9XoAyphLnN9O2V4cG9ydHMuZGVjb2RlVGltZT1honujKNEGbnVtYmVyjb9hKbDRHE9ubHkgYSBudW1iZXIgY2FuIGJlIGRlY29kZWQ7rGM9TWF0aC5mbG9vcihhLzg2NEU1KTthlzg2NEU1KmM7rGI9TWF0aC5mbG9vcihhLzM2RTUpO2GXMzZFNSpiO6xlPU1hdGguZmxvb3IoYS82RTQpO6t7ZDpjLGg6YixtOmUsczpNYXRoLmZsb29yKChhLTZFNCplKS/V6AMpfX07ZXhwb3J0cy5mb3JtYXRUaW1lPWGie2E9ZCjRBm9iamVjdIu/YT9hOmV4cG9ydHMuZGVjb2RlVGltZShhKSk7YS5oltQYKmEuZDurYS5oK9EBOiso0QEwK2EubSkuc3Vic3RyKNT+KX07ZXhwb3J0cy5mb3JtYXREdXJhdGlvbj0oYSxjKaJ7Yz1joCHUATusYj0iIjthPWQo0QZvYmplY3SLv2E/YTpleHBvcnRzLmRlY29kZVRpbWUoYSkpO9M8YS5knihilmEuZCvRAmQgKTvTPGEuaJ4oYpZhLmgr0QJoICk70zxhLm2eKGKWYS5tK9ECbSApO9M8YS5znihilmEucyvRAXMpO2I9Yi50cmltKCk7q2M/Yi5yZXBsYWNlKNEBICwiIik6Yn07ZXhwb3J0cy5nZXRDdXJyZW50VGltZU1pbGxpcz0oKaJ7rGE9uERhdGU7q9XoAyoo1RAOKmEuZ2V0SG91cnMoKSvUPCphLmdldE1pbnV0ZXMoKSthLmdldFNlY29uZHMoKSl9fSk7CmV4cG9ydHMuZ2V0QWxhcm1zPaooKXurcmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEKc2NoZWQuanNvbizUASmgW107fTsKZXhwb3J0cy5zZXRBbGFybXM9qihhbGFybXMpe2FsYXJtcy5mb3JFYWNoKGWiZS50nDg2NDAwMDAwKTurcmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlSlNPTijRCnNjaGVkLmpzb24sYWxhcm1zKTt9OwpleHBvcnRzLmdldEFsYXJtPaooaWQpe6tleHBvcnRzLmdldEFsYXJtcygpLmZpbmQoYaJhLmlkimlkKTt9OwpleHBvcnRzLmdldEFjdGl2ZUFsYXJtcz2qKGFsYXJtcyx0aW1lKXujKCF0aW1lKXRpbWU9uERhdGUoKTusY3VycmVudFRpbWU9KHRpbWUuZ2V0SG91cnMoKSozNjAwMDAwKSsodGltZS5nZXRNaW51dGVzKCkqNjAwMDApKyh0aW1lLmdldFNlY29uZHMoKSrV6AMpK9UQJzurYWxhcm1zLmZpbHRlcihhomEub26eKGEubGFzdIx0aW1lLmdldERhdGUoKSmeKGEudDxjdXJyZW50VGltZSmeKGEuZG93knRpbWUuZ2V0RGF5KCkm1AEpnighYS5kYXRloGEuZGF0ZYp0aW1lLnRvTG9jYWxJU09TdHJpbmcoKS5zdWJzdHIo0yzUCikpKS5zb3J0KChhLGIpomEudC1iLnQpO30KZXhwb3J0cy5zZXRBbGFybT2qKGlkLGFsYXJtKXusYWxhcm1zPWV4cG9ydHMuZ2V0QWxhcm1zKCkuZmlsdGVyKGGiYS5pZIxpZCk7oyhhbGFybY23KXthbGFybS5pZD1pZDujKGFsYXJtLmRvd4u3KWFsYXJtLmRvdz3UfzujKGFsYXJtLm9ujbUpYWxhcm0ub249tDujKGFsYXJtLnRpbWVyKXtleHBvcnRzLnJlc2V0VGltZXIoYWxhcm0pO31hbGFybXMucHVzaChhbGFybSk7fWV4cG9ydHMuc2V0QWxhcm1zKGFsYXJtcyk7fTsKZXhwb3J0cy5yZXNldFRpbWVyPaooYWxhcm0sdGltZSl7dGltZT10aW1loLhEYXRlKCk7rGN1cnJlbnRUaW1lPSh0aW1lLmdldEhvdXJzKCkqMzYwMDAwMCkrKHRpbWUuZ2V0TWludXRlcygpKjYwMDAwKSsodGltZS5nZXRTZWNvbmRzKCkq1egDKTthbGFybS50PShjdXJyZW50VGltZSthbGFybS50aW1lciklODY0MDAwMDA7YWxhcm0ubGFzdD3RBXRpbWVyuWFsYXJtoGFsYXJtLnSRcmVxdWlyZSjRCnRpbWVfdXRpbHMpLmdldEN1cnJlbnRUaW1lTWlsbGlzKCk/0zq4RGF0ZSgpLmdldERhdGUoKTt9OwpleHBvcnRzLmdldFRpbWVUb0FsYXJtPaooYWxhcm0sdGltZSl7oyghYWxhcm0pq7c7oyghdGltZSl0aW1lPbhEYXRlKCk7rGN1cnJlbnRUaW1lPSh0aW1lLmdldEhvdXJzKCkqMzYwMDAwMCkrKHRpbWUuZ2V0TWludXRlcygpKjYwMDAwKSsodGltZS5nZXRTZWNvbmRzKCkq1egDKTusYWN0aXZlPWFsYXJtLm9unihhbGFybS5kb3eSKCh0aW1lLmdldERheSgpKyhhbGFybS50PGN1cnJlbnRUaW1lKSkl1AcpKSbUAZ4oIWFsYXJtLmRhdGWgYWxhcm0uZGF0ZYp0aW1lLnRvTG9jYWxJU09TdHJpbmcoKS5zdWJzdHIo0yzUCikpO6MoIWFjdGl2ZSmrtzusdD1hbGFybS50LWN1cnJlbnRUaW1lO6MoYWxhcm0ubGFzdIp0aW1lLmdldERhdGUoKaB0PC02MDAwMCl0ljg2NDAwMDAwO6t0O307CmV4cG9ydHMucmVsb2FkPaooKXtldmFsKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKNENc2NoZWQuYm9vdC5qcykpO0JhbmdsZS5lbWl0KNELYWxhcm1SZWxvYWQpO307CmV4cG9ydHMubmV3RGVmYXVsdEFsYXJtPaooKXuuc2V0dGluZ3M9ZXhwb3J0cy5nZXRTZXR0aW5ncygpO6xhbGFybT17dDrUDCozNjAwMDAwLGRlbDq1LG9uOrQscnA6tSxhczpzZXR0aW5ncy5kZWZhdWx0QXV0b1Nub296ZSxkb3c61H8sbGFzdDrTLHZpYnJhdGU6c2V0dGluZ3MuZGVmYXVsdEFsYXJtUGF0dGVybix9O75zZXR0aW5nczurYWxhcm07fQpleHBvcnRzLm5ld0RlZmF1bHRUaW1lcj2qKCl7rnNldHRpbmdzPWV4cG9ydHMuZ2V0U2V0dGluZ3MoKTusdGltZXI9e3RpbWVyOtQFKtQ8KtXoAyxkZWw6c2V0dGluZ3MuZGVmYXVsdERlbGV0ZUV4cGlyZWRUaW1lcnMsb246tCxycDq1LGFzOrUsZG93OtR/LGxhc3Q60yx2aWJyYXRlOnNldHRpbmdzLmRlZmF1bHRUaW1lclBhdHRlcm59vnNldHRpbmdzO6t0aW1lcjt9OwpleHBvcnRzLmdldFNldHRpbmdzPaooKXurT2JqZWN0LmFzc2lnbih7dW5sb2NrQXRCdXp6OrQsZGVmYXVsdFNub296ZU1pbGxpczo2MDAwMDAsZGVmYXVsdEF1dG9Tbm9vemU6tSxkZWZhdWx0RGVsZXRlRXhwaXJlZFRpbWVyczq0LGJ1enpDb3VudDrUCixidXp6SW50ZXJ2YWxNaWxsaXM61bgLLGRlZmF1bHRBbGFybVBhdHRlcm460QI9PSxkZWZhdWx0VGltZXJQYXR0ZXJuOtECPT19LHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRE3NjaGVkLnNldHRpbmdzLmpzb24stCmge30pO30KZXhwb3J0cy5zZXRTZXR0aW5ncz2qKHNldHRpbmdzKXtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGVKU09OKNETc2NoZWQuc2V0dGluZ3MuanNvbixzZXR0aW5ncyk7fTv//zQIAABzY2hlZC5zZXR0aW5ncy5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 123224, "TW9kdWxlcy5hZGRDYWNoZWQo0QRidXp6LKooKXtleHBvcnRzLnBhdHRlcm49Y6K4UHJvbWlzZShkonuqYSgpe6MoIiKKYymrZCgpO6xiPWNb0107Yz1jLnN1YnN0cijUASk70QEuimI/QmFuZ2xlLmJ1enoo1GQsLjI1KS50aGVuKCgponNldFRpbWVvdXQoYSzUZCkpOtEBLIpiP0JhbmdsZS5idXp6KNXIACwuMjUpLnRoZW4oKCmic2V0VGltZW91dChhLNRkKSk60QEtimI/QmFuZ2xlLmJ1enoo1fQBLC4yNSkudGhlbigoKaJzZXRUaW1lb3V0KGEs1GQpKTrRATqKYj9CYW5nbGUuYnV6eijUZCzUASkudGhlbigoKaJzZXRUaW1lb3V0KGEs1GQpKTrRATuKYj9CYW5nbGUuYnV6eijVyAAs1AEpLnRoZW4oKCmic2V0VGltZW91dChhLNRkKSk60QE9imI/QmFuZ2xlLmJ1enoo1fQBLNQBKS50aGVuKCgponNldFRpbWVvdXQoYSzUZCkpOnNldFRpbWVvdXQoYSzUZCl9YSgpfSl9KTsKTW9kdWxlcy5hZGRDYWNoZWQo0QlidXp6X21lbnUsqigpe2V4cG9ydHMucGF0dGVybj2qKGMsZCl7rGE90TIgLiA6IC4uIDo6ICwgOyAsLCA7OyAtID0gLS0gPT0gLi4uIDo6OiAtLS0gOzs7ID09PS5zcGxpdCjRASApO6t7dmFsdWU6TWF0aC5tYXgo0yxhLmluZGV4T2YoYykpLG1pbjrTLG1heDphLmxlbmd0aC3UASxmb3JtYXQ6YqJhW2JdoNEDT2ZmLG9uY2hhbmdlOmKie3JlcXVpcmUo0QRidXp6KS5wYXR0ZXJuKGFbYl0pO2QoYVtiXSl9fX19KTsoqihiYWNrKXutc2V0dGluZ3M9cmVxdWlyZSjRBXNjaGVkKS5nZXRTZXR0aW5ncygpO0Uuc2hvd01lbnUoeyIiOnvRBXRpdGxlOtEJU2NoZWR1bGVyfSzRBjwgQmFjazooKaJiYWNrKCks0Q5VbmxvY2sgYXQgQnV6ejp7dmFsdWU6c2V0dGluZ3MudW5sb2NrQXRCdXp6LG9uY2hhbmdlOnaie3NldHRpbmdzLnVubG9ja0F0QnV6ej12O3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO319LNEVRGVsZXRlIEV4cGlyZWQgVGltZXJzOnt2YWx1ZTpzZXR0aW5ncy5kZWZhdWx0RGVsZXRlRXhwaXJlZFRpbWVycyxvbmNoYW5nZTp2ontzZXR0aW5ncy5kZWZhdWx0RGVsZXRlRXhwaXJlZFRpbWVycz12O3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO319LNETRGVmYXVsdCBBdXRvIFNub296ZTp7dmFsdWU6c2V0dGluZ3MuZGVmYXVsdEF1dG9Tbm9vemUsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuZGVmYXVsdEF1dG9Tbm9vemU9djtyZXF1aXJlKNEFc2NoZWQpLnNldFNldHRpbmdzKHNldHRpbmdzKTt9fSzRDkRlZmF1bHQgU25vb3plOnt2YWx1ZTpzZXR0aW5ncy5kZWZhdWx0U25vb3plTWlsbGlzLzYwMDAwLG1pbjrUBSxtYXg61B4sc3RlcDrUBSxmb3JtYXQ6dqJ2K9EBbSxvbmNoYW5nZTp2ontzZXR0aW5ncy5kZWZhdWx0U25vb3plTWlsbGlzPXYqNjAwMDA7cmVxdWlyZSjRBXNjaGVkKS5zZXRTZXR0aW5ncyhzZXR0aW5ncyk7fX0s0QpCdXp6IENvdW50Ont2YWx1ZTpzZXR0aW5ncy5idXp6Q291bnSKtj/UBDpzZXR0aW5ncy5idXp6Q291bnQsbWluOtQELG1heDrUDyxzdGVwOtQBLGZvcm1hdDp2onaL1AQ/0QdGb3JldmVyOnYsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYnV6ekNvdW50PXaL1AQ/tjp2O3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO319LNENQnV6eiBJbnRlcnZhbDp7dmFsdWU6c2V0dGluZ3MuYnV6ekludGVydmFsTWlsbGlzL9XoAyxtaW461AEsbWF4OtQFLHN0ZXA61AEsZm9ybWF0OnaidivRAXMsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYnV6ekludGVydmFsTWlsbGlzPXYq1egDO3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO319LNEVRGVmYXVsdCBBbGFybSBQYXR0ZXJuOnJlcXVpcmUo0QlidXp6X21lbnUpLnBhdHRlcm4oc2V0dGluZ3MuZGVmYXVsdEFsYXJtUGF0dGVybix2ontzZXR0aW5ncy5kZWZhdWx0QWxhcm1QYXR0ZXJuPXY7cmVxdWlyZSjRBXNjaGVkKS5zZXRTZXR0aW5ncyhzZXR0aW5ncyk7fSks0RVEZWZhdWx0IFRpbWVyIFBhdHRlcm46cmVxdWlyZSjRCWJ1enpfbWVudSkucGF0dGVybihzZXR0aW5ncy5kZWZhdWx0VGltZXJQYXR0ZXJuLHaie3NldHRpbmdzLmRlZmF1bHRUaW1lclBhdHRlcm49djtyZXF1aXJlKNEFc2NoZWQpLnNldFNldHRpbmdzKHNldHRpbmdzKTt9KX0pO30pSw0AAHNjaGVkLmNsa2luZm8uanM=");
  base64DecodeToExistingUint8Array(bufferView, 125356, "TW9kdWxlcy5hZGRDYWNoZWQo0Qp0aW1lX3V0aWxzLKooKXuqZChhKXure2Q6YS5koNMsaDphLmig0yxtOmEubaDTLHM6YS5zoNN9fWV4cG9ydHMuZW5jb2RlVGltZT1honthPWQoYSk7qzg2NEU1KmEuZCszNkU1KmEuaCs2RTQqYS5tK9XoAyphLnN9O2V4cG9ydHMuZGVjb2RlVGltZT1honujKNEGbnVtYmVyjb9hKbDRHE9ubHkgYSBudW1iZXIgY2FuIGJlIGRlY29kZWQ7rGM9TWF0aC5mbG9vcihhLzg2NEU1KTthlzg2NEU1KmM7rGI9TWF0aC5mbG9vcihhLzM2RTUpO2GXMzZFNSpiO6xlPU1hdGguZmxvb3IoYS82RTQpO6t7ZDpjLGg6YixtOmUsczpNYXRoLmZsb29yKChhLTZFNCplKS/V6AMpfX07ZXhwb3J0cy5mb3JtYXRUaW1lPWGie2E9ZCjRBm9iamVjdIu/YT9hOmV4cG9ydHMuZGVjb2RlVGltZShhKSk7YS5oltQYKmEuZDurYS5oK9EBOiso0QEwK2EubSkuc3Vic3RyKNT+KX07ZXhwb3J0cy5mb3JtYXREdXJhdGlvbj0oYSxjKaJ7Yz1joCHUATusYj0iIjthPWQo0QZvYmplY3SLv2E/YTpleHBvcnRzLmRlY29kZVRpbWUoYSkpO9M8YS5knihilmEuZCvRAmQgKTvTPGEuaJ4oYpZhLmgr0QJoICk70zxhLm2eKGKWYS5tK9ECbSApO9M8YS5znihilmEucyvRAXMpO2I9Yi50cmltKCk7q2M/Yi5yZXBsYWNlKNEBICwiIik6Yn07ZXhwb3J0cy5nZXRDdXJyZW50VGltZU1pbGxpcz0oKaJ7rGE9uERhdGU7q9XoAyoo1RAOKmEuZ2V0SG91cnMoKSvUPCphLmdldE1pbnV0ZXMoKSthLmdldFNlY29uZHMoKSl9fSk7KKooKXuqZ2V0QWxhcm1WYWx1ZShhKXutbWluPU1hdGgucm91bmQocmVxdWlyZSjRBXNjaGVkKS5nZXRUaW1lVG9BbGFybShhKS8o1Dwq1egDKSk7oyghbWluKavTO6tnZXRBbGFybU1heChhKS1taW47fapnZXRBbGFybU1heChhKXujKGEudGltZXIpq01hdGgucm91bmQoYS50aW1lci8o1Dwq1egDKSk7q9WgBTt9qmdldEFsYXJtSWNvbihhKXujKGEub24pe6MoYS50aW1lcimr0UwYGIE=");
  base64DecodeToExistingUint8Array(bufferView, 126325, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOcAAMMAAYGAAYGAAYGAB//gB//g");
  base64DecodeToExistingUint8Array(bufferView, 126388, "O6MoYS5kYXRlKavRTBgYgQ==");
  base64DecodeToExistingUint8Array(bufferView, 126414, "D//wH//4GAAYGAAYGAAYH//4H//4H//4H/74H/z4H/n4HzP4H4f4H8/4H//4H//4H//4D//w");
  base64DecodeToExistingUint8Array(bufferView, 126477, "O6vRTBgYgQAAAAAAAAAGAGAOAHAcfjg5/5wD/8AH/+AP5/AP5/Af5/gf5/gf5/gf5/gf4fgf+PgP/vAP//AH/+AD/8AB/4AAfgAAAAAAAAA7faR7oyhhLnRpbWVyKavRTBgYgQ==");
  base64DecodeToExistingUint8Array(bufferView, 126587, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOR4AMH+AYG2AYMDAYOHB/OHB/MDAAG2AAH+AAB4O6MoYS5kYXRlKavRSxgYAQ==");
  base64DecodeToExistingUint8Array(bufferView, 126675, "D//wH//4GAAYGAAYGAAYH//4H//4H//4H/74H/wAH/gAHzB4H4H+H8m2H/MDH/OHH/OHD/MDAAG2AAH+AAB4O6vRTBgYgQAAAAAAAAAGAGAOAHAcfjg5/5wD/8AH/+AP5/AP5/Af5/gf5/gf5wAf5gAf4Hgf+f4P+bYP8wMH84cD84cB8wMAebYAAf4AAHg7fX2qZ2V0QWxhcm1UZXh0KGEpe6MoYS50aW1lcil7oyghYS5vbimr0QNvZmY7rXRpbWU9TWF0aC5yb3VuZChyZXF1aXJlKNEFc2NoZWQpLmdldFRpbWVUb0FsYXJtKGEpLyjUPCrV6AMpKTujKHRpbWU+1DwpdGltZT1NYXRoLnJvdW5kKHRpbWUv1DwpK9EBaDukdGltZZbRAW07q3RpbWU7faMoYS5kYXRlKXuuZD24RGF0ZShhLmRhdGUpO6tgJHtkLmdldERhdGUoKX0gJHtyZXF1aXJlKCJsb2NhbGUiKS5tb250aChkLCAxKX1gO32rcmVxdWlyZSjRCnRpbWVfdXRpbHMpLmZvcm1hdFRpbWUoYS50KTt9qmdldEFsYXJtT3JkZXIoYSl7rXZhbD1yZXF1aXJlKNEFc2NoZWQpLmdldFRpbWVUb0FsYXJtKGEpO6Mov3ZhbIrRCXVuZGVmaW5lZCmrODY0MDAq1egDO6t2YWw7fapnZXRSZWZyZXNoSW50ZXJ2YWxzKGEpe65taW51dGU91Dwq1egDO65oYWxmaG91cj3UHiptaW51dGU7rmhvdXI91AIqaGFsZmhvdXI7rW1zZWNzPXJlcXVpcmUo0QVzY2hlZCkuZ2V0VGltZVRvQWxhcm0oYSk7oyi/bXNlY3OK0Ql1bmRlZmluZWSgbXNlY3OK0ymrW107oyhtc2Vjcz5ob3VyKXutcmVtYWluPShtc2VjcyttaW51dGUpJWhhbGZob3VyO6MocmVtYWluPNQbKm1pbnV0ZZ5yZW1haW6M0ymrW2hhbGZob3VyLHJlbWFpbl07q1toYWxmaG91cixtc2Vjcy1ob3VyXTt9pHujKCFhLnRpbWVyKatbXTurW21pbnV0ZSxtc2Vjc107fX2qX2RvSW50ZXJ2YWwoaW50ZXJ2YWwpe6tzZXRUaW1lb3V0KCgponuvLmVtaXQo0QZyZWRyYXcpO68uaW50ZXJ2YWw9c2V0SW50ZXJ2YWwoKCmie68uZW1pdCjRBnJlZHJhdyk7fSxpbnRlcnZhbCk7fSxpbnRlcnZhbCk7fapfZG9Td2l0Y2hUaW1lb3V0KGEsc3dpdGNoVGltZW91dCl7q3NldFRpbWVvdXQoKCmie68uZW1pdCjRBnJlZHJhdyk7Y2xlYXJJbnRlcnZhbCivLmludGVydmFsKTuvLmludGVydmFsPbc7rHRtcD1nZXRSZWZyZXNoSW50ZXJ2YWxzKGEpO6xpbnRlcnZhbD10bXBb0107rHN3aXRjaFRpbWVvdXQ9dG1wW9QBXTujKCFpbnRlcnZhbCmrO68uaW50ZXJ2YWw9X2RvSW50ZXJ2YWwuY2FsbCivLGludGVydmFsKTuvLnN3aXRjaFRpbWVvdXQ9X2RvU3dpdGNoVGltZW91dC5jYWxsKK8sYSxzd2l0Y2hUaW1lb3V0KTt9LHN3aXRjaFRpbWVvdXQpO32sYWxsPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCnNjaGVkLmpzb24s1AEpoFtdO6xhbGFybUl0ZW1zPXtuYW1lOtEGQWxhcm1zLGltZzpnZXRBbGFybUljb24oe29uOtQBfSksZHluYW1pYzq0LGl0ZW1zOmFsbC5maWx0ZXIoYaIhYS5hcHBpZCkuc29ydCgoYSxiKaJnZXRBbGFybU9yZGVyKGEpLWdldEFsYXJtT3JkZXIoYikpLm1hcChhoih7bmFtZTq2LGhhc1JhbmdlOrQsZ2V0Oigpoih7dGV4dDpnZXRBbGFybVRleHQoYSksaW1nOmdldEFsYXJtSWNvbihhKSx2OmdldEFsYXJtVmFsdWUoYSksbWluOtMsbWF4OmdldEFsYXJtTWF4KGEpfSksc2hvdzqqKCl7rHRtcD1nZXRSZWZyZXNoSW50ZXJ2YWxzKGEpO6xpbnRlcnZhbD10bXBb0107rHN3aXRjaFRpbWVvdXQ9dG1wW9QBXTujKCFpbnRlcnZhbCmrO68uaW50ZXJ2YWw9X2RvSW50ZXJ2YWwuY2FsbCivLGludGVydmFsKTuvLnN3aXRjaFRpbWVvdXQ9X2RvU3dpdGNoVGltZW91dC5jYWxsKK8sYSxzd2l0Y2hUaW1lb3V0KTt9LGhpZGU6qigpe6Mory5pbnRlcnZhbCljbGVhckludGVydmFsKK8uaW50ZXJ2YWwpO6Mory5zd2l0Y2hUaW1lb3V0KWNsZWFyVGltZW91dCivLnN3aXRjaFRpbWVvdXQpO68uaW50ZXJ2YWw9tzuvLnN3aXRjaFRpbWVvdXQ9tzt9LHJ1bjqqKCl7oyhhLmRhdGUpqzuvLmhpZGUoKTthLm9uPSFhLm9uO2EubGFzdD3TO6MoYS5vbp5hLnRpbWVyKXJlcXVpcmUo0QVzY2hlZCkucmVzZXRUaW1lcihhKTuvLmVtaXQo0QZyZWRyYXcpO3JlcXVpcmUo0QVzY2hlZCkuc2V0QWxhcm1zKGFsbCk7cmVxdWlyZSjRBXNjaGVkKS5yZWxvYWQoKTuvLnNob3coKTt9fSkpLH07q2FsYXJtSXRlbXM7fSn/AgEAAHNjaGVkLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 128792, "eyJpZCI6InNjaGVkIiwibmFtZSI6IlNjaGVkdWxlciIsInR5cGUiOiJzY2hlZHVsZXIiLCJpY29uIjoic2NoZWQuaW1nIiwidmVyc2lvbiI6IjAuMzYiLCJ0YWdzIjoidG9vbCxzeXN0ZW0sYWxhcm0sY2xraW5mbyIsImZpbGVzIjoic2NoZWQuaW5mbyxzY2hlZC5ib290LmpzLHNjaGVkLmpzLHNjaGVkLmltZyxzY2hlZCxzY2hlZC5zZXR0aW5ncy5qcyxzY2hlZC5jbGtpbmZvLmpzIiwiZGF0YSI6InNjaGVkLmpzb24sc2NoZWQuc2V0dGluZ3MuanNvbiJ9//+jAQAAd2lkYWxhcm0ud2lkLmpz");
  base64DecodeToExistingUint8Array(bufferView, 129084, "V0lER0VUU1vRBWFsYXJtXT17YXJlYTrRAnRsLHdpZHRoOtMsZHJhdzqqKCl7oyivLndpZHRoKWcucmVzZXQoKS5kcmF3SW1hZ2Uo0UsYGAEAAAAAAAAAGAAOGHAMPDAY/xgZ/5gx/4wz/8wz/8wD/8AD/8AD/8AD/8AD/8AD/8AH/+AP//AP//AAAAAAPAAAGAAAAAAAAAAsry54LK8ueSk7fSxyZWxvYWQ6qigpe1dJREdFVFNb0QVhbGFybV0ud2lkdGg9KHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCnNjaGVkLmpzb24s1AEpoFtdKS5zb21lKGFsYXJtomFsYXJtLm9unihhbGFybS5oaWRkZW6NtCkpP9QYOtM7fX07V0lER0VUU1vRBWFsYXJtXS5yZWxvYWQoKTtCYW5nbGUub24o0QthbGFybVJlbG9hZCwoKaJ7oyhXSURHRVRTW9EFYWxhcm1dKXtXSURHRVRTW9EFYWxhcm1dLnJlbG9hZCgpO0JhbmdsZS5kcmF3V2lkZ2V0cygpO319KTv/jAAAAHdpZGFsYXJtLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 129536, "eyJpZCI6IndpZGFsYXJtIiwibmFtZSI6IkFsYXJtcyBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDIiLCJ0YWdzIjoidG9vbCxhbGFybSx3aWRnZXQiLCJmaWxlcyI6IndpZGFsYXJtLmluZm8sd2lkYWxhcm0ud2lkLmpzIn2XOAAAYWxhcm0uYXBwLmpz");
  base64DecodeToExistingUint8Array(bufferView, 129708, "TW9kdWxlcy5hZGRDYWNoZWQo0Qp0aW1lX3V0aWxzLKooKXuqZChhKXure2Q6YS5koNMsaDphLmig0yxtOmEubaDTLHM6YS5zoNN9fWV4cG9ydHMuZW5jb2RlVGltZT1honthPWQoYSk7qzg2NEU1KmEuZCszNkU1KmEuaCs2RTQqYS5tK9XoAyphLnN9O2V4cG9ydHMuZGVjb2RlVGltZT1honujKNEGbnVtYmVyjb9hKbDRHE9ubHkgYSBudW1iZXIgY2FuIGJlIGRlY29kZWQ7rGM9TWF0aC5mbG9vcihhLzg2NEU1KTthlzg2NEU1KmM7rGI9TWF0aC5mbG9vcihhLzM2RTUpO2GXMzZFNSpiO6xlPU1hdGguZmxvb3IoYS82RTQpO6t7ZDpjLGg6YixtOmUsczpNYXRoLmZsb29yKChhLTZFNCplKS/V6AMpfX07ZXhwb3J0cy5mb3JtYXRUaW1lPWGie2E9ZCjRBm9iamVjdIu/YT9hOmV4cG9ydHMuZGVjb2RlVGltZShhKSk7YS5oltQYKmEuZDurYS5oK9EBOiso0QEwK2EubSkuc3Vic3RyKNT+KX07ZXhwb3J0cy5mb3JtYXREdXJhdGlvbj0oYSxjKaJ7Yz1joCHUATusYj0iIjthPWQo0QZvYmplY3SLv2E/YTpleHBvcnRzLmRlY29kZVRpbWUoYSkpO9M8YS5knihilmEuZCvRAmQgKTvTPGEuaJ4oYpZhLmgr0QJoICk70zxhLm2eKGKWYS5tK9ECbSApO9M8YS5znihilmEucyvRAXMpO2I9Yi50cmltKCk7q2M/Yi5yZXBsYWNlKNEBICwiIik6Yn07ZXhwb3J0cy5nZXRDdXJyZW50VGltZU1pbGxpcz0oKaJ7rGE9uERhdGU7q9XoAyoo1RAOKmEuZ2V0SG91cnMoKSvUPCphLmdldE1pbnV0ZXMoKSthLmdldFNlY29uZHMoKSl9fSk7Ck1vZHVsZXMuYWRkQ2FjaGVkKNEKZGF0ZV91dGlscyyqKCl7ZXhwb3J0cy5kb3c9KGMsYSmie6xiPXJlcXVpcmUo0QZsb2NhbGUpLmRvdyh7Z2V0RGF5OigpoihjfNMpJdQHfSxhKS5zbGljZSjTLNQCimE/1AE61GQpO6vUAophP2IudG9VcHBlckNhc2UoKTpifTtleHBvcnRzLmRvd3M9KGMsYSmie6corGI9W10sZD3TO9QHPmQ7ZJgpYi5wdXNoKGV4cG9ydHMuZG93KGQrKGOg0yksYSkpO6vUAophP2IubWFwKGWiZS50b1VwcGVyQ2FzZSgpKTpifTtleHBvcnRzLm1vbnRoPShjLGEponusYj1yZXF1aXJlKNEGbG9jYWxlKS5tb250aCh7Z2V0TW9udGg6KCmiKNQLKyhjfNMpKSXUDH0sYSkuc2xpY2Uo0yzUAophP9QBOtRkKTur1AKKYT9iLnRvVXBwZXJDYXNlKCk6Yn07ZXhwb3J0cy5tb250aHM9Y6J7pyisYT1bXSxiPXJlcXVpcmUo0QZsb2NhbGUpLGQ90zvUDD5kO2SYKWEucHVzaChiLm1vbnRoKHtnZXRNb250aDooKaJkfSxjKS5zbGljZSjTLNQCimM/1AE61GQpKTur1AKKYz9hLm1hcChlomUudG9VcHBlckNhc2UoKSk6YX19KTsKTW9kdWxlcy5hZGRDYWNoZWQo0QRidXp6LKooKXtleHBvcnRzLnBhdHRlcm49Y6K4UHJvbWlzZShkonuqYSgpe6MoIiKKYymrZCgpO6xiPWNb0107Yz1jLnN1YnN0cijUASk70QEuimI/QmFuZ2xlLmJ1enoo1GQsLjI1KS50aGVuKCgponNldFRpbWVvdXQoYSzUZCkpOtEBLIpiP0JhbmdsZS5idXp6KNXIACwuMjUpLnRoZW4oKCmic2V0VGltZW91dChhLNRkKSk60QEtimI/QmFuZ2xlLmJ1enoo1fQBLC4yNSkudGhlbigoKaJzZXRUaW1lb3V0KGEs1GQpKTrRATqKYj9CYW5nbGUuYnV6eijUZCzUASkudGhlbigoKaJzZXRUaW1lb3V0KGEs1GQpKTrRATuKYj9CYW5nbGUuYnV6eijVyAAs1AEpLnRoZW4oKCmic2V0VGltZW91dChhLNRkKSk60QE9imI/QmFuZ2xlLmJ1enoo1fQBLNQBKS50aGVuKCgponNldFRpbWVvdXQoYSzUZCkpOnNldFRpbWVvdXQoYSzUZCl9YSgpfSl9KTsKTW9kdWxlcy5hZGRDYWNoZWQo0QlidXp6X21lbnUsqigpe2V4cG9ydHMucGF0dGVybj2qKGMsZCl7rGE90TIgLiA6IC4uIDo6ICwgOyAsLCA7OyAtID0gLS0gPT0gLi4uIDo6OiAtLS0gOzs7ID09PS5zcGxpdCjRASApO6t7dmFsdWU6TWF0aC5tYXgo0yxhLmluZGV4T2YoYykpLG1pbjrTLG1heDphLmxlbmd0aC3UASxmb3JtYXQ6YqJhW2JdoNEDT2ZmLG9uY2hhbmdlOmKie3JlcXVpcmUo0QRidXp6KS5wYXR0ZXJuKGFbYl0pO2QoYVtiXSl9fX19KTsKQmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwquc2V0dGluZ3M9T2JqZWN0LmFzc2lnbih7c2hvd0NvbmZpcm06tCxzaG93QXV0b1Nub296ZTq0LHNob3dIaWRkZW46tH0scmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEKYWxhcm0uanNvbizUASmge30pOwquZmlyc3REYXlPZldlZWs9KHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDHNldHRpbmcuanNvbiy0KaB7fSkuZmlyc3REYXlPZldlZWug0zsKrldPUktEQVlTPdQ+OwquV0VFS0VORD1maXJzdERheU9mV2Vlaz/VwAA61EE7Cq5FVkVSWV9EQVk9Zmlyc3REYXlPZldlZWs/1f4AOtR/OwquSU5URVJWQUxTPVvRA2RheSzRBHdlZWss0QVtb250aCzRBHllYXJdOwquSU5URVJWQUxfTEFCRUxTPVvRA0RheSzRBFdlZWss0QVNb250aCzRBFllYXJdOwquaWNvbkFsYXJtT2490QEAK9FMGBiBAAAAAAAAAAYAYA4AcBx+ODn/nAP/wAf/4A/n8A/n8B/n+B/n+B/n+B/n+B/h+B/4+A/+8A//8Af/4AP/wAH/gAB+AAAAAAAAADuuaWNvbkFsYXJtT2ZmPdEBACsoZy50aGVtZS5kYXJrP9FQGBjBAP////8AAAAAAAAGAGAOAHAcfjg5/5wD/8AH/+AP5/AP5/Af5/gf5/gf5wAf5gAf4Hgf+f4P+bYP8wMH84cD84cB8wMAebYAAf4AAHg60VAYGMEA//8AAAAAAAAAAAYAYA4AcBx+ODn/nAP/wAf/4A/n8A/n8B/n+B/n+B/nAB/mAB/geB/5/g/5tg/zAwfzhwPzhwHzAwB5tgAB/gAAeCk7rmljb25UaW1lck9uPdEBACsoZy50aGVtZS5kYXJrP9FQGBjBAP////8=");
  base64DecodeToExistingUint8Array(bufferView, 132434, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOcAAMMAAYGAAYGAAYGAB//gB//g");
  base64DecodeToExistingUint8Array(bufferView, 132497, "OtFQGBjBAP//");
  base64DecodeToExistingUint8Array(bufferView, 132517, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOcAAMMAAYGAAYGAAYGAB//gB//g");
  base64DecodeToExistingUint8Array(bufferView, 132580, "KTuuaWNvblRpbWVyT2ZmPdEBACsoZy50aGVtZS5kYXJrP9FQGBjBAP////8=");
  base64DecodeToExistingUint8Array(bufferView, 132633, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOR4AMH+AYG2AYMDAYOHB/OHB/MDAAG2AAH+AAB4OtFQGBjBAP//");
  base64DecodeToExistingUint8Array(bufferView, 132716, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOR4AMH+AYG2AYMDAYOHB/OHB/MDAAG2AAH+AAB4KTusYWxhcm1zPXJlcXVpcmUo0QVzY2hlZCkuZ2V0QWxhcm1zKCk7YWxhcm1zLmZvckVhY2goZaJlLnScODY0MDAwMDApO6poYW5kbGVGaXJzdERheU9mV2Vlayhkb3cpe6MoZmlyc3REYXlPZldlZWuK1AEpe6MoKGRvdybUASmK1AEpe2Rvd5bUfzt9pKMoKGRvdybVgAApitWAACl7ZG93l9R/O319q2Rvdzt9YWxhcm1zLmZpbHRlcihlomUudGltZXKLtykuZm9yRWFjaChhomEuZG93PWhhbmRsZUZpcnN0RGF5T2ZXZWVrKGEuZG93KSk7qmdldExhYmVsKGUpe65kYXRlU3RyPWdldERhdGVUZXh0KGUuZGF0ZSk7qyhlLnRpbWVyP3JlcXVpcmUo0Qp0aW1lX3V0aWxzKS5mb3JtYXREdXJhdGlvbihlLnRpbWVyKTooZGF0ZVN0cj9gJHtkYXRlU3RyfSR7ZS5ycD8iKiI6IiJ9ICR7cmVxdWlyZSgidGltZV91dGlscyIpLmZvcm1hdFRpbWUoZS50KX1gOnJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5mb3JtYXRUaW1lKGUudCkrKGUucnA/YCAke2RlY29kZVJlcGVhdChlKX1gOiIiKSkpKyhlLm1zZz9gICR7ZS5tc2d9YDoiIik7fapnZXREYXRlVGV4dChkKXurZJ4oc2V0dGluZ3MubWVudURhdGVGb3JtYXSL0QRtbWRkP2Quc3Vic3RyaW5nKGQuc3RhcnRzV2l0aCi4RGF0ZSgpLmdldEZ1bGxZZWFyKCkpP9QFOtMpOnJlcXVpcmUo0QZsb2NhbGUpLmRhdGUouERhdGUoZCks1AEpKTt9qnRyaW1MYWJlbChsYWJlbCxtYXhMZW5ndGgpe6Moc2V0dGluZ3Muc2hvd092ZXJmbG93KatsYWJlbDurKGxhYmVsLmxlbmd0aD5tYXhMZW5ndGg/bGFiZWwuc3Vic3RyaW5nKNMsbWF4TGVuZ3RoLdQDKSvRAy4uLjpsYWJlbC5zdWJzdHJpbmco0yxtYXhMZW5ndGgpKTt9qmZvcm1hdEFsYXJtUHJvcGVydHkobXNnKXujKHNldHRpbmdzLnNob3dPdmVyZmxvdymrbXNnO6MobXNnirYpe6ttc2c7faSjKG1zZy5sZW5ndGg+1Acpe6ttc2cuc3Vic3RyaW5nKNMs1AYpK9EDLi4uO32ke6ttc2cuc3Vic3RyaW5nKNMs1AcpO319qnNob3dNYWluTWVudShzY3JvbGwsZ3JvdXAsc2Nyb2xsYmFjayl7rm1lbnU9eyIiOnvRBXRpdGxlOmdyb3VwoNEPQWxhcm1zICYgVGltZXJzLHNjcm9sbDpzY3JvbGx9LNEGPCBCYWNrOigpomdyb3VwP3Nob3dNYWluTWVudShzY3JvbGxiYWNrKTpsb2FkKCks0QZOZXcuLi46KCmic2hvd05ld01lbnUoZ3JvdXApfTuuZ2V0R3JvdXBzPXNldHRpbmdzLnNob3dHcm91cJ4hZ3JvdXA7rmdyb3Vwcz1nZXRHcm91cHM/e306tzuuZ2V0SWNvbj0oZSmie6tlLm9uPyhlLnRpbWVyP2ljb25UaW1lck9uOmljb25BbGFybU9uKTooZS50aW1lcj9pY29uVGltZXJPZmY6aWNvbkFsYXJtT2ZmKTt9O2FsYXJtcy5mb3JFYWNoKChlLGluZGV4KaJ7rnNob3dBbGFybT0hc2V0dGluZ3Muc2hvd0dyb3VwoChncm91cD9lLmdyb3Vwi2dyb3VwOiFlLmdyb3VwKTujKHNob3dBbGFybSl7rmxhYmVsPXRyaW1MYWJlbChnZXRMYWJlbChlKSzUKCk7bWVudVtsYWJlbF09e3ZhbHVlOmUub24sb25jaGFuZ2U6KHYsdG91Y2gponujKHRvdWNonijUAop0b3VjaC50eXBloNWRADx0b3VjaC54KSl7ZS5vbj12O6MoZS5vbilwcmVwYXJlRm9yU2F2ZShlLGluZGV4KTtzYXZlQW5kUmVsb2FkKCk7faR7c2V0VGltZW91dChlLnRpbWVyP3Nob3dFZGl0VGltZXJNZW51OnNob3dFZGl0QWxhcm1NZW51LNQKLGUsaW5kZXgstyxzY3JvbGxlcj9zY3JvbGxlci5zY3JvbGw6tyxncm91cCk7fX0sZm9ybWF0OnaiZ2V0SWNvbihlKX07faSjKGdldEdyb3Vwcyl7Z3JvdXBzW2UuZ3JvdXBdPbc7fX0pO6MoIWdyb3VwKXtPYmplY3Qua2V5cyhncm91cHMpLnNvcnQoKS5mb3JFYWNoKGeibWVudVtnXT0oKaJzaG93TWFpbk1lbnUotixnLHNjcm9sbGVyP3Njcm9sbGVyLnNjcm9sbDq3KSk7bWVudVvRCEFkdmFuY2VkXT0oKaJzaG93QWR2YW5jZWRNZW51KCk7faxzY3JvbGxlcj1FLnNob3dNZW51KG1lbnUpLnNjcm9sbGVyO32qc2hvd05ld01lbnUoZ3JvdXApe65uZXdNZW51PXsiIjp70QV0aXRsZTrRBk5ldy4uLn0s0QY8IEJhY2s6KCmic2hvd01haW5NZW51KGdyb3VwKSzRBUFsYXJtOigponNob3dFZGl0QWxhcm1NZW51KLcstyy1LLYsZ3JvdXApLNEFVGltZXI6KCmic2hvd0VkaXRUaW1lck1lbnUotyy3KSzRBUV2ZW50OigponNob3dFZGl0QWxhcm1NZW51KLcstyy0LLYsZ3JvdXApfTujKGdyb3VwKb5uZXdNZW51W9EFVGltZXJdO0Uuc2hvd01lbnUobmV3TWVudSk7fapzaG93RWRpdEFsYXJtTWVudShzZWxlY3RlZEFsYXJtLGFsYXJtSW5kZXgsd2l0aERhdGUsc2Nyb2xsLGdyb3VwKXusaXNOZXc9YWxhcm1JbmRleIu3O6xhbGFybT1yZXF1aXJlKNEFc2NoZWQpLm5ld0RlZmF1bHRBbGFybSgpO6MoaXNOZXeeZ3JvdXApYWxhcm0uZ3JvdXA9Z3JvdXA7oyh3aXRoRGF0ZaAoc2VsZWN0ZWRBbGFybZ5zZWxlY3RlZEFsYXJtLmRhdGUpKXthbGFybS5kZWw9cmVxdWlyZSjRBXNjaGVkKS5nZXRTZXR0aW5ncygpLmRlZmF1bHREZWxldGVFeHBpcmVkVGltZXJzO31hbGFybS5kb3c9aGFuZGxlRmlyc3REYXlPZldlZWsoYWxhcm0uZG93KTujKHNlbGVjdGVkQWxhcm0pe09iamVjdC5hc3NpZ24oYWxhcm0sc2VsZWN0ZWRBbGFybSk7fax0aW1lPXJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5kZWNvZGVUaW1lKGFsYXJtLnQpO6Mod2l0aERhdGWeIWFsYXJtLmRhdGUpYWxhcm0uZGF0ZT24RGF0ZSgpLnRvTG9jYWxJU09TdHJpbmcoKS5zbGljZSjTLNQKKTusZGF0ZT1hbGFybS5kYXRlP7hEYXRlKGFsYXJtLmRhdGUpOrc7rHRpdGxlPWRhdGU/KGlzTmV3P9EJTmV3IEV2ZW50OtEKRWRpdCBFdmVudCk6KGlzTmV3P9EJTmV3IEFsYXJtOtEKRWRpdCBBbGFybSk7rGtleWJvYXJkPdEJdGV4dGlucHV0O7F7a2V5Ym9hcmQ9cmVxdWlyZShrZXlib2FyZCk7fWNhdGNoKGUpe2tleWJvYXJkPbY7faxkYXRldGltZWlucHV0O7F7ZGF0ZXRpbWVpbnB1dD1yZXF1aXJlKNENZGF0ZXRpbWVpbnB1dCk7fWNhdGNoKGUpe2RhdGV0aW1laW5wdXQ9tjt9rm1lbnU9eyIiOnvRBXRpdGxlOnRpdGxlfSzRBjwgQmFjazooKaJ7cHJlcGFyZUFsYXJtRm9yU2F2ZShhbGFybSxhbGFybUluZGV4LHRpbWUsZGF0ZSk7c2F2ZUFuZFJlbG9hZCgpO3Nob3dNYWluTWVudShzY3JvbGwsZ3JvdXApO319O6MoYWxhcm0uZGF0ZZ5kYXRldGltZWlucHV0KXttZW51W2Ake2dldERhdGVUZXh0KGRhdGUudG9Mb2NhbElTT1N0cmluZygpLnNsaWNlKDAsMTApKX0gJHtyZXF1aXJlKCJ0aW1lX3V0aWxzIikuZm9ybWF0VGltZSh0aW1lKX1gXT17dmFsdWU6ZGF0ZSxmb3JtYXQ6dqIiIixvbmNoYW5nZTp2ontzZXRUaW1lb3V0KCgponusZGF0ZXRpbWU9uERhdGUodi5nZXRUaW1lKCkpO2RhdGV0aW1lLnNldEhvdXJzKHRpbWUuaCx0aW1lLm0pO2RhdGV0aW1laW5wdXQuaW5wdXQoe2RhdGV0aW1lfSkudGhlbihyZXN1bHSie3RpbWUuaD1yZXN1bHQuZ2V0SG91cnMoKTt0aW1lLm09cmVzdWx0LmdldE1pbnV0ZXMoKTtwcmVwYXJlQWxhcm1Gb3JTYXZlKGFsYXJtLGFsYXJtSW5kZXgsdGltZSxyZXN1bHQstCk7c2V0VGltZW91dChzaG93RWRpdEFsYXJtTWVudSzUCixhbGFybSxhbGFybUluZGV4LHdpdGhEYXRlLHNjcm9sbCxncm91cCk7fSk7fSzUZCk7fX07faR7T2JqZWN0LmFzc2lnbihtZW51LHvRBEhvdXI6e3ZhbHVlOnRpbWUuaCxmb3JtYXQ6dqIo0QEwK3YpLnN1YnN0cijU/iksbWluOtMsbWF4OtQXLHdyYXA6tCxvbmNoYW5nZTp2onRpbWUuaD12fSzRBk1pbnV0ZTp7dmFsdWU6dGltZS5tLGZvcm1hdDp2oijRATArdikuc3Vic3RyKNT+KSxtaW460yxtYXg61Dssd3JhcDq0LG9uY2hhbmdlOnaidGltZS5tPXZ9LNEDRGF5Ont2YWx1ZTpkYXRlP2RhdGUuZ2V0RGF0ZSgpOrYsbWluOtQBLG1heDrUHyx3cmFwOrQsb25jaGFuZ2U6dqJkYXRlLnNldERhdGUodil9LNEFTW9udGg6e3ZhbHVlOmRhdGU/ZGF0ZS5nZXRNb250aCgpK9QBOrYsZm9ybWF0OnaicmVxdWlyZSjRCmRhdGVfdXRpbHMpLm1vbnRoKHYpLG9uY2hhbmdlOnaiZGF0ZS5zZXRNb250aCgodivUCykl1AwpfSzRBFllYXI6e3ZhbHVlOmRhdGU/ZGF0ZS5nZXRGdWxsWWVhcigpOrYsbWluOrhEYXRlKCkuZ2V0RnVsbFllYXIoKSxtYXg61TQILG9uY2hhbmdlOnaiZGF0ZS5zZXRGdWxsWWVhcih2KX19KTt9T2JqZWN0LmFzc2lnbihtZW51LHvRB01lc3NhZ2U6e3ZhbHVlOmFsYXJtLm1zZyxmb3JtYXQ6Zm9ybWF0QWxhcm1Qcm9wZXJ0eSxvbmNoYW5nZTooKaJ7c2V0VGltZW91dCgoKaJ7a2V5Ym9hcmQuaW5wdXQoe3RleHQ6YWxhcm0ubXNnfSkudGhlbihyZXN1bHSie2FsYXJtLm1zZz1yZXN1bHQ7cHJlcGFyZUFsYXJtRm9yU2F2ZShhbGFybSxhbGFybUluZGV4LHRpbWUsZGF0ZSy0KTtzZXRUaW1lb3V0KHNob3dFZGl0QWxhcm1NZW51LNQKLGFsYXJtLGFsYXJtSW5kZXgsd2l0aERhdGUsc2Nyb2xsLGdyb3VwKTt9KTt9LNRkKTt9fSzRBUdyb3VwOnt2YWx1ZTphbGFybS5ncm91cCxmb3JtYXQ6Zm9ybWF0QWxhcm1Qcm9wZXJ0eSxvbmNoYW5nZTooKaJ7c2V0VGltZW91dCgoKaJ7a2V5Ym9hcmQuaW5wdXQoe3RleHQ6YWxhcm0uZ3JvdXB9KS50aGVuKHJlc3VsdKJ7YWxhcm0uZ3JvdXA9cmVzdWx0O3ByZXBhcmVBbGFybUZvclNhdmUoYWxhcm0sYWxhcm1JbmRleCx0aW1lLGRhdGUstCk7c2V0VGltZW91dChzaG93RWRpdEFsYXJtTWVudSzUCixhbGFybSxhbGFybUluZGV4LHdpdGhEYXRlLHNjcm9sbCxncm91cCk7fSk7fSzUZCk7fX0s0QdFbmFibGVkOnt2YWx1ZTphbGFybS5vbixvbmNoYW5nZTp2omFsYXJtLm9uPXZ9LNEGUmVwZWF0Ont2YWx1ZTpkZWNvZGVSZXBlYXQoYWxhcm0pLG9uY2hhbmdlOigponNldFRpbWVvdXQoc2hvd0VkaXRSZXBlYXRNZW51LNRkLGFsYXJtLnJwLGRhdGWgYWxhcm0uZG93LChyZXBlYXQsZG93KaJ7oyhyZXBlYXQpe2FsYXJtLmRlbD21O31hbGFybS5ycD1yZXBlYXQ7YWxhcm0uZG93PWRvdztwcmVwYXJlQWxhcm1Gb3JTYXZlKGFsYXJtLGFsYXJtSW5kZXgsdGltZSxkYXRlLLQpO3NldFRpbWVvdXQoc2hvd0VkaXRBbGFybU1lbnUs1AosYWxhcm0sYWxhcm1JbmRleCx3aXRoRGF0ZSxzY3JvbGwsZ3JvdXApO30pfSzRB1ZpYnJhdGU6cmVxdWlyZSjRCWJ1enpfbWVudSkucGF0dGVybihhbGFybS52aWJyYXRlLHaiYWxhcm0udmlicmF0ZT12KSzRC0F1dG8gU25vb3plOnt2YWx1ZTphbGFybS5hcyxvbmNoYW5nZTp2omFsYXJtLmFzPXZ9LNEXRGVsZXRlIEFmdGVyIEV4cGlyYXRpb246e3ZhbHVlOmFsYXJtLmRlbCxvbmNoYW5nZTp2omFsYXJtLmRlbD12fSzRBkhpZGRlbjp7dmFsdWU6YWxhcm0uaGlkZGVuoLUsb25jaGFuZ2U6dqJhbGFybS5oaWRkZW49dn0s0QZDYW5jZWw6KCmic2hvd01haW5NZW51KHNjcm9sbCxncm91cCks0QdDb25maXJtOigpontwcmVwYXJlQWxhcm1Gb3JTYXZlKGFsYXJtLGFsYXJtSW5kZXgsdGltZSxkYXRlKTtzYXZlQW5kUmVsb2FkKCk7c2hvd01haW5NZW51KHNjcm9sbCxncm91cCk7fX0pO6MoIWtleWJvYXJkKb5tZW51W9EHTWVzc2FnZV07oygha2V5Ym9hcmSgIXNldHRpbmdzLnNob3dHcm91cCm+bWVudVvRBUdyb3VwXTujKCFzZXR0aW5ncy5zaG93Q29uZmlybSm+bWVudVvRB0NvbmZpcm1dO6MoIXNldHRpbmdzLnNob3dBdXRvU25vb3plKb5tZW51W9ELQXV0byBTbm9vemVdO6MoIXNldHRpbmdzLnNob3dIaWRkZW4pvm1lbnVb0QZIaWRkZW5dO6MoIWFsYXJtLmRhdGUpe75tZW51W9EDRGF5XTu+bWVudVvRBU1vbnRoXTu+bWVudVvRBFllYXJdO32jKCFpc05ldyl7bWVudVvRBkRlbGV0ZV09KCmie0Uuc2hvd1Byb21wdChnZXRMYWJlbChhbGFybSkr0QEKK9ENQXJlIHlvdSBzdXJlPyx7dGl0bGU60QxEZWxldGUgQWxhcm19KS50aGVuKChjb25maXJtKaJ7oyhjb25maXJtKXthbGFybXMuc3BsaWNlKGFsYXJtSW5kZXgs1AEpO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoc2Nyb2xsLGdyb3VwKTt9pHthbGFybS50PXJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5lbmNvZGVUaW1lKHRpbWUpO3NldFRpbWVvdXQoc2hvd0VkaXRBbGFybU1lbnUs1AosYWxhcm0sYWxhcm1JbmRleCx3aXRoRGF0ZSxzY3JvbGwsZ3JvdXApO319KTt9O31FLnNob3dNZW51KG1lbnUpO32qcHJlcGFyZUFsYXJtRm9yU2F2ZShhbGFybSxhbGFybUluZGV4LHRpbWUsZGF0ZSx0ZW1wKXthbGFybS50PXJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5lbmNvZGVUaW1lKHRpbWUpO2FsYXJtLmxhc3Q9YWxhcm0udDxyZXF1aXJlKNEKdGltZV91dGlscykuZ2V0Q3VycmVudFRpbWVNaWxsaXMoKT+4RGF0ZSgpLmdldERhdGUoKTrTO6MoZGF0ZSlhbGFybS5kYXRlPWRhdGUudG9Mb2NhbElTT1N0cmluZygpLnNsaWNlKNMs1AopO6MoIXRlbXApe6MoYWxhcm1JbmRleIu3KXthbGFybXMucHVzaChhbGFybSk7faR7YWxhcm1zW2FsYXJtSW5kZXhdPWFsYXJtO319fapwcmVwYXJlRm9yU2F2ZShhbGFybSxhbGFybUluZGV4KXujKGFsYXJtLnRpbWVyKXtwcmVwYXJlVGltZXJGb3JTYXZlKGFsYXJtLGFsYXJtSW5kZXgscmVxdWlyZSjRCnRpbWVfdXRpbHMpLmRlY29kZVRpbWUoYWxhcm0udGltZXIpKTt9pHtwcmVwYXJlQWxhcm1Gb3JTYXZlKGFsYXJtLGFsYXJtSW5kZXgscmVxdWlyZSjRCnRpbWVfdXRpbHMpLmRlY29kZVRpbWUoYWxhcm0udCkpO319qnNhdmVBbmRSZWxvYWQoKXthbGFybXMuZmlsdGVyKGWiZS50aW1lcou3KS5mb3JFYWNoKGGiYS5kb3c9aGFuZGxlRmlyc3REYXlPZldlZWsoYS5kb3cpKTtyZXF1aXJlKNEFc2NoZWQpLnNldEFsYXJtcyhhbGFybXMpO3JlcXVpcmUo0QVzY2hlZCkucmVsb2FkKCk7YWxhcm1zLmZpbHRlcihlomUudGltZXKLtykuZm9yRWFjaChhomEuZG93PWhhbmRsZUZpcnN0RGF5T2ZXZWVrKGEuZG93KSk7fapkZWNvZGVSZXBlYXQoYWxhcm0pe6thbGFybS5ycD8oYWxhcm0uZGF0ZT9gJHthbGFybS5ycC5udW19KiR7SU5URVJWQUxfTEFCRUxTW0lOVEVSVkFMUy5pbmRleE9mKGFsYXJtLnJwLmludGVydmFsKV19YDpyZXF1aXJlKNEKZGF0ZV91dGlscykuZG93cyhmaXJzdERheU9mV2VlayzUAikubWFwKChkYXksaW5kZXgpomFsYXJtLmRvdyYo1AGPKGluZGV4K2ZpcnN0RGF5T2ZXZWVrKSk/ZGF5OtEBXykuam9pbigiIikudG9Mb3dlckNhc2UoKSk60QRPbmNlO32qc2hvd0VkaXRSZXBlYXRNZW51KHJlcGVhdCxkYXksZG93Q2hhbmdlQ2FsbGJhY2spe6xkb3c7rm1lbnU9eyIiOnvRBXRpdGxlOtEMUmVwZWF0IEFsYXJtfSzRBjwgQmFjazooKaJkb3dDaGFuZ2VDYWxsYmFjayhyZXBlYXQsZG93KSzRCU9ubHkgT25jZTooKaJkb3dDaGFuZ2VDYWxsYmFjayi1LEVWRVJZX0RBWSl9O61yZXN0T2ZNZW51O6Mov2RheYvRBm51bWJlcil7ZG93PWRheTusb3JpZ2luYWxEb3c9ZG93O6xpc0N1c3RvbT1yZXBlYXSeZG93jFdPUktEQVlTnmRvd4xXRUVLRU5EnmRvd4xFVkVSWV9EQVk7cmVzdE9mTWVudT170QhXb3JrZGF5czp7dmFsdWU6cmVwZWF0nmRvd4pXT1JLREFZUyxvbmNoYW5nZTooKaJkb3dDaGFuZ2VDYWxsYmFjayi0LFdPUktEQVlTKX0s0QhXZWVrZW5kczp7dmFsdWU6cmVwZWF0nmRvd4pXRUVLRU5ELG9uY2hhbmdlOigpomRvd0NoYW5nZUNhbGxiYWNrKLQsV0VFS0VORCl9LNEJRXZlcnkgRGF5Ont2YWx1ZTpyZXBlYXSeZG93ikVWRVJZX0RBWSxvbmNoYW5nZTooKaJkb3dDaGFuZ2VDYWxsYmFjayi0LEVWRVJZX0RBWSl9LNEGQ3VzdG9tOnt2YWx1ZTppc0N1c3RvbT9kZWNvZGVSZXBlYXQoe3JwOrQsZG93OmRvd30pOrUsb25jaGFuZ2U6KCmic2V0VGltZW91dChzaG93Q3VzdG9tRGF5c01lbnUs1AosZG93LGRvd0NoYW5nZUNhbGxiYWNrLHJlcGVhdCxvcmlnaW5hbERvdyl9fTt9pHtkb3c9RVZFUllfREFZO65yZXBlYXRPYmo9cmVwZWF0oHtpbnRlcnZhbDrRBW1vbnRoLG51bTrUAX07cmVzdE9mTWVudT170QVFdmVyeTp7dmFsdWU6cmVwZWF0T2JqLm51bSxtaW461AEsb25jaGFuZ2U6dqJ7cmVwZWF0PXJlcGVhdE9iajtyZXBlYXQubnVtPXY7fX0s0QhJbnRlcnZhbDp7dmFsdWU6SU5URVJWQUxTLmluZGV4T2YocmVwZWF0T2JqLmludGVydmFsKSxmb3JtYXQ6dqJJTlRFUlZBTF9MQUJFTFNbdl0sbWluOtMsbWF4OklOVEVSVkFMUy5sZW5ndGgt1AEsb25jaGFuZ2U6dqJ7cmVwZWF0PXJlcGVhdE9iajtyZXBlYXQuaW50ZXJ2YWw9SU5URVJWQUxTW3ZdO319fTt9T2JqZWN0LmFzc2lnbihtZW51LHJlc3RPZk1lbnUpO0Uuc2hvd01lbnUobWVudSk7fapzaG93Q3VzdG9tRGF5c01lbnUoZG93LGRvd0NoYW5nZUNhbGxiYWNrLG9yaWdpbmFsUmVwZWF0LG9yaWdpbmFsRG93KXuubWVudT17IiI6e9EFdGl0bGU60QtDdXN0b20gRGF5c30s0QY8IEJhY2s6KCmie6xyZXBlYXQ9ZG93PtM7ZG93Q2hhbmdlQ2FsbGJhY2socmVwZWF0LHJlcGVhdD9kb3c6RVZFUllfREFZKTt9fTtyZXF1aXJlKNEKZGF0ZV91dGlscykuZG93cyhmaXJzdERheU9mV2VlaykuZm9yRWFjaCgoZGF5LGkponttZW51W2RheV09e3ZhbHVlOiEhKGRvdyYo1AGPKGkrZmlyc3REYXlPZldlZWspKSksb25jaGFuZ2U6dqJ2Pyhkb3ef1AGPKGkrZmlyc3REYXlPZldlZWspKTooZG93nX4o1AGPKGkrZmlyc3REYXlPZldlZWspKSl9O30pO21lbnVb0QZDYW5jZWxdPSgponNldFRpbWVvdXQoc2hvd0VkaXRSZXBlYXRNZW51LNQKLG9yaWdpbmFsUmVwZWF0LG9yaWdpbmFsRG93LGRvd0NoYW5nZUNhbGxiYWNrKTtFLnNob3dNZW51KG1lbnUpO32qc2hvd0VkaXRUaW1lck1lbnUoc2VsZWN0ZWRUaW1lcix0aW1lckluZGV4KXusaXNOZXc9dGltZXJJbmRleIu3O6x0aW1lcj1yZXF1aXJlKNEFc2NoZWQpLm5ld0RlZmF1bHRUaW1lcigpO6Moc2VsZWN0ZWRUaW1lcil7T2JqZWN0LmFzc2lnbih0aW1lcixzZWxlY3RlZFRpbWVyKTt9rHRpbWU9cmVxdWlyZSjRCnRpbWVfdXRpbHMpLmRlY29kZVRpbWUodGltZXIudGltZXIpO6xrZXlib2FyZD3RCXRleHRpbnB1dDuxe2tleWJvYXJkPXJlcXVpcmUoa2V5Ym9hcmQpO31jYXRjaChlKXtrZXlib2FyZD22O32ubWVudT17IiI6e9EFdGl0bGU6aXNOZXc/0QlOZXcgVGltZXI60QpFZGl0IFRpbWVyfSzRBjwgQmFjazooKaJ7cHJlcGFyZVRpbWVyRm9yU2F2ZSh0aW1lcix0aW1lckluZGV4LHRpbWUpO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoKTt9LNEFSG91cnM6e3ZhbHVlOnRpbWUuaCxtaW460yxtYXg61Bcsd3JhcDq0LG9uY2hhbmdlOnaidGltZS5oPXZ9LNEHTWludXRlczp7dmFsdWU6dGltZS5tLG1pbjrTLG1heDrUOyx3cmFwOrQsb25jaGFuZ2U6dqJ0aW1lLm09dn0s0QdTZWNvbmRzOnt2YWx1ZTp0aW1lLnMsbWluOtMsbWF4OtQ7LHN0ZXA61AEsd3JhcDq0LG9uY2hhbmdlOnaidGltZS5zPXZ9LNEHTWVzc2FnZTp7dmFsdWU6dGltZXIubXNnLGZvcm1hdDpmb3JtYXRBbGFybVByb3BlcnR5LG9uY2hhbmdlOigpontzZXRUaW1lb3V0KCgpontrZXlib2FyZC5pbnB1dCh7dGV4dDp0aW1lci5tc2d9KS50aGVuKHJlc3VsdKJ7dGltZXIubXNnPXJlc3VsdDtwcmVwYXJlVGltZXJGb3JTYXZlKHRpbWVyLHRpbWVySW5kZXgsdGltZSy0KTtzZXRUaW1lb3V0KHNob3dFZGl0VGltZXJNZW51LNQKLHRpbWVyLHRpbWVySW5kZXgpO30pO30s1GQpO319LNEHRW5hYmxlZDp7dmFsdWU6dGltZXIub24sb25jaGFuZ2U6dqJ0aW1lci5vbj12fSzRF0RlbGV0ZSBBZnRlciBFeHBpcmF0aW9uOnt2YWx1ZTp0aW1lci5kZWwsb25jaGFuZ2U6dqJ0aW1lci5kZWw9dn0s0QZIaWRkZW46e3ZhbHVlOnRpbWVyLmhpZGRlbqC1LG9uY2hhbmdlOnaidGltZXIuaGlkZGVuPXZ9LNEHVmlicmF0ZTpyZXF1aXJlKNEJYnV6el9tZW51KS5wYXR0ZXJuKHRpbWVyLnZpYnJhdGUsdqJ0aW1lci52aWJyYXRlPXYpLNEGQ2FuY2VsOigponNob3dNYWluTWVudSgpLNEHQ29uZmlybTooKaJ7cHJlcGFyZVRpbWVyRm9yU2F2ZSh0aW1lcix0aW1lckluZGV4LHRpbWUpO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoKTt9fTujKCFrZXlib2FyZCm+bWVudVvRB01lc3NhZ2VdO6MoIXNldHRpbmdzLnNob3dDb25maXJtKb5tZW51W9EHQ29uZmlybV07oyghc2V0dGluZ3Muc2hvd0hpZGRlbim+bWVudVvRBkhpZGRlbl07oyghaXNOZXcpe21lbnVb0QZEZWxldGVdPSgpontFLnNob3dQcm9tcHQoZ2V0TGFiZWwodGltZXIpK9EBCivRDUFyZSB5b3Ugc3VyZT8se3RpdGxlOtEMRGVsZXRlIFRpbWVyfSkudGhlbigoY29uZmlybSmie6MoY29uZmlybSl7YWxhcm1zLnNwbGljZSh0aW1lckluZGV4LNQBKTtzYXZlQW5kUmVsb2FkKCk7c2hvd01haW5NZW51KCk7faR7dGltZXIudGltZXI9cmVxdWlyZSjRCnRpbWVfdXRpbHMpLmVuY29kZVRpbWUodGltZSk7c2V0VGltZW91dChzaG93RWRpdFRpbWVyTWVudSzUCix0aW1lcix0aW1lckluZGV4KTt9fSk7fTt9RS5zaG93TWVudShtZW51KTt9qnByZXBhcmVUaW1lckZvclNhdmUodGltZXIsdGltZXJJbmRleCx0aW1lLHRlbXApe3RpbWVyLnRpbWVyPXJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5lbmNvZGVUaW1lKHRpbWUpO3RpbWVyLnQ9KHJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5nZXRDdXJyZW50VGltZU1pbGxpcygpK3RpbWVyLnRpbWVyKSU4NjQwMDAwMDt0aW1lci5sYXN0PdM7oyghdGVtcCl7oyh0aW1lckluZGV4i7cpe2FsYXJtcy5wdXNoKHRpbWVyKTt9pHthbGFybXNbdGltZXJJbmRleF09dGltZXI7fX19qnNob3dBZHZhbmNlZE1lbnUoKXtFLnNob3dNZW51KHsiIjp70QV0aXRsZTrRCEFkdmFuY2VkfSzRBjwgQmFjazooKaJzaG93TWFpbk1lbnUoKSzRElNjaGVkdWxlciBTZXR0aW5nczooKaJldmFsKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKNERc2NoZWQuc2V0dGluZ3MuanMpKSgoKaJzaG93QWR2YW5jZWRNZW51KCkpLNEKRW5hYmxlIEFsbDooKaJlbmFibGVBbGwotCks0QtEaXNhYmxlIEFsbDooKaJlbmFibGVBbGwotSks0QpEZWxldGUgQWxsOigpomRlbGV0ZUFsbCgpfSk7faplbmFibGVBbGwob24pe6MoYWxhcm1zLmZpbHRlcihlomUub26KIW9uKS5sZW5ndGiK0yl7RS5zaG93QWxlcnQob24/0RFOb3RoaW5nIHRvIEVuYWJsZTrREk5vdGhpbmcgdG8gRGlzYWJsZSxvbj/RCkVuYWJsZSBBbGw60QtEaXNhYmxlIEFsbCkudGhlbigoKaJzaG93QWR2YW5jZWRNZW51KCkpO32ke0Uuc2hvd1Byb21wdCjRDUFyZSB5b3Ugc3VyZT8se3RpdGxlOm9uP9EKRW5hYmxlIEFsbDrRC0Rpc2FibGUgQWxsfSkudGhlbigoY29uZmlybSmie6MoY29uZmlybSl7YWxhcm1zLmZvckVhY2goKGFsYXJtLGkponthbGFybS5vbj1vbjujKG9uKXByZXBhcmVGb3JTYXZlKGFsYXJtLGkpO30pO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoKTt9pHtzaG93QWR2YW5jZWRNZW51KCk7fX0pO319qmRlbGV0ZUFsbCgpe6MoYWxhcm1zLmxlbmd0aIrTKXtFLnNob3dBbGVydCjREU5vdGhpbmcgdG8gZGVsZXRlLNEKRGVsZXRlIEFsbCkudGhlbigoKaJzaG93QWR2YW5jZWRNZW51KCkpO32ke0Uuc2hvd1Byb21wdCjRDUFyZSB5b3Ugc3VyZT8se3RpdGxlOtEKRGVsZXRlIEFsbH0pLnRoZW4oKGNvbmZpcm0ponujKGNvbmZpcm0pe2FsYXJtcz1bXTtzYXZlQW5kUmVsb2FkKCk7c2hvd01haW5NZW51KCk7faR7c2hvd0FkdmFuY2VkTWVudSgpO319KTt9fXNob3dNYWluTWVudSgpO/+EBAAAYWxhcm0uaW1n");
  base64DecodeToExistingUint8Array(bufferView, 144228, "MDCEBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmERFmZmZmZmZmZmZmZmZmZmYRERFmZmZmERFmZmZmERERZmZmZmZmZhERERERZmZmERFmZmYREREREWZmZmZmYREREREWZmbMzMzMZmZhERERERZmZmZmERERERFmzMzMzMzMzMxmERERERFmZmZhERERERbMzMzMzMzMzMzMYREREREWZmZhERERERzMzMzMzMzMzMzMwREREREWZmYRERERFMzMzEQz//8zRMzMzEERERERZmYRERERTMzMQ////////zTMzMQRERERZmYREREUzMzD//////////88zMxBERERZmYRERFMzMQ/////8A/////zTMzEERERZmYRERHMzE//////8A//////9MzMERERZmYREWzMxP//////8A///////0zMxhERZmZhFszMw///////8A///////zzMzGEWZmZhZszMP///////8A////////PMzGYWZmZmbMzE////////8A////////9MzMZmZmZmbMzD////////8A////////88zMZmZmZmbMxP////////8A/////////0zMZmZmZmbMxP////////8A/////////0zMZmZmZmzMw/////////8A/////////zzMxmZmZmzMw/////////8A/////////zzMxmZmZmzMz/////////MAP/////////zMxmZmZmzMz/////////BVD/////////zMxmZmZmzMz/////////BVA/////////zMxmZmZmzMz////////zQAAD////////zMxmZmZmzMw///////80PzAAP//////zzMxmZmZmzMw///////ND//MAA//////zzMxmZmZmbMxP/////zQ///8wAD/////0zMZmZmZmbMxP////80P////zAAP////0zMZmZmZmbMzD////ND//////MC////88zMZmZmZmbMzE///zQ///////8/////9MzMZmZmZmZszMP/80P/////////////PMzGZmZmZmZszMw//z/////////////zzMzGZmZmZmZmzMxP///////////////0zMxmZmZmZmZmbMzE//////////////9MzMZmZmZmZmZmbMzMQ////////////zTMzMZmZmZmZmZmZszMzD//////////88zMzGZmZmZmZmZmZmzMzMQ////////zTMzMxmZmZmZmZmZmZmFMzMzEQz//8zRMzMzEFmZmZmZmZmZmZhERzMzMzMzMzMzMzMwREWZmZmZmZmZmYRERbMzMzMzMzMzMzMYRERZmZmZmZmZmEREWZmzMzMzMzMzMxmZhERFmZmZmZmZmERFmZmZmbMzMzMZmZmZmERFmZmZmZmZmERZmZmZmZmZmZmZmZmZmYRFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZhkEAABhbGFybS5zZXR0aW5ncy5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 145416, "KKooYmFjayl7rXNldHRpbmdzPU9iamVjdC5hc3NpZ24oe3Nob3dDb25maXJtOrQsc2hvd0F1dG9Tbm9vemU6tCxzaG93SGlkZGVuOrR9LHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCmFsYXJtLmpzb24s1AEpoHt9KTuuc2F2ZT0oKaJyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUo0QphbGFybS5qc29uLHNldHRpbmdzKTuuREFURV9GT1JNQVRTPVvRB2RlZmF1bHQs0QRtbWRkXTuuREFURV9GT1JNQVRTX0xBQkVMUz1b0QdEZWZhdWx0LNEETU1ERF07rmFwcE1lbnU9eycnOnt0aXRsZTrRBWFsYXJtfSzRBjwgQmFjazpiYWNrLNEQTWVudSBEYXRlIEZvcm1hdDp7dmFsdWU6REFURV9GT1JNQVRTLmluZGV4T2Yoc2V0dGluZ3MubWVudURhdGVGb3JtYXSg0QdkZWZhdWx0KSxmb3JtYXQ6dqJEQVRFX0ZPUk1BVFNfTEFCRUxTW3ZdLG1pbjrTLG1heDpEQVRFX0ZPUk1BVFMubGVuZ3RoLdQBLG9uY2hhbmdlOnaie6Modj7TKXtzZXR0aW5ncy5tZW51RGF0ZUZvcm1hdD1EQVRFX0ZPUk1BVFNbdl07faR7vnNldHRpbmdzLm1lbnVEYXRlRm9ybWF0O31zYXZlKCk7fX0s0RVTaG93IE1lbnUgQXV0byBTbm9vemU6e3ZhbHVlOiEhc2V0dGluZ3Muc2hvd0F1dG9Tbm9vemUsb25jaGFuZ2U6dqJ7c2V0dGluZ3Muc2hvd0F1dG9Tbm9vemU9djtzYXZlKCk7fX0s0RFTaG93IE1lbnUgQ29uZmlybTp7dmFsdWU6ISFzZXR0aW5ncy5zaG93Q29uZmlybSxvbmNoYW5nZTp2ontzZXR0aW5ncy5zaG93Q29uZmlybT12O3NhdmUoKTt9fSzREFNob3cgTWVudSBIaWRkZW46e3ZhbHVlOiEhc2V0dGluZ3Muc2hvd0hpZGRlbixvbmNoYW5nZTp2ontzZXR0aW5ncy5zaG93SGlkZGVuPXY7c2F2ZSgpO319LNEPU2hvdyBNZW51IEdyb3VwOnt2YWx1ZTohIXNldHRpbmdzLnNob3dHcm91cCxvbmNoYW5nZTp2ontzZXR0aW5ncy5zaG93R3JvdXA9djtzYXZlKCk7fX0s0RJTaG93IFRleHQgT3ZlcmZsb3c6e3ZhbHVlOiEhc2V0dGluZ3Muc2hvd092ZXJmbG93LG9uY2hhbmdlOnaie3NldHRpbmdzLnNob3dPdmVyZmxvdz12O3NhdmUoKTt9fSx9O0Uuc2hvd01lbnUoYXBwTWVudSk7fSn////GAAAAYWxhcm0uaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 146500, "eyJpZCI6ImFsYXJtIiwibmFtZSI6IkFsYXJtcyIsInNyYyI6ImFsYXJtLmFwcC5qcyIsImljb24iOiJhbGFybS5pbWciLCJ2ZXJzaW9uIjoiMC41MiIsInRhZ3MiOiJ0b29sLGFsYXJtIiwiZmlsZXMiOiJhbGFybS5pbmZvLGFsYXJtLmFwcC5qcyxhbGFybS5pbWcsYWxhcm0uc2V0dGluZ3MuanMiLCJkYXRhIjoiYWxhcm0uc2V0dGluZ3MuanNvbiJ9//8=");
  base64DecodeToExistingUint8Array(bufferView, 146713, "AQEBAQE=");
  base64DecodeToExistingUint8Array(bufferView, 146736, "AQYEAAILCQQAAAwHAAgDAQMDAwMDAwMDAwMAAA8QEQUAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAANAgQCAgICAgICAgICAgICAgICAgICAgICAgICAgAKDgAAPT0APT09ACE9ACE9PQA8PQA8PAA8PD0APj0APj4APj4+AD4+PQA+Pj49ACs9AC09ACsrAC0tACo9AC89ACU9ACY9ACYmAHw9AHx8AF49AD0+AGlmAGVsc2UAZG8Ad2hpbGUAZm9yAGJyZWFrAGNvbnRpbnVlAGZ1bmN0aW9uAHJldHVybgB2YXIAbGV0AGNvbnN0AHRoaXMAdGhyb3cAdHJ5AGNhdGNoAGZpbmFsbHkAdHJ1ZQBmYWxzZQBudWxsAHVuZGVmaW5lZABuZXcAaW4AaW5zdGFuY2VvZgBzd2l0Y2gAY2FzZQBkZWZhdWx0AGRlbGV0ZQB0eXBlb2YAdm9pZABkZWJ1Z2dlcgBjbGFzcwBleHRlbmRzAHN1cGVyAHN0YXRpYwBvZg==");
  base64DecodeToExistingUint8Array(bufferView, 147140, "Pz8AADAAAAAAZGVlcFNsZWVwAHVuc2FmZUZsYXNoAHVuc3luY0ZpbGVzAHByZXRva2VuaXNlAGppdERlYnVnAG9uRXJyb3JTYXZlAG9uRXJyb3JGbGFzaAAAgODw+A==");
  base64DecodeToExistingUint8Array(bufferView, 147250, "B4AzAAAABwABgDQAAAAPAAGANQAAABcACIA2AAAAHABYgDcAAAAiAHiAOAAAACYAA4A5AAAAKwAAgDoAAAAxAACAOwAAADUAA4A8AAAAPAAYgD0=");
  base64DecodeToExistingUint8Array(bufferView, 147344, "YW5hbG9nAGdldEluZm8AZ2V0TW9kZQBtb2RlAHB1bHNlAHB3bQByZWFkAHJlc2V0AHNldAB0b2dnbGUAd3JpdGU=");
  base64DecodeToExistingUint8Array(bufferView, 147426, "AQAvAAAABAARACAAAAAKACEAMAAAABYAAQAxAAAAJgAFcD4AAAAqAAVwPwAAAC8AAQAbAAAANgABAB4AAABAAAsAQAAAAEgACQkLAAAAUQARAAwAAABWAAEAHAAAAFgACQANAAAAXgAJCUEAAABrAAkJQgAAAHgAEQAyAAAAgQABAAoAAACKAARwQwAAAI8AAQAYAAAAkwABcEQAAACYAAdwRQAAAKEACQlGAAAArAAJCUcAAAC3AAkJSAAAAMEACQAQAAAAzwABACIAAADUAAFwSQAAANgAAXBJAAAA3QABcEoAAADiAARwSwAAAOYAAXBMAAAA8AABcE0AAAD6AAEAKAAAAP8AAQAnAAAABwEBAB0AAAALAQdwTgAAAA8BEQAjAAAAFgEJACQAAAAdASkAEwAAACUBCQAaAAAAKQEJABQAAAAxAQkAEQAAAEABSQASAAAARwEBABcAAABLAQFwTwAAAFABAQAVAAAAVwEBcFAAAABfAQEAFgAAAGsBEQAmAAAAcgEJAA4AAAB+AQFwUQAAAIcBCQAPAAAAkQEBcFIAAACVAQkJUwAAAKEBCQlUAAAArQEJCVUAAAC5AQkJVgAAAMQBCQlXAAAA1gEBAB8AAADgAQVwWAAAAOgBSQAZAAAA8QEvAFkAAAD8AegDWgAAAAgCAXBbAAAAEgIJAFwAAAAXAgkAXQAAABwCyAFeAAAAKwIQAF8AAAA5AhAAYAAAAEYCEABhAAAAUQIBACEAAABZAgkAYgAAAGwC6AJjAAAAeQIMAGQAAACFAkgAZQAAAJICAABmAAAAlwIYAGcAAACcAggAaAAAAKECCQBpAAAAtAIJAAkAAAC5AgEAKgAAALwCKQBqAAAAxwIBAGsAAADRAgcAbAAAANkCAXBtAAAA4AIBcG0AAADrAgsAbgAAAPQCCwBvAAAA+gIIAHAAAAD/Ag8AcQAAAAoDSQByAAAAEwMhAXMAAAAaAyEBdAAAACEDIQF1AAAAJwNoBnYAAAAvA2AAdwAAADYDYAB4AAAAPQNgAHkAAABDAxAAegAAAEkDAQArAAAAUQMJAHsAAABZAxgAfAAAAF8DCAB9AAAAcAPJBX4AAAB8AwgAfwAAAI4DOACAAAAAlgPJBYEAAAChA0kDggAAAKoDSAKDAAAAswMIAIQAAABBRVMAQXJyYXkAQXJyYXlCdWZmZXIAQXJyYXlCdWZmZXJWaWV3AEJUTgBCVE4xAEJhbmdsZQBCbHVldG9vdGgAQm9vbGVhbgBEYXRhVmlldwBEYXRlAEUARXJyb3IARmxvYXQzMkFycmF5AEZsb2F0NjRBcnJheQBGdW5jdGlvbgBHcmFwaGljcwBISUdIAEkyQwBJMkMxAEluZmluaXR5AEludDE2QXJyYXkASW50MzJBcnJheQBJbnQ4QXJyYXkASW50ZXJuYWxFcnJvcgBKU09OAExFRABMRUQxAExFRDIATE9XAExvb3BiYWNrQQBMb29wYmFja0IATWF0aABNb2R1bGVzAE5SRgBOYU4ATnVtYmVyAE9iamVjdABPbmVXaXJlAFBpbgBQcm9taXNlAFJlZmVyZW5jZUVycm9yAFJlZ0V4cABTUEkAU1BJMQBTZXJpYWwAU2VyaWFsMQBTdG9yYWdlRmlsZQBTdHJpbmcAU3ludGF4RXJyb3IAVGVybWluYWwAVHlwZUVycm9yAFVTQgBVaW50MTZBcnJheQBVaW50MjRBcnJheQBVaW50MzJBcnJheQBVaW50OEFycmF5AFVpbnQ4Q2xhbXBlZEFycmF5AFVuaXN0cm9rZQBWSUJSQVRFAFdhdmVmb3JtAGFuYWxvZ1JlYWQAYW5hbG9nV3JpdGUAYXJndW1lbnRzAGF0b2IAYnRvYQBjaGFuZ2VJbnRlcnZhbABjbGVhckludGVydmFsAGNsZWFyVGltZW91dABjbGVhcldhdGNoAGNvbnNvbGUAZGVjb2RlVVJJQ29tcG9uZW50AGRpZ2l0YWxQdWxzZQBkaWdpdGFsUmVhZABkaWdpdGFsV3JpdGUAZHVtcABlY2hvAGVkaXQAZW5jb2RlVVJJQ29tcG9uZW50AGV2YWwAZnMAZ2V0UGluTW9kZQBnZXRTZXJpYWwAZ2V0VGltZQBnbG9iYWwAZ2xvYmFsVGhpcwBpc0Zpbml0ZQBpc05hTgBsb2FkAHBhcnNlRmxvYXQAcGFyc2VJbnQAcGVlazE2AHBlZWszMgBwZWVrOABwaW5Nb2RlAHBva2UxNgBwb2tlMzIAcG9rZTgAcHJpbnQAcHJvY2VzcwByZXF1aXJlAHJlc2V0AHNldEJ1c3lJbmRpY2F0b3IAc2V0SW50ZXJ2YWwAc2V0U2xlZXBJbmRpY2F0b3IAc2V0VGltZQBzZXRUaW1lb3V0AHNldFdhdGNoAHNoaWZ0T3V0AHRyYWNl");
  base64DecodeToExistingUint8Array(bufferView, 149266, "IQGFAAAACAAgAYYAAAAQAAFwhwAAABgAIQGIAAAAJAAgAYkAAAAwACEBigAAADUA4QGLAAAAOgAhAYwAAABEACABjQAAAE4AAQCOAAAAUgAAAI8AAABeABgAkAAAAGsAAQCRAAAAdAABAJIAAAB/AAEAkwAAAIkACQCUAAAAmQABAJUAAACkAAEAlgAAAKwAAQCXAAAAtwABAJgAAADDAAQAmQAAANAAIQGaAAAA1gAgAZsAAADcAAMAnAAAAOoAAwCdAAAA+AADAJ4AAAADAQMAnwAAAA8BAwCgAAAAFwEDAKEAAAAfAQMAogAAACcBAwCjAAAAMAFgAKQAAAA2AQgApQAAADsBAACmAAAARwEAAKcAAABLAQkAqAAAAFMBAACpAAAAYAEYAKoAAABtAVsAqwAAAH8BWwCsAAAAjwFbAK0AAACbAVsArgAAAKcBOACvAAAAuAEIALAAAADDASAAsQAAANABSBiyAAAA3gEYALMAAADqATgAtAAAAPgBGAC1AAAAAgIIALYAAAANAjgAtwAAAB0CIAC4AAAAKgJIALkAAAAwAgAAugAAADoCAAC7AAAARwIAALwAAABZAgAAvQAAAGoCAAC+AAAAeQIAAL8AAACBAiEBwAAAAIkCIAHB");
  base64DecodeToExistingUint8Array(bufferView, 149760, "YWNjZWxSZABhY2NlbFdyAGFwcFJlY3QAYmFyb21ldGVyUmQAYmFyb21ldGVyV3IAYmVlcABidXp6AGNvbXBhc3NSZABjb21wYXNzV3IAZGJnAGRyYXdXaWRnZXRzAGZhY3RvcnlSZXNldABnZXRBY2NlbABnZXRDb21wYXNzAGdldEdQU0ZpeABnZXRIZWFsdGhTdGF0dXMAZ2V0TENETW9kZQBnZXRMb2dvAGdldE9wdGlvbnMAZ2V0UHJlc3N1cmUAZ2V0U3RlcENvdW50AGhybVJkAGhybVdyAGlzQmFja2xpZ2h0T24AaXNCYXJvbWV0ZXJPbgBpc0NoYXJnaW5nAGlzQ29tcGFzc09uAGlzR1BTT24AaXNIUk1PbgBpc0xDRE9uAGlzTG9ja2VkAGxjZFdyAGxvYWQAbG9hZFdpZGdldHMAb2ZmAHByb2plY3QAcmVzZXRDb21wYXNzAHNldEJhY2tsaWdodABzZXRCYXJvbWV0ZXJQb3dlcgBzZXRDb21wYXNzUG93ZXIAc2V0R1BTUG93ZXIAc2V0SFJNUG93ZXIAc2V0TENEQnJpZ2h0bmVzcwBzZXRMQ0RNb2RlAHNldExDRE9mZnNldABzZXRMQ0RPdmVybGF5AHNldExDRFBvd2VyAHNldExDRFRpbWVvdXQAc2V0TG9ja2VkAHNldE9wdGlvbnMAc2V0UG9sbEludGVydmFsAHNldFN0ZXBDb3VudABzZXRVSQBzaG93Q2xvY2sAc2hvd0xhdW5jaGVyAHNob3dMb2FkaW5nU2NyZWVuAHNob3dSZWNvdmVyeU1lbnUAc2hvd1Rlc3RTY3JlZW4Ac29mdE9mZgB0b3VjaFJkAHRvdWNoV3I=");
  base64DecodeToExistingUint8Array(bufferView, 150434, "CQDCAAAABgBIBsMAAAAKAPlPxAAAABMACQDFAAAAGgCIAMYAAAAeAP8PxwAAACMACADIAAAALQBPCMkAAAA2AEkCygAAAEEAAADLAAAASAAAAMwAAABaAAEAzQAAAGIAAADOAAAAcAB4AM8AAAB/AAkA0AAAAIgAzADRAAAAlQAHANIAAACjAAQA0wAAAK4AAQDUAAAAtwABANUAAADCAAEA1gAAANAAAQDXAAAA2QABANgAAADnAAkB2QAAAPEAHwDaAAAAAAEEANsAAAAHAQFw3AAAABABCwDdAAAAFwEAAN4AAAAkAQAA3wAAADABSQbgAAAAPQFIQuEAAABIASEB4gAAAFMBSQDjAAAAXQFhAuQAAABoAUgC5QAAAG0BAADmAAAAdAEkAOcAAACAAcgA6AAAAIwBDADpAAAAlQFIAOoAAACgARAA6wAAAKcBCADsAAAAsAEIAO0AAAC8ATgA7gAAAMgBSQDvAAAA0gEJAPAAAADbAUgA8QAAAOcBSQDyAAAA8gEJAPMAAAD/ASAA9AAAAAUCAAD1AAAAGgIPAPYAAAAeAgkA9wAAACwCEQD4AAAAOQIJAPkAAAA+AhEA+gAAAEcCEQD7AAAAVALPAfw=");
  base64DecodeToExistingUint8Array(bufferView, 150912, "Q1JDMzIARkZUAEhTQnRvUkdCAGFzVVRGOABhc20AY2xpcABjb21waWxlZEMAY29udm9sdmUAZGVjb2RlVVRGOABkZWZyYWcAZHVtcEZyYWdtZW50YXRpb24AZHVtcFN0cgBkdW1wVmFyaWFibGVzAGVuYWJsZVdhdGNoZG9nAGZyb21VVEY4AGdldEFkZHJlc3NPZgBnZXRBbmFsb2dWUmVmAGdldEJhdHRlcnkAZ2V0Q2xvY2sAZ2V0Q29uc29sZQBnZXRFcnJvckZsYWdzAGdldEZsYWdzAGdldFBvd2VyVXNhZ2UAZ2V0U2l6ZU9mAGdldFRlbXBlcmF0dXJlAGh3UmFuZABpbnRlcm5hbABpc1VURjgAa2lja1dhdGNoZG9nAGxvY2tDb25zb2xlAGxvb2t1cE5vQ2FzZQBtYXBJblBsYWNlAG1lbW9yeUFyZWEAbWVtb3J5TWFwAG5hdGl2ZUNhbGwAcGlwZQByZWJvb3QAcmV2ZXJzZUJ5dGUAc2V0Qm9vdENvZGUAc2V0Q2xvY2sAc2V0Q29uc29sZQBzZXREU1QAc2V0RmxhZ3MAc2V0UGFzc3dvcmQAc2V0VGltZVpvbmUAc2hvd0FsZXJ0AHNob3dNZW51AHNob3dNZXNzYWdlAHNob3dQcm9tcHQAc2hvd1Njcm9sbGVyAHNyYW5kAHN0b3BFdmVudFByb3BhZ2F0aW9uAHN1bQB0b0FycmF5QnVmZmVyAHRvRmxhdFN0cmluZwB0b0pTAHRvU3RyaW5nAHRvVWludDhBcnJheQB2YXJpYW5jZQAAAAAAAAEA/QAAAAsAAQD+AAAAHQBIAP8AAAAsAEgAAAEAAGdldEFkZHJlc3MAZ2V0U2VjdXJpdHlTdGF0dXMAc2V0QWR2ZXJ0aXNpbmcAc2V0U2VydmljZXM=");
  base64DecodeToExistingUint8Array(bufferView, 151616, "AQEAAHNldENvbnNvbGUAAAAAAYACAQAABgAJgAMBAAAOAAGABAEAABQATIIFAQAAHwAJgAYBAAAkABmABwEAACoACckIAQAANAAhiQkBAAA/ACGJCgEAAEwAIckLAQAAWAAJmQwBAABiAEmADQEAAG0AIckOAQAAdgD5/w8BAACBAMmAEAEAAIoAyYARAQAAlQAJyRIBAACeAAm5EwEAAKkAAIAUAQAArgAhiRUBAAC5ACHJFgEAAMUACYAXAQAAzgAJgBgBAADZAAnJGQEAAOIASYAaAQAA6QBJgBsBAADyACGDHAEAAPwABIAdAQAAAwEEgB4BAAAOAQSAHwEAABcBAYAgAQAAHwEEgCEBAAAtAQGAIgEAADYBBIAjAQAAQAEZgCQBAABMASSBJQEAAFUBSYAmAQAAaAEEgCcBAABxAQmAKAEAAH4BIYEpAQAAhQEhgSoBAACMAUmAKwEAAJwBAYAsAQAAogEhgS0BAACpAUmCLgEAALQBIckvAQAAwAFJgjABAADJAQmBMQEAANEBIYAyAQAA3gEhgDMBAADoASGANAEAAPIBIYA1AQAA/AEhgDYBAAAGAiGANwEAABICIYk4AQAAHwIBgDkBAAAtAgnDOgEAADsCCYE7AQAARgIhgDwBAABUAiGDPQEAAF0C4YA+AQAAaQIJgD8BAAByAgmAQAEAAIACDIBBAQAAjAIB8EIBAACSAkyCQwEAAJoCSYBEAQAArAIJgUUBAABhc0JNUABhc0ltYWdlAGFzVVJMAGJsZW5kQ29sb3IAYmxpdABjbGVhcgBjbGVhclJlY3QAZHJhd0NpcmNsZQBkcmF3Q2lyY2xlQUEAZHJhd0VsbGlwc2UAZHJhd0ltYWdlAGRyYXdJbWFnZXMAZHJhd0xpbmUAZHJhd0xpbmVBQQBkcmF3UG9seQBkcmF3UG9seUFBAGRyYXdSZWN0AGRyYXdTdHJpbmcAZHVtcABmaWxsQ2lyY2xlAGZpbGxFbGxpcHNlAGZpbGxQb2x5AGZpbGxQb2x5QUEAZmlsbFJlY3QAZmlsdGVyAGZpbmRGb250AGZsb29kRmlsbABnZXRCUFAAZ2V0QmdDb2xvcgBnZXRDb2xvcgBnZXRGb250AGdldEZvbnRIZWlnaHQAZ2V0Rm9udHMAZ2V0SGVpZ2h0AGdldE1vZGlmaWVkAGdldFBpeGVsAGdldFZlY3RvckZvbnRQb2x5cwBnZXRXaWR0aABpbWFnZU1ldHJpY3MAbGluZVRvAG1vdmVUbwBxdWFkcmF0aWNCZXppZXIAcmVzZXQAc2Nyb2xsAHNldEJnQ29sb3IAc2V0Q2xpcFJlY3QAc2V0Q29sb3IAc2V0Rm9udABzZXRGb250MTJ4MjAAc2V0Rm9udDE0AHNldEZvbnQxNwBzZXRGb250MjIAc2V0Rm9udDI4AHNldEZvbnQ2eDE1AHNldEZvbnRBbGlnbgBzZXRGb250Qml0bWFwAHNldEZvbnRDdXN0b20Ac2V0Rm9udFBCRgBzZXRGb250VmVjdG9yAHNldFBpeGVsAHNldFJvdGF0aW9uAHNldFRoZW1lAHN0cmluZ01ldHJpY3MAc3RyaW5nV2lkdGgAdGhlbWUAdG9Db2xvcgB0cmFuc2Zvcm1WZXJ0aWNlcwB3cmFwU3RyaW5n");
  base64DecodeToExistingUint8Array(bufferView, 152882, "CQBGAQAABABJAEcBAABuZXcAcmVjb2duaXNlAAAAAAARgEgBAAAHAEmASQEAAA0ACYNKAQAAEgBJgEsBAAAZAAmATAEAAB4ACYBNAQAAKABIgE4BAAAwAAuBTwEAADkACYFQAQAAQQAJgFEBAABGAAHwUgEAAE0ASYBTAQAAUQABgFQBAABVABSAVQEAAFoASYBWAQAAYQABgFcBAABpAAGAWAEAAG8AYYBZAQAAdQBJgFoBAAB6AAmAWwEAAH8AYYRcAQAAhgAJgAEAAACPABSAXQE=");
  base64DecodeToExistingUint8Array(bufferView, 153104, "Y29uY2F0AGV2ZXJ5AGZpbGwAZmlsdGVyAGZpbmQAZmluZEluZGV4AGZvckVhY2gAaW5jbHVkZXMAaW5kZXhPZgBqb2luAGxlbmd0aABtYXAAcG9wAHB1c2gAcmVkdWNlAHJldmVyc2UAc2hpZnQAc2xpY2UAc29tZQBzb3J0AHNwbGljZQB0b1N0cmluZwB1bnNoaWZ0AAAAAAsAXgEAAGlzQXJyYXkAAAAAAAAABPBfAQAAYnl0ZUxlbmd0aAAAAAAB8GABAAAHAATwYQEAABIABPBiAQAAHQBJgEkBAAAjAAmDSgEAACgASYBLAQAALwAJgEwBAAA0AAmATQEAAD4ASIBOAQAARgALgU8BAABPAAmBYwEAAFcACYBRAQAAXABJgGQBAABgAEmAVgEAAGcAAYBXAQAAbwAIgWUBAABzAGGAWQEAAHkASYBaAQAAfgAJgGYBAACDAGGAZwEAAGJ1ZmZlcgBieXRlTGVuZ3RoAGJ5dGVPZmZzZXQAZXZlcnkAZmlsbABmaWx0ZXIAZmluZABmaW5kSW5kZXgAZm9yRWFjaABpbmNsdWRlcwBpbmRleE9mAGpvaW4AbWFwAHJlZHVjZQByZXZlcnNlAHNldABzbGljZQBzb21lAHNvcnQAc3ViYXJyYXkAAAAAAAAA4YBoAQAACwDhgGkBAAAWAOGAagEAAB8A4YBrAQAAKADhgGwBAAAwAOGAbQEAADoA4YBuAQAARADhgG8BAABNAGCGcAEAAFgAYIZxAQAAYwBghnIBAABsAGCGcwEAAHUAYIZ0AQAAfQBghnUBAACHAGCGdgEAAJEAYIZ3AQAAZ2V0RmxvYXQzMgBnZXRGbG9hdDY0AGdldEludDE2AGdldEludDMyAGdldEludDgAZ2V0VWludDE2AGdldFVpbnQzMgBnZXRVaW50OABzZXRGbG9hdDMyAHNldEZsb2F0NjQAc2V0SW50MTYAc2V0SW50MzIAc2V0SW50OABzZXRVaW50MTYAc2V0VWludDMyAHNldFVpbnQ4");
  base64DecodeToExistingUint8Array(bufferView, 153890, "BwB4AQAABAAPAHkBAABub3cAcGFyc2U=");
  base64DecodeToExistingUint8Array(bufferView, 153922, "BIB6AQAACAAEgHsBAAAPAASAfAEAABsABIB9AQAAJAAEgH4BAAAtAASAfwEAAD0ABICAAQAASAAEgIEBAABRAASAggEAAFwAB4CDAQAAZAAEgIQBAAB2ACeAhQEAAH4AZ4KGAQAAigBnkocBAACTACeAiAEAAKMAZ4KJAQAArgBngIoBAAC3AGeAiwEAAMIAP4CMAQAAygABgI0BAADWAAGAjQEAAN0AAYCOAQAA7gABgI8BAAD3AAGAkAEAAAMBB4CDAQ==");
  base64DecodeToExistingUint8Array(bufferView, 154128, "Z2V0RGF0ZQBnZXREYXkAZ2V0RnVsbFllYXIAZ2V0SG91cnMAZ2V0SXNEU1QAZ2V0TWlsbGlzZWNvbmRzAGdldE1pbnV0ZXMAZ2V0TW9udGgAZ2V0U2Vjb25kcwBnZXRUaW1lAGdldFRpbWV6b25lT2Zmc2V0AHNldERhdGUAc2V0RnVsbFllYXIAc2V0SG91cnMAc2V0TWlsbGlzZWNvbmRzAHNldE1pbnV0ZXMAc2V0TW9udGgAc2V0U2Vjb25kcwBzZXRUaW1lAHRvSVNPU3RyaW5nAHRvSlNPTgB0b0xvY2FsSVNPU3RyaW5nAHRvU3RyaW5nAHRvVVRDU3RyaW5nAHZhbHVlT2YAAAAAAYCRAQAAdG9TdHJpbmcAAAAAAAABgJEBAAB0b1N0cmluZwAAAAAAAAGAkQEAAHRvU3RyaW5nAAAAAAAAAYCRAQAAdG9TdHJpbmcAAAAAAAABgJEBAAB0b1N0cmluZwAAAAAAABAAegAAAAYAEAB6AAAADAAQAHoAAAARABAAegAAABUAEACSAQAAGwAQAHoAAABkZWJ1ZwBlcnJvcgBpbmZvAGxvZwB0cmFjZQB3YXJu");
  base64DecodeToExistingUint8Array(bufferView, 154594, "CQCTAQAABgBJApQBAABwYXJzZQBzdHJpbmdpZnk=");
  base64DecodeToExistingUint8Array(bufferView, 154642, "B3CVAQAACgAHcJYBAAAUAAdwlwEAACYAB3CYAQAAKgAHcJkB");
  base64DecodeToExistingUint8Array(bufferView, 154688, "TUFYX1ZBTFVFAE1JTl9WQUxVRQBORUdBVElWRV9JTkZJTklUWQBOYU4AUE9TSVRJVkVfSU5GSU5JVFkAAAAAAAAAIYCaAQAAdG9GaXhlZA==");
  base64DecodeToExistingUint8Array(bufferView, 154786, "SICbAQAADAABgJwBAAASAIiAnQEAABcAC4CeAQAAJgAB8FIBAAAtAEiAmwEAADAASICfAQAAQAAIgKABAABTAEiAoQEAAGIACYABAAAAawABgKIB");
  base64DecodeToExistingUint8Array(bufferView, 154880, "YWRkTGlzdGVuZXIAY2xvbmUAZW1pdABoYXNPd25Qcm9wZXJ0eQBsZW5ndGgAb24AcHJlcGVuZExpc3RlbmVyAHJlbW92ZUFsbExpc3RlbmVycwByZW1vdmVMaXN0ZW5lcgB0b1N0cmluZwB2YWx1ZU9m");
  base64DecodeToExistingUint8Array(bufferView, 155010, "EQCjAQAABwBJAKQBAAAOAEkApQEAAB8ASQKmAQAALgAJAKcBAAA2AAkAqAEAAEIASQCpAQAAWwAJAKoBAAB1AAkAqwEAAIkACQCsAQAAmAAJAK0BAACdAEkArgEAAKwACQCvAQ==");
  base64DecodeToExistingUint8Array(bufferView, 155120, "YXNzaWduAGNyZWF0ZQBkZWZpbmVQcm9wZXJ0aWVzAGRlZmluZVByb3BlcnR5AGVudHJpZXMAZnJvbUVudHJpZXMAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMAZ2V0T3duUHJvcGVydHlOYW1lcwBnZXRQcm90b3R5cGVPZgBrZXlzAHNldFByb3RvdHlwZU9mAHZhbHVlcw==");
  base64DecodeToExistingUint8Array(bufferView, 155314, "SYCwAQAABgCJgLEBAAALAImAsAEAABAACICyAQAAYXBwbHkAYmluZABjYWxsAHJlcGxhY2VXaXRoAAAAAAAAAAmAswEAAAUAC4C0AQAAZXhlYwB0ZXN0");
  base64DecodeToExistingUint8Array(bufferView, 155410, "DAC1AQAABAAhALYBAAAIAAEAtwEAAA0AIwC4AQAAYWRkAGdldABsaXN0AHJlbW92ZQ==");
  base64DecodeToExistingUint8Array(bufferView, 155474, "IYC5AQAABwAhgLoBAAASABGAuwEAABkAS4C8AQAAIgBLgL0BAAArAEyAvgEAADMATIC/AQAAPwAB8FIBAABGAAmAwAEAAEwAYYDBAQAAUwBhgMIBAABcAAGAwwEAAGoAIYDEAQAAcQBJgMUBAAB5AEmAxgEAAIQAYYDHAQAAigAJgMgBAACQAAuByQEAAJsAYYDKAQAAogBhgMsBAACsAAGAzAEAALgAAYDNAQAAxAABgM4B");
  base64DecodeToExistingUint8Array(bufferView, 155664, "Y2hhckF0AGNoYXJDb2RlQXQAY29uY2F0AGVuZHNXaXRoAGluY2x1ZGVzAGluZGV4T2YAbGFzdEluZGV4T2YAbGVuZ3RoAG1hdGNoAHBhZEVuZABwYWRTdGFydAByZW1vdmVBY2NlbnRzAHJlcGVhdAByZXBsYWNlAHJlcGxhY2VBbGwAc2xpY2UAc3BsaXQAc3RhcnRzV2l0aABzdWJzdHIAc3Vic3RyaW5nAHRvTG93ZXJDYXNlAHRvVXBwZXJDYXNlAHRyaW0AAAAAAAARAM8BAABmcm9tQ2hhckNvZGU=");
  base64DecodeToExistingUint8Array(bufferView, 155906, "SADQAQAACgABANEBAAAUAAAA0gEAACQACADTAQAAYWRkQ2FjaGVkAGdldENhY2hlZAByZW1vdmVBbGxDYWNoZWQAcmVtb3ZlQ2FjaGVk");
  base64DecodeToExistingUint8Array(bufferView, 156002, "B3DUAQAAAgAHcNUBAAAHAAdw1gEAAAsAB3DXAQAAEgAHcNgBAAAYAAdw2QEAABsAB3DaAQAAIwAHcNsBAAApAD8A3AEAAC0APwDdAQAAMgA/AN4BAAA3AD8A3wEAADwA/wHgAQAAQgA/AOEBAABHAP8P4gEAAEwAPwDjAQAAUAA/AOQBAABUAD8A5QEAAFoAPwDmAQAAXgAXAOcBAABiABcA6AEAAGYA/wHpAQAAagAkAOoBAAByAAcA6wEAAHkAOQDsAQAAfwA8AO0BAACEAD8A7gEAAIgAPwDvAQAAjQA/APABAACRAP8B8QEAAEUATE4xMABMTjIATE9HMTBFAExPRzJFAFBJAFNRUlQxXzIAU1FSVDIAYWJzAGFjb3MAYXNpbgBhdGFuAGF0YW4yAGNlaWwAY2xpcABjb3MAZXhwAGZsb29yAGxvZwBtYXgAbWluAHBvdwByYW5kSW50AHJhbmRvbQByb3VuZABzaWduAHNpbgBzcXJ0AHRhbgB3cmFw");
  base64DecodeToExistingUint8Array(bufferView, 156402, "CADyAQAACgABAPMBAAASACEA9AEAABoAIQH1AQAAHwAIAfYB");
  base64DecodeToExistingUint8Array(bufferView, 156448, "ZXJhc2VQYWdlAGdldEZyZWUAZ2V0UGFnZQByZWFkAHdyaXRlAAAAAAAASALlAAAAcGlwZQ==");
  base64DecodeToExistingUint8Array(bufferView, 156514, "AXD3AQAABAAJAPgBAAALAAFw+QE=");
  base64DecodeToExistingUint8Array(bufferView, 156544, "ZW52AG1lbW9yeQB2ZXJzaW9u");
  base64DecodeToExistingUint8Array(bufferView, 156578, "CYD6AQAABQADgPsBAAALACGA/AEAABIACID9AQAAGQAAgP4BAAAeAMiA/wEAAHJlYWQAcmVzZXQAc2VhcmNoAHNlbGVjdABza2lwAHdyaXRl");
  base64DecodeToExistingUint8Array(bufferView, 156674, "CQAAAgAABAAJAAECAAALAAkAAgI=");
  base64DecodeToExistingUint8Array(bufferView, 156704, "YWxsAHJlamVjdAByZXNvbHZl");
  base64DecodeToExistingUint8Array(bufferView, 156738, "CYADAgAABgBJgAQCAABjYXRjaAB0aGVuAAAAACkABQIAAGZpbmQ=");
  base64DecodeToExistingUint8Array(bufferView, 156786, "BIAGAgAACgAAgAcCAAAQABCACAIAABcAA4AJAgAAIwBIgOUAAAAoAAiACgIAAC4ACIALAgAANgAhgAwCAAA7ABiADQIAAEYASIAOAgAATAAAgA8CAABUABCAEAIAAGF2YWlsYWJsZQBmbHVzaABpbmplY3QAaXNDb25uZWN0ZWQAcGlwZQBwcmludABwcmludGxuAHJlYWQAc2V0Q29uc29sZQBzZXR1cAB1bnNldHVwAHdyaXRl");
  base64DecodeToExistingUint8Array(bufferView, 156978, "GAARAgAACAAIABICAAAOAAAAEwIAABcAHAAUAgAAHwAJABUCAAAoAAwAFgIAAC0ASQAXAgAAMgBJABgCAAA3AAAAGQIAAEAACQkaAgAARQAJABsCAABVAMkAHAIAAF4AS0gdAgAAZABLAB4CAABjb21wYWN0AGVyYXNlAGVyYXNlQWxsAGdldEZyZWUAZ2V0U3RhdHMAaGFzaABsaXN0AG9wZW4Ab3B0aW1pc2UAcmVhZAByZWFkQXJyYXlCdWZmZXIAcmVhZEpTT04Ad3JpdGUAd3JpdGVKU09OAAAAAAAAgB8CAAAGAASAIAIAABAASIDlAAAAFQAhgCECAAAaAAGAIgIAACMACIAjAgAAZXJhc2UAZ2V0TGVuZ3RoAHBpcGUAcmVhZAByZWFkTGluZQB3cml0ZQAAAAAAACkAJAIAAGZpbmQ=");
  base64DecodeToExistingUint8Array(bufferView, 157314, "SYElAgAABQAI2SYCAAAOAAjZJwIAABcACIAoAgAAHQAQgCkC");
  base64DecodeToExistingUint8Array(bufferView, 157360, "c2VuZABzZW5kNGJpdABzZW5kOGJpdABzZXR1cAB3cml0ZQAAAAApACoCAABmaW5k");
  base64DecodeToExistingUint8Array(bufferView, 157426, "CYErAgAACQAhiSwCAAARAAiALQIAABcAiIAuAgAAcmVhZEZyb20AcmVhZFJlZwBzZXR1cAB3cml0ZVRv");
  base64DecodeToExistingUint8Array(bufferView, 157506, "6IMvAgAACwDogzACAAAXAACAMQI=");
  base64DecodeToExistingUint8Array(bufferView, 157536, "c3RhcnRJbnB1dABzdGFydE91dHB1dABzdG9wAAAAAAAAAAkAMgIAAAkACQAzAgAAY29tcHJlc3MAZGVjb21wcmVzcw==");
  base64DecodeToExistingUint8Array(bufferView, 157618, "IRk0AgAAEgAhGTUCAAAhAAkANgIAAC0AAQA3AgAAY3JlYXRlQXJyYXlCdWZmZXIAY3JlYXRlQ2FsbGJhY2sAY3JlYXRlSW1hZ2UAZ2V0SW5zdGFuY2U=");
  base64DecodeToExistingUint8Array(bufferView, 157714, "CQA4AgAABQAJADkCAAAMAAkAOgIAABMACQA7AgAAGgAJADwC");
  base64DecodeToExistingUint8Array(bufferView, 157760, "U0hBMQBTSEEyMjQAU0hBMjU2AFNIQTM4NABTSEE1MTI=");
  base64DecodeToExistingUint8Array(bufferView, 157810, "SRI9AgAACwBJEj4CAABjY21EZWNyeXB0AGNjbUVuY3J5cHQ=");
  base64DecodeToExistingUint8Array(bufferView, 157856, "JD8CACQ/AgAAMD8CAJA/AgAL4D8CAFBDAgBuEEcCAABJAgA9oEsCAIBNAgA74E8CAABQAgAEPFACAERQAgABUFACAHBSAgBEMFUCAEBVAgACUFUCABBWAgAXqFYCALBWAgABvFYCAMRWAgAB0FYCAHBXAgAUAFgCAIBYAgAQIFkCADBZAgACQFkCABBaAgAZHFsCACRbAgABMFsCADhbAgABRFsCAExbAgABWFsCAGBbAgABbFsCAHRbAgABgFsCALBbAgAG4FsCAPBbAgACEFwCAEBcAgAFgFwCAIhcAgABoFwCAABdAgALgF0CAPBdAgANsF4CANBeAgAE8F4CAABfAgACEF8CADBfAgAEUF8CABBgAgAX3GACAORgAgABAGECACBhAgAEYGECAFBiAgAe8GICACBjAgAFSGMCAFBjAgABYGMCAIBjAgADoGMCANBjAgAGAGQCACBkAgADQGQCAFBkAgACXGQCAGRkAgABcGQCANBkAgAMMGUCAKBlAgAOEGYCAEBmAgAGbGYCAHRmAgABgGYCALBmAgAF1GYCANxmAgAB8GYCABBnAgAEMGcCADBnAgAAQGcCAGBnAgADgGcCAJBnAgACsGcCANBnAgAEEGgCAEBoAgAFcGgCAIBoAgACUGluAEJhbmdsZQBFAE5SRgBCbHVldG9vdGgAR3JhcGhpY3MAVW5pc3Ryb2tlAEFycmF5AEFycmF5QnVmZmVyAEFycmF5QnVmZmVyVmlldwBVaW50OEFycmF5AFVpbnQ4Q2xhbXBlZEFycmF5AEludDhBcnJheQBVaW50MTZBcnJheQBJbnQxNkFycmF5AFVpbnQyNEFycmF5AFVpbnQzMkFycmF5AEludDMyQXJyYXkARmxvYXQzMkFycmF5AEZsb2F0NjRBcnJheQBEYXRhVmlldwBEYXRlAEVycm9yAFN5bnRheEVycm9yAFR5cGVFcnJvcgBJbnRlcm5hbEVycm9yAFJlZmVyZW5jZUVycm9yAEZ1bmN0aW9uAGNvbnNvbGUASlNPTgBOdW1iZXIAT2JqZWN0AEJvb2xlYW4AUmVnRXhwAFN0cmluZwBNb2R1bGVzAE1hdGgAZnMAcHJvY2VzcwBPbmVXaXJlAFByb21pc2UAU2VyaWFsAFN0b3JhZ2VGaWxlAFNQSQBJMkMAV2F2ZWZvcm0AQUVTAACsYT17fSxrPSHUATujKNEGb2JqZWN0ir9jnihhPWMsYz1hLm1vZGUsIWMpKbBFcnJvcijRHE1pc3NpbmcgbW9kZSBpbiBzZXRVSSh7Li4ufSkpO2dsb2JhbC5XSURHRVRTnldJREdFVFMuYmFja54oaz0h0yxXSURHRVRTLmJhY2sucmVtb3ZlKGEuYmFjaykpO0JhbmdsZS5idG5XYXRjaGVznihCYW5nbGUuYnRuV2F0Y2hlcy5mb3JFYWNoKGNsZWFyV2F0Y2gpLL5CYW5nbGUuYnRuV2F0Y2hlcyk7QmFuZ2xlLnN3aXBlSGFuZGxlcp4oQmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFc3dpcGUsQmFuZ2xlLnN3aXBlSGFuZGxlciksvkJhbmdsZS5zd2lwZUhhbmRsZXIpO0JhbmdsZS5kcmFnSGFuZGxlcp4oQmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEEZHJhZyxCYW5nbGUuZHJhZ0hhbmRsZXIpLL5CYW5nbGUuZHJhZ0hhbmRsZXIpO0JhbmdsZS50b3VjaEhhbmRsZXKeKEJhbmdsZS5yZW1vdmVMaXN0ZW5lcijRBXRvdWNoLEJhbmdsZS50b3VjaEhhbmRsZXIpLL5CYW5nbGUudG91Y2hIYW5kbGVyKTtCYW5nbGUudG91Y2hIYW5kbGVyMp4oQmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFdG91Y2gsQmFuZ2xlLnRvdWNoSGFuZGxlcjIpLL5CYW5nbGUudG91Y2hIYW5kbGVyMik7vkJhbmdsZS51aVJlZHJhdzu+QmFuZ2xlLkNMT0NLO6MoQmFuZ2xlLnVpUmVtb3ZlKXutYj1CYW5nbGUudWlSZW1vdmU7vkJhbmdsZS51aVJlbW92ZTtiKCl9Zy5yZXNldCgpO6MoYyl7oyjRBnVwZG93bopjKXujKGEuZHJhZymwRXJyb3Io0TFDdXN0b20gZHJhZyBoYW5kbGVyIG5vdCBzdXBwb3J0ZWQgaW4gbW9kZSB1cGRvd24hKTusZj3TO0JhbmdsZS5kcmFnSGFuZGxlcj1iontmlmIuZHk7pyhiLmKgKGY90yk71CA8TWF0aC5hYnMoZik7KdM8Zj8oZpfUICxlKNQBKSk6KGaW1CAsZSjU/ykpLEJhbmdsZS5idXp6KNQUKX07QmFuZ2xlLm9uKNEEZHJhZyxCYW5nbGUuZHJhZ0hhbmRsZXIpO0JhbmdsZS50b3VjaEhhbmRsZXI9YqJ7QmFuZ2xlLmJ1enoo1B4pO2UoKX07QmFuZ2xlLm9uKNEFdG91Y2gsQmFuZ2xlLnRvdWNoSGFuZGxlcik7QmFuZ2xlLmJ0bldhdGNoZXM9W3NldFdhdGNoKKooKXtCYW5nbGUuYnV6eijUHik7ZSgpfSxCVE4xLHtyZXBlYXQ61AEsZWRnZTrRBnJpc2luZ30pXX2koyjRCWxlZnRyaWdodIpjKXujKGEuZHJhZymwRXJyb3Io0TRDdXN0b20gZHJhZyBoYW5kbGVyIG5vdCBzdXBwb3J0ZWQgaW4gbW9kZSBsZWZ0cmlnaHQhKTusaD3TO0JhbmdsZS5kcmFnSGFuZGxlcj1iontolmIuZHg7pyhiLmKgKGg90yk71CA8TWF0aC5hYnMoaCk7KdM8aD8oaJfUICxlKNQBKSk6KGiW1CAsZSjU/ykpLEJhbmdsZS5idXp6KNQUKX07QmFuZ2xlLm9uKNEEZHJhZyxCYW5nbGUuZHJhZ0hhbmRsZXIpO0JhbmdsZS50b3VjaEhhbmRsZXI9YqJ7QmFuZ2xlLmJ1enoo1B4pO2UoKX07QmFuZ2xlLm9uKNEFdG91Y2gsQmFuZ2xlLnRvdWNoSGFuZGxlcik7QmFuZ2xlLmJ0bldhdGNoZXM9W3NldFdhdGNoKKooKXtCYW5nbGUuYnV6eijUHik7ZSgpfSxCVE4xLHtyZXBlYXQ61AEsZWRnZTrRBnJpc2luZ30pXX2koyjRBWNsb2NrimMpQmFuZ2xlLkNMT0NLPdQBLEJhbmdsZS5idG5XYXRjaGVzPVtzZXRXYXRjaChCYW5nbGUuc2hvd0xhdW5jaGVyLEJUTjEse3JlcGVhdDrUASxlZGdlOtEGcmlzaW5nfSldO6SjKNELY2xvY2t1cGRvd26KYylCYW5nbGUuQ0xPQ0s91AEsQmFuZ2xlLnRvdWNoSGFuZGxlcj0oYixkKaJ71Hg+ZC54oChCYW5nbGUuYnV6eijUHiksZSjUWDxkLnk/1AE61P8pKX0sQmFuZ2xlLm9uKNEFdG91Y2gsQmFuZ2xlLnRvdWNoSGFuZGxlciksQmFuZ2xlLmJ0bldhdGNoZXM9W3NldFdhdGNoKEJhbmdsZS5zaG93TGF1bmNoZXIsQlROMSx7cmVwZWF0OtQBLGVkZ2U60QZyaXNpbmd9KV07pKMo0QZjdXN0b22KYylhLmNsb2NrnihCYW5nbGUuYnRuV2F0Y2hlcz1bc2V0V2F0Y2goQmFuZ2xlLnNob3dMYXVuY2hlcixCVE4xLHtyZXBlYXQ61AEsZWRnZTrRBnJpc2luZ30pXSk7pLBFcnJvcijREFVua25vd24gVUkgbW9kZSArRS50b0pTKGMpKTthLmNsb2NrnihCYW5nbGUuQ0xPQ0s91AEpO6MoYS50b3VjaCmjKEJhbmdsZS50b3VjaEhhbmRsZXIpQmFuZ2xlLm9uKNEFdG91Y2gsQmFuZ2xlLnRvdWNoSGFuZGxlcjI9YS50b3VjaCk7pEJhbmdsZS5vbijRBXRvdWNoLEJhbmdsZS50b3VjaEhhbmRsZXI9YS50b3VjaCk7YS5kcmFnnihCYW5nbGUuZHJhZ0hhbmRsZXI9YS5kcmFnLEJhbmdsZS5vbijRBGRyYWcsQmFuZ2xlLmRyYWdIYW5kbGVyKSk7YS5zd2lwZZ4oQmFuZ2xlLnN3aXBlSGFuZGxlcj1hLnN3aXBlLEJhbmdsZS5vbijRBXN3aXBlLEJhbmdsZS5zd2lwZUhhbmRsZXIpKTshYS5idG6eIWEuYnRuUmVsZWFzZaBCYW5nbGUuYnRuV2F0Y2hlc6AoQmFuZ2xlLmJ0bldhdGNoZXM9W10pO2EuYnRunkJhbmdsZS5idG5XYXRjaGVzLnB1c2goc2V0V2F0Y2goYS5idG4uYmluZChhKSxCVE4xLHtyZXBlYXQ61AEsZWRnZTrRBnJpc2luZ30pKTthLmJ0blJlbGVhc2WeQmFuZ2xlLmJ0bldhdGNoZXMucHVzaChzZXRXYXRjaChhLmJ0blJlbGVhc2UuYmluZChhKSxCVE4xLHtyZXBlYXQ61AEsZWRnZTrRB2ZhbGxpbmd9KSk7YS5yZW1vdmWeKEJhbmdsZS51aVJlbW92ZT1hLnJlbW92ZSk7YS5yZWRyYXeeKEJhbmdsZS51aVJlZHJhdz1hLnJlZHJhdyk7oyhhLmJhY2ueKMDTi0JhbmdsZS5idG5XYXRjaGVznihCYW5nbGUuYnRuV2F0Y2hlcz1bc2V0V2F0Y2goqigpe0JhbmdsZS5idG5XYXRjaGVzPcDTO2EuYmFjaygpfSxCVE4xLHtlZGdlOtEGcmlzaW5nfSldKSxnbG9iYWwuV0lER0VUU55CYW5nbGUuYXBwUmVjdC55KSl7rGw9qihiLGQpe9QkPmQueZ7UMD5kLnieKGQuaGFuZGxlZD0h0yxFLnN0b3BFdmVudFByb3BhZ2F0aW9uKCksQmFuZ2xlLmJ1enoo1B4pLnRoZW4oKCmiYS5iYWNrKCkpKX07QmFuZ2xlLnByZXBlbmRMaXN0ZW5lcijRBXRvdWNoLGwpO1dJREdFVFM9T2JqZWN0LmFzc2lnbih7YmFjazp7YXJlYTrRAnRsLHdpZHRoOtQYLGRyYXc6YqJnLnJlc2V0KCkuc2V0Q29sb3Io0QQjZjAwKS5kcmF3SW1hZ2Uo0UwYGIEAABgAAf+AB//gD//wH//4P//8P//8f8/+f4f+fw/+fh/+/AA//AA/fh/+fw/+f4f+f8/+P//8P//8H//4D//wB//gAf+AABgALGIueCxiLnkpLHJlbW92ZTqqKGIpe6xkPVdJREdFVFMuYmFjazvRAnRsjGQuYXJlYZ4oYj0h0yk7QmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFdG91Y2gsbCk7YqBnLnJlc2V0KCkuY2xlYXJSZWN0KHt4OmQueCx5OmQueSx3OtQYLGg61Bh9KTu+V0lER0VUUy5iYWNrO2KgQmFuZ2xlLmRyYXdXaWRnZXRzKCl9fX0sZ2xvYmFsLldJREdFVFMpO2ugQmFuZ2xlLmRyYXdXaWRnZXRzKCl9fQCqZChhLGMsaCl7rGI9bi5pbmRleE9mKGEpO3BbYl09aDtimtQRO2cucmVzZXQoKS5jbGVhclJlY3Qo1DAsYizVrwAsYivUESkuc2V0Rm9udCjRBzZ4ODoxeDIpO2cuc2V0QmdDb2xvcihoP9EEIzBmMDrRBCNmMDApLmNsZWFyUmVjdCjTLGIs1DAsYivUESk7Zy5zZXRGb250QWxpZ24o0yzTKS5kcmF3U3RyaW5nKGEs1BgsYivUCSk7Zy5zZXRGb250QWxpZ24o1P8s0ykuZHJhd1N0cmluZyhjLNQ0LGIr1AkpfUJhbmdsZS5zZXRVSSgpO2NsZWFySW50ZXJ2YWwoKTtjbGVhcldhdGNoKCk7Zy5jbGVhcijUASk7QmFuZ2xlLnJlbW92ZUFsbExpc3RlbmVycygpO0UucmVtb3ZlQWxsTGlzdGVuZXJzKCk7QmFuZ2xlLnNldFBvbGxJbnRlcnZhbCjUUCk7QmFuZ2xlLnNldEJhcm9tZXRlclBvd2VyKNQBLNEDYXBwKTtCYW5nbGUuc2V0Q29tcGFzc1Bvd2VyKNQBLNEDYXBwKTtCYW5nbGUuc2V0R1BTUG93ZXIo1AEs0QNhcHApO0JhbmdsZS5zZXRIUk1Qb3dlcijUASzRA2FwcCk7QmFuZ2xlLnNldExDRFBvd2VyKNQBKTtCYW5nbGUuc2V0TG9ja2VkKNMpO0JhbmdsZS5zZXRMQ0RUaW1lb3V0KNMpO6xwPVtdO65uPdEqVFMgR1BTIEhSTSBCYXJvIE1hZyBBY2MgQnRuIEZXIENoZyBWaWJyYXRlLnNwbGl0KNEBICksbD1NYXRoLmFiczusbT0h1AEsZT3TLGs7bi5mb3JFYWNoKGGiZChhLCIiLCHUASkpO0JhbmdsZS5vbijRBXRvdWNoLChhLGMpomQo0QJUUyxjLngr0QEsK2MueSzU5zxjLnieLdQZPGMueZ7VyAA+Yy54ntXIAD5jLnkpKTtCYW5nbGUub24o0QNHUFMsYaJkKNEDR1BTLGEudGltZT9yZXF1aXJlKNEGbG9jYWxlKS50aW1lKGEudGltZSzUASk60QItLSwh0ykpO0JhbmdsZS5vbijRB0hSTS1yYXcsYaJkKNEDSFJNLGEudmNQUEcs045hLnZjUFBHntWIE5FhLnZjUFBHKSk7QmFuZ2xlLm9uKNEIcHJlc3N1cmUsYaJkKNEEQmFybyxNYXRoLnJvdW5kKGEucHJlc3N1cmUpLNWEAzxhLnByZXNzdXJlntVMBD5hLnByZXNzdXJlKSk7QmFuZ2xlLm9uKNEDbWFnLGGiZCjRA01hZyxhLngr0QEsK2EueSvRASwrYS56LNWIEz5sKGEueCme1YgTPk1hdGguYWJzKGEueSme1YgTPk1hdGguYWJzKGEueikpKTtCYW5nbGUub24o0QVhY2NlbCxhontkKNEDQWNjLGEueC50b0ZpeGVkKNQBKSvRASwrYS55LnRvRml4ZWQo1AEpK9EBLCthLnoudG9GaXhlZCjUASksLjU+bChhLngpni41PmwoYS55KZ4tLjg+YS56KTttPyhlmCxrlmEuZGlmZizUCjxlnihtPSHUASxEMTkucmVzZXQoKSxhPdQDPGssZCjRB1ZpYnJhdGUsYT/RAm9rOtEEZmFpbCxhKSkpOsDTi2ueLjEyPmEuZGlmZj8oZZgs1A88ZZ4oZT3TLG09IdMsaz3TLEQxOS5zZXQoKSkpOmU9030pO3NldFdhdGNoKGGiZCjRA0J0bixhLnN0YXRlP9EFUHJlc3M60QhSZWxlYXNlZCwh0yksQlROLHtlZGdlOtMscmVwZWF0OtQBfSk7rHE9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0QguYm9vdGNkZSk7ZCjRAkZXLNEFYm9vdCArKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCWJvb3QuaW5mbyzUASmge30pLnZlcnNpb26g0QROT05FLHGecS5pbmNsdWRlcyjRD2Nsb2NrSGFzV2lkZ2V0cykpO3NldFRpbWVvdXQoqigpe6xhPSgxRS00K2FuYWxvZ1JlYWQoRDMpK2FuYWxvZ1JlYWQoRDMpK2FuYWxvZ1JlYWQoRDMpKS/UAyxjPdMsaD3TO3NldEludGVydmFsKKooKXusYj1hbmFsb2dSZWFkKEQzKSxmPTEzLjM1OSpiO2ifQmFuZ2xlLmlzQ2hhcmdpbmcoKTtiPmGeKGM91AEpO2I9aJ5jntQCPGaeNC40PmY7Zj1mLnRvRml4ZWQo1AIpK9ECdiArKEJhbmdsZS5pc0NoYXJnaW5nKCk/0QZjaGFyZ2U60QlkaXNjaGFyZ2UpO3BlZWszMigxMDczNzQzMjI0KaAoZj3RB05PIERDREMsYj0h1AEpO2Qo0QNDaGcsZixiKX0s1fQBKX0s1egDKTtCYW5nbGUub24o0QVzd2lwZSxhontwLmV2ZXJ5KGOiYymeKEJhbmdsZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKSxjbGVhckludGVydmFsKCksY2xlYXJXYXRjaCgpLGcuY2xlYXIoKSxzZXRUaW1lb3V0KKooKXtCYW5nbGUuc2V0QmFyb21ldGVyUG93ZXIo0yzRA2FwcCk7QmFuZ2xlLnNldENvbXBhc3NQb3dlcijTLNEDYXBwKTtCYW5nbGUuc2V0R1BTUG93ZXIo0yzRA2FwcCk7QmFuZ2xlLnNldEhSTVBvd2VyKNMs0QNhcHApO0JhbmdsZS5zZXRCYWNrbGlnaHQo0yk7QmFuZ2xlLnNldExvY2tlZCjUASk7Zy5jbGVhcijUASkuc2V0Rm9udCjRBzEyeDIwOjIpLnNldEZvbnRBbGlnbijTLNMpLmRyYXdTdHJpbmco0QlURVNUClBBU1Ms1Fgs1FgpO3JlcXVpcmUo0QdTdG9yYWdlKS53cml0ZUpTT04o0Qx3ZWxjb21lLmpzb24se3dlbGNvbWVkOiHUAX0pO0JhbmdsZS5zZXRQb2xsSW50ZXJ2YWwo1SADKTtOUkYuc2xlZXAoKTtzZXRUaW1lb3V0KKooKXtCYW5nbGUub2ZmKCl9LDM2RTUpfSzUZCkpfSkA0QZzdHJpbmeKv2GeKGE9e3RpdGxlOmF9KTthPWGge307YS5idXR0b25zPXtPazrUAX07YS5pbWc9cmVxdWlyZSjRCmhlYXRzaHJpbmspLmRlY29tcHJlc3Mo0YCUSjhQGi/7//8EgyCAVUABAcEChggQFDVAEhwUEh0AEhwEEBVQdixUODB4QOCB4QtDgkoYBw/4DIMYBw7YDIMEkjoMEiQEEukoMEiAAQE4oEQAFLIYxjAlMYiQFZptEl3p1UjDQEEgjIMYBgkEZBjAQPDBwIPDBwIABDkUFDAUMCk7q0Uuc2hvd1Byb21wdChiLGEpAKp6KGEsYil7rGM9YS5zdGVwoNQBO6MoIWEubm9MaXN0nsDTjWEubWlunsDTjWEubWF4ntQUPihhLm1heC1hLm1pbikvYymsdT1FLnNob3dTY3JvbGxlcih7aDrUKCxjOihhLm1heCtjLWEubWluKS9jLGJhY2s6dCxyZW1vdmU6bS5yZW1vdmUsc2Nyb2xsTWluOtToLHNjcm9sbDrU6CxkcmF3OihoLGUponujKNM+aCmraD1nLmZpbmRGb250KNEYAAwMgQD///8AAAAAD///8AAAAAD///8gK2Ise3c6Zy5nZXRXaWR0aCgpLdQCLGg61BgsbWF4OtQYfSksZy5zZXRGb250QWxpZ24o1P8s0ykuZHJhd1N0cmluZyhoLnRleHQsZS54K9QMLGUueSvUKC3UDCk7Zy5zZXRDb2xvcihnLnRoZW1lLmJnMikuZmlsbFJlY3Qoe3g6ZS54K9QELHk6ZS55K9QCLHc6ZS53LdQILGg6ZS5oLdQELHI61AV9KTtoPWgqYythLm1pbjusZj1hLmZvcm1hdD9hLmZvcm1hdChoLNQBKTpoO2Y9Zy5maW5kRm9udChmLHt3OmUudyxoOmUuaCx3cmFwOtQBLHRyaW061AF9KTtnLnNldENvbG9yKGcudGhlbWUuZmcyKS5zZXRGb250QWxpZ24o1P8s0ykuZHJhd1N0cmluZyhmLnRleHQsZS54K9QMLGUueSvUFCk7Zy5kcmF3SW1hZ2UoYXRvYihoimEudmFsdWU/0UhGQlNCQUFINEFIL2dIZ2VEZ0J3dzhNWS94bWYrYkgvanovODgvL1BQL3p6Lzg4ZitObi9tWS94akR3dzRBY0hnZUFmK0FCK0E60UhGQlNCQUFINEFIL2dIZ2VEZ0J3d0FNWUFCbUFBYkFBRHdBQThBQVBBQUR3QUE4QUFOZ0FHWUFCakFBdzRBY0hnZUFmK0FCK0EpLGUueCtlLnct1CAsZS55K9QULdQKKX0sc2VsZWN0OqooaCl7oyghKNM+aCkpe0JhbmdsZS5idXp6KNQUKTthLnZhbHVlPWEubWluK2gqYzujKGEub25jaGFuZ2UpYS5vbmNoYW5nZShhLnZhbHVlKTt1LmlzQWN0aXZlKCmeKHYuc2Nyb2xsPXAuc2Nyb2xsZXIuc2Nyb2xsLHQoKSl9fX0pO6R7rGQ9QmFuZ2xlLmFwcFJlY3Qsaz1hLnZhbHVlO2cucmVzZXQoKS5jbGVhclJlY3QoZCk7Zy5zZXRGb250KNEFMTJ4MjApLnNldEZvbnRBbGlnbijTLNMpLmRyYXdTdHJpbmco0RgADAyBAP///wAAAAAP///wAAAAAP///yArYixkLngrZC53L9QCLGQueSvUDCk7qmgoKXusZj1kLngrZC53L9QCLGw91AwrZC55K2QuaC/UAix4PWEuZm9ybWF0P2EuZm9ybWF0KGss1AIpOms7Zy5yZXNldCgpLnNldENvbG9yKGcudGhlbWUuYmcyKS5maWxsUmVjdCh7eDpkLngr1BgseTpkLnkr1CQsdzpkLnct1DAsaDpkLmgt1DAscjrUBX0pO2cuc2V0Q29sb3IoZy50aGVtZS5mZzIpLnNldEZvbnRWZWN0b3IoTWF0aC5taW4o1B4s1GQqKGQudy3UNCkvZy5zZXRGb250VmVjdG9yKNRkKS5zdHJpbmdXaWR0aCh4KSkpLnNldEZvbnRBbGlnbijTLNMpLmRyYXdTdHJpbmcoeCxmLGwpO2cuZmlsbFBvbHkoW2YsbC3ULSxmK9QPLGwt1B4sZi3UDyxsLdQeXSkuZmlsbFBvbHkoW2YsbCvULSxmK9QPLGwr1B4sZi3UDyxsK9QeXSl9qmUoZil7oyhmKWuXKGag1AEpKihhLnN0ZXCg1AEpLMDTjWEubWlunms8YS5taW6eKGs9YS53cmFwP2EubWF4OmEubWluKSzA041hLm1heJ5rPmEubWF4nihrPWEud3JhcD9hLm1pbjphLm1heCksaCgpO6R7YS52YWx1ZT1rO6MoYS5vbmNoYW5nZSlhLm9uY2hhbmdlKGEudmFsdWUpO0JhbmdsZS51aVJlZHJhd4ponih2LnNjcm9sbD1wLnNjcm9sbGVyLnNjcm9sbCx0KCkpfX1oKCk7rHE90ztCYW5nbGUuc2V0VUkoe21vZGU60QZjdXN0b20sYmFjazp0LHJlbW92ZTptLnJlbW92ZSxyZWRyYXc6aCxkcmFnOmaie3GWZi5keTunKGYuYqAocT3TKTvUIDxNYXRoLmFicyhxKTsp0zxxPyhxl9QgLGUo1AEpKToocZbUICxlKNT/KSksQmFuZ2xlLmJ1enoo1BQpfSx0b3VjaDooZixsKaJ7QmFuZ2xlLmJ1enoo1BQpO9RSPmwueT9lKNT/KTrVjgA8bC55P2Uo1AEpOmUoKX19KX19qnQoKXtwLnNjcm9sbGVyPUUuc2hvd1Njcm9sbGVyKHYpfaMowNOLbimrZy5jbGVhclJlY3QoQmFuZ2xlLmFwcFJlY3QpLEJhbmdsZS5zZXRVSSgpO6xtPW5bIiJdoHt9O20udGl0bGWgKG0udGl0bGU90QRNZW51KTusdz1tLmJhY2ugblvRBjwgQmFja10scj1PYmplY3Qua2V5cyhuKS5maWx0ZXIoYaIiIo1hntEGPCBCYWNrjGEpO3IuZm9yRWFjaChhonthPW5bYV070QZvYmplY3SMv2Gg0Qdib29sZWFujL9hLnZhbHVloGEuZm9ybWF0oChhLmZvcm1hdD1iotEBACthdG9iKGI/0TxFaEtCQUgvL3YvLy8vLy8vLy8vLy8vNS8veC8vai8vSCtlUCtNZi9BLy9oLy96Ly8vLy8vLy8vLzMvL2c60TxFaEtCQUgvL3YvLzhBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQS8vLzMvL2cpKX0pO6xwPXtkcmF3OigponAuc2Nyb2xsZXIuZHJhdygpLHNjcm9sbGVyOsDTfTuteTusdj17aDrUKCxjOnIubGVuZ3RoLHNjcm9sbE1pbjrU6CxzY3JvbGw6towoeT1tLnNjcm9sbCk/eTrU6CxiYWNrOncscmVtb3ZlOm0ucmVtb3ZlLGRyYXc6KGEsYimie2cuc2V0Rm9udEFsaWduKNT/LNMpO6Mo0z5hKatnLmRyYXdTdHJpbmcoZy5maW5kRm9udCjRGAAMDIEA////AAAAAA////AAAAAA////ICttLnRpdGxlLHt3OmIudyxoOtQYLG1heDrUGH0pLnRleHQsYi54K9QMLGIueSvUKC3UCik7Zy5zZXRDb2xvcihnLnRoZW1lLmJnMikuZmlsbFJlY3Qoe3g6Yi54K9QELHk6Yi55K9QCLHc6Yi53LdQILGg6Yi5oLdQELHI61AV9KS5zZXRDb2xvcihnLnRoZW1lLmZnMik7rGM9bltyW2FdXSx1PdQQO6Mo0QZvYmplY3SKv2Mpe6xkPWMudmFsdWU7Yy5mb3JtYXSeKGQ9Yy5mb3JtYXQoZCkpO8DTjWSeKGQ9Zy5maW5kRm9udChkLHt3OmIudy/UAixoOmIuaCx3cmFwOtQBLHRyaW061AF9KSxnLnNldEZvbnRBbGlnbijUASzTKS5kcmF3U3RyaW5nKGQudGV4dCxiLngrYi53LdQILNQCK2IueSvUFCksdZZnLnN0cmluZ1dpZHRoKGQudGV4dCkpfaTRCGZ1bmN0aW9uir9jnihnLmRyYXdJbWFnZSjRGQkSgQBgOB4PA8DweB4HA4PDweHh4PBwMAAsYi54K2Iudy3UFSxiLnkr1BQt1AkpLHWW1BApO61rO2cuc2V0Rm9udEFsaWduKNT/LNMpLmRyYXdTdHJpbmcoZy5maW5kRm9udCi2jChrPWOeYy50aXRsZSk/azpyW2FdLHt3OmIudy11LGg6Yi5oLHdyYXA61AEsdHJpbTrUAX0pLnRleHQsYi54K9QILNQCK2IueSvUFCl9LHNlbGVjdDqqKGEsYil7oyjTPmEpq3eedygpO6xjPW5bclthXV07QmFuZ2xlLmJ1enoo1BQpO6Mo0QhmdW5jdGlvboq/YyljKGIpO6SjKNEGb2JqZWN0ir9jKaMo0QZudW1iZXKKv2MudmFsdWUpeihjLHJbYV0pO6R70Qdib29sZWFuir9jLnZhbHVlnihjLnZhbHVlPSFjLnZhbHVlKTujKGMub25jaGFuZ2UpYy5vbmNoYW5nZShjLnZhbHVlLGIpO3Auc2Nyb2xsZXIuaXNBY3RpdmUoKZ5wLnNjcm9sbGVyLmRyYXdJdGVtKGEpfX19O3QoKTurcACqayhhKXurYSpkLmgrYi55LWZ9qmwoYSl7q01hdGguZmxvb3IoKGErZi1iLnkpL2QuaCl9oyghZCmrQmFuZ2xlLnNldFVJKCk7rG49KCmie2cucmVzZXQoKS5jbGVhclJlY3QoYikuc2V0Q2xpcFJlY3QoYi54LGIueSxiLngyLGIueTIpO6corGE9bChiLnkpLGM9TWF0aC5taW4obChiLnkyKSxkLmMt1AEpO2GOYzthmClkLmRyYXcoYSx7eDpiLngseTprKGEpLHc6Yi53LGg6ZC5ofSk7Zy5zZXRDbGlwUmVjdCjTLNMsZy5nZXRXaWR0aCgpLdQBLGcuZ2V0SGVpZ2h0KCkt1AEpfTtCYW5nbGUuc2V0VUkoe21vZGU60QZjdXN0b20sYmFjazpkLmJhY2sscmVtb3ZlOmQucmVtb3ZlLHJlZHJhdzpuLGRyYWc6YaJ7rGM9YS5keTtlLnNjcm9sbC1jPm2eKGM9ZS5zY3JvbGwtbSk7ZS5zY3JvbGwtYzxonihjPWUuc2Nyb2xsLWgpO2Uuc2Nyb2xsl2M7Yz1mO2Y9ZS5zY3JvbGwmLdQCO6MoY5dmKXtnLnJlc2V0KCkuc2V0Q2xpcFJlY3QoYi54LGIueSxiLngyLGIueTIpLnNjcm9sbCjTLGMpO2E9YS5keTujKNM+YSmnKGE9TWF0aC5tYXgoYi55Mi0o1AEtYSksYi55KSxnLnNldENsaXBSZWN0KGIueCxhLGIueDIsYi55MiksYz1sKGEpLGE9ayhjKTthPGIueTI7KWQuZHJhdyhjLHt4OmIueCx5OmEsdzpiLncsaDpkLmh9KSxjmCxhlmQuaDukpyhhPU1hdGgubWluKGIueSthLGIueTIpLGcuc2V0Q2xpcFJlY3QoYi54LGIueSxiLngyLGEpLGM9bChhKSxhPWsoYyk7YT5iLnktZC5oOylkLmRyYXcoYyx7eDpiLngseTphLHc6Yi53LGg6ZC5ofSksYZdkLmgsY5k7Zy5zZXRDbGlwUmVjdCjTLNMsZy5nZXRXaWR0aCgpLdQBLGcuZ2V0SGVpZ2h0KCkt1AEpfX0sdG91Y2g6KGEsYymie6MoIShjLnk8Yi55LdQEKSl7YT1sKGMueSk7rHA9Yy55K2YtYi55LWEqZC5oO9WjADxjLnme1aMAPGsoYSmeKGGZLHA9ZC5oLdQBKTso0z5ooNOOYSmeYTxkLmOeZC5zZWxlY3QoYSx7eDpjLngseTpwLHR5cGU6Yy50eXBlfSl9fX0pO6xiPUJhbmdsZS5hcHBSZWN0LGg903xkLnNjcm9sbE1pbixtPWQuaCpkLmMtYi5oO208aJ4obT1oKTusZT17c2Nyb2xsOkUuY2xpcCjTfGQuc2Nyb2xsLGgsbSksZHJhdzpuLGRyYXdJdGVtOmGie6xjPWsoYSk7Zy5yZXNldCgpLnNldENsaXBSZWN0KGIueCxNYXRoLm1heChjLGIueSksYi54MixNYXRoLm1pbihjK2QuaCxiLnkyKSk7ZC5kcmF3KGEse3g6Yi54LHk6Yyx3OmIudyxoOmQuaH0pO2cuc2V0Q2xpcFJlY3Qo0yzTLGcuZ2V0V2lkdGgoKS3UASxnLmdldEhlaWdodCgpLdQBKX0saXNBY3RpdmU6KCmiQmFuZ2xlLnVpUmVkcmF3im59LGY9ZS5zY3JvbGwmLdQCO2UuZHJhdygpO2cuZmxpcCgpO6tlAGc=");
  base64DecodeToExistingUint8Array(bufferView, 169216, "alXqH0ItwEdCXwAEliQWcwNTBgOHBAAAABAAEAIgx0ESRCAAkj11UpVUFXP6HQAA3yVkWnY0qRqWJAAAAAAAAJIuABGSLiAAlixpW3pN4FtaLQAA/lclWbV7JVs+VwAAT1mKeYp5anlXfwAAlWVvW29br28VVwAAe1tUW1J7UX/WVQAA7U9tSLooFRnVHwAAFwgpZAEQAXDHcQAARBDeJGV/ZSneJgAAoEQzUK1tq1TpVQYIBgCyZXpbelt/ZQBAAATrXrVVZVSjMwEAAABte70qf0d6cwAMk3eSfNZwknCTcQBwAwAEAAYABgAEAAMAQAGSCUQppxVEfSoIBChHGgSogiQA/LokBCg3GwAAAgBEIAAAhBAAAAQJRQAACUIAAIn/AQAJQgiAEEUIQCAAEAAEAAAACEccAIjJIgCQSgMfkEocgKBMIIAg9z8AQAAAAAAAAE588x3RQBQiRnkvHEGGSCLxx4giTjiHHAAAAAAAAAAADgABIJEQAhCREPQJDwAIBIEQ9AmOEAIQACABIMABAAAuEu84cZIYJaIqDyOkuggjYMYYJQRG7zjgAQAAAAAAAP+76A4QwkgCnMNPAhDeSCIQxkgiH7roHAAAAAAAAAAAEcboPBLuHCMU1hojHMYZPRLGGCHxx+ggAAAAAAAAAADOux8jMUISI9E7EiMxBhIVMkYSFS064ggBAAAAAADgIDHGjxBRRYEQlSiCCFURhAguEogEKpKPBAAA4AKOAAQgggACIEIB4DxCARAiIgLwIgIAECMCAPA8DnwAACCAAyAgAAQg7jn/PDBGFCMwfhQjMEL0Iu89FCIAAOAAREAGAABAAgDMRaI9REhSI0RwUiNESFIjTkRTI4ADAAAAAAAQAAAAEM4/6zwxxgwRMUboENE/GBAOBugPAAY=");
  base64DecodeToExistingUint8Array(bufferView, 169912, "McYYPzFGFQVRVRIJUVX1EI+oGD4AAOAAg2AADIQQABKEEAA4mIwEEJiMCjiEEAkShBAADINgAAAADAAAABAACAAQAAgAOAA+ABAACICRDQiAkFQJAGEJCARkAgCEaAceXxEoKAQgRywEwIAoH+xIKARsJx4EAAAAgABAGOADgAhPAMAQlAAAABYBAAAUAgAA7wMAAAAAAABpAwAAMgEAGlsSACwAOAAAAHz3AQA4AAAAEAAAAAAAAIAAAAgfAAAAy0EFPguiCgTAEQsIICAKEMDDBT4AAAAAAAACABEAYgAREIciCgDKHQQQihQEkIccBBByIwAQAgCROOUYkUAQBYowUB0fSJAlBCSQHZ8YUAGEBBABgHjgAAAA9xkAgAgkBYAOJAqADRjUgw4ASoANAEWACAAAAAcAgDEBAEQIkh6EEJA6HwmQGsQx0AoEAKAKHwCACgAAAAsAEAYkADAJJAAQSSkMEKkIDDhWEgABoBaAAEAvAAMAIhICZhxSAQAAVBJCCIQBpRSLEuccKaEYI3LFGCMzOgAAVhEAGISA4z6EEBYhSikLOc45DiExRhohMcbrPgAAQABGAWYc/3/nHBBCQgicc0IIEEJCCBBCQgj/f+ccAAAAAApYZhSOReccROUYI6TXGCMkzRgjRMUYI45F5xwAAAAAVoHADM4BFyMxghkjMaoaIzGSGiMxqhwjzgHnHAAACABKEQAYMUbIADFGLx0xqkgDMZI4HzESHyPOEWgfAAAAAMRZpQAAAEAAzjnnPCGEEArvvfc+McYYKe+99xYAAAAAgBmlGAAAAADOOecYMMYYCdB77wkQQggJ7733HAQAAABGKWUZAAAGAIwx4R2EEBcjhJAYI4SQGCPOORcdAAAAAEZZBQAAAAACzjlHHDHGCCYxxvgrMcYIMs45RxwAAAAgzChFIAAAACAxxhgtMcYYMzHGGDMxxvgs770XIAAA4CAKAAAAAAAAABEAAAARAAAAEQAAAA8AAAABAAAADgAAAAQEBAQEBAQEBB4EFRUeDAwEBAQEBAYEBAoKBAQLDg0KBgwHGBAEBAYEBAYLBCsMGxgUDAoGDAwQDAYOCh8QBAQOCAQHEAQECQoIBAgGBAQEFgQUBBUJBAwLBAQJBAwLBAQJHAkQBw8EBAkEChsEGxIWBAQEBBQEEQQeBAQEBAQeFAYGBhIOEAQEBAQEBAQLBgYECwsMEhMEBAQHCAQEFRQLBAQHBAQEBAwHBAQUBAQEBAQSGwQEBwgEBBUmCwQEBAQHCAQEBAQEBAAAAAAAAACpq8XDJymRjycpXVsqLGBeKy3HxS8xy8mCjaecT1p0aR0e1NMqKzpVU0VEUF1rbHuWo7zHxrecnqytoZSGhXZbTjUuMMXDKCo4Ul5dQVBFXUQpRTZBKUJdXE40lZelv8vKrr2yyrGWsqOulq/KybuhLDdQa8vNbVJGVGB2j5y3xsi9sX99lq6snpGFb1Y7HR9Eap7G7+3EnGhCGhxFbaHH7OrFn2tDKiyUkjVOiXA7VoNoaHCKgkRGrqyqrMbf3cRobYeCISPS0CosO1ZURkRQTjWcnqyuoqS9yMa3TlCenFRWpKIqLK6xy8OprERbQVRWY3yfuKuxy8OpkG1hVFZjfJekopWHhWttYSwuyshThIqknIInL0lDaoJeYG+KpKKIeniEgmknL0nHxUdBTlBda21hVFZjiG6XpKKVh4WRnpyPaoRbTlBqeHpuVFakooiJlJKDaFtdd3VcXnh2SWN5l7F1TlZwaIKKpJxBW3mPqX1UVmN8h5SSeGxtYayuyMZFSVhmgajAv6KWiJSisbytknlufZimpZmMcWJga4SeucjN2uXh0sSpdVxQKy3Ny1OknoWJU8XDJyw7VmN8bn2Ypb7Jxauvo5aIhGptYVRGQ8XDKy49S1ZHRlFqhJ+ur6Szv8rHuKqPW0I2Jyw7SWSYsb3IxautoolvVEVDxcMnL0lDam6IhKuxy8MnL0lDam6IhMXDe3+zsZeVJylqby4wzMqJhMXDJytFRKytx8OpqkJBLjClvsnGt5yRrJ6trqOvlicpdy4weczKhZHFwycpq7HLwycplZQwMs7MZK+uXcXDJymWLjDMyl3FwysuPUtmmrO/ysiur6SLcVZHRlFqhJ+uyMe4qo9bQjYnLDtWcImUkXd6blRGQ8XDsbzm24aIzMpOUF1rbXyXpKKVh4V2WycxS0fJx0VBJymenCcpoS8xyccnKcjGLC7MyjEzzMosLsjGJynNyy8xxcMnKW0vMYjJx4YnL0mrscvDqUdBGh85NtLV7+oaHNnXGh/v6tDTNzQrdXdSe33Q2PLqJylSUGBiysheX26Jo7zHraGHeXiEnqytx8a3nIJpJynFw15fbomHeXiEnqytoaO8x8a3nIJpLC7KyF5fbomjnoSHeXiEnqyuvMfGt5yCaSssRkVRxsRPNltgenVgYsrj7u3e0MTT1MheX26JysiHeXiEaVtdxcMnKUNBXV/H4Ovq0NHFKStFQycpkWBik8rIn6vFw2Nkc47PzYx+fYluW13s6mBi8e9eX258h3l4hGleX258iHl4hHeFhpWjvMfGt6mdrK2hrqCfkIJpKCqfra7Ix7idW12erK2hYGLKyLu8x8a3nFtdoGFjyMZbXcjGYGLMymVnzMqVyMZbXcvJYWPFw2JkyOHs69HSxltdrsdbYnyssMrDqXl1HyA6OUVfeISSrcfV1vDv4MWrkJ6PdWp2XUMqGhzs6hobKkVfemx7laCUrcfg6+rQ0cWrkoZ4XUM1NFFcdYKEd2t5lKOYf3JwfYl7YCwvPldIR1JrhaCvsKXAy8i5q5BcQzdocH11goqXj0FDXVt1d9/dUVJhfHpsa3eRn6CUlq+6uaqPdVxERcfGKyw7SVRGRVGSq7HLw6mQTzZoboiCQk5cdZCcqp6tlJKEal5gboiUraKwpJZ9YlZIVEVQdn6Lg5CYpZ2PkezqGhx3dSstR0UrLz5MZ5u0wMu+s5pmSzw4Q1yQq7q+y8e4qo9bQjZGSFdycGJgbIaUloqMpbCun4RqUV5shKCsgmFvh6OvhWhwsa+IgisvPDhDXJCrur7Lx7iqj1tCNi88S2aas77LwLSbZ0w+REhkfoqysIiWlHp8YmCurCcvSUE3OaGfqbHLw1tjfXUpK1BOnLjs6oKEnpzExdPg7Ord3tLf0V9rh5+tiVxohJyqhi8xxsQpKl5fbGlcXTZCNYqLzMuKi7CzwLyviYuZpr7Azcq9pZiWKCo4RVFEUl9raVxeUVBDRDc1eHqUoJ+ruMbIvL7X4uDRtqmQhURGYF4DBSAfBQcfHgQGIiASHhwEDxwRIBUIEwIEHhwGCCIgBAYULjo5HSwhOSAFIRIdBR45OCoQLDNNSXBzjYqxtc/Jop+GiEcuxcPIydfk8O7h4tbj1QIEHx4EBh4dAwUhHxEdGwEDHRsFByEfAAIdHAIEHBsoLEZFra7IxKqrQ0ICBCAeEBwaAAIcGgQGIB4oLTxKZZmyvsnGrK6jinBVRkTGxAQGISBCTrCkSFaqnDAyxcMnKZGcJylDRlVwiqOuq5GUiG5gXcXDKis6VWJue5exvcjGrK6ilXlsYFNFRFDFw041KStGRSosREMqLEhGOERCKjVCN0Y7LjkoKkRCLC5IRh0fLUdTUjZFOlI5HjorNh43UlFDKV5fbmNkc46oo4mMfn2Jo7GzwczLvMfFqZyEh6Gfq56sraGHeXdpxsfV4u7s3+DU4dNcXsbEJylEQygqQkFdX8fFKStHRTdDQSk1RF+JfFQ4LDpdT5KUrqxgYsXDKy1FRCcp7OotL0lHAAAAAAABAgMEBQYHCAkKCwwNAg4PEBESExQVFgAXGBkaGxwdGB4YGR8gGSEhGRgaIiMYGSQZGCUAFSYnKCkqKywYLS4vMDEyMzQwNTY3ODk6Ozw9Pjw/PUAYGUFCN0NERUZHSElKS0xNTk9QUFFSUFNUVVZXUFhRWVpbXF1RWFleWFlQUF9QYGFZYmNWZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7R3x9Wn5/gIGCg4SFhocLiImKi4xkjY6PkJGSk5GUkpGTlZaXmC6ZLpoumy6cnS6eLp8woDKhMqIyozKkpTamNqeoqaiqq6wWO5utPJk8mjybPJydPK6vsDyYsTeisTeasTecnbE3R5mys7RPULVPULZPULdPULi5T1BPULq7UrxUtFS1VLZUuLm9vlm/wMHAWn5QwsO3WFlQtFC1ULZQt1C4uROXxFDFZLRktWS2ZLi5aWrGx1BpalzIAAAAAAACAgQCAwEBAQEDAgEBAQEEAQIDAQMEAQMDAgIBAgEDAQEBAQEBAQIBAQEBAQEBAQECAgMBAgEBAgEBAQEBAQEBAgIBAgECAgICAgEBAwIBAgICAQIBAQECAgEBAQEBAAM=");
  base64DecodeToExistingUint8Array(bufferView, 173264, "AgICAQMCAAICAAIBAAMBAQMAAAECAAEBAAACAwMDAgICAgIDAgECAgICAwICAgMCAgICAgIDAgIDAwMEAgEBAwMDAwQDAQICAgIDAgICAwMDAgICAgMDAgICAgMDAgQABCEUpRznDGMAAAAAAAAAAJgvikKRRDdxz/vAtaXbtelbwlY58RHxWaSCP5LVXhyrmKoH2AFbgxK+hTEkw30MVXRdvnL+sd6Apwbcm3Txm8HBaZvkhke+78adwQ/MoQwkbyzpLaqEdErcqbBc2oj5dlJRPphtxjGoyCcDsMd/Wb/zC+DGR5Gn1VFjygZnKSkUhQq3JzghGy78bSxNEw04U1RzCmW7Cmp2LsnCgYUscpKh6L+iS2YaqHCLS8KjUWzHGeiS0SQGmdaFNQ70cKBqEBbBpBkIbDceTHdIJ7W8sDSzDBw5SqrYTk/KnFvzby5o7oKPdG9jpXgUeMiECALHjPr/vpDrbFCk96P5vvJ4ccaA");
  base64DecodeToExistingUint8Array(bufferView, 173696, "Iq4o15gvikLNZe8jkUQ3cS87TezP+8C1vNuJgaXbtek4tUjzW8JWORnQBbbxEfFZm08Zr6SCP5IYgW3a1V4cq0ICA6OYqgfYvm9wRQFbgxKMsuROvoUxJOK0/9XDfQxVb4l78nRdvnKxlhY7/rHegDUSxyWnBtyblCZpz3Txm8HSSvGewWmb5OMlTziGR77vtdWMi8adwQ9lnKx3zKEMJHUCK1lvLOktg+SmbqqEdErU+0G93KmwXLVTEYPaiPl2q99m7lJRPpgQMrQtbcYxqD8h+5jIJwOw5A7vvsd/Wb/Cj6g98wvgxiWnCpNHkafVb4ID4FFjygZwbg4KZykpFPwv0kaFCrcnJskmXDghGy7tKsRa/G0sTd+zlZ0TDThT3mOvi1RzCmWosnc8uwpqduau7UcuycKBOzWCFIUscpJkA/FMoei/ogEwQrxLZhqokZf40HCLS8IwvlQGo1FsxxhS79YZ6JLREKllVSQGmdYqIHFXhTUO9LjRuzJwoGoQyNDSuBbBpBlTq0FRCGw3Hpnrjt9Md0gnqEib4bW8sDRjWsnFswwcOcuKQeNKqthOc+Njd0/KnFujuLLW828uaPyy713ugo90YC8XQ29jpXhyq/ChFHjIhOw5ZBoIAseMKB5jI/r/vpDpvYLe62xQpBV5xrL3o/m+K1Ny4/J4ccacYSbqzj4nygfCwCHHuIbRHuvgzdZ92up40W7uf0999bpvF3KqZ/AGppjIosV9YwquDfm+BJg/ERtHHBM1C3EbhH0EI/V32yiTJMdAe6vKMry+yRUKvp48TA0QnMRnHUO2Qj7LvtTFTCp+ZfycKX9Z7PrWOqtvy18XWEdKjBlEbIA=");
  base64DecodeToExistingUint8Array(bufferView, 174464, "AQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAbAAAANg==");
  base64DecodeToExistingUint8Array(bufferView, 174512, "Y3x3e/Jrb8UwAWcr/terdsqCyX36WUfwrdSir5ykcsC3/ZMmNj/3zDSl5fFx2DEVBMcjwxiWBZoHEoDi6yeydQmDLBobblqgUjvWsynjL4RT0QDtIPyxW2rLvjlKTFjP0O+q+0NNM4VF+QJ/UDyfqFGjQI+SnTj1vLbaIRD/89LNDBPsX5dEF8Snfj1kXRlzYIFP3CIqkIhG7rgU3l4L2+AyOgpJBiRcwtOsYpGV5HnnyDdtjdVOqWxW9Opleq4IunglLhymtMbo3XQfS72LinA+tWZIA/YOYTVXuYbBHZ7h+JgRadmOlJseh+nOVSjfjKGJDb/mQmhBmS0PsFS7FlH0p1B+QWVTGhekwzonXpY7q2vLH51F8az6WKtL4wOTIDD6Va12bfaIzHaR9QJMJU/l1/zFKsvXJjVEgLVio4/esVpJJbobZ0XqDphd/sDhwy91AoFM8BKNRpeja9P5xgOPX+cVkpyVv21665VSWdrUvoMtWHQh00ngaSmOychEdcKJavSOeXiZWD5rJ7lx3b7hT7bwiK0XySCsZn3OOrRj30oY5RoxgpdRM2BiU39FsWR34LtrroT+gaAc+QgrlHBIaFiPRf0ZlN5sh1J7+Lerc9MjcksC4uMfj1dmVasqsusoBy+1wgOGxXua0zcIpTAoh/Ijv6WyAgNquu0WglyKzxwrp3m0kvMH8vBOaeKhZdr0zQYFvtXRNGIfxKb+ijQuU52i81WgBYrhMqT263ULg+w5QGDvql5xnwa9bhBRPiGK+ZbdBj3dPgWuTea9RpFUjbVxxF0FBAbUb2BQFf8ZmPsk1r3pl4lAQ8xn2Z53sOhCvQeJi4jnGVs4ecju26F8Ckd8Qg/p+IQeyQAAAAAJgIaDMivtSB4RcKxsWnJO/Q7/+w+FOFY9rtUeNi05JwoP2WRoXKYhm1tU0SQ2LjoMCmexk1fnD7TultIbm5GegMDFT2HcIKJad0tpHBIaFuKTugrAoCrlPCLgQxIbFx0OCQ0L8ovHrS22qLkUHqnIV/EZha91B0zumd27o39g/fcBJp9ccvW8RGY7xVv7fjSLQyl2yyPG3Lbt/Gi45PFj1zHcykJjhRATlyJAhMYRIIVKJH3Suz34rvkyEccpoW0dni9L3LIw8w2GUux3wePQK7MWbKlwuZkRlEj6R+lkIqj8jMSg8D8aVn0s2CIzkO+HSU7H2TjRwYzKov6Y1As2pvWBz6V63ijat44mP62/pCw6neRQeJINal/Mm1R+RmL2jRPCkNi46C45916Cw6/1n12AvmnQk3xv1S2pzyUSs8ismTsQGH2n6Jxjbts7u3vNJngJblkY9OyatwGDT5qo5pVuZar/5n4hvM8I7xXo5rrnm9lKbzbO6p8J1CmwfNYxpLKvKj8jMcallDA1ombAdE68N/yCyqbgkNCwM6fYFfEEmEpB7Nr3f81QDheR9i92TdaNQ++wTcyqTVTklgTfntG140xqiBvBLB+4RmVRf51e6gQBjDVd+od0c/sLQS6zZx1aktvSUukQVjNt1kcTmtdhjDehDHpZ+BSO6xM8ic6pJ+63Yck14Rzl7XpHsTyc0t9ZVfJzPxgUznlzxze/U/fN6l/9qlvfPW8UeETbhsqv84G5aMQ+OCQ0LMKjQF8WHcNyvOIlDCg8SYv/DZVBOagBcQgMs97YtOScZFbBkHvLhGHVMrZwSGxcdNC4V0JQUfSnU35BZcMaF6SWOideyzura/EfnUWrrPpYk0vjA1UgMPr2rXZtkYjMdiX1Akz8T+XX18Uqy4AmNUSPtWKjSd6xWmcluhuYReoO4V3+wALDL3USgUzwo41Gl8Zr0/nnA49flRWSnOu/bXralVJZLdS+g9NYdCEpSeBpRI7JyGp1wol49I55a5lYPt0nuXG2vuFPF/CIrWbJIKy0fc46GGPfSoLlGjFgl1EzRWJTf+CxZHeEu2uuHP6BoJT5CCtYcEhoGY9F/YeU3my3Unv4I6tz0+JySwJX4x+PKmZVqwey6ygDL7XCmobFe6XTNwjyMCiHsiO/pboCA2pc7RaCK4rPHJKnebTw8wfyoU5p4s1l2vTVBgW+H9E0YorEpv6dNC5ToKLzVTIFiuF1pPbrOQuD7KpAYO8GXnGfUb1uEPk+IYo9lt0Grt0+BUZN5r21kVSNBXHEXW8EBtT/YFAVJBmY+5fWvenMiUBDd2fZnr2w6EKIB4mLOOcZW9t5yO5HoXwK6XxCD8n4hB4AAAAAgwmAhkgyK+2sHhFwTmxacvv9Dv9WD4U4Hj2u1Sc2LTlkCg/ZIWhcptGbW1Q6JDYusQwKZw+TV+fStO6WnhubkU+AwMWiYdwgaVp3SxYcEhoK4pO65cCgKkM8IuAdEhsXCw4JDa3yi8e5LbaoyBQeqYVX8RlMr3UHu+6Z3f2jf2Cf9wEmvFxy9cVEZjs0W/t+dotDKdzLI8Zotu38Y7jk8crXMdwQQmOFQBOXIiCExhF9hUok+NK7PRGu+TJtxymhSx2eL/PcsjDsDYZS0HfB42wrsxaZqXC5+hGUSCJH6WTEqPyMGqDwP9hWfSzvIjOQx4dJTsHZONH+jMqiNpjUC8+m9YEopXreJtq3jqQ/rb/kLDqdDVB4kptqX8xiVH5GwvaNE+iQ2LheLjn39YLDr76fXYB8adCTqW/VLbPPJRI7yKyZpxAYfW7onGN72zu7Cc0mePRuWRgB7Jq3qINPmmXmlW5+qv/mCCG8z+bvFejZuuebzkpvNtTqnwnWKbB8rzGksjEqPyMwxqWUwDWiZjd0Trym/ILKsOCQ0BUzp9hK8QSY90Hs2g5/zVAvF5H2jXZN1k1D77BUzKpN3+SWBOOe0bUbTGqIuMEsH39GZVEEnV7qXQGMNXP6h3Qu+wtBWrNnHVKS29Iz6RBWE23WR4ya12F6N6EMjln4FInrEzzuzqknNbdhye3hHOU8ekexWZzS3z9V8nN5GBTOv3PHN+pT981bX/2qFN89b4Z4RNuByq/zPrloxCw4JDRfwqNAchYdwwy84iWLKDxJQf8NlXE5qAHeCAyznNi05JBkVsFhe8uEcNUytnRIbFxC0LhXp1BR9GVTfkGkwxoXXpY6J2vLO6tF8R+dWKus+gOTS+P6VSAwbfatdnaRiMxMJfUC1/xP5cvXxSpEgCY1o4+1YlpJ3rEbZyW6DphF6sDhXf51AsMv8BKBTJejjUb5xmvTX+cDj5yVFZJ6679tWdqVUoMt1L4h01h0aSlJ4MhEjsmJanXCeXj0jj5rmVhx3Se5T7a+4a0X8IisZskgOrR9zkoYY98xguUaM2CXUX9FYlN34LFkroS7a6Ac/oErlPkIaFhwSP0Zj0Vsh5Te+LdSe9Mjq3MC4nJLj1fjH6sqZlUoB7LrwgMvtXuahsUIpdM3h/IwKKWyI79qugIDglztFhwris+0kqd58vDzB+KhTmn0zWXavtUGBWIf0TT+isSmU500LlWgovPhMgWK63Wk9uw5C4PvqkBgnwZecRBRvW6K+T4hBj2W3QWu3T69Rk3mjbWRVF0FccTUbwQGFf9gUPskGZjpl9a9Q8yJQJ53Z9lCvbDoi4gHiVs45xnu23nICkehfA/pfEIeyfiEAAAAAIaDCYDtSDIrcKweEXJObFr/+/0OOFYPhdUePa45JzYt2WQKD6YhaFxU0ZtbLjokNmexDArnD5NXltK07pGeG5vFT4DAIKJh3EtpWncaFhwSugrikyrlwKDgQzwiFx0SGw0LDgnHrfKLqLkttqnIFB4ZhVfxB0yvdd277plg/aN/Jp/3AfW8XHI7xURmfjRb+yl2i0PG3Msj/Gi27fFjuOTcytcxhRBCYyJAE5cRIITGJH2FSj340rsyEa75oW3HKS9LHZ4w89yyUuwNhuPQd8EWbCuzuZmpcEj6EZRkIkfpjMSo/D8aoPAs2FZ9kO8iM07Hh0nRwdk4ov6Mygs2mNSBz6b13iileo4m2re/pD+tneQsOpINUHjMm2pfRmJUfhPC9o246JDY914uOa/1gsOAvp9dk3xp0C2pb9USs88lmTvIrH2nEBhjbuicu3vbO3gJzSYY9G5ZtwHsmpqog09uZeaV5n6q/88IIbzo5u8Vm9m65zbOSm8J1OqffNYpsLKvMaQjMSo/lDDGpWbANaK8N3ROyqb8gtCw4JDYFTOnmErxBNr3QexQDn/N9i8XkdaNdk2wTUPvTVTMqgTf5Ja1457RiBtMah+4wSxRf0Zl6gSdXjVdAYx0c/qHQS77Cx1as2fSUpLbVjPpEEcTbdZhjJrXDHo3oRSOWfg8iesTJ+7Oqck1t2Hl7eEcsTx6R99ZnNJzP1XyznkYFDe/c8fN6lP3qltf/W8U3z3bhnhE84HKr8Q+uWg0LDgkQF/Co8NyFh0lDLziSYsoPJVB/w0BcTmos94IDOSc2LTBkGRWhGF7y7Zw1TJcdEhsV0LQuPSnUFFBZVN+F6TDGideljqra8s7nUXxH/pYq6zjA5NLMPpVIHZt9q3MdpGIAkwl9eXX/E8qy9fFNUSAJmKjj7WxWkneuhtnJeoOmEX+wOFdL3UCw0zwEoFGl6ON0/nGa49f5wOSnJUVbXrrv1JZ2pW+gy3UdCHTWOBpKUnJyESOwolqdY55ePRYPmuZuXHdJ+FPtr6IrRfwIKxmyc46tH3fShhjGjGC5VEzYJdTf0ViZHfgsWuuhLuBoBz+CCuU+UhoWHBF/RmP3myHlHv4t1Jz0yOrSwLich+PV+NVqypm6ygHsrXCAy/Fe5qGNwil0yiH8jC/pbIjA2q6AhaCXO3PHCuKebSSpwfy8PNp4qFO2vTNZQW+1QY0Yh/Rpv6KxC5TnTTzVaCiiuEyBfbrdaSD7DkLYO+qQHGfBl5uEFG9IYr5Pt0GPZY+Ba7d5r1GTVSNtZHEXQVxBtRvBFAV/2CY+yQZvemX1kBDzInZnndn6EK9sImLiAcZWzjnyO7beXwKR6FCD+l8hB7J+AAAAACAhoMJK+1IMhFwrB5ack5sDv/7/YU4Vg+u1R49LTknNg/ZZApcpiFoW1TRmzYuOiQKZ7EMV+cPk+6W0rSbkZ4bwMVPgNwgomF3S2laEhoWHJO6CuKgKuXAIuBDPBsXHRIJDQsOi8et8raouS0eqcgU8RmFV3UHTK+Z3bvuf2D9owEmn/dy9bxcZjvFRPt+NFtDKXaLI8bcy+38aLbk8WO4MdzK12OFEEKXIkATxhEghEokfYW7PfjS+TIRrimhbceeL0sdsjDz3IZS7A3B49B3sxZsK3C5mamUSPoR6WQiR/yMxKjwPxqgfSzYVjOQ7yJJTseHONHB2cqi/ozUCzaY9YHPpnreKKW3jibarb+kPzqd5Cx4kg1QX8yban5GYlSNE8L22LjokDn3Xi7Dr/WCXYC+n9CTfGnVLalvJRKzz6yZO8gYfacQnGNu6Du7e9smeAnNWRj0bpq3AexPmqiDlW5l5v/mfqq8zwghFejm7+eb2bpvNs5KnwnU6rB81imksq8xPyMxKqWUMMaiZsA1Trw3dILKpvyQ0LDgp9gVMwSYSvHs2vdBzVAOf5H2LxdN1o1277BNQ6pNVMyWBN/k0bXjnmqIG0wsH7jBZVF/Rl7qBJ2MNV0Bh3Rz+gtBLvtnHVqz29JSkhBWM+nWRxNt12GMmqEMejf4FI5ZEzyJ66kn7s5hyTW3HOXt4UexPHrS31mc8nM/VRTOeRjHN79z983qU/2qW189bxTfRNuGeK/zgcpoxD65JDQsOKNAX8Idw3IW4iUMvDxJiygNlUH/qAFxOQyz3gi05JzYVsGQZMuEYXsytnDVbFx0SLhXQtDGY2Ol+Hx8hO53d5n2e3uN//LyDdZra73eb2+xkcXFVGAwMFACAQEDzmdnqVYrK33n/v4ZtdfXYk2rq+bsdnaaj8rKRR+Cgp2JyclA+n19h+/6+hWyWVnrjkdHyfvw8AtBra3ss9TUZ1+iov1Fr6/qI5ycv1OkpPfkcnKWm8DAW3W3t8Lh/f0cPZOTrkwmJmpsNjZafj8/QfX39wKDzMxPaDQ0XFGlpfTR5eU0+fHxCOJxcZOr2NhzYjExUyoVFT8IBAQMlcfHUkYjI2Wdw8NeMBgYKDeWlqEKBQUPL5qatQ4HBwkkEhI2G4CAm9/i4j3N6+smTicnaX+yss3qdXWfEgkJGx2Dg55YLCx0NBoaLjYbGy3cbm6ytFpa7lugoPukUlL2djs7TbfW1mF9s7POUikpe93j4z5eLy9xE4SEl6ZTU/W50dFoAAAAAMHt7SxAICBg4/z8H3mxsci2W1vt1Gpqvo3Ly0Znvr7Zcjk5S5RKSt6YTEzUsFhY6IXPz0q70NBrxe/vKk+qquXt+/sWhkNDxZpNTddmMzNVEYWFlIpFRc/p+fkQBAICBv5/f4GgUFDweDw8RCWfn7pLqKjjolFR812jo/6AQEDABY+Pij+Skq0hnZ28cDg4SPH19QRjvLzfd7a2wa/a2nVCISFjIBAQMOX//xr98/MOv9LSbYHNzUwYDAwUJhMTNcPs7C++X1/hNZeXoohERMwuFxc5k8TEV1Wnp/L8fn6Cej09R8hkZKy6XV3nMhkZK+Zzc5XAYGCgGYGBmJ5PT9Gj3Nx/RCIiZlQqKn47kJCrC4iIg4xGRsrH7u4pa7i40ygUFDyn3t55vF5e4hYLCx2t29t22+DgO2QyMlZ0OjpOFAoKHpJJSdsMBgYKSCQkbLhcXOSfwsJdvdPTbkOsrO/EYmKmOZGRqDGVlaTT5OQ38nl5i9Xn5zKLyMhDbjc3WdptbbcBjY2MsdXVZJxOTtJJqang2GxstKxWVvrz9PQHz+rqJcplZa/0enqOR66u6RAICBhvurrV8Hh4iEolJW9cLi5yOBwcJFempvFztLTHl8bGUcvo6COh3d186HR0nD4fHyGWS0vdYb293A2Li4YPioqF4HBwkHw+PkJxtbXEzGZmqpBISNgGAwMF9/b2ARwODhLCYWGjajU1X65XV/lpubnQF4aGkZnBwVg6HR0nJ56eudnh4Tjr+PgTK5iYsyIRETPSaWm7qdnZcAeOjokzlJSnLZubtjweHiIVh4eSyenpIIfOzkmqVVX/UCgoeKXf33oDjIyPWaGh+AmJiYAaDQ0XZb+/2tfm5jGEQkLG0GhouIJBQcMpmZmwWi0tdx4PDxF7sLDLqFRU/G27u9YsFhY6pcZjY4T4fHyZ7nd3jfZ7ew3/8vK91mtrsd5vb1SRxcVQYDAwAwIBAanOZ2d9VisrGef+/mK119fmTaurmux2dkWPysqdH4KCQInJyYf6fX0V7/r667JZWcmOR0cL+/Dw7EGtrWez1NT9X6Ki6kWvr78jnJz3U6SkluRyclubwMDCdbe3HOH9/a49k5NqTCYmWmw2NkF+Pz8C9ff3T4PMzFxoNDT0UaWlNNHl5Qj58fGT4nFxc6vY2FNiMTE/KhUVDAgEBFKVx8dlRiMjXp3DwygwGBihN5aWDwoFBbUvmpoJDgcHNiQSEpsbgIA93+LiJs3r62lOJyfNf7Kyn+p1dRsSCQmeHYODdFgsLC40GhotNhsbstxubu60Wlr7W6Cg9qRSUk12Oztht9bWzn2zs3tSKSk+3ePjcV4vL5cThIT1plNTaLnR0QAAAAAswe3tYEAgIB/j/PzIebGx7bZbW77UampGjcvL2We+vktyOTnelEpK1JhMTOiwWFhKhc/Pa7vQ0CrF7+/lT6qqFu37+8WGQ0PXmk1NVWYzM5QRhYXPikVFEOn5+QYEAgKB/n9/8KBQUER4PDy6JZ+f40uoqPOiUVH+XaOjwIBAQIoFj4+tP5KSvCGdnUhwODgE8fX132O8vMF3trZ1r9raY0IhITAgEBAa5f//Dv3z822/0tJMgc3NFBgMDDUmExMvw+zs4b5fX6I1l5fMiEREOS4XF1eTxMTyVaengvx+fkd6PT2syGRk57pdXSsyGRmV5nNzoMBgYJgZgYHRnk9Pf6Pc3GZEIiJ+VCoqqzuQkIMLiIjKjEZGKcfu7tNruLg8KBQUeafe3uK8Xl4dFgsLdq3b2zvb4OBWZDIyTnQ6Oh4UCgrbkklJCgwGBmxIJCTkuFxcXZ/Cwm6909PvQ6yspsRiYqg5kZGkMZWVN9Pk5IvyeXky1efnQ4vIyFluNze32m1tjAGNjWSx1dXSnE5O4EmpqbTYbGz6rFZWB/P09CXP6uqvymVljvR6eulHrq4YEAgI1W+6uojweHhvSiUlclwuLiQ4HBzxV6amx3O0tFGXxsYjy+jofKHd3ZzodHQhPh8f3ZZLS9xhvb2GDYuLhQ+KipDgcHBCfD4+xHG1tarMZmbYkEhIBQYDAwH39vYSHA4Oo8JhYV9qNTX5rldX0Gm5uZEXhoZYmcHBJzodHbknnp442eHhE+v4+LMrmJgzIhERu9JpaXCp2dmJB46OpzOUlLYtm5siPB4ekhWHhyDJ6elJh87O/6pVVXhQKCh6pd/fjwOMjPhZoaGACYmJFxoNDdplv78x1+bmxoRCQrjQaGjDgkFBsCmZmXdaLS0RHg8Py3uwsPyoVFTWbbu7OiwWFmOlxmN8hPh8d5nud3uN9nvyDf/ya73Wa2+x3m/FVJHFMFBgMAEDAgFnqc5nK31WK/4Z5/7XYrXXq+ZNq3aa7HbKRY/Kgp0fgslAicl9h/p9+hXv+lnrsllHyY5H8Av78K3sQa3UZ7PUov1foq/qRa+cvyOcpPdTpHKW5HLAW5vAt8J1t/0c4f2Trj2TJmpMJjZabDY/QX4/9wL198xPg8w0XGg0pfRRpeU00eXxCPnxcZPicdhzq9gxU2IxFT8qFQQMCATHUpXHI2VGI8NencMYKDAYlqE3lgUPCgWatS+aBwkOBxI2JBKAmxuA4j3f4usmzesnaU4nss1/snWf6nUJGxIJg54dgyx0WCwaLjQaGy02G26y3G5a7rRaoPtboFL2pFI7TXY71mG31rPOfbMpe1Ip4z7d4y9xXi+ElxOEU/WmU9FoudEAAAAA7SzB7SBgQCD8H+P8sch5sVvttltqvtRqy0aNy77ZZ745S3I5St6USkzUmExY6LBYz0qFz9Bru9DvKsXvquVPqvsW7ftDxYZDTdeaTTNVZjOFlBGFRc+KRfkQ6fkCBgQCf4H+f1DwoFA8RHg8n7oln6jjS6hR86JRo/5do0DAgECPigWPkq0/kp28IZ04SHA49QTx9bzfY7y2wXe22nWv2iFjQiEQMCAQ/xrl//MO/fPSbb/SzUyBzQwUGAwTNSYT7C/D7F/hvl+XojWXRMyIRBc5LhfEV5PEp/JVp36C/H49R3o9ZKzIZF3nul0ZKzIZc5Xmc2CgwGCBmBmBT9GeT9x/o9wiZkQiKn5UKpCrO5CIgwuIRsqMRu4px+6402u4FDwoFN55p95e4rxeCx0WC9t2rdvgO9vgMlZkMjpOdDoKHhQKSduSSQYKDAYkbEgkXOS4XMJdn8LTbr3TrO9DrGKmxGKRqDmRlaQxleQ30+R5i/J55zLV58hDi8g3WW43bbfabY2MAY3VZLHVTtKcTqngSalstNhsVvqsVvQH8/TqJc/qZa/KZXqO9Hqu6UeuCBgQCLrVb7p4iPB4JW9KJS5yXC4cJDgcpvFXprTHc7TGUZfG6CPL6N18od10nOh0HyE+H0vdlku93GG9i4YNi4qFD4pwkOBwPkJ8PrXEcbVmqsxmSNiQSAMFBgP2Aff2DhIcDmGjwmE1X2o1V/muV7nQabmGkReGwViZwR0nOh2euSee4TjZ4fgT6/iYsyuYETMiEWm70mnZcKnZjokHjpSnM5Sbti2bHiI8HoeSFYfpIMnpzkmHzlX/qlUoeFAo33ql34yPA4yh+FmhiYAJiQ0XGg2/2mW/5jHX5kLGhEJouNBoQcOCQZmwKZktd1otDxEeD7DLe7BU/KhUu9ZtuxY6LBZjY6XGfHyE+Hd3me57e4328vIN/2trvdZvb7HexcVUkTAwUGABAQMCZ2epzisrfVb+/hnn19ditaur5k12dprsyspFj4KCnR/JyUCJfX2H+vr6Fe9ZWeuyR0fJjvDwC/utrexB1NRns6Ki/V+vr+pFnJy/I6Sk91NycpbkwMBbm7e3wnX9/Rzhk5OuPSYmakw2NlpsPz9Bfvf3AvXMzE+DNDRcaKWl9FHl5TTR8fEI+XFxk+LY2HOrMTFTYhUVPyoEBAwIx8dSlSMjZUbDw16dGBgoMJaWoTcFBQ8Kmpq1LwcHCQ4SEjYkgICbG+LiPd/r6ybNJydpTrKyzX91dZ/qCQkbEoODnh0sLHRYGhouNBsbLTZubrLcWlrutKCg+1tSUvakOztNdtbWYbezs859KSl7UuPjPt0vL3FehISXE1NT9abR0Wi5AAAAAO3tLMEgIGBA/Pwf47GxyHlbW+22amq+1MvLRo2+vtlnOTlLckpK3pRMTNSYWFjosM/PSoXQ0Gu77+8qxaqq5U/7+xbtQ0PFhk1N15ozM1VmhYWUEUVFz4r5+RDpAgIGBH9/gf5QUPCgPDxEeJ+fuiWoqONLUVHzoqOj/l1AQMCAj4+KBZKSrT+dnbwhODhIcPX1BPG8vN9jtrbBd9rada8hIWNCEBAwIP//GuXz8w790tJtv83NTIEMDBQYExM1JuzsL8NfX+G+l5eiNUREzIgXFzkuxMRXk6en8lV+foL8PT1HemRkrMhdXee6GRkrMnNzleZgYKDAgYGYGU9P0Z7c3H+jIiJmRCoqflSQkKs7iIiDC0ZGyozu7inHuLjTaxQUPCje3nmnXl7ivAsLHRbb23at4OA72zIyVmQ6Ok50CgoeFElJ25IGBgoMJCRsSFxc5LjCwl2f09Nuvays70NiYqbEkZGoOZWVpDHk5DfTeXmL8ufnMtXIyEOLNzdZbm1tt9qNjYwB1dVksU5O0pypqeBJbGy02FZW+qz09Afz6uolz2Vlr8p6eo70rq7pRwgIGBC6utVveHiI8CUlb0ouLnJcHBwkOKam8Ve0tMdzxsZRl+joI8vd3XyhdHSc6B8fIT5LS92Wvb3cYYuLhg2KioUPcHCQ4D4+Qny1tcRxZmaqzEhI2JADAwUG9vYB9w4OEhxhYaPCNTVfaldX+a65udBphoaRF8HBWJkdHSc6np65J+HhONn4+BPrmJizKxERMyJpabvS2dlwqY6OiQeUlKczm5u2LR4eIjyHh5IV6ekgyc7OSYdVVf+qKCh4UN/feqWMjI8DoaH4WYmJgAkNDRcav7/aZebmMddCQsaEaGi40EFBw4KZmbApLS13Wg8PER6wsMt7VFT8qLu71m0WFjosUglq1TA2pTi/QKOegfPX+3zjOYKbL/+HNI5DRMTe6ctUe5QypsIjPe5MlQtC+sNOCC6hZijZJLJ2W6JJbYvRJXL49mSGaJgW1KRczF1ltpJscEhQ/e252l4VRlenjZ2EkNirAIy80wr35FgFuLNFBtAsHo/KPw8Cwa+9AwETims6kRFBT2fc6pfyz87wtOZzlqx0IuetNYXi+TfoHHXfbkfxGnEdKcWJb7diDqoYvhv8Vj5LxtJ5IJrbwP54zVr0H92oM4gHxzGxEhBZJ4DsX2BRf6kZtUoNLeV6n5PJnO+g4DtNrir1sMjruzyDU5lhFysEfrp31ibhaRRjVSEMfQIAAAABAAAAgAAAAG5UAAAQAAAAAAAAABAAAACozAIAAwAAAAEAAADAAAAAhlQAABAAAAAAAAAAEAAAAKjMAgAEAAAAAQAAAAABAAB6VAAAEAAAAAAAAAAQAAAAqMwCACsAAAAIAAAAgAAAAPJSAAAMAAAAAQAAABAAAADAzAIALAAAAAgAAADAAAAAClMAAAwAAAABAAAAEAAAAMDMAgAtAAAACAAAAAABAAD+UgAADAAAAAEAAAAQAAAAwMwCAAIAAACwywIAAwAAANDLAgAEAAAA8MsCACsAAAAQzAIALAAAADDMAgAtAAAAUMwC");
  base64DecodeToExistingUint8Array(bufferView, 183464, "AgAAAHACAABxAgAAcgIAAHMCAAB0AgAAAgAAAAAAAAB1AgAAdQIAAHYCAAB3Ag==");
  base64DecodeToExistingUint8Array(bufferView, 183520, "BAAABAEABAIgBAMhBAQiBAUjBAYABAcABAgABAkABAoABAsABAwABA0ABA4ABA8ABBAAFBEABBIABBMABBQABBUABBYABBcABBgABBkABBoABBsABBwkBB0lBB4mBB8nBCAABCEABCIABCMABCQABCUABCYABCcABCgABCkABCoABCsABCwABC0ABC4ABC8Au84gINKgP/+AcLg//8AOLh4ONj//4AOLn//wAOLv//M5n//wNLM4P8M5v4M5qFMM4J2MM4IOMM4KFLgP4j4OIRwUPwEH8F/CArmDnkAgfgwFABwkCAYRlBgPhEoYACgggCE4MB4QOGhCTCAQNB4g0DAAUQAQMcDgOBxA0DAAUgAQMwIAMDyAlCAAZQCSIMIgcgEoR2FgICBmEHoBnFIIUDEQUOUoMf5F/gF+oUD/EOCYUNCINAqHBgcCwkIjBYBg0AjxqBgFhgMMgcIkEYLAJVBUwNEgFCgUQAIOAiFgNgU4gGIgGEgkggkhBYKiBKoNwgMQgMIhGAhFD//BM4MIgPggUgFAMRUQOEM4OAgMogfAglAFQIpBkJFBYAMCwEGEwIBBoFCJoKbBMoME8EdIIOAmGAw0BwkQhkMHQNgnSrBwGhgMGgsIiEwQoMUoFn/0A/x2Bg/yiEf4EYgEngJrBAAkEAYSBBoDECAAjzDBwOAYgLrFToIOCZ4IRBdYrzDvACB+AOFwIFDBwMHJI38Agd8gE/JIwAEn8D/AOM//gBxd//46GAAv//4NLgP/V4IAKgf/L4gOJLBkH/6TFAA0PM5sfM5qFBwCFNBpaFBM5gOBM4I=");
  base64DecodeToExistingUint8Array(bufferView, 184144, "w1IAAMtSAAABVAAAGFQAAAMOdAEAAP8CCgEAAgAAAQIIAAIBEAADARQABAEYAAUBHAAGASAABwEkAAgBKAAJASwACgEwAAsBNAAMATgADQE8AA4BQAAPAUQAEAFIABEBTAASAVAAEwFUABQBWAAVAVwAFgFgABcBZAAYAWgAGQFsABoCcAAbAngAHAKAAB0CiAAeAZAAHwGUACACmAAhAqAAIgKoACMCsAAkA7gAJQLEACYCzAAnAtQAKAPcACkC6AAqAvAAKwL4ACwCAAEtAggBLgIQAS8CGAEwAiABMQMoATICNAEzBDwBNARMATUCXAE2AmQBNwJsATgDdAE5A4ABOgOMATsCmAE8BKABPQOwAT4DvAE/AsgBQATQAUED4AFCA+wBQwP4AUQCBAJFAgwCRgMUAkcDIAJIAiwCSQI0AkoCPAJLAkQCTAJMAk0DVAJOAmACTwJoAlADcAJRAnwCUgKEAlMCjAJUApQCVQKcAlYCpAJXAqwCWAK0AlkDvAJaA8gCWwLUAlwC3AJdAuQCXgLsAl8C9AJgAvwCYQIEA2ICDANjAhQDZAMcA2UCKANmAjADZwI4A2gCQANpAkgDagNQA2sCXANsAmQDbQJsA24CdANvAnwDcAKEA3ECjANyApQDcwKcA3QCpAN1AqwDdgK0A3cCvAN4AsQDeQLMA3oC1AN7AtwDfALkA30C7AN+AvQDfwH8A4ABAASBAAQEggEEBIMACASEAAgEhQAIBIYBCASHAQwEiAAQBIkAEASKABAEiwAQBIwAEASNABAEjgAQBI8AEASQABAEkQAQBJIAEASTARAElAAUBJUAFASWABQElwAUBJgAFASZABQEmgAUBJsAFAScABQEnQAUBJ4AFASfABQEoAAUBKEBFASiARgEowEcBKQBIASlASQEpgEoBKcBLASoATAEqQE0BKoBOASrATwErAJABK0ASASuAUgErwFMBLABUASxAVQEsgFYBLMBXAS0AWAEtQFkBLYBaAS3AWwEuAFwBLkBdAS6AngEuwGABLwBhAS9AYgEvgGMBL8BkATAAZQEwQGYBMIBnATDAqAExAGoBMUBrATGAbAExwG0BMgCuATJAsAEygHIBMsBzATMAtAEzQHYBM4B3ATPAeAE0AHkBNEB6ATSAewE0wHwBNQC9ATVAfwE1gEABdcBBAXYAQgF2QEMBdoCEAXbAhgF3AIgBd0CKAXeAjAF3wI4BeABQAXhAUQF4gFIBeMBTAXkAVAF5QFUBeYBWAXnAVwF6AFgBekBZAXqAWgF6wFsBewBcAXtAXQF7gF4Be8CfAXwAYQF8QGIBfIBjAXzAZAF9AGUBfUBmAX2AZwF9wGgBfgBpAX5AagF+gGsBfsBsAX8ArQF/QO8Bf4CyAX/AJcJ/gFBEQABpwn/AVQRAQG1CQIBwgkDAdEJBAHfCQUB8QkGAf4JBwENCggBGwoJASoKCgE4CgsBRwoMAVUKDQFkCg4BcgoPAYEKEAGUChEBpgoSAbUKEwHCChQBzwoVAd0KFgHrChcB+QoYAQcLGQEWCxgCZREaASMLGQJ3ERsBMQsaAoMRHAE/CxsCkxEdAVALHgFgCyAAAAAfAXILIQAFACABggsiAA0AIQGUCyMAFQAiAaQLJAAjACMBtgsCIr0SJQA0ACQBxgsmAEoAJQHYCycAWgAmAegLKABgACcB+QsGIssSKQBsACgBCAwqAHgAKQEYDCsAgwAqASYMLACQACsBMgwtAJYALAE8DC4AnQAtAUwMLwCjAC4BWgwwALIALwFmDDEAwAAwAXIMDyLbEjIAywAxAXsMMwDZADIBggwTIPQRESLrEjQA5wAzAZIMFCD8ERIi+RI1APYANAGiDDYABAE1AbIMNwASATYBwgw4ACABNwHTDBggBRI5AC4BOAHjDBkgCxI6ADwBOQHuDBogERI7AEMBOgH+DDwASwE7AQkNHCAXEhoiABM9AFcBPAEZDR0gHxI+AGIBPQEkDR4gJxI/AG4BPgEyDUAAfAE/AT4NICAvEh4iFhNBAI8BQAFMDSEgOhJCAJ4BQQFYDSIgSBJDAK0BQgFnDSIhoxJEALwBQwFyDUUAywFEAYENRgDZAUUBjw0mIFESRwDnAUYBoQ0mIa4SSAD2AUcBrw1JAAUCSAG+DUoADQJJAcwNSwAZAkoB2g1MACgCSwHsDU0ANgJMAfoNKyIiE04ASQJNAQgOTwBYAk4BFQ5QAGcCTwEkDjAgWRJRAHYCUAEyDlIAhwJRAUIOUwCWAlIBUg5UAKUCUwFnDlUAswJUAXYOVgDCAlUBiA5XANECVgGVDlgA5AJXAacOWQDzAlgBsw45IHQSWgADA1kBxQ46IHwSWwARA1oB0g5cABsDWwHkDl0AKgNcAfEOXgA0A10BAw9fADwDXgEQD2AAQwNfASEPYQBKA2ABLQ9iAFUDYQE/D2MAYwNiAUwPZABuA2MBWw9EIIQSZQB8A2QBZw9mAIcDZQF3D2cAkgNmAYUPaACgA2cBlQ9pAK4DaAGgD2oAtgNpAa8PSCIyE2sAwgNqAb0PbADQA2sByw9tANgDbAHYD24A5wNtAecPbwDyA24B9Q9wAP0DbwEGEHEACwRwARUQcgAZBHEBJRBzACMEcgEzEHQALQRzAUQQdQA4BHQBURB2AEMEdQFoEHcATgR2AXwQeABdBHcBjBB5AGgEeAGcEHoAdgR5AawQewCABHoBuhB8AIwEewHGEH0AlQR8AdQQfgChBH0B4BB+Ae4QfwH6EGAiPhNkIkwTZSJYE5IBBhGhAKgEogCwBKMAvgSkAM0EpQDYBKYA6ASnAPEEqAAABakABwWqABwFqwAoBawAMgWpA9kRrgA6Ba8ASgWwAFEFsQBaBbIAZQWzAG4FtAB3BbUAfgW2AIwFtwCbBbgAoQW5AKgFugCwBcP2gBO7ALwFvADGBb0A2QW+AOwFvwABBsAADwbBAB4GwgAtBsMAPAbAA+gRxABLBsUAWgbGAGwGxwB/BsgAkAbGAp8RyQCeBscCpxHKAKwGywC6BswAyAasIJMSzQDTBs4A3gbPAOkG0AD3BtEABwfSABYH0wAlB9QANAevJWQT1QBDB9YAUgfXAGEH2ABuB9kAfgfaAI0H2AKvEdsAnAfZArYR3ACrB9oCvBHdALoH2wLDEd4AygfcAsoR3wDZB90C0RHgAOgH4QD2B+IABAjjABII5AAgCOUALgjmADwI5wBLCOgAWQjpAGcI6gB1COsAgwjsAJEI7QCcCO4ApwjvALUIyiV0E/AAwwjxANEI8gDfCPMA7Qj0APsI9QAJCfYAFwn3ACUJ+AAyCfkAPwn6AE0J+wBbCfwAaQkB+4YT/QB3CfwBFhEC+5UT/gCHCf0BLREDAAABAwILAQAD//88BQQBAAZ77w0JCAAACdiw/WfD5r8NGwcNAQAIHI7vP3748OO/j8MBDAsBAA0e/GPzMxv/4H/wj83MbPyDBwgLAQAJHj8zMx7ed3Nz384CBAEAA28EDQEABcxmMzNjxgwEDQEABTNmzMxsNgMGBwEAB0z7e3/LAAgIAQIJGBgY//8YGBgCBAEJA28FAgEFBv8DAgIBCQMPBg0BAAcwjGEYwzCGYQwDBgsBAAfeP8/zPM/z7wEECwIABndmZmb2DwYLAQAH3j/DMMYYw/8DBgsBAAfeP8McB8Pz7wEHCwEACDAczzb7/2EwGAwGCwEAB/8/DN8Pw/PvAQYLAQAH3j8P3z/P8+8BBgsBAAf/D8MYhjEMwwAGCwEAB94/z543z/PvAQYLAQAH3j/Pvw/D8+8BAggBAwMP8AIKAQMDD/AGBgkBAgcwxhiDwWAwCAYBBAn//wAA//8GCQECB4PBYDDGGAMGCwEAB94/wzDGMADDAAoLAQALePhn2Nx7r7333GZ7hwEHCwEACBwOx2az+f7j8RgHCwEACL//ePz7jcfj/w8HCwEACL7/eDAYDAbjvw8HCwEACJ/feDwej8fj3wcGCwEAB/8/DN83DMP/AwYLAQAH/z8M3zcMwzAABwsBAAi+/3gwmM/H478fBwsBAAjj8Xj8/4/H4/EYAgsBAAP//z8FCwEABhhjjDHG+D8HCwEACOP5bPf57Gbz8RgGCwEAB8MwDMMwDMP/AwoLAQALAx9++PPP7733zDMPPDAHCwEACOPz+f3e7+fz8RgHCwEACL7/eDwej8fjvw8HCwEACL//eDz+/waDwQAHDQEACL7/eDwej8fzvw8MBgcLAQAIv/94PP79ZrPxGAcLAQAIvv948PDhweO/DwYLAQAH/88wDMMwDMMABwsBAAjj8Xg8Ho/H478PBwsBAAjj8fhus9l8HA4HCgsBAAsDDzzw7bb5559//DDDDAcLAQAI47HNxuFwbLbxGAgLAQAJw8PDZmY8PBgYGBgGCwEAB/8PYxjDGMb/AwMNAQAE/7Zt234GDQEAB8NgGAbDMBiGwTADDQEABL9t27Z/BgMBAAeMNwMHAgELCP8/BAMBAAVjDAYIAQMH3j/z//z7BgsBAAfDMHz/PM/z/wEGCAEDB94/D8P8ewYLAQAHMAz7/zzP8+8DBggBAwfeP///8HsECwEABez2b2ZmBgYMAQIHuPfPv3d4//x7BgsBAAfDMHz/PM/zPAMCCwEAA8//PwQOAAAEzMDMzMzMfwYLAQAHwzDM8/fN8zwDAgsBAAP//z8KCAEDC8/9P/PMM88888AGCAEDB98/z/M8zwYIAQMH3j/P8/x7BgsBAwffP8/z/D/DMAAGCwEDB/4/z/P8+zAMAwUIAQMG+58xxhgFCAEDBu7vw/d3BAsBAAVm9m9m5gwGCAEDB/M8z/P8+wYIAQMH8zx7nscwCggBAwsDDzyzbf75xwwzBggBAwfz/HveP88GCwEDB/M8z57HMMwxAAUIAQMG/zNmzP8EDQEABexmdnNm5gwCDQEAA////wMEDQEABXNm5uxmdgMFAwEABvY3AgsBAAPP/z8GDAEBBwzj/fMwzL/HMAcLAQAIOJ7DYPj9DIb/HwcGAAMH3b/N9u8CCAsBAAnDw2ZmPDz/GP8YGAINAQAD/8//AwYNAQAH3j8P3j7fHjz/HgYCAQAH8wwLCwEADPgwmJzy2dgGNjafcjIYPgAGCQEAB97M/7MP/D8HBQEECGzbxsYGBgQBBQc/CIIJCQEACnwE9WzbtmdbQXwABQIBAAb/AwUFAQAGbsftAAYIAQIHDPP/DPP/BQYBAAYuM/M/BQYBAAYPP/wfBAMBAAVsAwYLAQMH8zzP8z8PwzAABg0BAAf++77v66IoiqIoAgIBBgMPAwMACwP2AQQGAQAFd2b/BgkBAAfeP8+/B/w/BwUBBAgbG9u2AQoLAQALBBpECBEkeYYUSeIFBBAKCwEACwQaRAgRJHiDEkGCBAEeCwsBAAwMlBBEGAElmXEKScQTUIAABgsBAAcMAzAMYwzz7wEHCwEACAYMgMOx2Xz/8RgHCwEACDAGgMOx2Xz/8RgHCwEACAgOgMOx2Xz/8RgHCwEACO4dgMOx2Xz/8RgHCwEACDYbgMOx2Xz/8RgHDgEACBwKB8Dh2Gw23388HgMKCwEAC/zzz4MN9tnnww8zzD8/Bw0BAAi+/3gwGAwG478P4wAGCwEABwYG/P/wfcP/AwYLAQAHmAH8//B9w/8DBgsBAAfMDPz/8H3D/wMGCwEAB/MM/P/wfcP/AwQLAAAEw8DMzMwMBAsBAAU8MDMzMwMECwEABfZgZmZmBgYLAAAG8wwwDMMwDMMACAsBAAk+fubGz8/GxuZ+PgcLAQAI7h1gfD6/9/PxGAcLAQAIBgzA9x+Px+O/DwcLAQAIMAbA9x+Px+O/DwcLAQAICBvA9x+Px+O/DwcLAQAI7h3A9x+Px+O/DwcLAQAINhvA9x+Px+O/DwgIAQIJw+d+PDx+58MICwEACdx+ZnZ2fm5uZn47BwsBAAgGDGA8Ho/H478PBwsBAAgwBmA8Ho/H478PBwsBAAgIG2A8Ho/H478PBwsBAAg2G2A8Ho/H478PCAsBAAkwDADDw2Y8GBgYGAcLAQAIg8Hg9x//f4PBAAcLAQAIPL/ZfLuZzXabAQYLAQAHBgZ4/8z/8+8DBgsBAAeYAXj/zP/z7wMGCwEAB8wMeP/M//PvAwYLAQAHZgZ4/8z/8+8DBgsBAAfzDHj/zP/z7wMGCwEABwwDeP/M//PvAwoIAQML7v0/M+/3zPy/ewYLAQMH3j8Pw/x7AGMABgsBAAcGBnj//P/D7wEGCwEAB5gBeP/8/8PvAQYLAQAHzAx4//z/w+8BBgsBAAfzDHj//P/D7wEECwAABMNgZmZmBgQLAAAEPGBmZmYGBgsAAAbMDDAMwzAMwwAGCwAABvMMMAzDMAzDAAYLAQAHBu9h/j/P8+8BBgsBAAdmBnz/PM/zPAMGCwEABwYGeP88z/PvAQYLAQAHmAF4/zzP8+8BBgsBAAfMDHj/PM/z7wEGCwEAB2YGeP88z/PvAQYLAQAH8wx4/zzP8+8BCAgBAgkYGAD//wAYGAgIAAMIvH5mdm5mfj0GCwEABwYGzPM8z/PvAwYLAQAHmAHM8zzP8+8DBgsBAAfMDMzzPM/z7wMGCwEAB/MMzPM8z/PvAwYOAQAHmAHM8zx7HsMwxwAGDgEAB8MwDN8/z/83DMMABg4BAAfzDMzzPHsewzDHAAcKAQAIfwCHY7P5/uMxBgoBAQc/4P0z/8+/DwcLAQAIQR+Aw7HZfP/xGAYLAQAHoQd4/8z/8+8DCA0BAAkcHDY2NmN/f2NjcxDgBgoBAwfeP/P//PsEDgcLAQAIMAbA9x8PBuO/DwYLAQAHmAF4/zwM8+8BBwsBAAgIG8D3Hw8G478PBgsBAAfMDHj/PAzz7wEHCwEACBgMwPcfDwbjvw8GCwEABwwDeP88DPPvAQcLAQAINg7A9x8PBuO/DwYLAQAHMwN4/zwM8+8BBwsBAAg2DuDzG4/H498HCQwBAAqAYcOE5ePHjBkzZvzwAQcOAQAIvx/g85uPx+PxeP77AAcLAQAIMh7c95vNZrOfDwYKAQAHP/D/w/cN/w8GCgEBBz/g/fP/D78HBgsBAAehB/z/8H3D/wMGCwEAB6EHeP/8/8PvAQYLAQAHDAP8//B9w/8DBgsBAAcMA3j//P/D7wEGDQEAB/8/DN83DMP/ExgGCgEDB94////wewQGBgwBAAezxwD/P3zf8P8GDAEAB7PHAN4////wewcNAQAIHBvA9x8P5vPx+O8HBg4BAAfMDPD//HuH98+/BwcOAQAIQR/A9x8PBvP5ePz3AwYOAQAHoQf4//x7h/fPvwcHDgEACBgMwPcfDwbz+Xj89wMGDgEABwwD8P/8e4f3z78HBw4BAAi+/3gwmM/H478fwTAABg4BAAcIwfD//HuH98+/BwcOAQAIHBtgPB6P///xeDweAwYOAQAHzgYMw/D98zzP8wwHDQEACH/AeDwe///j8Xg8BgcLAAAHhp/B5zebzWazGQYOAAAGdgMwDMMwDMMwDAMGCwAABnYDMAzDMAzDAAQNAAAED2ZmZmZmBgQKAAEED2ZmZmYGDgAABqEHMAzDMAzDMAwDBgsAAAahBzAMwzAMwwAEDgAABGZmZmZmFuEEDgAABGZgZmZmFuECDgEAA8///w8CCAEDA///CAsBAAnDw8PDw8PDw8P7fwYOAQAH8wzM8zzP82zDPAcGDgEAB8wMMAzDMAzDMM8BBg4BAAfMDDAMwzAMwzDPAQcNAQAI4/ls9/nsZvPxGAMBBg4BAAfDMMzz983zPAMMAQYIAQMH87w93zzPBg4BAAeMAQzDMAzDMAz/DwMOAQAEHrZt27YBBg4BAAfDMAzDMAzD/wOMAQMOAAADtm3btuEBBgsBAAfzPE7DMAzD/wMFCwEABnvPNcYYYwwGCwEAB8MwzPMwDMP/AwULAQAGY4y9xxhjDAcLAAAHBoPB5nscDAa/HwQLAAAEZmb+Z2YGBwsBAAgwBmB8Pr/38/EYBgwBAAcYYwDfP8/zPM8HDgEACOPz+f3e7+fz8RiAYQAGCwEDB98/z/M8zwBDAAcLAQAICBtgfD6/9/PxGAYMAQAHs8cA3z/P8zzPBgwBAAfDIATeP8/zPM8HDgEACL3/eDwej8fj8RiM5wEGCwEDB98/z/M8zzPOAQcKAQAIf4DvPx6Px38fBgoBAQc/4P3zPM+/BwcLAQAIQR/A9x+Px+O/DwYLAQAHoQd4/zzP8+8BBwwBAAhIkgTg+4/H4/HfBwcMAQAISJIE4PnNZrPZzwMLCwEADP7//xjGMJ7xjGEMY/i//wEKCAEDC/79P/P8M8z8v38HDgEACBgG4Pcfj8e/32w2HgMFDAEABpgZsP8ZY4wBBw4BAAi//3g8/v1ms/EYwzAABQsBAwb7nzHGGMwMBw4BAAgzBuD3H4/Hv99sNh4DBQwBAAbbEbD/GWOMAQcOAQAIGAbA9x8PHj48ePz3AQUMAQAGmBng/j58fwcHDgEACBwbwPcfDx4+PHj89wEFDAEABsRt4P4+fH8HBw0BAAi+/3jw8OHB478PwgAFCgEDBu7vw/d3yAAHDgEACGYMwPcfDx4+PHj89wEFDAEABtsR4P4+fH8HBg0BAAf/zzAMwzAMw0EMBA4BAAVm9m9m5owXBg4BAAczA/w/wzAMwzAMAwYMAQAHsG1az2MYhuEwBg4BAAf/D/w/wzAMwzAMAwQLAQAFZvZv/+YMBwsBAAjOHGA8Ho/H478PBgsBAAdmBszzPM/z7wMHCgEACH/AeDwej8d/HwYKAQEHPzDP8zzPvw8HCwEACEEfYDwej8fjvw8GCwEAB6EHzPM8z/PvAwcNAQAIDImEARiPx+Px+O8DBg0BAAeMJDHAPM/zPP8+BwwBAAhIkgQwHo/H4/HfBwYMAQAHpJQA8zzP8/z7Bw0BAAjj8Xg8Ho/H47+PgAEGCgEDB/M8z/P8+wQOCg4BAAswMAPAwAMPfLtt/vnnHz/MMAMKDAEACzDgwQwAAw88s23++ccMMwgLAQAJGGYAw8NmPBgYGBgGDgEAB8wMzPM8ex7DMMcACAsBAAlmZgDDw2Y8GBgYGAYLAQAHmAH8P4wxxv8DBQsBAAbYgP8ZM+Z/BgsBAAcMA/w/jDHG/wMFCwEABoyB/xkz5n8GCwEABzMD/D+MMcb/AwULAQAG24H/GTPmfwULAAAF3BtjzjHGGAYOAAAGOM8wjOcxDMMwzwEKDgEAC8DAAAD//PNgg332+fDDDPPPDwoMAQALYMCAAQDu/T8z7/fM/L97CA4BAAlgGADcfmZ2dn5ubmZ+OwgMAAAIMBgMALx+ZnZuZn49Bw4BAAi+/3jw8OHB478PgGEABQsBAwbu78P3d4AZBg4BAAf/zzAMwzAMwwCMAQQOAQAFZvZvZuYMbAYDAQAHjDcDBgMBAAezxwAFAgEABtEBAgIBAAMPBAQBAAWWaQMDAQsE5AAGAgEAB2YGBgMCAAiklAAHCwEACL7/eDwej+822x0HCAEDCP+/zWaz2cwJAgEFCv//Aw0CAQUO////AwIEAQAD9gIEAQADbwIEAQkDbwUEAQAGMu0NBQQBAAZ7ywQFBAEJBnvLBAYIAQAHDPP/DMMwBgsBAAcM8/8Mw/w/wwAFBQEEBu7/7wAKAgEJCzPPDBALAQARHg7/BzMDswH/AP558P94zmzO5v/DewQFAQQFbGMMBAUBBAVjbAMGDQEABzCMYRjDMIZhDAMICwAACDh8xoYfBh+Gxnw4CQUBAAofbdu3bRsHCwEACL7/eDwej+822x0GCwEAB94/w/4/z/PvAQgLAQAJGBg8PGZmZsPD//8ICwEACf//w8PDw8PDw8PDBgsBAAf/fxgO5xjH/wMFAgEFBv8DCwwBAAwABhjAAAMYYAzDDGbgAQ8wAAoFAQQLzu09897OAQYOAAAGOM8wDMMwDMMwzwEIBwEDCY7bcQCO23EICQECCTAw//8Y//8MDAcIAQMIcN6DBwf8/wcIAQMIBw/ecwD8/wcMAQAI/2AwGAwGg8Fg8A8IBwEDCRg8ZsNmPBgDAgAMAz8HCwEACHy/4f83m81msxkHCwEACHy/+f83m81msxkAAAAAAAADEXQBAAD/AgoBAAIAAAECCAACARAAAwEUAAQBGAAFARwABgEgAAcBJAAIASgACQEsAAoBMAALATQADAE4AA0BPAAOAUAADwFEABABSAARAUwAEgFQABMBVAAUAVgAFQFcABYBYAAXAWQAGAFoABkBbAAaAnAAGwJ4ABwCgAAdAogAHgGQAB8BlAAgApgAIQKgACICqAAjArAAJAO4ACUCxAAmAswAJwLUACgD3AApAugAKgLwACsC+AAsAgABLQIIAS4CEAEvAhgBMAIgATEDKAEyAjQBMwQ8ATQETAE1AlwBNgJkATcCbAE4A3QBOQOAAToDjAE7ApgBPASgAT0DsAE+A7wBPwLIAUAE0AFBA+ABQgPsAUMD+AFEAgQCRQIMAkYDFAJHAyACSAIsAkkCNAJKAjwCSwJEAkwCTAJNA1QCTgJgAk8CaAJQA3ACUQJ8AlIChAJTAowCVAKUAlUCnAJWAqQCVwKsAlgCtAJZA7wCWgPIAlsC1AJcAtwCXQLkAl4C7AJfAvQCYAL8AmECBANiAgwDYwIUA2QDHANlAigDZgIwA2cCOANoAkADaQJIA2oDUANrAlwDbAJkA20CbANuAnQDbwJ8A3AChANxAowDcgKUA3MCnAN0AqQDdQKsA3YCtAN3ArwDeALEA3kCzAN6AtQDewLcA3wC5AN9AuwDfgL0A38B/AOAAQAEgQAEBIIBBASDAAgEhAAIBIUACASGAQgEhwEMBIgAEASJABAEigAQBIsAEASMABAEjQAQBI4AEASPABAEkAAQBJEAEASSABAEkwEQBJQAFASVABQElgAUBJcAFASYABQEmQAUBJoAFASbABQEnAAUBJ0AFASeABQEnwAUBKAAFAShARQEogEYBKMBHASkASAEpQEkBKYBKASnASwEqAEwBKkBNASqATgEqwE8BKwCQAStAEgErgFIBK8BTASwAVAEsQFUBLIBWASzAVwEtAFgBLUBZAS2AWgEtwFsBLgBcAS5AXQEugJ4BLsBgAS8AYQEvQGIBL4BjAS/AZAEwAGUBMEBmATCAZwEwwKgBMQBqATFAawExgGwBMcBtATIArgEyQLABMoByATLAcwEzALQBM0B2ATOAdwEzwHgBNAB5ATRAegE0gHsBNMB8ATUAvQE1QH8BNYBAAXXAQQF2AEIBdkBDAXaAhAF2wIYBdwCIAXdAigF3gIwBd8COAXgAUAF4QFEBeIBSAXjAUwF5AFQBeUBVAXmAVgF5wFcBegBYAXpAWQF6gFoBesBbAXsAXAF7QF0Be4BeAXvAnwF8AGEBfEBiAXyAYwF8wGQBfQBlAX1AZgF9gGcBfcBoAX4AaQF+QGoBfoBrAX7AbAF/AK0Bf0DvAX+AsgF/wB3DP4BOxYAAY0M/wFWFgEBogwCAbQMAwHJDAQB2wwFAfIMBgEEDQcBFw0IASoNCQE9DQoBUA0LAWMNDAF1DQ0BiA0OAZsNDwGuDRABxQ0RAdgNEgHtDRMB/w0UAREOFQEjDhYBNQ4XAUcOGAFZDhkBbQ4YAmwWGgF/DhkCghYbAZEOGgKSFhwBpA4bAqgWHQG4Dh4Bzg4gAAAAHwHiDiEABQAgAfgOIgAOACEBDA8jABgAIgEiDyQAKgAjATgPAiIYGCUAPwAkAU4PJgBfACUBZA8nAHgAJgF4DygAfwAnAY4PBiIrGCkAjwAoAaIPKgCfACkBsg8rAK4AKgHCDywAuwArAdIPLQDCACwB4g8uAMgALQHyDy8AzgAuAQIQMADhAC8BEBAxAPQAMAEeEA8iQBgyAAQBMQEoEDMAFwEyATAQEyAZFxEiUxg0ACoBMwFDEBQgIRcSImUYNQA/ATQBVRA2AFIBNQFpEDcAZQE2AXsQOAB4ATcBkBAYICoXOQCLATgBoxAZIDEXOgCeATkBsxAaIDgXOwCmAToBxxA8AK4BOwHVEBwgPxcaImsYPQC9ATwB6RAdIEkXPgDKAT0B9RAeIFMXPwDZAT4BBxFAAOwBPwEVESAgXRceIowYQQAKAkABJxEhIG0XQgAfAkEBNREiIIAXQwAyAkIBSBEiIfkXRABFAkMBVBFFAFgCRAFnEUYAagJFAXoRJiCJF0cAfAJGAY8RJiEFGEgAjwJHAaERSQCiAkgBtBFKAKsCSQHHEUsAuQJKAdoRTADMAksB8BFNAN4CTAECEisinRhOAPUCTQEVEk8ACANOAScSUAAbA08BOhIwIJMXUQAuA1ABTBJSAEQDUQFfElMAVwNSAXISVABqA1MBjhJVAH0DVAGkElYAkANVAboSVwClA1YByRJYALwDVwHeElkAzwNYAewSOSC9F1oA4gNZAQITOiDHF1sA9ANaARMTXAACBFsBKRNdABUEXAE6E14AIwRdAVATXwAsBF4BYRNgADMEXwF3E2EAOwRgAYcTYgBKBGEBnRNjAFwEYgGuE2QAawRjAcQTRCDRF2UAfQRkAdYTZgCMBGUB7BNnAJwEZgH+E2gAsQRnARQUaQDDBGgBJBRqAMwEaQE3FEgirxhrANoEagFJFGwA7ARrAVwUbQD1BGwBbhRuAAsFbQGBFG8AGgVuAZMUcAApBW8BpxRxADwFcAG6FHIATwVxAc0UcwBbBXIB4BR0AGkFcwH1FHUAeQV0AQcVdgCIBXUBIhV3AJgFdgE6FXgAqwV3AU0VeQC7BXgBYxV6AM8FeQF2FXsA3QV6AYgVfADvBXsBmRV9APkFfAGrFX4ACwZ9AbsVfgHNFX8B3hVgIr0YZCLPGGUi3xiSAe4VoQATBqIAHAajAC8GpABEBqUAWAamAGsGpwB1BqgAhgapAI0GqgCrBqsAugasAMcGqQP2Fq4A0QavAOgGsADvBrEA+wayAAoHswAVB7QAIAe1ACgHtgA7B7cAVge4AFwHuQBjB7oAbgfD9h8ZuwB9B7wAige9AKEHvgC4B78AzwfAAOIHwQD3B8IADAjDACEIwAMJF8QANgjFAEsIxgBhCMcAewjIAJEIxgK6FskAowjHAsMWygC1CMsAxwjMANkIrCDkF80A5QjOAPEIzwABCdAAEQnRACYJ0gA5CdMATAnUAF8JryXvGNUAcgnWAIUJ1wCYCdgApQnZALwJ2gDPCdgCzBbbAOIJ2QLTFtwA9QnaAtkW3QAICtsC4BbeABsK3ALnFt8ALgrdAu4W4ABDCuEAVgriAGkK4wB8CuQAjgrlAKAK5gCzCucAyQroANsK6QDuCuoAAQvrABQL7AAmC+0AMwvuAEAL7wBRC8olChnwAGEL8QB0C/IAhgvzAJkL9ACsC/UAvwv2ANEL9wDjC/gA8Av5AAIM+gAVDPsAKAz8ADsMAfslGf0ATQz8AQAWAvs8Gf4AYwz9AR8WAwAAAQMCDgEAA///Dw8GBgEAB/M8z/MMCgoBAAuYYfb//8ww8///ZpgBCBABAAkYGH7/wwMPPnzwwMP/fhgYDw4BABA+4P/fGGaMMWb4G/gGgH1gf5gxxphhbPAf8AELDgEADDjggzuMYQw28MDHZj7bcM7ndx4DAgYBAAP/DwURAQAGmDFjzBhjDGMMYxgFEQEABsMYxhjGGGPGmDEDCAoBAAkYGNv/PDz/2xgYCAgBBAkYGBj//xgYGAIFAQsDvwEEAgEHBf8CAwELAz8HEAEACGAwDAbDYDAMBsNgMAwGCA4BAAk8fufDw8PDw8PDw+d+PAYOAgAIjPM8DMMwDMMw/w8IDgEACTx+58PAwOBwOBwOB///CA4BAAk8fufDwOB4OODAw+d+PAkOAQAKYODgwcPGjZn//8GAAQMGDAgOAQAJ//8DAwM/f+DAwMPnfjwIDgEACTx+58MDO3/jw8PD5348CA4BAAn//8DA4GBwMDgYHAwMDAgOAQAJPH7nw8Pnfn7nw8PnfjwIDgEACTx+58PDw8f+3MDA5348AgoBBAM/wA8CDAEEAz/AbwcLAQMIYBiGYRgYGBgYGAkHAQUK//8DAADg/38HCwEDCAMDAwMDwzAMwwAIDgAACDx+58PA4HA4GBgYABgYDg4BAA/4h/9ngA3A4/P8PDPPzLPz/Dw2G/w+Hw4ACQ4BAAo4cOBgw4aNMWP+/A0ePHgwCA4BAAk/f+PDw+N/f+PDw+N/PwgOAQAJPH7nwwMDAwMDA8PnfjwIDgEACT9/48PDw8PDw8PD438/Bw4BAAj//2AwGHw+g8Fg8P8DBw4BAAj//2AwGHw+g8FgMBgACA4BAAk8fufDAwPz88PDw8f+/AgOAQAJw8PDw8PD///Dw8PDw8MCDgEAA////w8FDgEABhhjjDHGGGP+DggOAQAJw8NjYzM7Hx87M2Njw8MHDgEACIPBYDAYDAaDwWDw/wMKDgEACwMPfPjhzz+/994zzzzwwAMPDAgOAQAJw8PHx8/P29vz8+Pjw8MIDgEACTx+58PDw8PDw8PD5348CA4BAAk/f+PDw+N/PwMDAwMDAwgRAQAJPH7nw8PDw8PDw8P3fjwwYMAIDgEACT9/48PD439/M3Nj48PDCA4BAAk8fufDAwceeODAw+d+PAgOAQAJ//8YGBgYGBgYGBgYGBgIDgEACcPDw8PDw8PDw8PD5348CQ4BAAqDBw8efNyYMWPu2LDhgwMHCg4BAAsDDzzwwDPfbptttvnHDzPMMAMIDgEACcPDZmY8PBgYPDxmZsPDCA4BAAnDw8NmZmY8PDwYGBgYGAcOAQAI/z8cBsNgGAyD4fD/AwQRAQAF/zMzMzMzM/MPBxABAAiDgcFgYDAYGAwGBoOBwQQRAQAF/8zMzMzMzPwPBwQAAAcIjm0MCAIBDgn//wUEAQAGwzAMBwsBAwi+/xjs/4/H878bBw4BAAiDwWD3H4/H4/F4/N8BBwsBAwi+/3gwGAwG478PBw4BAAhgMNj9H4/H4/F4/HcDBwsBAwi+/3g8/v8G478PBg4AAAY4zzD/zzAMwzAMAwgQAQEJ4D5/Y2Njfz4HPn9jY2N/PgcOAQAIg8Fg9z+Px+PxeDweAwIPAQADD///PwQRAAAEzMDMzMzMzPwHBw4BAAiDwWA8nu8+n918PB4DAg4BAAP///8PDAsBAw0b9//nPMZjPMZjPMZjPMYDDAcLAQMIu/95PB6Px+PxGAcLAQMIvv94PB6Px+O/DwcPAQIIu/94PB6Px+P/bjAYDAAHDwECCO7/eDwej8fjvxsMBoMBBQsBAwb7nzHGGGMMBgsBAwfePx8Oh8Pz7wEGDgAABgzD/D/DMAzDMDwOBwsBAwjj8Xg8Ho/H478bCAsBAwnDw8PnZmZ+PDwYGAoLAQMLAw888My322abbf4xwwwICwEDCcPnZn48PH5m58PDCA8BAgnDw8NmZmY8PDwYGBgcDgYGCwEDB/8PYxjDGMb/AwYRAQAHOM8wDMM4h8MwDMPwOAIRAQAD/////wMGEQEAB8fDMAzDcDjHMAzDPAcHAwEACM5/DgIOAQADz///DwcPAQEIGAzG9x8PBoPx34fBYAAJDgAACfDwcWDAgMGfPwwYGDDw7z8KDAABCgMf7h8/zhlmmHP8+Hf4wAgOAQAJw8PDZmY8PBj/GP8YGBgCEQEAA////P8DBhABAAfePw+H98/z7+Hw/HsGAgEAB/MMDg4BAA/wA//jwJln8/OGvQFvwBv2/GyeOXD8D/wABwsBAAi+f9j/n//dgP8fCQcBBQqYmZmZYYYZZggFAQcJ///AwMAMDAEADfjhfwa2z/u92fu835ttYP6HHwYCAQAH/w8HBwEACL7/eDz++wAICgEECRgYGP//GBgY//8GCAEAB94/45zz/wYIAQAH3g9zPPx7BQQBAAaYmQEHDwECCOPxeDwez//v8WAwGAwAChEBAAv8+//333//7TffYIMNNthggw022GADAgMBBwM/BAQBDQXMbwYIAQAHjPMwDPP/BwsBAAi+/3g8Hv99gP8fCQcBBQozzDDDzMzMDAsNAgANDHDggxvGmH/8DXbYY7/5BxYwCw0CAA0McOCDG8aYf/wP/jhnnHHGH34LDQIADQ744IY5xpht/M132GO/+QcWMAgOAAAIGBgAGBgYHA4HA8PnfjwJDgEACgxgAMCBgw0bY8b8+Rs8eDAJDgEACjAYAMCBgw0bY8b8+Rs8eDAJDgEACjiMAcCBgw0bY8b8+Rs8eDAJDgEACpzkAMCBgw0bY8b8+Rs8eDAJDgEACsaMAcCBgw0bY8b8+Rs8eDAJDwEACjiIECGCAwcbNsaM+fM3ePBgDA4BAA3wj/94wAdswAbuYz5+8AdjMAbjP/4IEQEACTx+58MDAwMDAwPD5348EBIMBw4BAAgGDOD/Hww+n8Fg8P8DBw4BAAgYA+D/Hww+n8Fg8P8DBw4BAAicMeD/Hww+n8Fg8P8DBw4BAAg2G+D/Hww+n8Fg8P8DBA4AAATDwMzMzMzMBA4BAAU8MDMzMzMzBg4AAAbMDDAMwzAMwzAMAwYOAAAG8wwwDMMwDMMwDAMJDgEACn78GTds2PDnz4YNGzbuzw8IDgEACY5xAMPDx8ff2/Pj48PDCA4BAAkGGAA8fufDw8PDw+d+PAgOAQAJYBgAPH7nw8PDw8PnfjwIDgEACRhmADx+58PDw8PD5348CA4BAAmOcQA8fufDw8PDw+d+PAgOAQAJZmYAPH7nw8PDw8PnfjwICAEDCcPnfjw8fufDCg4AAAp48++cceaZZ59tvnnmmXP/7AEIDgEACQwYAMPDw8PDw8PD5348CA4BAAkYDADDw8PDw8PDw+d+PAgOAQAJGGYAw8PDw8PDw8PnfjwIDgEACWZmAMPDw8PDw8PD5348CA4BAAkwDADDw2ZmPDwYGBgYGAgOAQAJAwMDP3/jw8Pjfz8DAwMJDgEACnz8GTNmzM8/44YNGzbs3x4HDwEACAYGBuD7j8H+/3g8/7sBBw8BAAgwDAPg+4/B/v94PP+7AQcPAQAIGJ4Z4PuPwf7/eDz/uwEHDgEACM4cwPcfg/3/8Xj+dwMHDgEACDYbwPcfg/3/8Xj+dwMHEAEACBgSCQPw/cdg/388nv/dDAsBAw2e9/9jDMZ+/P/jNwZj/P+eBwcOAQMIvv94MBgMBuO/D4EwAAcPAQAIBgYG4PuPx+P/bzD++wAHDwEACBiGAeD7j8fj/28w/vsABw8BAAgYnhng+4/H4/9vMP77AAcOAQAINhvA9x+Px//fYPz3AQQPAAAEYwxmZmZmZgYEDwAABGwDZmZmZmYGBg8AAAaMNwMMwzAMwzAMwwAGDgAABvMMMAzDMAzDMAwDCA4BAAnmfjw/d3zuxsbGxu58OAcOAQAIzhxg9z+Px+PxeDweAwcPAQAIBgYG4PuPx+PxeDz++wAHDwEACDAMA+D7j8fj8Xg8/vsABw8BAAgYnhng+4/H4/F4PP77AAcOAQAIzhzA9x+Px+PxePz3AQcOAQAINhvA9x+Px+PxePz3AQgIAQMJGBgA//8AGBgJCwADCXz9mzNnz5o3Z87+9QEHDwEACAYGBjAej8fj8Xg8/rsBBw8BAAgwDAMwHo/H4/F4PP67AQcPAQAIGJ4ZMB6Px+PxeDz+uwEHDgEACDYbYDwej8fj8Xj8dwMIEQEACWAYAMPDZmZmPDw8GBgYHA4GBxEBAAiDwWAw+P3H4/H/NxgMBgMIEQEACWZmAMPDZmZmPDw8GBgYHA4GCQ4BAAr+/AHAgYMNG2PG/PkbPHgwBw4BAAj/P8D3H4P9//F4/ncDCQ4BAAqC+ADAgYMNG2PG/PkbPHgwBw4BAAgiDsD3H4P9//F4/ncDCRABAAo4cOBgw4aNMWP+/A0ePH4yBDAHDgEDCL7/GOz/j8fzv5tAwgAIDgEACWAYADx+58MDAwPD5348Bw8BAAgwDAPg+48Hg8FgMP77AAgOAQAJGGYAPH7nwwMDA8PnfjwHDwEACBieGeD7jweDwWAw/vsACA4BAAkYGAA8fufDAwMDw+d+PAcOAQAIGAzA9x8PBoPBYPz3AQgOAQAJZhgAPH7nwwMDA8PnfjwHDwEACGYeBuD7jweDwWAw/vsACA4BAAlmGAA/f+PDw8PDw+N/PwoOAQALYIMNppt/jTHGGGOMMcYYf7gBCA4BAAn//wA/f+PDw8PDw+N/PwkOAQAKbPjgd/9nzJgxY8aMGfPHDQcOAQAI/z/g/x8MPp/BYPD/AwcOAQAI/z/A9x+Px//fYPz3AQcOAQAIIg7g/x8MPp/BYPD/AwcOAQAIQR/A9x+Px//fYPz3AQcOAQAIGAzg/x8MPp/BYPD/AwcOAQAIDAbA9x+Px//fYPz3AQcRAQAI//9gMBh8PoPBYPD/Mxg4Bw4BAwi+/3g8/v8G47+PwcMBBw4BAAhjDuD/Hww+n8Fg8P8DBw8BAAhmHgbg+4/H4/9vMP77AAgPAQAJGGYAPH7nwwPz88PDx/78CBEBAAkYZgDgPn9jY38+Bz5/Y2N/PggPAQAJQjwAPH7nwwPz88PDx/78CBEBAAkiHADgPn9jY38+Bz5/Y2N/PggPAQAJGBgAPH7nwwPz88PDx/78CBEBAAkYGADgPn9jY38+Bz5/Y2N/PggRAQAJPH7nwwMD8/PDw8PH/vwAMBgIEQEACQgEAOA+f2Njfz4HPn9jY38+CBEBAAkYZgDDw8PDw8P//8PDw8PDwwcRAQAIjBlgMBjs/uPxeDwej8djCBEBAAn//wDDw8PDw8P//8PDw8PDwwgPAAAIBh8fBnb+xsbGxsbGxsbGBg4AAAZmBjAMwzAMwzAMAwYOAAAGZgYwDMMwDMMwDAMGDgAABv8PMAzDMAzDMAwDBg4AAAb/DzAMwzAMwzAMAwYOAAAGoQcwDMMwDMMwDAMGDgAABqEHMAzDMAzDMAwDBBEAAARmZmZmZmZmEQ4EEQAABGZgZmZmZmYRDgIRAQADz////wMCCwEDA///PwgOAQAJw8PDw8PDw8PDw8PjezsGEQEAB/MMzPM8z/M8zzYM+x4HEQEACBgzAIPBYDAYDAaDwXAeBwYRAQAHzAwwDMMwDMMwDMM8BwgQAQAJw8NjYzM7Hx87M2Njw8MYDAcQAQAIg8FgPJ7vPp/dfDweYxgICwEDCcPD43M7Hztz48PDBxEBAAgYA2AwGAwGg8FgMBgM/n8EEQEABTwwMzMzMzMzAwcRAQAIg8FgMBgMBoPBYPD/AzAMAxEAAAO2bdu2bcMDBw4BAAjj8Xg4HA0Gg8Fg8P8DBQ4BAAZ777nGGGOMMQYHDgEACIPBYDCYzQaDwWDw/wMFDgEABmOMMfYeY4wxBggOAAAIBgYGBmZ+HwcGBgYG/v4EDgAABGZm5n9mZmYIDgEACTAMAMPDx8ff2/Pj48PDBw8BAAgwDAOw+5/H4/F4PB6PAQgQAQAJw8PHx8/P29vz8+Pjw8MYDAcOAQMIu/95PB6Px+PxGIBhAAgOAQAJZhgAw8PHx9/b8+Pjw8MHDwEACGYeBrD7n8fj8Xg8Ho8BBw8BAAiDgSCw+5/H4/F4PB6PAQgRAQAJO3/jw8PDw8PDw8PDw8DgfD4HDgEDCLv/eTwej8fj8RjM5wEIDgEACf//ADx+58PDw8PD5348Bw4BAAj/P8D3H4/H4/F4/PcBCA4BAAlCPAA8fufDw8PDw+d+PAcOAQAIIg7A9x+Px+PxePz3AQgOAQAJSCQAPH7nw8PDw8PnfjwHDwEACEiSBOD7j8fj8Xg8/vsADQ4BAA583/8fg2EwDIbB8Bk+w2AYDINj4P/5PgwLAQMN3vf/YzzGYzz+YzAGY/z/3gcIEQEACTAMAD9/48PD439/M3Nj48PDBQ8BAAaYGbD/GWOMMcYACBABAAk/f+PDw+N/fzNzY+PDwxgMBQ0BAwb7nzHGGGMMzAAIEQEACWYYAD9/48PD439/M3Nj48PDBg8AAAazxwC27xiGYRiGYQAIEQEACTAMADx+58MDBx544MDD5348Bg8BAAcYYwDePx8Oh8Pz7wEIEQEACRhmADx+58MDBx544MDD5348Bg8BAAeMNwPePx8Oh8Pz7wEIEQEACTx+58MDBx544MDD5348EBIMBg4BAwfePx8Oh8Pz7yGIAQgRAQAJZhgAPH7nwwMHHnjgwMPnfjwGDwEAB7PHAN4/Hw6Hw/PvAQgRAQAJ//8YGBgYGBgYGBgYGBgIEQ4GEQEABwzDMP/PMAzDcDyOIAYIEQEACWYYAP//GBgYGBgYGBgYGBgYBw4BAAhsNpP1+zEYDAaDw8MBCBEBAAn//wD//xgYGBgYGBgYGBgYGAYOAQAHDPP/DPP/DMNwPA4IDgEACY5xAMPDw8PDw8PD5348Bw4BAAjOHGA8Ho/H4/F4/HcDCA4BAAn//wDDw8PDw8PDw+d+PAcOAQAI/z9gPB6Px+PxePx3AwgOAQAJgX4Aw8PDw8PDw8PnfjwHDgEACCIOYDwej8fj8Xj8dwMIDwEACRgkJBjDw8PDw8PDw+d+PAcQAQAIGBIJAxiPx+PxeDwe/90IDgEACUgkAMPDw8PDw8PD5348Bw8BAAhIkgQwHo/H4/F4PP67AQgQAQAJw8PDw8PDw8PDw8PnfjwIcAcOAQMI4/F4PB6Px+O/H4KAAwoRAQALMDADwMADDzzwzLfbZptt/vHDDDPMAAoPAQALMODBDAADDzzwzLfbZptt/jHDDAgOAQAJGGYAw8NmZjw8GBgYGBgIEQEACRhmAMPDZmZmPDw8GBgYHA4GCA4BAAlmZgDDw2ZmPDwYGBgYGAcOAQAIMAbg/4fDMAyG4fD/AwYPAQAHGGMA/w9jGMMYxv8DBw4BAAgYDOD/h8MwDIbh8P8DBg4BAAcMA/w/jGEMYxj/DwcOAQAIZgzg/4fDMAyG4fD/AwYPAQAHs8cA/w9jGMMYxv8DBg4BAAe8bxjGcRiGYRiGAQYRAAAGOM8wDMN4HsMwDMM8BwwRAQANAAMMAAD/+I8HfMAGbOA+5uMHfzAGYzD+4w8MDwEADYABDGAAAJ73/2MMxn78/+M3BmP8/54HChEAAArAwAAA3vw7Z5x55tlnm2+eeebcP3sACQ8AAAlgYGAAwNe/OXP2rHlz5uxfHwgRAQAJPH7nwwMHHnjgwMPnfjwAGAwGDgEDB94/Hw6Hw/PvAYwBCBEBAAn//xgYGBgYGBgYGBgYGAAYDAYRAQAHDMMw/88wDMNwPA5gDAcEAAAHCI5tDAcEAAAHYxsHAQYCAQAHoQcCAgEAAw8EBAEABZZpBQMBDgYhOgcCAQAIzhwGAwEAB6SUAAgOAQAJfv/Dw8PDw8PD52Zm5+cICwEDCf//ZmZmZmZmZubGCQIBBwr//wMQAgEHEf////8CBgEAA9YPAgYBAAO/BgIGAQsDvwYGBgEAB2IUzfMMBgYBAAfzPItiBAYGAQsH8zyLYgQICwEACRgYGP//GBgYGBgYCA4BAAkYGBj//xgYGBj//xgYGAUFAQUG7v/vAAwDAQsNYzzGYwwVDgIAFz5g4P8HjGGAMQYwZgD+BoBvAAD2fWD/H2YcY4xjhnFs8P8HfB8FBwEFBpiZYRgGBQcBBQbDMMzMAAcQAQAIYDAMBsNgMAwGw2AwDAYJDgEACnj4OTds4I8BA38MGHbODw8JBgEACh9t27dt2zYIDgEACX7/w8PDw8PDw+dmZufnCA4BAAk+f+PAwNz+x8PDw+d+PAkOAAAJOHDgYMOGjTFjxgYPHvz/PwgOAQAJ///Dw8PDw8PDw8PDw8MHDgEACP//wGBgcDgMg2Hw/wMEAgEHBf8OEAEADwAwAAyAAWAADAADYAAYA8PAYBg4BtwANoAHwAANBwEGDh7v98/ncTyff7/HAwYRAAAGOM8wDMMwDMMwDMM8BwkIAQQKnv/PAwDA8/95CQsBAwpgwPz/DwMDhv//GTAACAsBAwnA8DwPPPDAAAD//wgLAQMJAw888DwPAwAA//8KEQEAC/8HGGCAAQYYYIABBhhggAEGGGCA/wMLCwABCyCAAzYYY7ABG4wx2IADCAACAwEOAz8KDgAACvjzzwAD///PMMMMM8wwwwwzDAoOAAAK+PPPMMP//88wwwwzzDDDDDMMAAAAAAAAAAMWdAEAAP8CCgEAAgAAAQIIAAIBEAADARQABAEYAAUBHAAGASAABwEkAAgBKAAJASwACgEwAAsBNAAMATgADQE8AA4BQAAPAUQAEAFIABEBTAASAVAAEwFUABQBWAAVAVwAFgFgABcBZAAYAWgAGQFsABoCcAAbAngAHAKAAB0CiAAeAZAAHwGUACACmAAhAqAAIgKoACMCsAAkA7gAJQLEACYCzAAnAtQAKAPcACkC6AAqAvAAKwL4ACwCAAEtAggBLgIQAS8CGAEwAiABMQMoATICNAEzBDwBNARMATUCXAE2AmQBNwJsATgDdAE5A4ABOgOMATsCmAE8BKABPQOwAT4DvAE/AsgBQATQAUED4AFCA+wBQwP4AUQCBAJFAgwCRgMUAkcDIAJIAiwCSQI0AkoCPAJLAkQCTAJMAk0DVAJOAmACTwJoAlADcAJRAnwCUgKEAlMCjAJUApQCVQKcAlYCpAJXAqwCWAK0AlkDvAJaA8gCWwLUAlwC3AJdAuQCXgLsAl8C9AJgAvwCYQIEA2ICDANjAhQDZAMcA2UCKANmAjADZwI4A2gCQANpAkgDagNQA2sCXANsAmQDbQJsA24CdANvAnwDcAKEA3ECjANyApQDcwKcA3QCpAN1AqwDdgK0A3cCvAN4AsQDeQLMA3oC1AN7AtwDfALkA30C7AN+AvQDfwH8A4ABAASBAAQEggEEBIMACASEAAgEhQAIBIYBCASHAQwEiAAQBIkAEASKABAEiwAQBIwAEASNABAEjgAQBI8AEASQABAEkQAQBJIAEASTARAElAAUBJUAFASWABQElwAUBJgAFASZABQEmgAUBJsAFAScABQEnQAUBJ4AFASfABQEoAAUBKEBFASiARgEowEcBKQBIASlASQEpgEoBKcBLASoATAEqQE0BKoBOASrATwErAJABK0ASASuAUgErwFMBLABUASxAVQEsgFYBLMBXAS0AWAEtQFkBLYBaAS3AWwEuAFwBLkBdAS6AngEuwGABLwBhAS9AYgEvgGMBL8BkATAAZQEwQGYBMIBnATDAqAExAGoBMUBrATGAbAExwG0BMgCuATJAsAEygHIBMsBzATMAtAEzQHYBM4B3ATPAeAE0AHkBNEB6ATSAewE0wHwBNQC9ATVAfwE1gEABdcBBAXYAQgF2QEMBdoCEAXbAhgF3AIgBd0CKAXeAjAF3wI4BeABQAXhAUQF4gFIBeMBTAXkAVAF5QFUBeYBWAXnAVwF6AFgBekBZAXqAWgF6wFsBewBcAXtAXQF7gF4Be8CfAXwAYQF8QGIBfIBjAXzAZAF9AGUBfUBmAX2AZwF9wGgBfgBpAX5AagF+gGsBfsBsAX8ArQF/QO8Bf4CyAX/AP0Q/gHdHgABHhH/Af0eAQE+EQIBVREDAXgRBAGREQUBthEGAcwRBwHoEQgB/xEJARsSCgEyEgsBThIMAWUSDQGBEg4BmhIPAbYSEAHUEhEB8BISAQwTEwEjExQBOhMVAVETFgFqExcBgRMYAZgTGQGzExgCGh8aAcoTGQI4HxsB4RMaAk8fHAH6ExsCcB8dARsUHgE5FCAAAAAfAVkUIQAFACABdxQiAA8AIQGYFCMAGQAiAbUUJAAyACMB1hQCIjohJQBTACQB9BQmAH0AJQEVFScAnQAmATAVKACkACcBURUGIlEhKQC6ACgBbRUqANAAKQGNFSsA4wAqAaoVLAD6ACsBxRUtAAIBLAHcFS4ACQEtAfcVLwAPAS4BEBYwACoBLwEjFjEARAEwATYWDyJvITIAVwExAUEWMwBxATIBShYTIP8fESKPITQAiwEzAWQWFCAHIBIipiE1AKcBNAF9FjYAwQE1AZsWNwDbATYBthY4APUBNwHWFhggESA5AA8COAHxFhkgGSA6ACkCOQEDFxogISA7ADICOgEdFzwAPgI7ATAXHCApIBoiriE9AFECPAFLFx0gNCA+AGICPQFbFx4gPyA/AHUCPgFyF0AAjAI/AYMXICBKIB4i3iFBALUCQAGaFyEgWCBCANUCQQGrFyIgayBDAPECQgHHFyIhEiFEAA0DQwHaF0UAKQNEAfYXRgBAA0UBDhgmIHcgRwBXA0YBLxgmIR4hSABzA0cBRhhJAI8DSAFiGEoAmQNJAXsYSwCsA0oBkxhMAMgDSwG0GE0A3wNMAcwYKyL6IU4ABgRNAegYTwAiBE4B/xhQAD4ETwEbGTAggSBRAFoEUAE0GVIAegRRAVIZUwCWBFIBbxlUALAEUwGYGVUAzARUAbYZVgDoBFUB1hlXAAQFVgHqGVgAMAVXAQsaWQBOBVgBHho5IMEgWgBqBVkBPxo6IM0gWwCBBVoBWBpcAJEFWwF1Gl0ArAVcAY0aXgC8BV0BqxpfAMUFXgHEGmAAzQVfAeIaYQDUBWAB+RpiAOcFYQEXG2MA/gViATAbZAARBmMBURtEINkgZQAoBmQBZxtmADsGZQGIG2cAUgZmAZ8baABuBmcBwBtpAIUGaAHTG2oAjwZpAe8bSCIVImsAnwZqAQwcbAC2BmsBKBxtAMAGbAE/HG4A3gZtAVscbwDxBm4BdBxwAAQHbwGUHHEAGwdwAa8ccgAyB3EB0RxzAEIHcgHsHHQAVQdzAQ0ddQBoB3QBJB12AHsHdQFYHXcAkgd2AX4deACuB3cBmh15AMMHeAG7HXoA3wd5AdcdewDvB3oB7h18AAgIewEBHn0AEwh8ARkefgAsCH0BLB5+AUMefwFaHmAiKCJkIkIiZSJbIpIBbx6hADYIogBACKMAVwikAHMIpQCQCKYArAinALcIqADQCKkA1wiqAAUJqwAYCawAKwmpA8wfrgA4Ca8ATwmwAFYJsQBjCbIAfAmzAIkJtACWCbUAnQm2ALMJtwDZCbgA3wm5AOcJugD0CcP2syK7AAcKvAAaCr0ARgq+AHIKvwCeCsAAtQrBANUKwgD1CsMAFQvAA+gfxAA1C8UAVQvGAHcLxwCcC8gAvQvGAoYfyQDUC8cCjx/KAOsLywACDMwAGQysIPQgzQAqDM4AOwzPAE4M0ABhDNEAgQzSAJ0M0wC5DNQA1QyvJXQi1QDxDNYADQ3XACkN2AA7DdkAVw3aAHMN2AKYH9sAjw3ZAqEf3ACrDdoCpx/dAMcN2wKxH94A4w3cArkf3wD/Dd0CwR/gAB0O4QA0DuIASw7jAGIO5AB+DuUAlQ7mAK8O5wDNDugA5A7pAPsO6gASD+sAKQ/sAEAP7QBRD+4AYg/vAHkPyiWYIvAAjA/xAKMP8gC/D/MA1g/0AO0P9QAEEPYAIBD3ADcQ+ABOEPkAZRD6AHwQ+wCTEPwAqhAB+7ki/QDBEPwBih4C+9Mi/gDiEP0Bth4EAAABBAISAQAD////ww8GBgEAB/M8z/MMDQwBAA4wBsbAmP///zEGxvj//58xMAbGAAoWAQALMMAAAz/+zTzzDDf4wA98sMMM88wz+8cPDDDAABERAQASfoD/wQ//G4YzjGOYw78DvwOAA4D7gfuHM4xjmMOwg+ED/wP8AAwSAQAN+MAfjmMwhsMc/IAHPODHZzxuwzY8g3N8/s7HAgYBAAP/DwYWAQAHMIwxjGEYwzAMw2AYBsNgMAwGFgEAB8NgMAyGYTAMwzCMYRjDGMMACgsAAAowwDDz//zgwc//M8MAAwwMAQUNYAAGYAAGYPD//w8GYAAGYAAGAwYBDwS2twEGAgEKB/8PAgMBDwM/CBYBAAnAwMBgYGAwMDAYGBgYDAwMBgYGAwMDCRIBAAp8/B0fPHjw4MGDBw8ePHjw4OP++AAGEgMACYzzMAzDMAzDMAzDMP8PCRIBAAp8/B0fDBg4MHBg4MDAgYEDAwf//wMJEgEACnz8HR8MGDBg4PjwAQcMGPDg4/74AAoSAQAL4MADDzbYMMOMMcYM8///wAADDDDAAAMJEgEACv//DxgwYMCAP/+AAwYMGPDg4/74AAkSAQAKfPwdHzxgwJ5/xwcPHjx48ODj/vgACRIBAAr//wMGDBgYMGDAwIABAwMGDAwYMAAJEgEACnz8HR88ePDg4/78HR88ePDg4/74AAkSAQAKfPwdHzx48ODBx/3zBgwY8ODj/vgAAg4BBAP/APAPAxEABAO2DQCAbW8DCA4BBAnAYDAYDAYDAwYMGDBgwAwIAQcN////AAAAAAAA////CA4ABAgDBgwYMGDAwGAwGAwGAwgSAQAJPH7nw8DAwOBwOBgYAAAYGBgYEBIBABHgB/gfPDwOcAZgx+bjx2PGY8ZjxmPG48fHxgbGDn4cPHgAYAAMEgEADWAABvAAD/CAGZiBGQzDMPzjfwZmYAc+wAM8wAoSAQAL//w3+MADDzz4f/8NPvDAAw888OD//QMKEgEAC/z4d/jAAw8wwAADDDDAAAMMPPDh/vEDChIBAAt//DPc4AMPPPDAAw888MADDzz4cP/8AQgSAQAJ//8DAwMDAwM/PwMDAwMDA///CBIBAAn//wMDAwMDAz8/AwMDAwMDAwMKEgEAC/z4d/jAAwwwwADjjz/wwAMPPPDB/vMPChIBAAsDDzzwwAMPPPDA//8/8MADDzzwwAMPDAISAQAD/////w8GEgAABjAMwzAMwzAMwzAM498DChIBAAsDDzz4YMMNM84cP/wwxzjDDDfY4AMPDAgSAQAJAwMDAwMDAwMDAwMDAwMDA///DxIBABAH8AP4A/4B/8HfYO+4Z8xz57Hx+Hg4PBweAA+AB8AD4AEwChIBAAsHH/zwwx9vvPPMc489/vDDDz74wAMPDAoSAQAL/Ph3+MADDzzwwAMPPPDAAw888OH+8QMKEgEAC//8N/jAAw888OD//TPAAAMMMMAAAwwAChUBAAv8+Hf4wAMPPPDAAw888MADDzzw+f7xAw5wgAMKEgEAC//8N/jAAw888OD//TfMMMMNNtjgAw8MCRIBAAp8/B0fPOCAAw444IADDhjw4OP++AAKEgAACv//DwMMMMAAAwwwwAADDDDAAAMMMMAAChIBAAsDDzzwwAMPPPDAAw888MADDzzw4f7xAwoSAQALAw888MCGGWaYYcwwwwwzeOCBBwwwwAAREgEAEgOABwAPAB4APAD4APjhcMPhxseczzmbY3fH7oaPDx8fHBw4OHBwAAsSAAALAx7wwQ3mOMZwBxv4wAc2uMMYxxns4AMeMAoSAQALAw98uGGGOccMM/zggQcMMMAAAwwwwAAIEgEACf//wMBgYDAwGBgMDAYGAwP//wQWAQAF/zMzMzMzMzMzM/8IFgEACQMDAwYGBgwMDBgYGBgwMDBgYGDAwMAEFgEABf/MzMzMzMzMzMz/CAQBAAkYPGbDCgIBEgv//w8EAwEABWMMCA4BBAk8fufAwPz+x8PDw+f+3AgSAQAJAwMDAzt/58PDw8PDw8PD5387CA4BBAk8fufDAwMDAwMDw+d+PAgSAQAJwMDAwNz+58PDw8PDw8PD5/7cCA4BBAk8fufDw8P/fwMDw+d+PAgSAAAI8PgcDAx/fwwMDAwMDAwMDAwMCRQBAgrAwfHxd3zw4OP//BgwwMff8cGDj/vjAwgSAQAJAwMDAzt/58PDw8PDw8PDw8PDAhIBAAM//P//DwQWAAAEzAzAzMzMzMzM7DcIEgEACQMDAwMDw8PjczsfHztzY+PDwwISAQAD/////w8ODgEEDzvP/3eeD8PD8DA8DA/Dw/AwPAwPw8PwAAwIDgEECTt/58PDw8PDw8PDw8PDCA4BBAk8fufDw8PDw8PDw+d+PAgSAQQJO3/nw8PDw8PDw8PnfzsDAwMDCBIBBAnc/ufDw8PDw8PDw+f+3MDAwMAGDgEEB/t/DMMwDMMwDMMACA4BBAk8fufDAw8+eODAw+d+PAYSAAAGDMMwzP8zDMMwDMMwPA4IDgEECcPDw8PDw8PDw8PD5/7cCg4BBAsDDzzw4YYZ5hwzzPCDBx4wwAANDgEEDgN4AA/gATyOz/l9t222zfd5PI/HYBgMCQ4ABAmDjxtzx4YPDhx82LgzdnwwChIBBAsDD3y4YYY5xwwz/OCBBwwwwIADBh44AAYOAQQH/w/DOMYxjnEM/w8HFgEACHA8h8FgMBgMx+HgYDAYDAaDg4cDAhYBAAP//////w8HFgIACYcHB4PBYDAYHByOw2AwGAyG8zgACgQBAAsc+37fOAISAQADP/z//w8IEgECCRgYGBg8fucDAwMD5348GBgYGAoSAAAK8OCDAQcMMMAAAwz88YcBBhhgwAH//w8KEwEACwMf7hw//DhnmGGGGWaYYYY5xw8/zh0+MAoSAQALAw98uGHOMcMPHnjA4J9/MPjnHwwwwAACFgEAA///D///DwgUAQAJPH7nwwMHPn7iw8NHfnzgwMPnfjwGAgEAB/MMEhIBABPgH+D/wQGOA3DGj41/PIfxDMAzAM8APAPwHMbjHxs/5gAcBzj4f4B/AAgOAQAJfv/DwP7/w+P/3gAA//8LCgAGCzDGOeecc45zOIdzOIcxCgYBCAv//w844IADDgwMAQAN+OF/BrbP+73Z+7zf221g/ocfCAIBAAn//wgIAQAJPH7nw8PnfjwMDQEFDWAABmAABmDw//8PBmAABmDw//8PBgoBAAfeP8M45xz/DwYKAQAH3j/DHA/PvwcEAwEABWwDCBEBBAnDw8PDw8PDw8Pn/9sDAwMDAwwWAAAM/O////zP//zP/szPwAzMwAzMwAzMwAzMwAzMwAzMwAzMAgMBCQM/BQQAEgUYfwcGCgEAB4zzNAzDMP8PCA4BAAk8fufDw8PD5348AAD//wsKAAYLYziHcziHc5xzzjnnGAMREgEAEhgAOQB7ANMAgwEDAwMGAwwDfmN84wDjAeMD4wbjDOM/w38DYALAABESAQASGAA5AHsA0wCDAQMDAwYDDAN+f3z/AZ8DGwczBwMHAwcDBwP/Av4BERIBABI+AP8AjwMDBoMHAw8DMINxA39jfOMA4wHjA+MG4wzjP8N/A2ACwAAIEgEACRgYGAAAGBgYHA4HAwMDw+d+PAwSAQANOAAOAAAGYAAP8IAZmMEwDMM//mdgBjbAAzzADBIBAA3AAQcAAAZgAA/wgBmYwTAMwz/+Z2AGNsADPMAMEgEADfDAMAAABmAAD/CAGZjBMAzDP/5nYAY2wAM8wAwSAQANOGYcAAAGYAAP8IAZmMEwDMM//mdgBjbAAzzADBIBAA2YgRkAAAZgAA/wgBmYwTAMwz/+Z2AGNsADPMAMEwEADfCAGZgBD2AABvAAD5iBGQzDMPzjfwZmYAM8wAMMDhIBAA/gP/gPH8AGsAFugBlgBpwP/8MfGAaGgWFwGAwGg//gDwoWAQAL/Ph3+MADDzDAAAMMMMAAAww88OH+8QMDDDxwAAgSAQAJDjgA//8DAwMDPz8DAwMDA///CBIBAAlwHAD//wMDAwM/PwMDAwMD//8IEgEACRhmAP//AwMDAz8/AwMDAwP//wgSAQAJZmYA//8DAwMDPz8DAwMDA///BRIAAAWHA8YYY4wxxhhjjAEFEgAABfwAY4wxxhhjjDHGAAYSAQAHzAwwDMMwDMMwDMMwDAMGEgAABvMMMAzDMAzDMAzDMAwDDBIAAAz8wT8Mx+AMzMAMzMB//McMzMAMzMAMznD8wx8KEgEACxyPA8DBBz/88MY7zzz28MMPPvjAAw8MChIBAAscwAEAP/4dPvDAAw888MADDzzw4f7xAwoSAQAL4OAAAD/+HT7wwAMPPPDAAw888OH+8QMKEgEACzAwAwA//h0+8MADDzzwwAMPPPDh/vEDChIBAAscjwMAP/4dPvDAAw888MADDzzw4f7xAwoSAQALzDADAD/+HT7wwAMPPPDAAw888OH+8QMKCgEGCwMf7hw/eODBj3OHDwwKEgEAC3z7f9jgww8//thzz7zzxh8//LDh/+0DChIBAAscwAHAwAMPPPDAAw888MADDzzw4f7xAwoSAQAL4OAAwMADDzzwwAMPPPDAAw888OH+8QMKEgEACzAwA8DAAw888MADDzzwwAMPPPDh/vEDChIBAAvMMAPAwAMPPPDAAw888MADDzzw4f7xAwoSAQAL4OAAwMADG2YYM8zggQcMMMAAAwwwwAAKEgEACwMMMMAA//w3+MADDzzw4P/9M8AAAwwACxIAAAvwwA/nGMYwhjHuPe9jOIMZzGAGM5jl7GMOCBIBAAkOHDgAPH7nwMD8/sfDw8Pn/twIEgEACXA4HAA8fufAwPz+x8PDw+f+3AgSAQAJPGbDADx+58DA/P7Hw8PD5/7cChIBAAsc+zcOADz4cQ4wwPDjzzHDDDPMOf5wAwgSAQAJZmYAADx+58DA/P7Hw8PD5/7cCBUBAAkYPGZmPBgAPH7nwMD8/sfDw8Pn/twODgEEDzyP/3eeD8PAMD/sjx9/w88wMAyf5/4fzwMIEgEECTx+58MDAwMDAwPD5348GBgeDggSAQAJDhw4ADx+58PDw/9/AwPD5348CBIBAAlwOBwAPH7nw8PD/38DA8PnfjwIEgEACRhmwwA8fufDw8P/fwMDw+d+PAgSAQAJZmYAADx+58PDw/9/AwPD5348BRIAAAXHccAYY4wxxhhjjAEFEgAABdwdYIwxxhhjjDHGAAgSAAAIGGbDABgYGBgYGBgYGBgYGBgYBhIAAAbzDAAMwzAMwzAMwzAMAwgSAQAJBu78P3dgfP7nw8PDw8PD5348ChIAAAoc+zcOAHb445xhhhlmmGGGGWaYYYYZBggSAQAJDhw4ADx+58PDw8PDw8PD5348CBIBAAlwOBwAPH7nw8PDw8PDw8PnfjwIEgEACRhmwwA8fufDw8PDw8PDw+d+PAoSAAAKHPs3DgB48OOcYYYZZphhhhlmmHP84AEIEgEACWZmAAA8fufDw8PDw8PDw+d+PAwMAQUNYAAGYAAAAPD//w8AAAAGYAAGCg4ABAp48++cceaZZ5ttnnnmmHP/7AEIEgEACQ4cOADDw8PDw8PDw8PDw+f+3AgSAQAJcDgcAMPDw8PDw8PDw8PD5/7cCBIBAAkYZsMAw8PDw8PDw8PDw8Pn/twIEgEACWZmAADDw8PDw8PDw8PDw+f+3AoWAQAL4MCBAwADD3y4YYY5xwwz/OCBBwwwwIADBh44AAgWAQAJAwMDAwMDP3/jw8PDw+N/PwMDAwMDAwoWAQALzDADAAADD3y4YYY5xwwz/OCBBwwwwIADBh44AAwSAQAN/ud/AAAGYAAP8IAZmMEwDMM//mdgBjbAAzzACBIBAAn//wAAPH7nwMD8/sfDw8Pn/twMFAEADQzDOfgBDwAABmAAD/CAGZjBMAzDP/5nYAY2wAM8wAgUAQAJw+d+PAAAPH7nwMD8/sfDw8Pn/twMFQEADWAABvAAD/CAGZiBGQzDMPzjfwZmYAc+wAM/2IABeAAHCBEBBAk8fufAwPz+x8PDw+f+3Bh4cAoSAQAL4OAAAD/+HT7wAAMMMMAAAwww8OH+8QMIEgEACXA4HAA8fufDAwMDAwMDw+d+PAoSAQALMDADAD/+HT7wAAMMMMAAAwww8OH+8QMIEgEACRhmwwA8fufDAwMDAwMDw+d+PAoSAQALMMAAAD/+HT7wAAMMMMAAAwww8OH+8QMIEgEACRgYAAA8fufDAwMDAwMDw+d+PAoSAQALzMAAAD/+HT7wAAMMMMAAAwww8OH+8QMIFAEACcNmPBgAADx+58MDAwMDAwPD5348ChIBAAvMwADAH/8MN/jAAw888MADDzz4cP/8AQsSAQAMwAY2sIHNbX+fYxjDGMYwhjGMYQzjHP7gBgoSAQAL//0HwB//DDf4wAMPPPDAAw88+HD//AEKEgEAC8DAAz/w3PhzzjDDDDPMMMMMM8w5/nADCBIBAAn//wD//wMDAwM/PwMDAwMD//8IEgEACf//AAA8fufDw8P/fwMDw+d+PAgSAQAJwzwA//8DAwMDPz8DAwMDA///CBQBAAnD5348AAA8fufDw8P/fwMDw+d+PAgSAQAJGBgA//8DAwMDPz8DAwMDA///CBIBAAkYGAAAPH7nw8PD/38DA8PnfjwIFgEACf//AwMDAwMDPz8DAwMDAwP//xgYeHAIEgEECTx+58PDw/9/AwPD5348GBh4cAgSAQAJZhgA//8DAwMDPz8DAwMDA///CBQBAAnDZjwYAAA8fufDw8P/fwMDw+d+PAoWAQALeDBjGAD8+Hf4wAMMMMAA448/8MADDzzwwf7zDwkWAQAKeJgZBgAcHB9/x4//82PAAB9/xwcPPu6PDwoVAQALhjnHDwD8+Hf4wAMMMMD44w888MADD3yw//wDCRYBAAqGnfMDABwcH3/Hj//zY8AAH3/HBw8+7o8PChYBAAswwAAAAPz4d/jAAwwwwADjjz/wwAMPPPDB/vMPCRUBAAowYAAADo6Pv+PH//kxYICPv+ODBx/3xwcKFgEAC/z4d/jAAwwwwADjjz/wwAMPPPDB/vMPABw4cAAJFgEACggwYAAAHBwff8eP//NjwAAff8cHDz7ujw8KFgEAC3gwYxgAAw888MADDzzwwP//P/DAAw888MADDwwIFgEACTxmwwADAwMDO3/nw8PDw8PDw8PDw8MKFgEAC///DwAAAw888MADDzzwwP//P/DAAw888MADDwwKEgAACgz88AMD7PDHOcMMM8wwwwwzzDDDDDMMChUAAAocjwMADDDAAAMMMMAAAwwwwAADDDDAAAMMMAAKEwAAChz7Nw4AAGCAAQYYYIABBhhggAEGGGCAAQgWAAAI//8AABgYGBgYGBgYGBgYGBgYGBgYGAgSAAAI//8AABgYGBgYGBgYGBgYGBgYCBYAAAjD534AGBgYGBgYGBgYGBgYGBgYGBgYCBQAAAjD5348AAAYGBgYGBgYGBgYGBgYGAUVAAAFGGOMMcYYY4wxxn6P5wAFFQAABcYAY4wxxhhjjDFmjO8BAhUBAAPP/////wMCDgEEA////w8JEgEACoMHDx48ePDgwYMHDx48ePDg4fv2AAcWAQAI4/EYABiPx+PxeDwej8djMxiOwwAJFgAACXiYGQYAAwYMGDBgwIABAwYMGDBgwMDx4QEIFgAACDxmwwAYGBgYGBgYGBgYGBgYGBgcDgYKFQEACwMPPPhgww0zzhw//DDHOMMMN9jgAw8MBw4cAAgWAQAJAwMDAwPDw+NzOx8fO3Nj48PDADgcDggNAQUJw8PD43M7Hztz48PDwwgVAQAJOA4AAwMDAwMDAwMDAwMDAwMDA///BRUAAAX8AGOMMcYYY4wxxhhjAAgWAQAJAwMDAwMDAwMDAwMDAwMDA///ADgcDgQWAAAEZmZmZmZmZmZmzH8IEgEACcPDw8PDwwMDAwMDAwMDAwP//wUSAQAGe++99xhjjDHGGGMACBIBAAkDAwMDAwMDMzMDAwMDAwMD//8FEgEABmOMMcbYe4wxxhhjAAoSAAAKDDDAAAMMMMAcf388wAADDDDAAAP88w8GEgAABgzDMAzPe8/DMAzDMAwDChIBAAvg4ADAwQc//PDGO8889vDDDz74wAMPDAgTAQAJcDgcAAA7f+fDw8PDw8PDw8PDwwoWAQALBx/88MMfb7zzzHOPPf7www8++MADDwwAHDhwAAgSAQQJO3/nw8PDw8PDw8PDw8MAOBwOChIBAAuG4QHAwQc//PDGO8889vDDDz74wAMPDAgUAQAJw2Y8GAAAO3/nw8PDw8PDw8PDw8MIEwEACQMDAwEAO3/nw8PDw8PDw8PDw8MKFgEAC/v8d/jAAw888MADDzzwwAMPPPDAAwMMOHD44AAIEwEDCTt/58PDw8PDw8PDw8PDwMDgfDwKEgEAC///DwA//h0+8MADDzzwwAMPPPDh/vEDCBIBAAn//wAAPH7nw8PDw8PDw8PnfjwKEgEAC4bhAQA//h0+8MADDzzwwAMPPPDh/vEDCBQBAAnD5348AAA8fufDw8PDw8PDw+d+PAsSAQAMOHcOAPjhn8MNbGADG9jABjawgQ3scP7hBwoTAQALnDt3DgAA8ODHOcMMM8wwwwwzzDDn+MEDEBIBABH8/v7/hwMDAwMDAwMDAwMDAw8DDwMDAwMDAwMDAwOHA/7//P4ODgEED7yP/3eMD8PD8DA8/A9/w8AwMAwf4/4f7wMKFQEAC+DgAMA//w0+8MADDzz4f/8NM8xwgw02+MADAwYTAQAHOOcAwP4fwzAMwzAMwzAAChYBAAv//Df4wAMPPPDg//03zDDDDTbY4AMPDAAcOHAABhIBBAf7fwzDMAzDMAzDwTDPAQoWAQALhjGDBwD//Df4wAMPPPDg//03zDDDDTbY4AMPDAgUAAAIw2Y8GAAAdn4OBgYGBgYGBgYGBgYJFQEACuBwAODj7/jgAQcccMABBxxwwIAHH/fHBwgTAQAJcDgcAAA8fufDAw8+eODAw+d+PAkWAQAKeJgZBsDH3/HBAw444IADDjjggAEPPu6PDwgUAQAJGDxmwwAAPH7nwwMPPnjgwMPnfjwJFgEACnz8HR884IADDjjggAMOGPDg4/74wIDhwwMIEgEECTx+58MDDz544MDD5348GBgeDgkWAQAKhpnhAcDH3/HBAw444IADDjjggAEPPu6PDwgUAQAJw2Y8GAAAPH7nwwMPPnjgwMPnfjwKFgAACv//DwMMMMAAAwwwwAADDDDAAAMMMIABBhh44AAGFgAABgzDMMz/MwzDMAzDMDyOYZ4DChYAAAqGMYMHAP//DwMMMMAAAwwwwAADDDDAAAMMMMAACBIAAAjMzMzMzD8/DAwMDAwMDAwMPDgKFgAACv//DwAA//8PAwwwwAADDDDAAAMMMMAAAwwwwAAGEgAABgzDMMz/M8z/MwzDMDwOChIBAAscjwPAwAMPPPDAAw888MADDzzw4f7xAwoTAQALHPs3DgAADDPMMMMMM8wwwwwzzDDn+MMNChIBAAv//w/AwAMPPPDAAw888MADDzzw4f7xAwgSAQAJ//8AAMPDw8PDw8PDw8PD5/7cChIBAAuG4QHAwAMPPPDAAw888MADDzzw4f7xAwgUAQAJw+d+PAAAw8PDw8PDw8PDw8Pn/twKFQEAC3gwwwweAw888MADDzzwwAMPPPDAAw98uH/8AAgWAQAJGDxmZjwYAADDw8PDw8PDw8PDw+f+3AsVAQAMOHcOAAY2sIENbGADG9jABjawgQ1sYAMb2OH8ww8JEwEACtzd3QEAYNiwYcOGDRs2bNiwYef8cQMKFgEACwMPPPDAAw888MADDzzwwAMPPPDh/vEDAwzwgAMIEgEECcPDw8PDw8PDw8PD5/7cGBh4cBEWAQASgAeAGYBhAAAwAHgA8ADgAcADgA+AHw43HG58zPmcszl2d+xu+Pjw8cHBgYMDBwcNFAEADsAAPMAMDAMAAMAAHsADeACP43N+322bbfN9Hs/jMRgGAwoSAQALMDADwMADG2YYM8zggQcMMMAAAwwwwAAKFgEAC3gwYxgAAw98uGGGOccMM/zggQcMMMCAAwYeOAAKEgEAC8wwA8DAAxtmGDPM4IEHDDDAAAMMMMAACBIBAAlwHAD//8DAYDAwGAwMBgMD//8GEgEABzjnAP8PwzjGMY5xDP8PCBMBAAkYGAAA///AwGAwMBgMDAYDA///BhIBAAcMAwD/D8M4xjGOcQz/DwgSAQAJzDAA///AwGAwMBgMDAYDA///CBIAAAjDZhgAfn5gYHAwOBgcDA4Gfn4HEgAAB3A8h8FgPBwMBoPBYDAYDAYIFgAACODwOBgYGBgYGH5+GBgYGBgYGBgcDwcOFgEADwAHcAAAAADgP/gPH8AGsAFugBlgBpwP/8MfGAaGgWFwGAwGg//gDw4TAQAPgANwAA4AAAAAz+P/nefDMDDMD/vjx9/wMwwMw+e5/8fzAAoVAQAL4OAAAN/+Hzb48MOPP/bcM++88ccPP2z4f/sAChMAAArgwIEDAADgzb9zxplnnm22eeaZY879swcJFgEACnz8HR884IADDjjggAMOGPDg4/74AMDBwQEIEgEECTx+58MDDz544MDD5348ADgcDgoWAAAK//8PAwwwwAADDDDAAAMMMMAAAwwwwAAAHDhwAAYWAAAGDMMwzP8zDMMwDMMwPA5wzgEIBAAACBg8ZsMIBAAACMNmPBgIBAAACMPnfjwCAgEAAw8GBgIACN4/z78HBQQBEgZjfAcIAwAACM7/cwgGAAAIzMxmZjMzChIBAAv8+Hf4wAMPPPDAAw888OGGOccMM88/DwoOAQQL///PDDPMMMMMM8wwwwwzzDEGDAIBCg3///8UAgEKFf//////AwYBAATe/gMDBgEABP/tAQMGAQ8E/+0BBwYBAAjm2ex+vwMHBgAAB/f73WyeAQcGAA8H9/vdbJ4BBgwBAAcMw/w/wzAMwzAGEgEABwzD/D/DMAzDMMz/MwwDBwcBBwgc3///93EADAMBDw1jPMZjDBoSAQAbfAAD+AcPcPwfwOA/AINxAAzmAHDcAYC/AwB8BwAA7uMD3N8fuOPjcAYH4xgczGFwsIPj4wf8/Q3g4wMFCgEGBhAzM4ZhGAIFCgAGBWEYhjEzIwAIFgEACcDAwOBgYHAwMDgYGBwMDA4GBgcDAwMLEgEADPDBH8cZzAAG/OMfDGDAP/7BAAYwmOP4gw8JBgAACR9t27dt2zYKEgEAC/z4d/jAAw888MADDzzw4YY5xwwzzz8PCBIBAAk8fufDwMDc/ufDw8PDw8PnfjwLEgAAC3CAAxzggA98YIM7jGGM4wxmsIMPeMD//z8MEgAADP///wZmYAZmYAZmYAZmYAZmYAZmYAZmYAZmYAgSAAAI//8DBwYODBwYGBwMDgYHA///DAIACgz///8RFAEAEgCAAQADAAcABgAOAAwAHAAYADgAMABwAGAw4ODAgMMBjgG4A+ADgAcABgASCgEGE3z4+PN3/PjgwQMDDww8ePDx4/788eEDCBYAAAjg8DgYGBgYGBgYGBgYGBgYGBgYHA8HDAkABgx87n/nAwAAAAB87n/nAwwOAAQMAAMwgPH//w8MYAAGMPD//48BDMAADA0ABQwAD/zwwQcf8AF8AB/AD/AA8P//DwwNAAUMD/AD+AA+gA/44IMPP/AAAPD//w8LFgIADf8PYAADGMAABjCAAQxgAAMYwAAGMIABDGAAAxjA/wMNDQAEDUAAHMAGjMFgDNgANmAMBmPABnAABAACAwETAz8JEgAACfDxc2DA4P9/xowZM2bMmDFjxowZAwkSAAAJ8PFzZsz4/3/GjBkzZsyYMWPGjBkD");
  base64DecodeToExistingUint8Array(bufferView, 212192, "Axx0AQAA/wIKAQACAAABAggAAgEQAAMBFAAEARgABQEcAAYBIAAHASQACAEoAAkBLAAKATAACwE0AAwBOAANATwADgFAAA8BRAAQAUgAEQFMABIBUAATAVQAFAFYABUBXAAWAWAAFwFkABgBaAAZAWwAGgJwABsCeAAcAoAAHQKIAB4BkAAfAZQAIAKYACECoAAiAqgAIwKwACQDuAAlAsQAJgLMACcC1AAoA9wAKQLoACoC8AArAvgALAIAAS0CCAEuAhABLwIYATACIAExAygBMgI0ATMEPAE0BEwBNQJcATYCZAE3AmwBOAN0ATkDgAE6A4wBOwKYATwEoAE9A7ABPgO8AT8CyAFABNABQQPgAUID7AFDA/gBRAIEAkUCDAJGAxQCRwMgAkgCLAJJAjQCSgI8AksCRAJMAkwCTQNUAk4CYAJPAmgCUANwAlECfAJSAoQCUwKMAlQClAJVApwCVgKkAlcCrAJYArQCWQO8AloDyAJbAtQCXALcAl0C5AJeAuwCXwL0AmAC/AJhAgQDYgIMA2MCFANkAxwDZQIoA2YCMANnAjgDaAJAA2kCSANqA1ADawJcA2wCZANtAmwDbgJ0A28CfANwAoQDcQKMA3IClANzApwDdAKkA3UCrAN2ArQDdwK8A3gCxAN5AswDegLUA3sC3AN8AuQDfQLsA34C9AN/AfwDgAEABIEABASCAQQEgwAIBIQACASFAAgEhgEIBIcBDASIABAEiQAQBIoAEASLABAEjAAQBI0AEASOABAEjwAQBJAAEASRABAEkgAQBJMBEASUABQElQAUBJYAFASXABQEmAAUBJkAFASaABQEmwAUBJwAFASdABQEngAUBJ8AFASgABQEoQEUBKIBGASjARwEpAEgBKUBJASmASgEpwEsBKgBMASpATQEqgE4BKsBPASsAkAErQBIBK4BSASvAUwEsAFQBLEBVASyAVgEswFcBLQBYAS1AWQEtgFoBLcBbAS4AXAEuQF0BLoCeAS7AYAEvAGEBL0BiAS+AYwEvwGQBMABlATBAZgEwgGcBMMCoATEAagExQGsBMYBsATHAbQEyAK4BMkCwATKAcgEywHMBMwC0ATNAdgEzgHcBM8B4ATQAeQE0QHoBNIB7ATTAfAE1AL0BNUB/ATWAQAF1wEEBdgBCAXZAQwF2gIQBdsCGAXcAiAF3QIoBd4CMAXfAjgF4AFABeEBRAXiAUgF4wFMBeQBUAXlAVQF5gFYBecBXAXoAWAF6QFkBeoBaAXrAWwF7AFwBe0BdAXuAXgF7wJ8BfABhAXxAYgF8gGMBfMBkAX0AZQF9QGYBfYBnAX3AaAF+AGkBfkBqAX6AawF+wGwBfwCtAX9A7wF/gLIBf8A0hb+Ac4qAAH4Fv8BCysBASsXAgFJFwMBfxcEAaAXBQHZFwYB9xcHASYYCAFJGAkBeBgKAZsYCwHKGAwB6xgNARoZDgE9GQ8BbBkQAZ0ZEQHJGRIB7xkTARUaFAEzGhUBWxoWAXwaFwGkGhgBxRoZAesaGAI6KxoBCRsZAmkrGwExGxoChCscAVQbGwK6Kx0BgxseAasbIAAAAB8B2hshAAUAIAECHCIAEAAhATEcIwAbACIBWRwkADwAIwGIHAIiKS4lAGIAJAGwHCYAmQAlAd8cJwDFACYBBx0oAMwAJwE4HQYiSi4pAOUAKAFeHSoA/gApAYYdKwASASoBpx0sADABKwHNHS0AOQEsAesdLgBAAS0BEx4vAEYBLgE0HjAAbAEvAU4eMQCNATABaB4PInYuMgCjATEBex4zAMQBMgGEHhMgeCwRIqIuNADlATMBqh4UIIAsEiLDLjUACwI0AcseNgAsAjUB+h43AE0CNgEiHzgAbgI3AU4fGCCJLDkAjwI4AW8fGSCSLDoAsAI5AYQfGiCbLDsAuQI6AawfPADIAjsBxh8cIKQsGiLLLj0A5AI8Ae4fHSCxLD4A9wI9AQEgHiC+LD8AEwM+ASIgQAA0Az8BPSAgIMssHiIML0EAcANAAV4gISDkLEIAnANBAXQgIiAFLUMAwgNCAZogIiHnLUQA6ANDAbAgRQAOBEQB3yBGAC8ERQECISYgFy1HAFAERgExISYhAy5IAHYERwFSIUkAnARIAYEhSgCnBEkBpCFLAMIESgHHIUwA6ARLAfYhTQAJBUwBFyIrIigvTgBABU0BQyJPAGYFTgFhIlAAjAVPAZAiMCAjLVEAsgVQAbEiUgDeBVEB4CJTAAQGUgEJI1QAKgZTAUUjVQBWBlQBbiNWAHwGVQGdI1cAqAZWAbojWADfBlcB6SNZAAsHWAEEJDkgey1aADcHWQEzJDogiC1bAFgHWgFWJFwAcQdbAYUkXQCXB1wBoiReALAHXQHRJF8AvQdeAfQkYADEB18BICVhAM4HYAE5JWIA5wdhAWglYwAICGIBiyVkACEIYwG+JUQglS1lAEIIZAHdJWYAWwhlARMmZwB2CGYBOSZoAJkIZwFsJmkAughoAYcmagDFCGkBtiZIIlAvawDfCGoB1yZsAPoIawEDJ20ABQlsASEnbgAuCW0BUCdvAEcJbgFxJ3AAYAlvAaAncQCBCXABxidyAKIJcQH1J3MAtwlyAR4odADMCXMBSih1AOcJdAFoKHYAAAp1AZ8odwAZCnYB1ih4AEIKdwECKXkAWwp4ASopegB8CnkBVil7AJEKegF3KXwAsAp7AZEpfQC8CnwBsSl+ANsKfQHLKX4B7Cl/AQwqYCJnL2QiiC9lIqIvkgEnKqEA5QqiAPAKowATC6QAPwulAFkLpgCFC6cAkQuoALcLqQDAC6oAAgyrABsMrAAvDKkDNSyuADwMrwBqDLAAcgyxAIQMsgClDLMAtgy0AMcMtQDRDLYA8gy3AB4NuAAkDbkALA26ADoNw/YQMLsAUw28AGcNvQChDb4A2w2/ABUOwAA2DsEAYg7CAI4OwwC6DsADWyzEAOYOxQASD8YAQQ/HAHgPyACkD8YC2yvJAMUPxwLoK8oA5g/LAAcQzAAoEKwguy3NADsQzgBOEM8AbxDQAIUQ0QCxENIA3RDTAAMR1AApEa8lvC/VAE8R1gB7EdcAoRHYALMR2QDkEdoAChLYAvUr2wAwEtkC/yvcAFYS2gIGLN0AfBLbAhMs3gCoEtwCHSzfAM4S3QInLOAA9BLhABUT4gA2E+MAVxPkAHUT5QCTE+YAthPnAN8T6AD9E+kAHhTqAD8U6wBgFOwAfhTtAJQU7gCqFO8AyxTKJfIv8ADfFPEABRXyACMV8wBEFfQAZRX1AIYV9gCkFfcAwhX4AOAV+QABFvoAIhb7AEMW/ABkFgH7FzD9AIIW/AFPKgL7PTD+AKoW/QGTKgYAAAEGAhYCAAT/////8A8GCAIACPM8z/M8zw4QAAAOwAwwA2aAGf///w8zwAwwA8zw////mAFmwAwwAwoaAgAMMMAAAwz8+DfzzDPMMMMM/vAHM8wwwzzzzP7xAwMMMMAAFBQCAhb8AOwfYAMDMzAYA8MwMAYDMzCwAf4NwG8AAPMDmH/ADAzGwDAMjMHADAxswMAD+DcAPw4WAgAQ8AP+wcAwMAwMA8PAMDAMBsMAH8ADDLPDNsAMMAPMADOwDWz+MT8MAggCAAT//wYaAgAIMAxjGMMYxjAMwzAMg2EwDIbBMAwGGgIACMMwGAbDYBgMwzAMwzCGMYxhDMMACgwBAAswwDDz//zggQc//88MAwwODgIGEMAAMAAMAAPAADDw////wAAwAAwAA8AAMAAECAASBMxsNjMIAgIMCv//AgQCEgT/ChoCAAwAAwwYYIABAwwwYIABBgwwwIABBhgwwAADBhhgwAADDAAKFgIADPz4N/DAAw888MADDzzwwAMPPPDAAw888MD+8QMGFgQACs7DMAzDMAzDMAzDMAzDMP8PChYCAAz8+DfwwAADDDDAAAMMMMDAgAEDBgwYMMAA//8PChYCAAz8+DfwwAADDDDAAAPMDz8AAwwwwAADPPDA/vEDDBYAAAwAAzjAAzYwgzEMYzADMzD///8AAzAAAzAAAzAAAzAAAzAKFgIADP//P8AAAwwwwAD//AcwwAADDDDAAAM88MD+8QMKFgIADPz4N/DAAwwwwAD//DfwwAMPPPDAAw888MD+8QMKFgIADP//DzDAAAMGGGDAAAMMGGCAAQMMMMAAAwwwwAAKFgIADPz4N/DAAw888MADD8wPPwMPPPDAAw888MD+8QMKFgIADPz4N/DAAw888MADD+w//wADDDDAAw888MD+8QMCEAIGBP8AAP8EFAAGBMzMAAAAAMxmMzMKEgIEDAADBgwYMGDAgAEDDGAAAxjAAAYwgAEMDggCChD///8PAAAAAAAA8P///woSAgQMAxjAAAYwgAEMYAADDBgwYMCAAQMGDAAKFgIADPz4N/DAAAMMMMAAAwwMGDDAAAMMAAAAAwwwwAAUFgIAFsA/AP4HMMCAARgMAGMAYAM/PPjDwzA8DMPDMDwMw8M4POzDgzM8AMMGMMwAwxjwBwM/4AMAPAAOFgIAEMAAMAAegAcwA8wAM2AYGAaGwcAwMAwMA+P/+X8GmAE2AA/AA/AADAwWAgAO//N/AzzAAzzAAzzAAzzA//M/AzzAAzzAAzzAAzzA//c/DBYCAA78438DPMADMAADMAADMAADMAADMAADMAADMAADPMD+xz8MFgIADv/zfwM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wP/3PwoWAgAM//8/wAADDDDAAAMM8M8/AwwwwAADDDDAAP//DwoWAgAM//8/wAADDDDAAAMM8M8/AwwwwAADDDDAAAMMAAwWAgAO/ON/AzzAAzAAAzAAAzAAAz/wAzzAAzzAAzzAAzzA/s//DBYCAA4DPMADPMADPMADPMADPMD///8DPMADPMADPMADPMADPMACFgIABP//////DwgWAAAIwMDAwMDAwMDAwMDAwMDAwMDAwMB/PwwWAgAOAzzAAzZgAzMwgzEYwzAM//APwzAMgzEYAzMwAzZgAzzAChYCAAwDDDDAAAMMMMAAAwwwwAADDDDAAAMMMMAA//8PEhYCABQDAB8A/gD8B/gzMM/APIbxGMbDDA8zPHjw4MEDAw8MPADwAMADAA8APADwAMADAA8ADAwWAgAOAzzAB3zAD/zAG7zBMzzDYzzGwzzMgz3YAz/wAzzAAzzADBYCAA78438DPMADPMADPMADPMADPMADPMADPMADPMADPMD+xz8MFgIADv/zfwM8wAM8wAM8wAM8wP/3PwMwAAMwAAMwAAMwAAMwAAwaAgAO/ON/AzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzA/sc/AAzAAAzADBYCAA7/838DPMADPMADPMADPMD/9z8DMzADMzADNmADNsADPMAMFgIADvzjfwM8wAMwAAbAABgAA2AADIABMAAGYAAMwAM8wP7HPw4WAAAO////DwwAA8AAMAAMAAPAADAADAADwAAwAAwAA8AAMAAMAAPAADAADBYCAA4DPMADPMADPMADPMADPMADPMADPMADPMADPMADPMD+xz8OFgIAEAPwADwAD8AGmAFmgBlgDAwDw8AwMBgGhoFhwAwwA8wAHoAHwAAwABIWAgAUAwAPADwA8ADAAwAPADww8MDAAwMPDDww8MDAAwMPDGx4mOFhhocxM8PMDDMzeHjAwAAOFgIAEAPwADwAG2AGGAPDwGAYGAbMAAwAAzADxoBhMDAMjAFmgA3AA/AADA4WAgAQA/AAPAAPwAOwAWaAMTAMDIaBYcAMMAPMAB6AB8AAMAAMAAPAADAAChYCAAz//w8wwIABBgwwYIABAwwYYMAAAwYYMMAA//8PBhoCAAj/PwzDMAzDMAzDMAzDMAzDMAz/DwoaAgAMAwwwgAEGGMAAAwxggAEGMMAAAxhggAEMMMAAAzDAAAMMBhoCAAj/D8MwDMMwDMMwDMMwDMMwDMP/DwoGAgAMMODBjGEDDwwIAgIUCv//BgYCAAjDYDAYDAoQAgYM/Pg38MAAA8y//wMPPPDAAw/sP/8KFgIADAMMMMAAAwzwz38DDzzwwAMPPPDAAw888MD//QMKEAIGDPz4N/DAAwwwwAADDDDAAAMP7B8/ChYCAAwAAwwwwAADzL//Aw888MADDzzwwAMPPPDA/vMPChACBgz8+DfwwAMPPPDA//8/wAADD+wfPwgWAAAI8PgMDAwM//8MDAwMDAwMDAwMDAwMDAoYAgQMwIPPj38DDzzwwAMPzA8/AwzAj38DDzzwwAMP7B8/ChYCAAwDDDDAAAMM8M9/Aw888MADDzzwwAMPPPDAAw8MAhYCAAT/8P///w8GHAAABjAMwwAAwzAMwzAMwzAMwzAMwzD8PQgWAgAKAwMDAwMDw8NjYzMzDw8zM2Njw8PDwwIWAgAE//////8PEhACBhT//PzzNzDwwMADAw8MPDDwwMADAw8MPDDwwMADAw8MPADwAMAKEAIGDP/8N/DAAw888MADDzzwwAMPPPDAChACBgz8+DfwwAMPPPDAAw888MADD+wfPwoWAgYM//w38MADDzzwwAMPPPDAAw/83z8DDDDAAAMMAAoWAgYM/Ps/8MADDzzwwAMPPPDAAw/sP/8AAwwwwAADDAgQAgYK4/MfDwMDAwMDAwMDAwMDAwgQAgYKPH7DwwMDPnzAwMDAw8N+PAgWAgAKDAwMDAwM//8MDAwMDAwMDAwMDAz48AoQAgYMAw888MADDzzwwAMPPPDAAw/sP/8KEAIGDAMPPPDAAw888MCGGcYMM3jgAQMMEhACBhQDAA8APADwAMADAw8MPDDwwMCGhxkexswMMzN4eODhAQMDDAwKEAIGDAMPPLBhhjEDAwzMGGbYwAMPPPDAChYCBgwDDzzwwIYZZphhzDDDDDN44AEDDDDAgAEDBgwACBACBgr//8DAYGAwGBgMDAYGA///CBoCAArw+AwMDAwMDAwMDAwDAwwMDAwMDAwMDAz48AIaAgAE////////DwgaAgAKDx8wMDAwMDAwMDAwwMAwMDAwMDAwMDAwHw8KBAIADDz7PN88AhYCAAT/8P///w8KGAICDDDAAAMMMMDAj38zzzzDDDPMMPPM/vEDAwwwwAADDA4WAAAOwA/4AwPAABgABoABYAAMAAPw//w/DAADwAAYAAaAATAADAD///8PDgwABg7z8/zMwDAwDAwDw8AwMAwMAzM/z88OFgIAEAPwADwAG2AGGAPDwGAYGAbMADPADP///w8MAAP///8PDAADwAAwAAIaAgAE////8P//DwoaAgAM/Pg38MADDDDAAPzwN/DAAw888MD+8AMwwAADPPDA/vEDCAQCAgrDw8PDFhYCABjA/wD4fwADMGAAGAw/jOEfNgwMjwHDMwDwDAA8AwDPAMAzAPAMADwGDA8Dw4Y/GMMPgwFgwAAM4P8B8D8AChACAAz//AcwwPz7P/DAAw/sP/8AAPD//wwKAggOMIxhDGMYwzAMhsEwGAbDCgYCCgz//w8wwAADDBISAgAU/P/4/zcA8ADA8w/PPzwD8wzMMzDPwDz/8PzDMzDPwDwA8ADA/v/x/wMKAgIADP//DwoKAgAM/Pg38MADDzzwwP7xAw4QAgYQMDwMD8PD8P///w/Dw/AwPAz/////A/wAP8AP8AgMAgAKP3/AwGAwGAwGA///CAwCAAo/f8DAPz/AwMDAfz8GBgIACDDGGMMAChYCBgwDDzzwwAMPPPDAAw/8//8DDzzAAAMMMMAAAwwADBoCAA787////M///M///M///M///M/+zM/ADMzADMzADMzADMzADMzADMwCBAIMBP8EBgAWBMzM/wYMAgAIzsMwDMMwDPP/ChACAAz8+DfwwAMPPPDAAw/sHz8AAPD//wwKAggOw2AYDINhMAzDGMYwhjEMExYBABRgAIADAB6A8QAGBhgwYICBAQwGYBgGYzj+4fGHDRhmYBiDYRgGwxj4Z8C/AYAHAAwAYAAAAxMWAQAUYACAAwAegPEABgYYMGCAgQEMBmAYAGMA/nnw7weYYWAGgwEYBmAYgGEAhgEYBmAAgH8A/AMTFgIAFTwA8APAMMCGAQYMGGBg8ICBBwbAGAZm+LDhh4fvH2Z+GINhGIbBGPxj4J8BwAYABgAwAIABChYCAAwwwAADDAAAAAMMMMAAAwYMGDDAAAMMMPDA/vEDDhYCABAYAAwABgADAAAwAB7ADDADzIBhYBgMDAPD//A/BpgBZoANwAPwAAwOFgIAEAAGwAAYAAMAADAAHsAMMAPMgGFgGAwMA8P/8D8GmAFmgA3AA/AADA4WAgAQ4AHMgGEwMAAAMAAewAwwA8yAYWAYDAwDw//wPwaYAWaADcAD8AAMDhYCABB8sDE2+AAAwAB4AB7ADDADzIBhYBgMDAPD//A/BpgBZoANwAPwAAwOFgIAEBgGhoFhAADAAHgAHsAMMAPMgGFgGAwMA8P/8D8GmAFmgA3AA/AADA4YAgAQwAB4ADPADOABMAAMgAfgAcwAM8AMGAaGwcAwMPwP/2OAGWAG2AA8AA/AEhYCABTA/wP/DzwA8ABgA4ANADMAzAAYA2AMwPAPwz8MAxgM4D+A/wADAwwMMDDAwAAD/w/8DwwaAgAO/ON/AzzAAzAAAzAAAzAAAzAAAzAAAzAAAzAAAzzA/sc/wAAMfMADChYCAAwYwAAGMAD8//8AAwwwwAD//DPAAAMMMMAA//8PChYCAAxgwIABAwD8//8AAwwwwAD//DPAAAMMMMAA//8PChYCAAx4MGPYwAD8//8AAwwwwAD//DPAAAMMMMAA//8PChYCAAzMMMMMAP//P8AAAwwwwAD//DPAAAMMMMAA//8PBRYAAAXDMAwYY4wxxhhjjDHGGAUWAAAFmJkBGGOMMcYYY4wxxhgKFgAACngwY9jAAMAAAwwwwAADDDDAAAMMMMAAAwwwwAAGFgAABvM8AwzDMAzDMAzDMAzDMAwDDhYAAA78D//HADPADDADzAAzwAwwA/wP/8MMMAPMADPADDADzAAzwPwf/wMOFgIAEHywMTb4AAADzADzwDwwG8wGM8PMMGPMGDPMDDODzWAz8Aw8A8wAAwwWAgAOGAADYAAMAMA//jfAAzzAAzzAAzzAAzzAAzzAAzzA/sc/DBYCAA6AAQxgAAMAwD/+N8ADPMADPMADPMADPMADPMADPMD+xz8MFgIADvCAGQxjYADAP/43wAM8wAM8wAM8wAM8wAM8wAM8wP7HPw4WAgAQfLAxNvgAAPyD/zHADDADzAAzwAwwA8wAM8AMMAPMADPADDD+B/8ADBYCAA4MwzAMAwD8438DPMADPMADPMADPMADPMADPMADPMD+xz8KCgAICgMPbBgzMMDAjGEDDwwQFgAAEPDP8M8MMAwwDDwMPAw8DDwMMwwzDDMMM8wwzDDMMMwwPDA8MAwwDDDzD/MPDBYCAA4YAANgAAwAMMADPMADPMADPMADPMADPMADPMADPMD+xz8MFgIADoABDGAAAwAwwAM8wAM8wAM8wAM8wAM8wAM8wAM8wP7HPwwWAgAO8IAZDGNgADDAAzzAAzzAAzzAAzzAAzzAAzzAAzzA/MM/DBYCAA4MwzAMAwADPMADPMADPMADPMADPMADPMADPMADPMD8wz8OFgIAEIABMAAGwAAAwAA8AA/ADAwDw8DADDADzAAMAAPAADAADAADwAAwAAwWAgAOAzAAAzAAAzAA//M/AzzAAzzAAzzA//M/AzAAAzAAAzAADBYAAAzwAA8MwzAMwzAMwzDP8zwMzMAMzMAMzMAMzMDMwzwMwAAKFgIADAxgAAMYwADAj38DDwwwwPz7P/DAAw888MD+8w8KFgIADMCAAQMGDADAj38DDwwwwPz7P/DAAw888MD+8w8KFgIADDDgwYxhAwPAj38DDwwwwPz7P/DAAw888MD+8w8KFAICDB7PPB4A/Pg38MAAA8y//wMPPPDAAw/sP/8KFAICDMwwwwwA/Pg38MAAA8y//wMPPPDAAw/sP/8KGAIADPDAwzDDDMMDDwD8+DfwwAADzL//Aw888MADD+w//xIQAgYU/Pzw8zMw8MDAAAMDDMw/MP/AA/8M/DMwwMAAAwMPDMzPDz8/ChQCBgz8+DfwwAMMMMAAAwwwwAADD+wfPzDA8MADChYCAAwMYAADGMAAwA8/Aw888MADD/z//wMMMPDA/PADChYCAAzAgAEDBgwAwA8/Aw888MADD/z//wMMMPDA/PADChYCAAww4MGMYQMDwA8/Aw888MADD/z//wMMMPDA/PADChQCAgzMMMMMAPz4N/DAAw888MD//z/AAAMP7B8/BhYAAAaDwWAwwDAMwzAMwzAMwzAMAwYWAAAGMMYYA8AwDMMwDMMwDMMwDAMKFgAACjDgwYxhAwMAAwwwwAADDDDAAAMMMMAAAwwwwAAGFAACBvM8AwzDMAzDMAzDMAzDMAwWAgAODMAAGA/z/MAPwAAM/OAfAzMwAzMwAzMwAzMwAzMw/sEPChQCAgwezzweAP/8N/DAAw888MADDzzwwAMPPPDAChYCAAwMYAADGMAAwI9/Aw888MADDzzwwAMPPPDA/vEDChYCAAzAgAEDBgwAwI9/Aw888MADDzzwwAMPPPDA/vEDChYCAAww4MGMYQMDwI9/Aw888MADDzzwwAMPPPDA/vEDChQCAgwezzweAPz4N/DAAw888MADDzzwwAMP7B8/ChQCAgzMMMMMAPz4N/DAAw888MADDzzwwAMP7B8/Dg4CBhDAADAADAADAAAA8P///wAAAAAMAAPAADAADhAABg7wM/zMwDAwDA/Dw8wwM8wMM8PD8DAMDAMzP8wPChYCAAwMYAADGMAAMPDAAw888MADDzzwwAMPPPDA/PMPChYCAAzAgAEDBgwAMPDAAw888MADDzzwwAMPPPDA/PMPChYCAAww4MGMYQMDMPDAAw888MADDzzwwAMPPPDA/PMPChQCAgzMMMMMAAMPPPDAAw888MADDzzwwAMP7D//ChwCAAzAgAEDBgwAMPDAAw9smGGGGcYMM8wwgwceMMAAAwwYMGDAAAocAgAMAwwwwAADDDDAAP/8M/DAAw888MADD/zPPwMMMMAAAwwwwAAKGgICDMwwwwwAAw888MCGGWaYYcwwwwwzeOABAwwwwIABAwYMAA4aAgAQ////DwAAAMAAMAAMAAMwA8wAM8AMMAPMwMAwMAwMA8P/8D8D8AA8AA/AA/AADAoUAgIM//8PAAD8+DfwwAADzL//Aw888MADD+w//w4cAgAQA/AAzP/wPwAAAAAMAAPAAHgAHsAMMAPMgGFgGBgGhsHAMDD8D/9jgBlgBtgAPAAPwAoWAgAMAw/MDz8AAMCPfwMPDDDA/Ps/8MADDzzwwP7zDxAaAgASwADAAMAA4AHgATADMAMwAxgGGAYYBhgGDAwMDPwP/A8GGAYYBhgDMAMYAwwAAwADAPwA/AoUAgYM/Pg38MAAA8y//wMPPPDAAw/sP/8wwAA88AwcAgAOAAMYwAAGMAAA/ON/AzzAAzAAAzAAAzAAAzAAAzAAAzAAAzAAAzzA/sc/ChgCAAzAgAEDBgwwAAAA/Pg38MADDDDAAAMMMMAAAw/sHz8MHAIADsAAMzDDwAwMAPzjfwM8wAMwAAMwAAMwAAMwAAMwAAMwAAMwAAM8wP7HPwoYAgAMMODBjGEDDwwAAPz4N/DAAwwwwAADDDDAAAMP7B8/DBwCAA7AAAzAAAwAAAD8438DPMADMAADMAADMAADMAADMAADMAADMAADPMD+xz8KFgIADDDAAAMMAADAj38DDzzAAAMMMMAAAwww8MD+8QMMHAIADgzMwDADM8AAAPzjfwM8wAMwAAMwAAMwAAMwAAMwAAMwAAMwAAM8wP7HPwoYAgAMAw9sGDN4wAAAAPz4N/DAAwwwwAADDDDAAAMP7B8/DBwCAA4MzMAwAzPAAAD/8z8DPMADPMADPMADPMADPMADPMADPMADPMADPMD/8z8QFgIAEgDzAPMAwwDDADMAM/wD/AMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwP8A/wDDhYAAA78D//DADPADDADzAAzwAwwA/wP/8MMMAPMADPADDADzAAzwPwP/wMMFgIADgzDMPADPwAP8PzDPwMzMAMzMAMzMAMzMAMzMAMzMPzDPwoaAgAM//8PAAD//z/AAAMMMMAAAwzwzz8DDDDAAAMMMMAA//8PChQCAgz//w8AAPzwM/DAAw888MD//z/AAAMPzA8/ChwCAAwDD8wPPwAA8P//AwwwwAADDDDAAP/8M8AAAwwwwAADDPD//woWAgAMAw/MDz8AAMAPPwMPPPDAAw/8//8DDDDwwPzwAwocAgAMMMAAAwwAAPD//wMMMMAAAwwwwAD//DPAAAMMMMAAAwzw//8KFgIADDDAAAMMAADADz8DDzzwwAMP/P//Awww8MD88AMKGgIADP//P8AAAwwwwAADDPDPPwMMMMAAAwwwwAD//w8DDMADDwoUAgYM/PAz8MADDzzwwP//P8AAAw/MDz8wwAA88AocAgAMAw9sGDN4APD//wMMMMAAAwwwwAD//DPAAAMMMMAAAwzw//8KGAIADAMPbBgzeMAAAAD88DPwwAMPPPDA//8/wAADD8wPPwwcAgAOwAAzMMPADAwA/MM/AzzAAzAAAzAAAzAAAz/wAzzAAzzAAzzAAzzA/M//ChwCAAx4MGPYwAADzA8/Aw888MADD8wPPwMMwA8/Aw888MADD8wPPwwcAgAOAzzA/MM/AAAA/MM/AzzAAzAAAzAAAzAAAz/wAzzAAzzAAzzAAzzA/M//ChwCAAwDD8wPPwADzA8/Aw888MADD8wPPwMMwA8/Aw888MADD8wPPwwcAgAOwAAMwAAMAAAA/MM/AzzAAzAAAzAAAzAAAz/wAzzAAzzAAzzAAzzA/M//ChwCAAwwwAADDAADzA8/Aw888MADD8wPPwMMwA8/Aw888MADD8wPPwwcAgAO/MM/AzzAAzAAAzAAAzAAAz/wAzzAAzzAAzzAAzzA/M//wAAM8AAPPMADChwCAAwwwMAAAzzwADDA/PAz8MADD8wPPwMMwA8/Aw888MADD8wPPwwcAgAOwAAzMMPADAwAAzzAAzzAAzzAAzzAAzzA////AzzAAzzAAzzAAzzAAzzAChwCAAx4MGPYwAMDMMAAAwwwwAD//DPwwAMPPPDAAw888MADDzzwwBAWAAAQDDAMMAwwDDAMMAww/////wwwDDD8P/w/DDAMMAwwDDAMMAwwDDAMMAwwDDAMFgAADAzAAP/zPwzAAPzDPwzMwAzMwAzMwAzMwAzMwAzMwAzMwAocAAAKPPM8zzwAAAADDDDAAAMMMMAAAwwwwAADDDDAAAMMMMAAAwwKFgAACjzzPM88AAAAAwwwwAADDDDAAAMMMMAAAwwwwAAKGgAACv//DwAAMMAAAwwwwAADDDDAAAMMMMAAAwwwwAADDDDAAAoUAAIK//8PAAAwwAADDDDAAAMMMMAAAwwwwAADDAocAAAKAw/MDz8AAAADDDDAAAMMMMAAAwwwwAADDDDAAAMMMMAAAwwKFgAACgMPzA8/AAAAAwwwwAADDDDAAAMMMMAAAwwwwAAGHAAABgzDMAzDMAzDMAzDMAzDMAwzDMPA8wYcAAAGDMMwAMAwDMMwDMMwDMMwDDMMw8DzBBwCAAb//wAzMzMzMzMzMzMzMwIQAgYE/////wwWAgAOAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAwzM8CBwCAArDw8PDAADDw8PDw8PDw8PDw8PDw8zMwMDAwDw8DBwAAAzgATMYxsAMDADAAAzAAAzAAAzAAAzAAAzAAAzAAAzAAAzAAAzAAAw/8AMKHAAACjAww8zAAwMAAwwwwAADDDDAAAMMMMAAAwwwwAADDDDA8MADDBoCAA4DPMADPMADMzADMzDDMAz/8A/DMAwDMzADMzADPMADPMDwAA/AAAwIHAIACgMDAwMDA8PDw8MzMw8PMzMzM8PDw8MAADw8DAwIEAIGCsPDw8MzMw8PMzPDw8PDw8MKHAIADMCAAQMGDAAwwAADDDDAAAMMMMAAAwwwwAADDDDAAAMM8P//BhwAAAYwzDADwDAMwzAMwzAMwzAMwzAMwzAKHAIADAMMMMAAAwwwwAADDDDAAAMMMMAAAwwwwAD//w8AMGDAgAEDBBwAAATMzMzMzMzMzMzMzADMMwoWAgAMAw888MDDDDPAAAMMMMAAAwwwwAADDDDAAP//DwgWAgAKw8PDwzMzAwMDAwMDAwMDAwMDAwMDAwoWAgAMAwwwwAADDDDMMMMMM8AAAwwwwAADDDDAAP//DwYWAgAIwzAMwzDP8zwMwzAMwzAMwwAMFgAADAzAAAzAAAzAAAzAAMzDPD/wAwzAAAzAAAzAAAzAAPzP/wYWAAAGDMMwDMMwPP88DMMwDMMwDAMMHAIADsAABjCAAQwAAAM8wA/8wA/8wDM8wzM8w8M8zMM8zAM/8AM/8AM8wAM8wAoYAgAMwIABAwYMMAAAAP/8M/DAAw888MADDzzwwAMPPPDADBwCAA4DPMAP/MAP/MAzPMMzPMPDPMzDPMwDP/ADP/ADPMADPMDAAAYwgAEMwAAKFgIGDP/8N/DAAw888MADDzzwwAMPPPDAAAADBgwYMAAMHAIADgMzMIbBDHgAAAM8wA/8wA/8wDM8wzM8w8M8zMM8zAM/8AM/8AM8wAM8wAoYAgAMAw9sGDN4wAAAAP/8N/DAAw888MADDzzwwAMPPPDAChgCAAwMMMAAAwMMAAAA//w38MADDzzwwAMPPPDAAw888MAMHAIADvMzfw/8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAAMwAAMwPzHPwoWAgYM//w38MADDzzwwAMPPPDAAw888MAAAwwwwPDAAwwaAgAO////AAAA/ON/AzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzA/sc/ChQCAgz//w8AAPz4N/DAAw888MADDzzwwAMP7B8/DBwCAA4DPMD8wz8AAAD8438DPMADPMADPMADPMADPMADPMADPMADPMADPMD+xz8KFgIADAMPzA8/AADAj38DDzzwwAMPPPDAAw888MD+8QMMHAIADjCMYQxjGMMAAPzjfwM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wP7HPwwYAgAOMIxhDGMYwzAMAAAA/OAfAzMwAzMwAzMwAzMwAzMwAzMw/sEPFBYCABb8/+///wMMMMAAAwwwwAADDDDAAAMMMMAAA/wwwA8DDDDAAAMMMMAAAwwwwAADDDDAAP7/z///EhACBhT8//j/NzDwwMADAw8MPDDwwMAD/w/8PzDAwAADAw8M7P8f/z8MHAIADgADGMAABjAAAP/zfwM8wAM8wAM8wAM8wP/3PwMzMAMzYAM2YAM8wAM8wAgYAgAKwGAwGAwMAADz8x8PAwMDAwMDAwMDAwMDDBwCAA7/838DPMADPMADPMADPMD/9z8DMzADM2ADNmADPMADPMDAAAYwgAEMwAAIFgIGCvPzHw8DAwMDAwMDAwMDAwMwGAwGAwMMHAIADgMzMIbBDHgAAP/zfwM8wAM8wAM8wAM8wP/3PwMzMAMzYAM2YAM8wAM8wAoYAAAKAw9sGDN4wAAAAMwzzwMPDDDAAAMMMMAAAwwwwAADDBwCAA4AAxjAAAYwAAD8wz8DPMADMAADMAADMAD8wz8ADMAADMAADMADPMD8wz8IGAIACjAYDAYDAwAAPH7DwwMDPnzAwMDAw8N+PAwcAgAO4AEzGMbADAwA/ON/AzzAAzAAAzAAAzAA/sN/AAzAAAzAAAzAAzzA/sc/ChgCAAww4MGMYQMPDAAAPPgxzDADDOADH8AAAwwwwwzjBw8MGgIADvzjfwM8wAMwAAMwAAMwAP7DfwAMwAAMwAAMwAM8wP7HP8AADHzAAwgUAgYKPH7DwwMDPnzAwMDAw8N+PDAwHw8MHAIADgyMYTADHsAAAPzjfwM8wAMwAAMwAAMwAP7DfwAMwAAMwAAMwAM8wP7HPwoYAgAMAw9sGDN4wAAAADz4McwwAwzgAx/AAAMMMMMM4wcPDhoAAA7///8PDAADwAAwAAwAA8AAMAAMAAPAADAADAADwAAwAAwAA8AD8AAwAAzwADwACBoCAAoMDAwMDAz//wwMDAwMDAwMDAwMDPDwwMA/Pw4cAAAODAwDg2HADOABAPD////AADAADAADwAAwAAwAA8AAMAAMAAPAADAADAADwAAwAAwAAwwWAgAODMzADMzADMMw//APDMAADMAADMAADMAADMAADMAA+AAPDhoAAA7///8PAAAA////DwwAA8AAMAAMAAPAADAADAADwAAwAAwAA8AAMAAMAAPAADAACBYAAAgMDAwMDAz//wwM//8MDAwMDAwMDPjwDBwCAA487MPjNzwAAAADPMADPMADPMADPMADPMADPMADPMADPMADPMADPMD+xz8KFgIADAwzPM88AAAw8MADDzzwwAMPPPDAAw888MD+8w8MGgIADv///wAAAAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wP7HPwoUAgIM//8PAAADDzzwwAMPPPDAAw888MADD+w//wwcAgAOAzzA/sc/AAAAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzA/sc/ChYCAAwDD+wfPwAAMPDAAw888MADDzzwwAMPPPDA/vMPDBwCAA7wgB8MwzD4AQ8AMMADPMADPMADPMADPMADPMADPMADPMADPMADPMD8wz8KGgIADDDgwQwzzDCDBwwAADDwwAMPPPDAAw888MADDzzwwPzzDwwcAgAOMIxhDGMYAAAAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzAAzzA/MM/DBgCAA4wjGEMYxjDMAwAAAADMzADMzADMzADMzADMzADMzADMzD+wz8MGgIADgM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wAM8wPzDPzAAA8ADPAoUAgYMAw888MADDzzwwAMPPPDAAw/MP/8wwAA88BIWAgAUgAcAMwCGAQwMAAAMADwA8ADAAwAPDDww8MDAAwMPDDwwsOFhhocxM8PMDDMzeHjAwAASFgIAFIAHADMAhgEMDAAADAA8APAAwAMADww8MPDAwAMDDww8MLDhYYaHMTPDzAwzM3h4wMAADhYCABDgAcyAYTAwAMAAbIAZYAwMA4NhYBgwA8wAHoAHwAAwAAwAA8AAMAAKHAIADHgwY9jAAwMw8MADD2yYYYYZxgwzzDCDBx4wwAADDBgwYMAADhYCABAwA8wAMwAAA/AAbIAZYAwMA4NhYBgwA8wAHoAHwAAwAAwAA8AAMAAKFgIADGDAgAEDAPz/P8AAAwYYMGDAgAEDBhgwwAD//w8IFQIBCmAwGAwA///AwDAwGBgMDAYGAwP//woVAgEMMMAAAwD//w8wwIABBgwYMGDAgAEGDDDA//8DCBUCAQoMDAwAAP//wMAwMBgYDAwGBgMD//8KFgIADAMbxgweAPz/P8AAAwYYMGDAgAEDBhgwwAD//w8KFQIBDAMbxgweAPzzDzDAwAADBhhgwAADBgwwwD//AAgWAAAIMHjMzAwMDAwMDA8PDAwMDAwMDAwMDAocAAAKwIMPAwwwwAADDDDAwA8/MMAAAwwwwAADDDDAAAMMMMDwwQMSHAIAFAAwAGAAwACAAQADAAAA/D/w/8ADAA8AMwDMADADwAyAMQDGABj/YPzDMADDAPwD8A9gMIDBAAYDDAww8P/A/xIYAgAUAAwAMABgAMA=");
  base64DecodeToExistingUint8Array(bufferView, 225632, "/Pz48zcw8MDAAAMDDMw/sP/AA/8N/DMwwMAAAwMPDMzPHz8/EBwAABAADAAGAAOAAcAAAADwz/DPDDAMMAw8DDwMPAw8DDMMM4wxjDGMMcwwzDDMMDwwPDAMMAww8w/zDw4YAAAOAANgAAyAATAADAAAAADwM/7MwDAwDA/Dw9gwNswMG8PD8DAMDAMzf8wPDBwCAA78438DPMADMAADMAADMAD+w38ADMAADMAADMADPMD+xz8AAAxgAAMYwAAIFgIGCjx+w8MDAz58wMDAwMPDfjwAAAwGAwMOHAAADv///w8MAAPAADAADAADwAAwAAwAA8AAMAAMAAPAADAADAADwAAwAAAAA2AADIABMAAIHAAACAwMDAwMDP//DAwMDAwMDAwMDAwM+PAAADAwGAwKBgIADDDgwYxhAw8MCgYCAAwDD2wYM3jAAAoEAgAMAw/sHz8EBAIABv//CAgCAAo8fsPDw8N+PAYGAhYIMAzD3wMKBAIADDz7PN88DAYCAA4wjGEMYxjDMAwMFgIADvzjfwM8wAM8wAM8wAM8wAM8wAM8wAM8wA7HMAzDMA//8AwQAgYO////DMMwDMMwDMMwDMMwDMMwDMZgDMzADAICDA7///8OAgIMEP///w8ECAIABmwzMzMECAAABMzMbDMECAASBMzMbDMICAIACszMZmYzMzMzCAgAAAjMzMzMZmYzMwgIABIIzMzMzGZmMzMKEAIADDDAAAMM//8PAwwwwAADDDDAAAMMChYCAAwwwAADDP//DwMMMMAAAwwwwAADDP//DwMMMMAACgoCCAz8+Pf//////////vEDDgQCEhDD8DA8DA/DHhYCACD8AACAfwAAMDAAAAwMAAADAwDAwAAAMDAA/A8MAP/+AfwDP/APAAA/AAD8AADw/8PPP/75B8DAAwMw8MAADDwwAAMPDMDAAwMw8MAA+OcfAPzwAwYKAggIMMYYw2AwGAwGCgIICIPBYDCMMcYAChoCAAwAAwwwwIABBhgwwAADBhhgwAADDBhggAEDDDAwwAADDAAOFgAADsAD+AHDYGAMMAPMADAA/8P/wAAwAP/D/8AAMAAMMAOMgcEw4AfwABIKAgAU/wP/DwzzPMzzMDPDzAwzMMzAMAPDDAwMFgIADvzjfwM8wAM8wAM8wAM8wAM8wAM8wAM8wAbGMAzDMA//8AoWAgAM/Pg38MADDwwwwPz7P/DAAw888MADDzzwwP7xAw4WAgAQwAAwAAyAB+ABzAAzwAwYBobBwDAwBpgBNgAPwAPwADwAD8D///8PDhYCABD///8/AA/AA/AAPAAPwAPwADwAD8AD8AA8AA/AA/AAPAAPwAPwAAwKFgIADP//P8AABhjAAAYwgAEMMGDAgAEDBhgwwAD//w8MAgAMDP///xQYAgAWAAAMAMAAAAYAYAAAAwAwAIABABgAwAAADABgAAAGAzAwAAMGGGCAAQwMwMAAGAaAYQAwAwAzAOABAAwAEgoCCBQ88PjAN4bZMMMDAw8MPMzwGGY+8PHAAwocAAAKwIMPAwwwwAADDDDAAAMMMMAAAwwwwAADDDDAAAMMMMDwwQMOCgIIEPywPzz8DT8AAADAD/vDw9/wAw4QAgYQAAPAABgABv///w8MAANgABjw////MAAMgAFgAAwOAggOAA888MADD/AAPAAPwAPwAAAA////DA4CCA4PwAPwADwAD/DAAw888AAAAAD///8OHAIAEP///z8AD8AD8AA8AA/AA/AAPAAPwAPwADwAD8AD8AA8AA/AA/AAPAAPwAPwAPz///8ODgIGEMAAeAAzYBgMjAE2AA/ABhgDg2HADOABMAAEBAAYBP//DBYAAAzwj/8MzMAMwAD///8MzMAMzMAMzMAMzMAMzMAMzMAMzMAMFgAADPCP/wzMwAzMwP///wzMwAzMwAzMwAzMwAzMwAzMwAzMwA==");
  base64DecodeToExistingUint8Array(bufferView, 227111, "D+YAACQAcAAAASADgAAAABABPAPAPPAPAPIAIAAAA4gIiBEQf/BEQIiAjgAABgYSECTAMmAZIEJDAwAAADwOhCIIRhBzIAGAHoAACQAcAAAAB8AwYIAiACAACACIAgwYB8AAACQAMAH4AMACQAAAAgAEAAgA/gAgAEAAgAAAAEgA4AAAEAAgAEAAgAEAAAAAYADAAAABAAwAYAMAGADAAAAA/gICCGIRhBAQH8AAAEABAAQAD/4AABA4QZCEIRBBwIAABAQQBCEIQhB7wAAADABoARAMID/4AIAAAfCCIIRBCIIQ+AAAP+CIIRBCIII+AAAQACB4QwCYAcAAAAPeCEIQhCEIPeAAAPCCEIQhCEIP+AAAGGAwwAAAwoGGAAAAgAKACIAggICAAACIARACIARACIARAAABAQEEARABQAEAAABAAQACCYQgCIAOAAAAP+CAIRxCRISJB/AAAAf4MQCCAMQAf4AAD/4QhCEIQhB7wAAB/wQBCAIQBBAQAAD/4QBCAIICA/gAAD/4QhCEIQhCAIAAD/4RACIARACAAAAB/wQBCAIQhBHwAAD/4AgAEAAgD/4AACAIf/CAIAACAwQBCAIQBD/wAAD/4AgAKAGMDAYAAD/4ABAAIABAAIAAD/4MAAYAMAD/4AAD/4MAAYAAwD/4AAB/wQBCAIQBB/wAAD/4QgCEAQgB4AAAB/wQBCAoQCB/oAAD/4QgCEAQ4B44AABwQRBCEIQRBBwAACAAQAD/4QACAAAAD/wABAAIABD/wAAD4AA8AAYA8D4AAAD/gADABgAwABgADD/gAADA4GYAMAGYDA4AADgADAAH4DADgAAACAYQNCOIWBDAIAAD/8QAiAEAADAAGAAMAAYAAwABAAAQAiAEf/gAACABgAQABgACAAAAABAAIABAAIABAAIAACAAIAAgAAAAJwCRASICSAP4AAD/4BCAQICBAPwAAAPwCBAQICBAIQAAAPwCBAQIBCD/4AAAPwCRASICRAOQAAAQAP/CQASACQAAAAOsCKQRSCKQeSCBgAAf/AIACAAQAB/AAAABAQIT/AAIABAAAAAgACAAQQCT/gAAf/ABAAYAMgCDAAAABCAIf/AAIABAAAD/AQAD/AQAB/AAAD/AIACAAQAB/AAAB+AQICBAQIB+AAAD/wIQCBAQIB+AAAB+AQICBAIQD/wAAD/AIACAAQABAAAABiASICRARIBGAAACAD/wCBAQICBAAAD+AAIABAAQD/AAADgADgADADgDgAAAD8AAYAcAAYD8AAADDAEgAYAEgDDAAADwYBsACABgDwAAACDAQoCZAUIDBAAAOTiNiQAQAAf/AAAQASNiOTgAAAgAIABAAEAAQACAAgAAABBB/4RBCAIQBBA4AADigD0AD8D0DigAABgASACQAMAAAAXACoAJAAAAVACoAKAAAAIACAAAAAf+ABAAIACAf4AAAMABgAAAJAD4ABAAAAOACIAOAAAAAf6MQKCAMQAf4AAAf4MQKCCMQAf4AAAf5MQSCBMQAf4AAIf6MQKCCMQAf4AAA/yYgEECYgA/wAAAf5MQWCBMQAf4AAP/CCAQQD/4QhCEIAAB/wQBKANQBRAQAAAf/SEJQhCEIQBAAAf/CEJQhSEIQBAAAf/KEKQhKEIQBAAA/+UIQhCUIQgCAACQBL/4QBAAAQBL/6QBAABQBT/5QBAACgCH/ygCAAD/4QhCEIICA/gAABf/RgBDAQGAf/AAAP+SAJQBCAIP+AAAP+CAJQBSAIP+AAAP+KAKQBKAIP+AAAP+KAKQBKAKP+AAAf8UAQgCUAQf8AABCAEgAYADAAkAIQAAAH/BBwJyBwQf8AAAD/xABUAJABD/wAAD/wABIAKABD/wAAD/xABQAJABT/wAAH/iACAASACH/gAADgADAIH6DADgAAAf/wgQECAgQD8AAAP/CAARBCIIOhADwAAAJwSRBSICSAP4AAAJwCRBSISSAP4AAAJwKRCSIKSAP4AABJwSRBSISSAP4AAAJwKRASIKSAP4AAAE4JIipEJJAH8AAAJwCRASIB+ASICRAOQAAAPwCBIQOCBAIQAAAPwSRBSICRAOQAAAPwCRBSISRAOQAAAPwKRCSIKRAOQAAAPwKRASIKRAOQAAAAISBBf4ABAAIAAAAICBBf4QBAAIAAAAIKBCf4IBAAIAAAAIKBAf4IBAAIAAAH4VAioENAhf4AABf4RABQASAAP4AAAPwSBCQIKBAPwAAAPwCBBQISBAPwAAAPwKBCQIKBAPwAAAPwKBCQIKBCPwAAAPwKBAQIKBAPwAAAEAAgA1gGsAEAAgAAAABAHwBFAJIBRAHwBAAAAD+CAIIBAAQD/AAAD+AAIIBCAQD/AAAD+BAIQBBAQD/AAAD+BAIABBAQD/AAADwYBsICCBgDwAAAf/ARACIAOAAAAeDINgAQIMAeA=");
  base64DecodeToExistingUint8Array(bufferView, 228960, "AwIGCAgICAMFBQYIAwYDBwcFBgYHBgYGBgYDAwYHBgcHBgYGBgYGBgYEBgYGBgYGBgYGBgYGBggGBgYEBwQGBwQGBgYGBgYHBgYGBgYGBgYGBgYGBgYGBgYGBgQCBAg=");
  base64DecodeToExistingUint8Array(bufferView, 229091, "BwAG");
  base64DecodeToExistingUint8Array(bufferView, 229104, "BQAEBAMGAAMABAQAAAAAAAYGBgYGBgcGBgYGBgQEBAQGBgYGBgYGBwYGBgYGBgYHBgYGBgYGCAYGBgYGBgYGBgYGBgYGBgYHCAYGBgYGBQY=");
  base64DecodeToExistingUint8Array(bufferView, 229199, "f+cH/nAAAA+AAPgAAAAAAAAPgAD4AAAAAAQQAEEAf/8H//AEEABBAH//B//wBBAAQQAAAADggB8MAxhgIIIP//j//4IIIDDGAYfACDgAAAAYAAPAMCQPA8PAGPAAPGAPDwPAkDAPAABgAAAAA8AcfgPsMGOBBBgQY8MD5mAcPAAP8ADDAAAA+AAPgAAAAAB/AB/8A4DgYAMEABAAAAQAEGADA4DgH/wAfwAAAAAIAAiIAMmABrAAPgABwAA+AAawAMmACIgACAAAAAAIAACAAAgAAIAA/4AP+AAIAACAAAgAAIAAAAAAAIAA+AAPAAAAAIAACAAAgAAIAACAAAgAAIAACAAAgAAIAAAAAABwAAcAAAAAAwAA8AA8AA8AA8AA8AA8AAMAAAAAAf/AP/4GAzBAYQQMEEGBBDAQZgMD/+Af/AAAAAgBAYAQMAEH//B//wAAEAABAAAQAAABwDA8BwYA0EAZBAMQQGEEDBBhgQPwEB4BAAAAEAQDAGBgAwQIEECBBAgQQIEGHDA/fgHjwAAAAAeAAPgAGIADCABggAwIAYCAMAgH//B//wAAAH8EB/BgQQMEEBBBAQQQEEEBBBgwQP4EB8AAAAH/wD/+BhAwQQEEEBBBAQQQEEGDBA/gAHwAAABwAAcAAEAABAAAQB8EB/BB4AR4AH4AB4AAAAAB48A/fgYcMECBBAgQQIEECBBhwwP34B48AAAAHwAD+BBgwQQEEEBBBAQQQEEGBDA//gH/wAAAAHDgBw4AAAAAAIBw+AcPAAAAAIAAHAADYABjAAwYAYDAMAYGADBAAQAAAAIQACEAAhAAIQACEAAhAAIQACEAAhAAIQAAAAQAEGADAwBgGAwAwYAGMAA2AAHAAAgAAAABwAA8AAYAAEAABAZwQOcEGABjAAPgABwAAAAAH/wD/+BgAwQAEEPhBH8QTBkEgJBoCQP/kB/5AAAAH/8D//BgQAQEAEBABAQAQEAGBAA//wH/8AAAB//wf/8EEBBBAQQQEEEBBBAQY4MD7+AcfAAAAB/8A//gYAMEABBAAQQAEEABBgAwOA4BgMAAAAf/8H//BAAQQAEEABBAAQQAEGADA//gH/wAAAB//wf/8ECBBAgQQIEECBBAgQQIEEABBAAQAAAH//B//wQIAECABAgAQIAECABAgAQAAEAAAAAAH/wD/+BgAwQAEEABBAgQQIEGCDA4/gGPwAAAB//wf/8ACAAAgAAIAACAAAgAAIAH//B//wAAAEABBAAQf/8H//BAAQQAEAAAAAHAAB4AADAAAQAAEEABBAAwf/4H/8BAAAQAAAAAB//wf/8AHAADYABjAAwYAYDAMAYGADBAAQAAAH//B//wAAEAABAAAQAAEAABAAAQAAEAABAAAAf/8D//AYAADAAAYAADAABgAAwAAYAAP/8H//AAAAf/8H//AGAAAwAAGAAAwAAGAAAwB//wf/8AAAAf/AP/4GADBAAQQAEEABBAAQYAMD/+Af/AAAAH//B//wQIAECABAgAQIAECABhgAPwAB4AAAAAH/wD/+BgAwQAEEAFBABwQAMGADg//sH/xAAAB//wf/8EDABA4AQLAECYBAjAYYYD8DAeAQAAAB4EA/BgYYMECBBAgQQIEECBBgwwMH4BA8AAAAQAAEAABAAAQAAH//B//wQAAEAABAAAQAAAAAB//Af/4AADAAAQAAEAABAAAQAAMH/+B//AAAAHgAB/gAB/AAB8AADwAA8AB8AH8Af4AHgAAAAAf/8H/+AADAABgAAwAAYAADAAAYAADAf/4H//AAAAYAMHgPAePAB3AAHAABwAB3AB48B4DwYAMAAABgAAeAAB4AAHgAAf8AH/AHgAHgAHgABgAAAAAEAPBAHwQDEEBhBAwQQYEEMBBGAQfAEHgBAAAAf/8H//BAAQQAEEABAAAAMAADwAAPAAA8AADwAAPAAA8AADAAAAQAEEABBAAQf/8H//AAAACAABgAAwAAYAAMAADAAAYAADAAAYAACAAAAAAAAEAABAAAQAAEAABAAAQAAEAABAAAQAAEAAAIAADAAAYAACAAAAAAABwAQ+AEYwBEEARBAEQQBEEAZBAD/wAf8AAAB//wf/8AQBAEAQBAEAQBAEAQBgMAP+AB/AAAAAH8AD/gBgMAQBAEAQBAEAQBAGAwAwYAEEAAAAAfwAP+AGAwBAEAQBAEAQBAEAQBB//wf/8AAAAB/AA/4AYjAEIQBCEAQhAEIQBiEAPjAB4gAAAAQAAEAABAAD//B//wRAAEQABEAAQAAAAAAB/AA/4QYDEEARBAEQQBEEARBAMwf/4H/8AAAH//B//wBAAAQAAEAABAAAQAAGAAA/8AH/AAAABAEAQBB3/wd/8AABAAAQAAAAAAwAAOAAAwAAEEABBAA3f/53/8AAAH//B//wACAABwAA2AAYwAMGAGAwBAEAAABAAQQAEH//B//wAAEAABAAAAB/8Af/AEAABAAAf/AH/wBAAAYAAD/wAf8AAAAH/wB/8AQAAEAABAAAQAAEAABgAAP/AB/wAAAAH8AD/gBgMAQBAEAQBAEAQBAGAwA/4AH8AAAAB//wf/8EAQBAEAQBAEAQBAEAYDAD/gAfwAAAAB/AA/4AYDAEAQBAEAQBAEAQBAEAf/8H//AAAAf/AH/wAYAAMAAGAABAAAQAAEAABAAAQAAAAAA8IAfjAEIQBCEAQhAEIQBCEAQhAGPwAh4AAAAEAABAAAQAB//gf/8AQBAEAQBAEAABAAAAB/wAf+AAAwAAEAABAAAQAAEAABAH/wB/8AAAAHAAB8AADwAAPAAA8AAPAAPAAPAAfAAHAAAAAAf+AH/wAAEAABAAfwAH8AABAAAQB/8Af+AAAABgMAcHABjAANgABwAAcAANgAGMAHBwBgMAAAAH/AB/4QADEAARAAEQABEAARAAMwf/4H/8AAAAQDAEBwBA0AQZAEMQBGEATBAFgQBwEAYBAAAAAIAACAAf/AP34GADBAAQQAEAAAB//wf/8AAABAAQQAEGADA/fgH/wACAAAgAAAAHAADwAAgAAIAADgAAcAABAAAQAA8AAOAAAAAAc/8HP/AAAAAfwAP+AGAwBAEB//wf/8BAEAYDADBgAQQAAAAAgQH/8D//BggQQIEECBBggQMAEBAHAABwAAABACAb9gD/wAQIAECABAgAQIAECAD/wBv2AQAgAAAGAAB4JAHiQAckAB/wAf8AckAeJAeCQGAAAAAAfj8H4/AAAAd8IP/jCIMQiBEIwRDH/wQ+4AAADgAA4AAAAAAAAA4AAOAAAAAAB/gAgEAT8gF/oBQKAUCgFAoBc6ATMgCAQAf4AAAADyAJ+gCQoAkKAJCgCQoAkKAP+gB/oAAAAAAgAAcAANgAGMADJgBnMATZABjAAwYAYDAEAQAAAAIAACAAAgAAIAACAAAgAAIAACAAA/AAPwAAAAAIAACAAAgAAIAACAAAgAAIAACAAAAAB/gAgEAX+gF/oBRCAUYgFHIBfaATigCAQAf4");
  base64DecodeToExistingUint8Array(bufferView, 231861, "B4AA/AAIQACEAAhAAPwAB4AAAAAACBAAgQAIEACBAP+QD/kACBAAgQAIEACBAAAAYgAOYACOAAmgAPIABiAAAAAEQADGAAkgAJIAD+AAbAAAAAAgAAYAAMAACAAAAAAAf/8H//AAEAABAAAQAAEAADAABgB/8Af/AAAAPwAH+ABAgAQIAH//B//wQAAEAAB//wf/8AAAABwAAcAAAAAAABAADwAA4AAAIAAGIAD+AA/gAAIAAAAAPiAH8gDBoAgKAICgCAoAwaAH8gA+IAAAAAQBAGAwAwYAGMAE2QBnMAMmABjAANgABwAAIAAAAAAGAgDAYBgP4wD+ZgAM4AGaADMgBn+Ax/gAAAAAwCAYBgMA/mAP7YgBuYAyOAYmgMPIGBiAAABEBgxgwJIYCSMA/mYGzOABmgAzIAZ/gMf4AAAAAcAAPgAGMADBBzgQcwEAABAAAwAB4AAcAAAAA//gf/6MCAyAgGgIAoCACAgAwIAH/+A//gAAAD/+B//gwIAICAKAgGgIDICAjAgAf/4D/+AAAAP/4H/+LAgGgIDICAyAgGgIAsCAB//gP/4AAAA//mf/7sCAiAgMgIBoCAKAgOwIDH/+A//gAAAD/+B//uwIDoCACAgAgIDoCA7AgAf/4D/+AAAAP/4H/+bAgPgICYCAmAgPgIBsCAB//gP/4AAAH/8D//BggAQIAECABAgAf/8H//BAgQQIEECBBAgQAAAB/8A//gYAMEABFAAfQAHkABBgAwOA4BgMAAAAD//g//6IECyBAmgQIoECCBAggQIIACCAAgAAAP/+D//ggQIIECKBAmgQLIECiBAggAIIACAAAA//4P/+KBAmgQLIECyBAmgQIoECCAAggAIAAAD//g//7oEC6BAggQIIEC6BAugQIIACCAAgAACIACyAAm//4v/+CAAggAIAAACAAggAIv/+b//sgAKIACAAACgAJoACz//s//5oACKAAgAADoAC6AAg//4P/+6AAugAIAAAAIAH//B//wQIEECBBAgQQIEEABBgAwP/4B/8AAAAD//m//7gwAgGAMAwBgGAIAwOAGDP/+D//gAAAD/4B//IwAbIACaAAigAIIACDABgf/wD/4AAAAP/gH/8DABggAIoACaAAsgAKMAGB//AP/gAAAA/+Af/wsAGaAAsgALIACaAAiwAYH/8A/+AAAAD/4Z//OwAaIACyAAmgAIoAC7ABsf/wD/4AAAAP/gH/87ABugAIIACCAAugALsAGB//AP/gAAACAgAwYAGMAA2AAHAABwAA2AAYwAMGACAgAAAAABAH/wD/+BgMwQGEEDBBBgQQwEGYDA//gH/wBAAAAAAD/+A//yAAGwAAmAAIgACAAAgAAYP/8D/+AAAAP/4D//AAAYAACIAAmAALAACgABg//wP/4AAAA//gP/8IABmAALAACwAAmAAIgAGD//A//gAAAD/+A//zgAG4AAgAAIAAC4AAuAAYP/8D/+AAAAMAADwAAPAAA8AID/mA/7A8Ag8AA8AAMAAAAAH//B//wCBAAgQAIEACBAAgQAMMAB+AAPAAAAAP/8H//BBBAQQMEEBBBAQYwED+DAc/gAHwAAAAAHABD4ERjBkQQNEEBRBAEQQBkEAP/AB/wAAAAAcAEPgBGMARBAUQQNEEGRBBGQQA/8AH/AAAAABwAQ+AUYwNEEGRBBkQQNEEBZBAD/wAf8AAAAAHAND4HRjBEQQZEEDRBAUQQdkEGP/AB/wAAAAAcAEPgdGMHRBAEQQBEEHRBB2QQA/8AH/AAAAABwAQ+A0YwfEEExBBMQQfEEDZBAD/wAf8AAAAAPgBH8ARBAEQQBkEAP/AH/gBCMAQhAEIQB+MAPiAAAAAfwAP+AGAwBAEQQB8EAeBAEAYDADBgAQQAAAAB/AA/4EYjBkIQNCEBQhAEIQBiEAPjAB4gAAAAH8AD/gBiMAQhAUIQNCEGQhBGIQA+MAHiAAAAAfwAP+AWIwNCEGQhBkIQNCEBYhAD4wAeIAAAAB/AA/4HYjB0IQBCEAQhB0IQdiEAPjAB4gAAAEQBBkAQN/8Bf/AAAQAAEAAAAEAQBAEBf/A3/wYAEEABAAAAFAEDQBBn/wZ/8DABAQAQAAAHQBB0AQB/8Af/BwAQcAEAAAAB/AU/4HYDAkAQdAEFwBAMAQBgMAP+AB/AAAAAf/A3/wdAAEQABkAANAABQAB2AAY/8AH/AAAAAfwAP+BGAwZAEDQBAUAQBAEAYDAD/gAfwAAAAB/AA/4AYDAEAQFAEDQBBkAQRgMAP+AB/AAAAAH8AD/gFgMDQBBkAQZAEDQBAWAwA/4AH8AAAAAfwDP+B2AwRAEGQBA0AQFAEHYDBj/gAfwAAAAB/AA/4HYDB0AQBAEAQBB0AQdgMAP+AB/AAAAACAAAgAAIAACAAcnAHJwACAAAgAAIAACAAAAAAf0AP+AGDwBBkAQxAEYQBMEAeDAD/gBfwAAAAH/AB/4EADBgAQMAEBABAAAQAAEAf/AH/wAAAAf8AH/gAAMAABAQAQMAEGABBAAQB/8Af/AAAAB/wAf+AQAwMAEGABBgAQMAEBABAH/wB/8AAAAH/AB/4HADBwAQAAEAABBwAQcAEAf/AH/wAAAAf8AH/hAAMQABEQARMAEWABFAAzB//gf/wAAAf//3//8EAQBAEAQBAEAQBAEAYDAD/gAfwAAAAH/AB/4XADFwARAAEQABFwARcAMwf/4H/8");
  base64DecodeToExistingUint8Array(bufferView, 233920, "BgMHCwsLCwMGBgwLBAsDCQsJCwsLCwsLCwsDBAoLCgsMCwsLCwsLCwsHDAsLDAsLCwsLCwsLCwwLCwsGCQYLCwULCwsLCwoLCwcJCgcLCwsLCwsLCgsLCwsLCwgDCAs=");
  base64DecodeToExistingUint8Array(bufferView, 234049, "AwsLDAsDCAcMCgwLCQwJCAsHBwULCwMEBgoMCwsLCwsLCwsLCw0LCwsLCwcHBwcMCwsLCwsLCw0LCwsLCwsLCwsLCwsLDQsLCwsLBwcHBwsLCwsLCwsLCwsLCwsLCwtKYW4ARmViAE1hcgBBcHIATWF5AEp1bgBKdWwAQXVnAFNlcABPY3QATm92AERlYwBTdW4ATW9uAFR1ZQBXZWQAVGh1AEZyaQBTYXQA/////w==");
  base64DecodeToExistingUint8Array(bufferView, 234240, "hwIAAIgCAACJAgAAigIAAIsCAACMAgAAjQIAAI4CAACPAgAAkAIAAJECAACSAgAAkwIAAJQCAACVAgAAlgIAAJcC");
  base64DecodeToExistingUint8Array(bufferView, 234322, "HwDgB/8HAPgf+OD///8=");
  base64DecodeToExistingUint8Array(bufferView, 234354, "KEJRjNe9QMwgiiAD4Af/Bx8AEYgf+AD4QPzg////AAAGAAwAEwAZAB8AgAGGAYwBkwGZAZ8BIAMmAywDMwM5Az8DwATGBMwE0wTZBN8EYAZmBmwGcwZ5Bn8G4AfmB+wH8wf5B/8HADAGMAwwEzAZMB8wgDGGMYwxkzGZMZ8xIDMmMywzMzM5Mz8zwDTGNMw00zTZNN80YDZmNmw2czZ5Nn824DfmN+w38zf5N/83AGAGYAxgE2AZYB9ggGGGYYxhk2GZYZ9hIGMmYyxjM2M5Yz9jwGTGZMxk02TZZN9kYGZmZmxmc2Z5Zn9m4GfmZ+xn82f5Z/9nAJgGmAyYE5gZmB+YgJmGmYyZk5mZmZ+ZIJsmmyybM5s5mz+bwJzGnMyc05zZnN+cYJ5mnmyec555nn+e4J/mn+yf85/5n/+fAMgGyAzIE8gZyB/IgMmGyYzJk8mZyZ/JIMsmyyzLM8s5yz/LwMzGzMzM08zZzN/MYM5mzmzOc855zn/O4M/mz+zP88/5z//PAPgG+Az4E/gZ+B/4gPmG+Yz5k/mZ+Z/5IPsm+yz7M/s5+z/7wPzG/Mz80/zZ/N/8YP5m/mz+c/55/n/+4P/m/+z/8//5////");
  base64DecodeToExistingUint8Array(bufferView, 234894, "//8AACsAgQCsAHkATgAMABIAFwAEACcAtwCQAMAA0gDXAAAABQAeACMAtAC5ANIA1wAAAAkABwAIAAwACwAOAA8A9VYAABwBAAA2AQAAnlcAABYBAAA1AQAA+FYAABEBAAA0AQAAPlcAAA4BAAAzAQAA4VYAAAgBAACpAgAA+1YAAAYBAACqAg==");
  base64DecodeToExistingUint8Array(bufferView, 235040, "T7thBWes3T8YLURU+yHpP5v2gdILc+8/GC1EVPsh+T/iZS8ifyt6PAdcFDMmpoE8vcvweogHcDwHXBQzJqaRPBgtRFT7Iek/GC1EVPsh6b/SITN/fNkCQNIhM3982QLA");
  base64DecodeToExistingUint8Array(bufferView, 235151, "gBgtRFT7IQlAGC1EVPshCcADAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1HzoAf/LKAPGHHQB8kCEAaiR8ANVu+gAwLXcAFTtDALUUxgDDGZ0ArcTCACxNQQAMAF0Ahn1GAONxLQCbxpoAM2IAALTSfAC0p5cAN1XVANc+9gCjEBgATXb8AGSdKgBw16sAY3z4AHqwVwAXFecAwElWADvW2QCnhDgAJCPLANaKdwBaVCMAAB+5APEKGwAZzt8AnzH/AGYeagCZV2EArPtHAH5/2AAiZbcAMuiJAOa/YADvxM0AbDYJAF0/1AAW3tcAWDveAN6bkgDSIigAKIboAOJYTQDGyjIACOMWAOB9ywAXwFAA8x2nABjgWwAuEzQAgxJiAINIAQD1jlsArbB/AB7p8gBISkMAEGfTAKrd2ACuX0IAamHOAAoopADTmbQABqbyAFx3fwCjwoMAYTyIAIpzeACvjFoAb9e9AC2mYwD0v8sAjYHvACbBZwBVykUAytk2ACio0gDCYY0AEsl3AAQmFAASRpsAxFnEAMjFRABNspEAABfzANRDrQApSeUA/dUQAAC+/AAelMwAcM7uABM+9QDs8YAAs+fDAMf4KACTBZQAwXE+AC4JswALRfMAiBKcAKsgewAutZ8AR5LCAHsyLwAMVW0AcqeQAGvnHwAxy5YAeRZKAEF54gD034kA6JSXAOLmhACZMZcAiO1rAF9fNgC7/Q4ASJq0AGekbABxckIAjV0yAJ8VuAC85QkAjTElAPd0OQAwBRwADQwBAEsIaAAs7lgAR6qQAHTnAgC91iQA932mAG5IcgCfFu8AjpSmALSR9gDRU1EAzwryACCYMwD1S34AsmNoAN0+XwBAXQMAhYl/AFVSKQA3ZMAAbdgQADJIMgBbTHUATnHUAEVUbgALCcEAKvVpABRm1QAnB50AXQRQALQ72wDqdsUAh/kXAElrfQAdJ7oAlmkpAMbMrACtFFQAkOJqAIjZiQAsclAABKS+AHcHlADzMHAAAPwnAOpxqABmwkkAZOA9AJfdgwCjP5cAQ5T9AA2GjAAxQd4AkjmdAN1wjAAXt+cACN87ABU3KwBcgKAAWoCTABARkgAP6NgAbICvANv/SwA4kA8AWRh2AGKlFQBhy7sAx4m5ABBAvQDS8gQASXUnAOu29gDbIrsAChSqAIkmLwBkg3YACTszAA6UGgBROqoAHaPCAK/trgBcJhIAbcJNAC16nADAVpcAAz+DAAnw9gArQIwAbTGZADm0BwAMIBUA2MNbAPWSxADGrUsATsqlAKc3zQDmqTYAq5KUAN1CaAAZY94AdozvAGiLUgD82zcArqGrAN8VMQAArqEADPvaAGRNZgDtBbcAKWUwAFdWvwBH/zoAavm5AHW+8wAok98Aq4AwAGaM9gAEyxUA+iIGANnkHQA9s6QAVxuPADbNCQBOQukAE76kADMjtQDwqhoAT2WoANLBpQALPw8AW3jNACP5dgB7iwQAiRdyAMamUwBvbuIA7+sAAJtKWADE2rcAqma6AHbPzwDRAh0AsfEtAIyZwQDDrXcAhkjaAPddoADGgPQArPAvAN3smgA/XLwA0N5tAJDHHwAq27YAoyU6AACvmgCtU5MAtlcEACkttABLgH4A2genAHaqDgB7WaEAFhIqANy3LQD65f0Aidv+AIm+/QDkdmwABqn8AD6AcACFbhUA/Yf/ACg+BwBhZzMAKhiGAE296gCz568Aj21uAJVnOQAxv1sAhNdIADDfFgDHLUMAJWE1AMlwzgAwy7gAv2z9AKQAogAFbOQAWt2gACFvRwBiEtIAuVyEAHBhSQBrVuAAmVIBAFBVNwAe1bcAM/HEABNuXwBdMOQAhS6pAB2ywwChMjYACLekAOqx1AAW9yEAj2nkACf/dwAMA4AAjUAtAE/NoAAgpZkAs6LTAC9dCgC0+UIAEdrLAH2+0ACb28EAqxe9AMqigQAIalwALlUXACcAVQB/FPAA4QeGABQLZACWQY0Ah77eANr9KgBrJbYAe4k0AAXz/gC5v54AaGpPAEoqqABPxFoALfi8ANdamAD0x5UADU2NACA6pgCkV18AFD+xAIA4lQDMIAEAcd2GAMnetgC/YPUATWURAAEHawCMsKwAssDQAFFVSAAe+w4AlXLDAKMGOwDAQDUABtx7AOBFzABOKfoA1srIAOjzQQB8ZN4Am2TYANm+MQCkl8MAd1jUAGnjxQDw2hMAujo8AEYYRgBVdV8A0r31AG6SxgCsLl0ADkTtABw+QgBhxIcAKf3pAOfW8wAifMoAb5E1AAjgxQD/140AbmriALD9xgCTCMEAfF10AGutsgDNbp0APnJ7AMYRagD3z6kAKXPfALXJugC3AFEA4rINAHS6JADlfWAAdNiKAA0VLACBGAwAfmaUAAEpFgCfenYA/f2+AFZF7wDZfjYA7NkTAIu6uQDEl/wAMagnAPFuwwCUxTYA2KhWALSotQDPzA4AEoktAG9XNAAsVokAmc7jANYguQBrXqoAPiqcABFfzAD9C0oA4fT7AI47bQDihiwA6dSEAPy0qQDv7tEALjXJAC85YQA4IUQAG9nIAIH8CgD7SmoALxzYAFO0hABOmYwAVCLMACpV3ADAxtYACxmWABpwuABplWQAJlpgAD9S7gB/EQ8A9LURAPzL9QA0vC0ANLzuAOhdzADdXmAAZ46bAJIz7wDJF7gAYVibAOFXvABRg8YA2D4QAN1xSAAtHN0ArxihACEsRgBZ89cA2XqYAJ5UwABPhvoAVgb8AOV5rgCJIjYAOK0iAGeT3ABV6KoAgiY4AMrnmwBRDaQAmTOxAKnXDgBpBUgAZbLwAH+IpwCITJcA+dE2ACGSswB7gkoAmM8hAECf3ADcR1UA4XQ6AGfrQgD+nd8AXtRfAHtnpAC6rHoAVfaiACuIIwBBulUAWW4IACEqhgA5R4MAiePmAOWe1ABJ+0AA/1bpABwPygDFWYoAlPorANPBxQAPxc8A21quAEfFhgCFQ2IAIYY7ACx5lAAQYYcAKkx7AIAsGgBDvxIAiCaQAHg8iQCoxOQA5dt7AMQ6wgAm9OoA92eKAA2SvwBloysAPZOxAL18CwCkUdwAJ91jAGnh3QCalBkAqCmVAGjOKAAJ7bQARJ8gAE6YygBwgmMAfnwjAA+5MgCn9Y4AFFbnACHxCAC1nSoAb35NAKUZUQC1+asAgt/WAJbdYQAWNgIAxDqfAIOioQBy7W0AOY16AIK4qQBrMlwARidbAAA07QDSAHcA/PRVAAFZTQDgcYA=");
  base64DecodeToExistingUint8Array(bufferView, 237955, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNf6CK2VHFWdAAAAAAAAAOEMAAPr+Qi52vzo7nrya9wy9vf3/////3z88VFVVVVXFP5ErF89VVaU/F9CkZxERgT8AAAAAAADIQu85+v5CLuY/JMSC/72/zj+19AzXCGusP8xQRtKrsoM/hDpOm+DXVT8=");
  base64DecodeToExistingUint8Array(bufferView, 238142, "8D9uv4gaTzubPDUz+6k99u8/XdzYnBNgcbxhgHc+muzvP9FmhxB6XpC8hX9u6BXj7z8T9mc1UtKMPHSFFdOw2e8/+o75I4DOi7ze9t0pa9DvP2HI5mFO92A8yJt1GEXH7z+Z0zNb5KOQPIPzxso+vu8/bXuDXaaalzwPiflsWLXvP/zv/ZIatY4890dyK5Ks7z/RnC9wPb4+PKLR0zLso+8/C26QiTQDarwb0/6vZpvvPw69LypSVpW8UVsS0AGT7z9V6k6M74BQvMwxbMC9iu8/FvTVuSPJkbzgLamumoLvP69VXOnj04A8UY6lyJh67z9Ik6XqFRuAvHtRfTy4cu8/PTLeVfAfj7zqjYw4+WrvP79TEz+MiYs8dctv61tj7z8m6xF2nNmWvNRcBITgW+8/YC86PvfsmjyquWgxh1TvP504hsuC54+8Hdn8IlBN7z+Nw6ZEQW+KPNaMYog7Ru8/fQTksAV6gDyW3H2RST/vP5SoqOP9jpY8OGJ1bno47z99SHTyGF6HPD+msk/OMe8/8ucfmCtHgDzdfOJlRSvvP14IcT97uJa8gWP14d8k7z8xqwlt4feCPOHeH/WdHu8/+r9vGpshPbyQ2drQfxjvP7QKDHKCN4s8CwPkpoUS7z+Py86JkhRuPFYvPqmvDO8/tquwTXVNgzwVtzEK/gbvP0x0rOIBQoY8MdhM/HAB7z9K+NNdOd2PPP8WZLII/O4/BFuOO4Cjhrzxn5JfxfbuP2hQS8ztSpK8y6k6N6fx7j+OLVEb+AeZvGbYBW2u7O4/0jaUPujRcbz3n+U02+fuPxUbzrMZGZm85agTwy3j7j9tTCqnSJ+FPCI0Ekym3u4/imkoemASk7wcgKwERdruP1uJF0iPp1i8Ki73IQrW7j8bmklnmyx8vJeoUNn10e4/EazCYO1jQzwtiWFgCM7uP+9kBjsJZpY8VwAd7UHK7j95A6Ha4cxuPNA8wbWixu4/MBIPP47/kzze09fwKsPuP7CvervOkHY8Jyo21dq/7j934FTrvR2TPA3d/ZmyvO4/jqNxADSUj7ynLJ12srnuP0mjk9zM3oe8QmbPotq27j9fOA+9xt54vIJPnVYrtO4/9lx77EYShrwPkl3KpLHuP47X/RgFNZM82ie1Nkev7j8Fm4ovt5h7PP3Hl9QSre4/CVQc4uFjkDwpVEjdB6vuP+rGGVCFxzQ8t0ZZiiap7j81wGQr5jKUPEghrRVvp+4/n3aZYUrkjLwJ3Ha54aXuP6hN7zvFM4y8hVU6sH6k7j+u6SuJeFOEvCDDzDRGo+4/WFhWeN3Ok7wlIlWCOKLuP2QZfoCqEFc8c6lM1FWh7j8oIl6/77OTvM07f2aeoO4/grk0h60Sary/2gt1EqDuP+6pbbjvZ2O8LxplPLKf7j9RiOBUPdyAvISUUfl9n+4/zz5afmQfeLx0X+zodZ/uP7B9i8BK7oa8dIGlSJqf7j+K5lUeMhmGvMlnQlbrn+4/09QJXsuckDw/Xd5PaaDuPx2lTbncMnu8hwHrcxSh7j9rwGdU/eyUPDLBMAHtoe4/VWzWq+HrZTxiTs8286LuP0LPsy/FoYi8Eho+VCek7j80NzvxtmmTvBPOTJmJpe4/Hv8ZOoRegLytxyNGGqfuP25XcthQ1JS87ZJEm9mo7j8Aig5bZ62QPJlmitnHqu4/tOrwwS+3jTzboCpC5azuP//nxZxgtmW8jES1FjKv7j9EX/NZg/Z7PDZ3FZmuse4/gz0epx8Jk7zG/5ELW7TuPykebIu4qV285cXNsDe37j9ZuZB8+SNsvA9SyMtEuu4/qvn0IkNDkrxQTt6fgr3uP0uOZtdsyoW8ugfKcPHA7j8nzpEr/K9xPJDwo4KRxO4/u3MK4TXSbTwjI+MZY8juP2MiYiIExYe8ZeVde2bM7j/VMeLjhhyLPDMtSuyb0O4/Fbu809G7kbxdJT6yA9XuP9Ix7pwxzJA8WLMwE57Z7j+zWnNuhGmEPL/9eVVr3u4/tJ2Ol83fgrx689O/a+PuP4czy5J3Gow8rdNamZ/o7j/62dFKj3uQvGa2jSkH7u4/uq7cVtnDVbz7FU+4ovPuP0D2pj0OpJC8OlnljXL57j80k6049NZovEde+/J2/+4/NYpYa+LukbxKBqEwsAXvP83dXwrX/3Q80sFLkB4M7z+smJL6+72RvAke11vCEu8/swyvMK5uczycUoXdmxnvP5T9n1wy4448etD/X6sg7z+sWQnRj+CEPEvRVy7xJ+8/ZxpOOK/NYzy15waUbS/vP2gZkmwsa2c8aZDv3CA37z/StcyDGIqAvPrDXVULP+8/b/r/P12tj7x8iQdKLUfvP0mpdTiuDZC88okNCIdP7z+nBz2mhaN0PIek+9wYWO8/DyJAIJ6RgryYg8kW42DvP6ySwdVQWo48hTLbA+Zp7z9LawGsWTqEPGC0AfMhc+8/Hz60ByHVgrxfm3szl3zvP8kNRzu5Kom8KaH1FEaG7z/TiDpgBLZ0PPY/i+cukO8/cXKdUezFgzyDTMf7UZrvP/CR048S94+82pCkoq+k7z99dCPimK6NvPFnji1Ir+8/CCCqQbzDjjwnWmHuG7rvPzLrqcOUK4Q8l7prNyvF7z/uhdExqWSKPEBFblt20O8/7eM75Lo3jrwUvpyt/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/ADj6/kIu5j8wZ8eTV/MuPQEAAAAAAOC/WzBRVVVV1T+QRev////PvxEB8SSzmck/n8gG5XVVxb8AAAAAAADgv3dVVVVVVdU/y/3/////z78M3ZWZmZnJP6dFZ1VVVcW/MN5EoyRJwj9lPUKk//+/v8rWKiiEcbw//2iwQ+uZub+F0K/3goG3P81F0XUTUrW/n97gw/A09z8AkOZ5f8zXvx/pLGp4E/c/AAANwu5v17+gtfoIYPL2PwDgURPjE9e/fYwTH6bR9j8AeCg4W7jWv9G0xQtJsfY/AHiAkFVd1r+6DC8zR5H2PwAAGHbQAta/I0IiGJ9x9j8AkJCGyqjVv9kepZlPUvY/AFADVkNP1b/EJI+qVjP2PwBAa8M39tS/FNyda7MU9j8AUKj9p53Uv0xcxlJk9vU/AKiJOZJF1L9PLJG1Z9j1PwC4sDn07dO/3pBby7y69T8AcI9EzpbTv3ga2fJhnfU/AKC9Fx5A07+HVkYSVoD1PwCARu/i6dK/02vnzpdj9T8A4DA4G5TSv5N/p+IlR/U/AIjajMU+0r+DRQZC/yr1PwCQJynh6dG/372y2yIP9T8A+EgrbZXRv9feNEeP8/Q/APi5mmdB0b9AKN7PQ9j0PwCY75TQ7dC/yKN4wD699D8AENsYpZrQv4ol4MN/ovQ/ALhjUuZH0L80hNQkBYj0PwDwhkUi68+/Cy0ZG85t9D8AsBd1SkfPv1QYOdPZU/Q/ADAQPUSkzr9ahLREJzr0PwCw6UQNAs6/+/gVQbUg9D8A8HcpomDNv7H0PtqCB/Q/AJCVBAHAzL+P/lddj+7zPwAQiVYpIMy/6UwLoNnV8z8AEIGNF4HLvyvBEMBgvfM/ANDTzMniyr+42nUrJKXzPwCQEi5ARcq/AtCfzSKN8z8A8B1od6jJvxx6hMVbdfM/ADBIaW0Myb/iNq1Jzl3zPwDARaYgcci/QNRNmHlG8z8AMBS0j9bHvyTL/85cL/M/AHBiPLg8x79JDaF1dxjzPwBgN5uao8a/kDk+N8gB8z8AoLdUMQvGv0H4lbtO6/I/ADAkdn1zxb/RqRkCCtXyPwAwwo973MS/Kv23qPm+8j8AANJRLEbEv6sbDHocqfI/AACDvIqww78wtRRgcpPyPwAASWuZG8O/9aFXV/p98j8AQKSQVIfCv787HZuzaPI/AKB5+Lnzwb+99Y+DnVPyPwCgLCXIYMG/OwjJqrc+8j8AIPdXf87Av7ZAqSsBKvI/AKD+Sdw8wL8yQcyWeRXyPwCAS7y9V7+/m/zSHSAB8j8AQECWCDe+vwtITUn07PE/AED5PpgXvb9pZY9S9djxPwCg2E5n+bu/fH5XESPF8T8AYC8gedy6v+kmy3R8sfE/AIAo58PAub+2GiwMAZ7xPwDAcrNGpri/vXC2e7CK8T8AAKyzAY23v7a87yWKd/E/AAA4RfF0tr/aMUw1jWTxPwCAh20OXrW/3V8nkLlR8T8A4KHeXEi0v0zSMqQOP/E/AKBqTdkzs7/a+RByiyzxPwBgxfh5ILK/MbXsKDAa8T8AIGKYRg6xv680hNr7B/E/AADSamz6r7+za04P7vXwPwBAd0qN2q2/zp8qXQbk8D8AAIXk7LyrvyGlLGNE0vA/AMASQImhqb8amOJ8p8DwPwDAAjNYiKe/0TbGgy+v8D8AgNZnXnGlvzkToJjbnfA/AIBlSYpco7/f51Kvq4zwPwBAFWTjSaG/+yhOL5978D8AgOuCwHKevxmPNYy1avA/AIBSUvFVmr8s+eyl7lnwPwCAgc9iPZa/kCzRzUlJ8D8AAKqM+yiSv6mt8MbGOPA/AAD5IHsxjL+pMnkTZSjwPwAAql01GYS/SHPqJyQY8D8AAOzCAxJ4v5WxFAYECPA/AAAkeQkEYL8a+ib3H+DvPwAAkITz728/dOphwhyh7z8AAD01QdyHPy6ZgbAQY+8/AIDCxKPOkz/Nre489iXvPwAAiRTBn5s/5xORA8jp7j8AABHO2LChP6uxy3iAru4/AMAB0FuKpT+bDJ2iGnTuPwCA2ECDXKk/tZkKg5E67j8AgFfvaietP1aaYAngAe4/AMCY5Zh1sD+Yu3flAcrtPwAgDeP1U7I/A5F8C/KS7T8AADiL3S60P85c+2asXO0/AMBXh1kGtj+d3l6qLCftPwAAajV22rc/zSxrPm7y7D8AYBxOQ6u5PwJ5p6Jtvuw/AGANu8d4uz9tCDdtJovsPwAg5zITQ70/BFhdvZRY7D8AYN5xMQq/P4yfuzO1Juw/AECRKxVnwD8/5+zug/XrPwCwkoKFR8E/wZbbdf3E6z8AMMrNbibCPyhKhgweles/AFDFptcDwz8sPu/F4mXrPwAQMzzD38M/i4jJZ0g36z8AgHprNrrEP0owHSFLCes/APDRKDmTxT9+7/KF6NvqPwDwGCTNasY/oj1gMR2v6j8AkGbs+EDHP6dY0z/mguo/APAa9cAVyD+LcwnvQFfqPwCA9lQp6cg/J0urkCos6j8AQPgCNrvJP9HykxOgAeo/AAAsHO2Lyj8bPNskn9fpPwDQAVxRW8s/kLHHBSWu6T8AwLzMZynMPy/Ol/Iuhek/AGBI1TX2zD91S6TuulzpPwDARjS9wc0/OEjnncY06T8A4M+4AYzOP+ZSZy9PDek/AJAXwAlVzz+d1/+OUuboPwC4HxJsDtA/fADMn86/6D8A0JMOuHHQPw7DvtrAmeg/AHCGnmvU0D/7FyOqJ3ToPwDQSzOHNtE/CJqzrABP6D8ASCNnDZjRP1U+ZehJKug/AIDM4P/40T9gAvSVAQboPwBoY9dfWdI/KaPgYyXi5z8AqBQJMLnSP6213Hezvuc/AGBDEHIY0z/CJZdnqpvnPwAY7G0md9M/VwYX8gd55z8AMK/7T9XTPwwT1tvKVuc/AOAv4+4y1D9rtk8BABDmPzxbQpFsAn48lbRNAwAw5j9BXQBI6r+NPHjUlA0AUOY/t6XWhqd/jjytb04HAHDmP0wlVGvq/GE8rg/f/v+P5j/9DllMJ358vLzFYwcAsOY/AdrcSGjBirz2wVweANDmPxGTSZ0cP4M8PvYF6//v5j9TLeIaBIB+vICXhg4AEOc/UnkJcWb/ezwS6Wf8/y/nPySHvSbiAIw8ahGB3/9P5z/SAfFukQJuvJCcZw8AcOc/dJxUzXH8Z7w1yH76/4/nP4ME9Z7BvoE85sIg/v+v5z9lZMwpF35wvADJP+3/z+c/HIt7CHKAgLx2Gibp/+/nP675nW0owI086KOcBAAQ6D8zTOVR0n+JPI8skxcAMOg/gfMwtun+irycczMGAFDoP7w1ZWu/v4k8xolCIABw6D91exHzZb+LvAR59ev/j+g/V8s9om4AibzfBLwiALDoPwpL4DjfAH28ihsM5f/P6D8Fn/9GcQCIvEOOkfz/7+g/OHB60HuBgzzHX/oeABDpPwO033aRPok8uXtGEwAw6T92AphLToB/PG8H7ub/T+k/LmL/2fB+j7zREjze/2/pP7o4JpaqgnC8DYpF9P+P6T/vqGSRG4CHvD4umN3/r+k/N5NaiuBAh7xm+0nt/8/pPwDgm8EIzj88UZzxIADw6T8KW4gnqj+KvAawRREAEOo/VtpYmUj/dDz69rsHADDqPxhtK4qrvow8eR2XEABQ6j8weXjdyv6IPEgu9R0AcOo/26vYPXZBj7xSM1kcAJDqPxJ2woQCv468Sz5PKgCw6j9fP/88BP1pvNEertf/z+o/tHCQEuc+grx4BFHu/+/qP6PeDuA+Bmo8Ww1l2/8P6z+5Ch84yAZaPFfKqv7/L+s/HTwjdB4BebzcupXZ/0/rP58qhmgQ/3m8nGWeJABw6z8+T4bQRf+KPEAWh/n/j+s/+cPClnf+fDxPywTS/6/rP8Qr8u4n/2O8RVxB0v/P6z8h6jvut/9svN8JY/j/7+s/XAsulwNBgbxTdrXh/w/sPxlqt5RkwYs841f68f8v7D/txjCN7/5kvCTkv9z/T+w/dUfsvGg/hLz3uVTt/2/sP+zgU/CjfoQ81Y+Z6/+P7D/xkvmNBoNzPJohJSEAsOw/BA4YZI79aLycRpTd/8/sP3Lqxxy+fo48dsT96v/v7D/+iJ+tOb6OPCv4mhYAEO0/cVq5qJF9dTwd9w8NADDtP9rHcGmQwYk8xA956v9P7T8M/ljFNw5YvOWH3C4AcO0/RA/BTdaAf7yqgtwhAJDtP1xc/ZSPfHS8gwJr2P+v7T9+YSHFHX+MPDlHbCkA0O0/U7H/sp4BiDz1kETl/+/tP4nMUsbSAG48lParzf8P7j/SaS0gQIN/vN3IUtv/L+4/ZAgbysEAezzvFkLy/0/uP1GrlLCo/3I8EV6K6P9v7j9Zvu+xc/ZXvA3/nhEAkO4/AcgLXo2AhLxEF6Xf/6/uP7UgQ9UGAHg8oX8SGgDQ7j+SXFZg+AJQvMS8ugcA8O4/EeY1XURAhbwCjXr1/w/vPwWR7zkx+0+8x4rlHgAw7z9VEXPyrIGKPJQ0gvX/T+8/Q8fX1EE/ijxrTKn8/2/vP3V4mBz0AmK8QcT54f+P7z9L53f00X13PH7j4NL/r+8/MaN8mhkBb7ye5HccANDvP7GszkvugXE8McPg9//v7z9ah3ABNwVuvG5gZfT/D/A/2gocSa1+irxYeobz/y/wP+Cy/MNpf5e8Fw38/f9P8D9blMs0/r+XPIJNzQMAcPA/y1bkwIMAgjzoy/L5/4/wPxp1N77f/228ZdoMAQCw8D/rJuaufz+RvDjTpAEA0PA/959Iefp9gDz9/dr6/+/wP8Br1nAFBHe8lv26CwAQ8T9iC22E1ICOPF305fr/L/E/7zb9ZPq/nTzZmtUNAFDxP65QEnB3AJo8mlUhDwBw8T/u3uPi+f2NPCZUJ/z/j/E/c3I73DAAkTxZPD0SALDxP4gBA4B5f5k8t54p+P/P8T9njJ+rMvllvADUivT/7/E/61unnb9/kzykhosMABDyPyJb/ZFrgJ88A0OFAwAw8j8zv5/rwv+TPIT2vP//T/I/ci4ufucBdjzZISn1/2/yP2EMf3a7/H88PDqTFACQ8j8rQQI8ygJyvBNjVRQAsPI/Ah/yM4KAkrw7Uv7r/8/yP/LcTzh+/4i8lq24CwDw8j/FQTBQUf+FvK/ievv/D/M/nSheiHEAgbx/X6z+/y/zPxW3tz9d/5G8VmemDABQ8z+9gosign+VPCH3+xEAcPM/zNUNxLoAgDy5L1n5/4/zP1Gnsi2dP5S8QtLdBACw8z/hOHZwa3+FPFfJsvX/z/M/MRK/EDoCejwYtLDq/+/zP7BSsWZtf5g89K8yFQAQ9D8khRlfN/hnPCmLRxcAMPQ/Q1HccuYBgzxjtJXn/0/0P1qJsrhp/4k84HUE6P9v9D9U8sKbscCVvOfBb+//j/Q/cio68glAmzwEp77l/6/0P0V9Db+3/5S83icQFwDQ9D89atxxZMCZvOI+8A8A8PQ/HFOFC4l/lzzRS9wSABD1PzakZnFlBGA8eicFFgAw9T8JMiPOzr+WvExw2+z/T/U/16EFBXICibypVF/v/2/1PxJkyQ7mv5s8EhDmFwCQ9T+Q76+BxX6IPJI+yQMAsPU/wAy/CghBn7y8GUkdAND1PylHJfsqgZi8iXq45//v9T8Eae2At36UvA==");
  base64DecodeToExistingUint8Array(bufferView, 244417, "gAEAzT4CAO++rd6+uv7KFf//AP//////////AQCgAKAAAAAJ+aA+IAPQBwQAAAAKAAAAIAMAAOD8///oAwAAoJIDANCSAwAbbAAAFQ==");
}

  var scratchBuffer = new ArrayBuffer(16);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
  function wasm2js_memory_fill(dest, value, size) {
    dest = dest >>> 0;
    size = size >>> 0;
    if (dest + size > bufferView.length) throw "trap: invalid memory.fill";
    bufferView.fill(value, dest, dest + size);
  }
      
  function wasm2js_memory_copy(dest, source, size) {
    // TODO: traps on invalid things
    bufferView.copyWithin(dest, source, source + size);
  }
      
function asmFunc(imports) {
 var buffer = new ArrayBuffer(17301504);
 var HEAP8 = new Int8Array(buffer);
 var HEAP16 = new Int16Array(buffer);
 var HEAP32 = new Int32Array(buffer);
 var HEAPU8 = new Uint8Array(buffer);
 var HEAPU16 = new Uint16Array(buffer);
 var HEAPU32 = new Uint32Array(buffer);
 var HEAPF32 = new Float32Array(buffer);
 var HEAPF64 = new Float64Array(buffer);
 var Math_imul = Math.imul;
 var Math_fround = Math.fround;
 var Math_abs = Math.abs;
 var Math_clz32 = Math.clz32;
 var Math_min = Math.min;
 var Math_max = Math.max;
 var Math_floor = Math.floor;
 var Math_ceil = Math.ceil;
 var Math_trunc = Math.trunc;
 var Math_sqrt = Math.sqrt;
 var env = imports.env;
 var emscripten_asm_const_int = env.emscripten_asm_const_int;
 var emscripten_asm_const_double = env.emscripten_asm_const_double;
 var __stack_pointer = 506720;
 var __stack_end = 0;
 var __stack_base = 0;
 var i64toi32_i32$HIGH_BITS = 0;
 // EMSCRIPTEN_START_FUNCS
;
 function __wasm_call_ctors() {
  emscripten_stack_init();
 }
 
 function stepcount_init() {
  AccelFilter_init(244896);
  HEAP32[61104] = 98304;
  HEAP16[122454] = 0;
  HEAP16[122455] = 0;
  HEAP16[122456] = 0;
  HEAP32[61229] = 0;
  HEAP8[244920] = 0;
  HEAP8[244921] = 0;
 }
 
 function AccelFilter_init($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 8 >> 2] < 7) {
    HEAP8[HEAP32[$1 + 12 >> 2] + HEAP32[$1 + 8 >> 2] | 0] = 0;
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] = 0;
 }
 
 function newUnistroke($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $1;
  HEAP32[$3 + 24 >> 2] = $2;
  Resample($0, 32, HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
  HEAPF32[$3 + 20 >> 2] = IndicativeAngle($0, 32);
  while (1) {
   if (HEAPF32[$3 + 20 >> 2] < Math_fround(-.785398006439209)) {
    HEAPF32[$3 + 20 >> 2] = HEAPF32[$3 + 20 >> 2] + Math_fround(1.570796012878418);
    continue;
   }
   break;
  };
  while (1) {
   if (HEAPF32[$3 + 20 >> 2] > Math_fround(.785398006439209)) {
    HEAPF32[$3 + 20 >> 2] = HEAPF32[$3 + 20 >> 2] + Math_fround(-1.570796012878418);
    continue;
   }
   break;
  };
  RotateBy($0, $0, 32, Math_fround(-HEAPF32[$3 + 20 >> 2]));
  ScaleTo($0, $0, 32, Math_fround(176.0));
  HEAP32[$3 + 8 >> 2] = 0;
  HEAP32[$3 + 12 >> 2] = 0;
  $1 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 4 >> 2] = $1;
  TranslateTo($0, $0, 32, $3);
  __stack_pointer = $3 + 32 | 0;
 }
 
 function Resample($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  $4 = __stack_pointer - 80 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 76 >> 2] = $0;
  HEAP32[$4 + 72 >> 2] = $1;
  HEAP32[$4 + 68 >> 2] = $2;
  HEAP32[$4 + 64 >> 2] = $3;
  HEAPF32[$4 + 60 >> 2] = PathLength(HEAP32[$4 + 68 >> 2], HEAP32[$4 + 64 >> 2]) / Math_fround(Math_fround(HEAP32[$4 + 72 >> 2]) + Math_fround(-1.0));
  HEAPF32[$4 + 56 >> 2] = 0;
  HEAP32[$4 + 52 >> 2] = 0;
  $5 = HEAP32[$4 + 76 >> 2];
  $3 = HEAP32[$4 + 52 >> 2];
  HEAP32[$4 + 52 >> 2] = $3 + 1;
  $2 = HEAP32[$4 + 68 >> 2];
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  $2 = $0;
  $0 = ($3 << 3) + $5 | 0;
  HEAP32[$0 >> 2] = $2;
  HEAP32[$0 + 4 >> 2] = $1;
  HEAP32[$4 + 48 >> 2] = 1;
  while (1) {
   if (HEAP32[$4 + 48 >> 2] < HEAP32[$4 + 64 >> 2]) {
    $3 = HEAP32[$4 + 68 >> 2];
    $5 = HEAP32[$4 + 48 >> 2] << 3;
    $2 = HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] - 1 << 3) | 0;
    $1 = HEAP32[$2 >> 2];
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$4 + 8 >> 2] = $1;
    HEAP32[$4 + 12 >> 2] = $0;
    $2 = $3 + $5 | 0;
    $0 = HEAP32[$2 >> 2];
    $1 = HEAP32[$2 + 4 >> 2];
    HEAP32[$4 >> 2] = $0;
    HEAP32[$4 + 4 >> 2] = $1;
    HEAPF32[$4 + 44 >> 2] = Distance($4 + 8 | 0, $4);
    block : {
     if (HEAPF32[$4 + 60 >> 2] <= Math_fround(HEAPF32[$4 + 56 >> 2] + HEAPF32[$4 + 44 >> 2])) {
      HEAPF32[$4 + 40 >> 2] = Math_fround(Math_fround(Math_fround(HEAPF32[$4 + 60 >> 2] - HEAPF32[$4 + 56 >> 2]) / HEAPF32[$4 + 44 >> 2]) * Math_fround(HEAPF32[HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] << 3) >> 2] - HEAPF32[HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] - 1 << 3) >> 2])) + HEAPF32[HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] - 1 << 3) >> 2];
      HEAPF32[$4 + 36 >> 2] = Math_fround(Math_fround(Math_fround(HEAPF32[$4 + 60 >> 2] - HEAPF32[$4 + 56 >> 2]) / HEAPF32[$4 + 44 >> 2]) * Math_fround(HEAPF32[(HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] << 3) | 0) + 4 >> 2] - HEAPF32[(HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] - 1 << 3) | 0) + 4 >> 2])) + HEAPF32[(HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] - 1 << 3) | 0) + 4 >> 2];
      HEAPF32[$4 + 28 >> 2] = HEAPF32[$4 + 40 >> 2];
      HEAPF32[$4 + 32 >> 2] = HEAPF32[$4 + 36 >> 2];
      $5 = HEAP32[$4 + 76 >> 2];
      $3 = HEAP32[$4 + 52 >> 2];
      HEAP32[$4 + 52 >> 2] = $3 + 1;
      $0 = HEAP32[$4 + 32 >> 2];
      $1 = HEAP32[$4 + 28 >> 2];
      $2 = $1;
      $1 = ($3 << 3) + $5 | 0;
      HEAP32[$1 >> 2] = $2;
      HEAP32[$1 + 4 >> 2] = $0;
      $1 = HEAP32[$4 + 32 >> 2];
      $0 = HEAP32[$4 + 28 >> 2];
      $2 = $0;
      $0 = HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 48 >> 2] - 1 << 3) | 0;
      HEAP32[$0 >> 2] = $2;
      HEAP32[$0 + 4 >> 2] = $1;
      HEAP32[$4 + 48 >> 2] = HEAP32[$4 + 48 >> 2] - 1;
      HEAPF32[$4 + 56 >> 2] = 0;
      break block;
     }
     HEAPF32[$4 + 56 >> 2] = HEAPF32[$4 + 56 >> 2] + HEAPF32[$4 + 44 >> 2];
    }
    HEAP32[$4 + 48 >> 2] = HEAP32[$4 + 48 >> 2] + 1;
    continue;
   }
   break;
  };
  if (HEAP32[$4 + 52 >> 2] == (HEAP32[$4 + 72 >> 2] - 1 | 0)) {
   HEAPF32[$4 + 20 >> 2] = HEAPF32[HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 64 >> 2] - 1 << 3) >> 2];
   HEAPF32[$4 + 24 >> 2] = HEAPF32[(HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 64 >> 2] - 1 << 3) | 0) + 4 >> 2];
   $5 = HEAP32[$4 + 76 >> 2];
   $3 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 + 52 >> 2] = $3 + 1;
   $0 = HEAP32[$4 + 24 >> 2];
   $1 = HEAP32[$4 + 20 >> 2];
   $2 = $1;
   $1 = ($3 << 3) + $5 | 0;
   HEAP32[$1 >> 2] = $2;
   HEAP32[$1 + 4 >> 2] = $0;
  }
  __stack_pointer = $4 + 80 | 0;
 }
 
 function IndicativeAngle($0, $1) {
  var $2 = 0, $3 = 0.0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  Centroid($2, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  $0 = HEAP32[$2 + 12 >> 2];
  $3 = atan2(+Math_fround(HEAPF32[$2 + 4 >> 2] - HEAPF32[$0 + 4 >> 2]), +Math_fround(HEAPF32[$2 >> 2] - HEAPF32[$0 >> 2]));
  __stack_pointer = $2 + 16 | 0;
  return Math_fround($3);
 }
 
 function RotateBy($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAPF32[$4 + 32 >> 2] = $3;
  Centroid($4 + 24 | 0, HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2]);
  HEAPF32[$4 + 20 >> 2] = cos(+HEAPF32[$4 + 32 >> 2]);
  HEAPF32[$4 + 16 >> 2] = sin(+HEAPF32[$4 + 32 >> 2]);
  HEAP32[$4 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 12 >> 2] < HEAP32[$4 + 36 >> 2]) {
    HEAPF32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 2] = Math_fround(Math_fround(Math_fround(HEAPF32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 2] - HEAPF32[$4 + 24 >> 2]) * HEAPF32[$4 + 20 >> 2]) - Math_fround(Math_fround(HEAPF32[(HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) | 0) + 4 >> 2] - HEAPF32[$4 + 28 >> 2]) * HEAPF32[$4 + 16 >> 2])) + HEAPF32[$4 + 24 >> 2];
    HEAPF32[(HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) | 0) + 4 >> 2] = Math_fround(Math_fround(Math_fround(HEAPF32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 2] - HEAPF32[$4 + 24 >> 2]) * HEAPF32[$4 + 16 >> 2]) + Math_fround(Math_fround(HEAPF32[(HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) | 0) + 4 >> 2] - HEAPF32[$4 + 28 >> 2]) * HEAPF32[$4 + 20 >> 2])) + HEAPF32[$4 + 28 >> 2];
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 48 | 0;
 }
 
 function ScaleTo($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAPF32[$4 + 32 >> 2] = $3;
  BoundingBox($4 + 16 | 0, HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2]);
  if (HEAPF32[$4 + 24 >> 2] < Math_fround(HEAPF32[$4 + 28 >> 2] * Math_fround(.5))) {
   HEAPF32[$4 + 24 >> 2] = HEAPF32[$4 + 28 >> 2] * Math_fround(.5)
  }
  if (HEAPF32[$4 + 28 >> 2] < Math_fround(HEAPF32[$4 + 24 >> 2] * Math_fround(.5))) {
   HEAPF32[$4 + 28 >> 2] = HEAPF32[$4 + 24 >> 2] * Math_fround(.5)
  }
  HEAP32[$4 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 12 >> 2] < HEAP32[$4 + 36 >> 2]) {
    HEAPF32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 2] = HEAPF32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 2] * Math_fround(HEAPF32[$4 + 32 >> 2] / HEAPF32[$4 + 24 >> 2]);
    HEAPF32[(HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) | 0) + 4 >> 2] = HEAPF32[(HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) | 0) + 4 >> 2] * Math_fround(HEAPF32[$4 + 32 >> 2] / HEAPF32[$4 + 28 >> 2]);
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 48 | 0;
 }
 
 function TranslateTo($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  Centroid($4 + 12 | 0, HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
  HEAP32[$4 + 8 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 8 >> 2] < HEAP32[$4 + 20 >> 2]) {
    HEAPF32[HEAP32[$4 + 28 >> 2] + (HEAP32[$4 + 8 >> 2] << 3) >> 2] = Math_fround(HEAPF32[HEAP32[$4 + 24 >> 2] + (HEAP32[$4 + 8 >> 2] << 3) >> 2] + HEAPF32[$3 >> 2]) - HEAPF32[$4 + 12 >> 2];
    HEAPF32[(HEAP32[$4 + 28 >> 2] + (HEAP32[$4 + 8 >> 2] << 3) | 0) + 4 >> 2] = Math_fround(HEAPF32[(HEAP32[$4 + 24 >> 2] + (HEAP32[$4 + 8 >> 2] << 3) | 0) + 4 >> 2] + HEAPF32[$3 + 4 >> 2]) - HEAPF32[$4 + 16 >> 2];
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 32 | 0;
 }
 
 function PathLength($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = Math_fround(0);
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAPF32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 1;
  while (1) {
   if (HEAP32[$2 + 16 >> 2] < HEAP32[$2 + 24 >> 2]) {
    $4 = HEAP32[$2 + 28 >> 2];
    $5 = HEAP32[$2 + 16 >> 2] << 3;
    $1 = HEAP32[$2 + 28 >> 2] + (HEAP32[$2 + 16 >> 2] - 1 << 3) | 0;
    $3 = HEAP32[$1 >> 2];
    $0 = HEAP32[$1 + 4 >> 2];
    HEAP32[$2 + 8 >> 2] = $3;
    HEAP32[$2 + 12 >> 2] = $0;
    $1 = $4 + $5 | 0;
    $0 = HEAP32[$1 >> 2];
    $3 = HEAP32[$1 + 4 >> 2];
    HEAP32[$2 >> 2] = $0;
    HEAP32[$2 + 4 >> 2] = $3;
    $6 = Distance($2 + 8 | 0, $2);
    HEAPF32[$2 + 20 >> 2] = HEAPF32[$2 + 20 >> 2] + $6;
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 32 | 0;
  return HEAPF32[$2 + 20 >> 2];
 }
 
 function Distance($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAPF32[$2 + 12 >> 2] = HEAPF32[$1 >> 2] - HEAPF32[$0 >> 2];
  HEAPF32[$2 + 8 >> 2] = HEAPF32[$1 + 4 >> 2] - HEAPF32[$0 + 4 >> 2];
  return Math_fround(Math_sqrt(Math_fround(Math_fround(HEAPF32[$2 + 12 >> 2] * HEAPF32[$2 + 12 >> 2]) + Math_fround(HEAPF32[$2 + 8 >> 2] * HEAPF32[$2 + 8 >> 2]))));
 }
 
 function Centroid($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAPF32[$0 >> 2] = 0;
  HEAPF32[$0 + 4 >> 2] = 0;
  HEAP32[$3 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 4 >> 2] < HEAP32[$3 + 8 >> 2]) {
    HEAPF32[$0 >> 2] = HEAPF32[$0 >> 2] + HEAPF32[HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) >> 2];
    HEAPF32[$0 + 4 >> 2] = HEAPF32[$0 + 4 >> 2] + HEAPF32[(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) | 0) + 4 >> 2];
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAPF32[$0 >> 2] = HEAPF32[$0 >> 2] / Math_fround(HEAP32[$3 + 8 >> 2]);
  HEAPF32[$0 + 4 >> 2] = HEAPF32[$0 + 4 >> 2] / Math_fround(HEAP32[$3 + 8 >> 2]);
 }
 
 function BoundingBox($0, $1, $2) {
  var $3 = 0, $4 = Math_fround(0);
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 28 >> 2] = $1;
  HEAP32[$3 + 24 >> 2] = $2;
  HEAPF32[$3 + 20 >> 2] = 3402823466385288598117041e14;
  HEAPF32[$3 + 16 >> 2] = -3402823466385288598117041e14;
  HEAPF32[$3 + 12 >> 2] = 3402823466385288598117041e14;
  HEAPF32[$3 + 8 >> 2] = -3402823466385288598117041e14;
  HEAP32[$3 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 4 >> 2] < HEAP32[$3 + 24 >> 2]) {
    if (HEAPF32[$3 + 20 >> 2] < HEAPF32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) >> 2]) {
     $4 = HEAPF32[$3 + 20 >> 2]
    } else {
     $4 = HEAPF32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) >> 2]
    }
    HEAPF32[$3 + 20 >> 2] = $4;
    if (HEAPF32[$3 + 12 >> 2] < HEAPF32[(HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) | 0) + 4 >> 2]) {
     $4 = HEAPF32[$3 + 12 >> 2]
    } else {
     $4 = HEAPF32[(HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) | 0) + 4 >> 2]
    }
    HEAPF32[$3 + 12 >> 2] = $4;
    if (HEAPF32[$3 + 16 >> 2] > HEAPF32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) >> 2]) {
     $4 = HEAPF32[$3 + 16 >> 2]
    } else {
     $4 = HEAPF32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) >> 2]
    }
    HEAPF32[$3 + 16 >> 2] = $4;
    if (HEAPF32[$3 + 8 >> 2] > HEAPF32[(HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) | 0) + 4 >> 2]) {
     $4 = HEAPF32[$3 + 8 >> 2]
    } else {
     $4 = HEAPF32[(HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 4 >> 2] << 3) | 0) + 4 >> 2]
    }
    HEAPF32[$3 + 8 >> 2] = $4;
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAPF32[$0 >> 2] = HEAPF32[$3 + 20 >> 2];
  HEAPF32[$0 + 4 >> 2] = HEAPF32[$3 + 12 >> 2];
  HEAPF32[$0 + 8 >> 2] = HEAPF32[$3 + 16 >> 2] - HEAPF32[$3 + 20 >> 2];
  HEAPF32[$0 + 12 >> 2] = HEAPF32[$3 + 8 >> 2] - HEAPF32[$3 + 12 >> 2];
 }
 
 function uint8ToPoints($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 >> 2] < HEAP32[$3 + 4 >> 2]) {
    $0 = HEAP32[$3 >> 2];
    HEAPF32[HEAP32[$3 + 12 >> 2] + ($0 << 3) >> 2] = HEAPU8[HEAP32[$3 + 8 >> 2] + ($0 << 1) | 0];
    HEAPF32[(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 >> 2] << 3) | 0) + 4 >> 2] = HEAPU8[(HEAP32[$3 + 8 >> 2] + (HEAP32[$3 >> 2] << 1) | 0) + 1 | 0];
    HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + 1;
    continue;
   }
   break;
  };
 }
 
 function newUnistroke8($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 272 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 268 >> 2] = $1;
  HEAP32[$3 + 264 >> 2] = $2;
  uint8ToPoints($3, HEAP32[$3 + 268 >> 2], HEAP32[$3 + 264 >> 2]);
  newUnistroke($0, $3, HEAP32[$3 + 264 >> 2]);
  __stack_pointer = $3 + 272 | 0;
 }
 
 function DistanceAtBestAngle($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 48 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 44 >> 2] = $0;
  HEAP32[$6 + 40 >> 2] = $1;
  HEAP32[$6 + 36 >> 2] = $2;
  HEAPF32[$6 + 32 >> 2] = $3;
  HEAPF32[$6 + 28 >> 2] = $4;
  HEAPF32[$6 + 24 >> 2] = $5;
  HEAPF32[$6 + 20 >> 2] = Math_fround(HEAPF32[$6 + 32 >> 2] * Math_fround(.6180340051651001)) + Math_fround(HEAPF32[$6 + 28 >> 2] * Math_fround(.3819659948348999));
  HEAPF32[$6 + 16 >> 2] = DistanceAtAngle(HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAPF32[$6 + 20 >> 2]);
  HEAPF32[$6 + 12 >> 2] = Math_fround(HEAPF32[$6 + 32 >> 2] * Math_fround(.3819659948348999)) + Math_fround(HEAPF32[$6 + 28 >> 2] * Math_fround(.6180340051651001));
  HEAPF32[$6 + 8 >> 2] = DistanceAtAngle(HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAPF32[$6 + 12 >> 2]);
  while (1) {
   if (Math_abs(+Math_fround(HEAPF32[$6 + 28 >> 2] - HEAPF32[$6 + 32 >> 2])) > +HEAPF32[$6 + 24 >> 2]) {
    if (HEAPF32[$6 + 16 >> 2] < HEAPF32[$6 + 8 >> 2]) {
     HEAPF32[$6 + 28 >> 2] = HEAPF32[$6 + 12 >> 2];
     HEAPF32[$6 + 12 >> 2] = HEAPF32[$6 + 20 >> 2];
     HEAPF32[$6 + 8 >> 2] = HEAPF32[$6 + 16 >> 2];
     HEAPF32[$6 + 20 >> 2] = Math_fround(HEAPF32[$6 + 32 >> 2] * Math_fround(.6180340051651001)) + Math_fround(HEAPF32[$6 + 28 >> 2] * Math_fround(.3819659948348999));
     HEAPF32[$6 + 16 >> 2] = DistanceAtAngle(HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAPF32[$6 + 20 >> 2]);
     continue;
    }
    HEAPF32[$6 + 32 >> 2] = HEAPF32[$6 + 20 >> 2];
    HEAPF32[$6 + 20 >> 2] = HEAPF32[$6 + 12 >> 2];
    HEAPF32[$6 + 16 >> 2] = HEAPF32[$6 + 8 >> 2];
    HEAPF32[$6 + 12 >> 2] = Math_fround(HEAPF32[$6 + 32 >> 2] * Math_fround(.3819659948348999)) + Math_fround(HEAPF32[$6 + 28 >> 2] * Math_fround(.6180340051651001));
    HEAPF32[$6 + 8 >> 2] = DistanceAtAngle(HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAPF32[$6 + 12 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $6 + 48 | 0;
  if (HEAPF32[$6 + 16 >> 2] < HEAPF32[$6 + 8 >> 2]) {
   $3 = HEAPF32[$6 + 16 >> 2]
  } else {
   $3 = HEAPF32[$6 + 8 >> 2]
  }
  return $3;
 }
 
 function DistanceAtAngle($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAPF32[$4 + 16 >> 2] = $3;
  $0 = $4 - ((HEAP32[$4 + 24 >> 2] << 3) + 15 & -16) | 0;
  __stack_pointer = $0;
  HEAP32[$4 + 12 >> 2] = $0;
  RotateBy(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAPF32[$4 + 16 >> 2]);
  $3 = PathDistance(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 24 >> 2]);
  __stack_pointer = $4 + 32 | 0;
  return $3;
 }
 
 function PathDistance($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = Math_fround(0);
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  HEAPF32[$3 + 32 >> 2] = 0;
  HEAP32[$3 + 28 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 28 >> 2] < HEAP32[$3 + 36 >> 2]) {
    $4 = HEAP32[$3 + 40 >> 2];
    $5 = HEAP32[$3 + 28 >> 2] << 3;
    $1 = HEAP32[$3 + 44 >> 2] + (HEAP32[$3 + 28 >> 2] << 3) | 0;
    $2 = HEAP32[$1 >> 2];
    $0 = HEAP32[$1 + 4 >> 2];
    HEAP32[$3 + 16 >> 2] = $2;
    HEAP32[$3 + 20 >> 2] = $0;
    $1 = $4 + $5 | 0;
    $0 = HEAP32[$1 >> 2];
    $2 = HEAP32[$1 + 4 >> 2];
    HEAP32[$3 + 8 >> 2] = $0;
    HEAP32[$3 + 12 >> 2] = $2;
    $6 = Distance($3 + 16 | 0, $3 + 8 | 0);
    HEAPF32[$3 + 32 >> 2] = HEAPF32[$3 + 32 >> 2] + $6;
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 48 | 0;
  return Math_fround(HEAPF32[$3 + 32 >> 2] / Math_fround(HEAP32[$3 + 36 >> 2]));
 }
 
 function unistroke_init() {
  HEAP8[244922] = 0;
  HEAP8[244923] = 1;
  HEAP8[244924] = 0;
 }
 
 function unistroke_touch($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 24 >> 2] = $0;
  HEAP32[$5 + 20 >> 2] = $1;
  HEAP32[$5 + 16 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 8 >> 2] = $4;
  block : {
   if (!HEAP32[$5 + 8 >> 2]) {
    HEAP8[244924] = 0;
    HEAP8[$5 + 31 | 0] = HEAP32[61232] > 88;
    break block;
   }
   if (!(HEAP8[244924] & 1)) {
    HEAP8[244922] = 0;
    HEAP8[244923] = 1;
    HEAPF32[61233] = 0;
    HEAPF32[61234] = 0;
    HEAP8[244940] = 0;
    HEAP32[61232] = 0;
    HEAP8[244924] = 1;
   }
   $0 = HEAP32[$5 + 16 >> 2];
   $1 = HEAP32[$5 + 12 >> 2];
   HEAP32[61232] = int_sqrt32(Math_imul($0, $0) + Math_imul($1, $1) | 0) + HEAP32[61232];
   HEAPF32[61233] = HEAPF32[61233] + Math_fround(HEAP32[$5 + 24 >> 2]);
   HEAPF32[61234] = HEAPF32[61234] + Math_fround(HEAP32[$5 + 20 >> 2]);
   HEAP8[244940] = HEAPU8[244940] + 1;
   if (HEAPU8[244940] >= HEAPU8[244923]) {
    if (HEAPU8[244922] == 32) {
     HEAP32[$5 + 4 >> 2] = 0;
     HEAP32[$5 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 >> 2] < 32) {
       HEAPF32[(HEAP32[$5 + 4 >> 2] << 3) + 244944 >> 2] = Math_fround(HEAPF32[(HEAP32[$5 >> 2] << 3) + 244944 >> 2] + HEAPF32[(HEAP32[$5 >> 2] << 3) + 244952 >> 2]) * Math_fround(.5);
       HEAPF32[((HEAP32[$5 + 4 >> 2] << 3) + 244944 | 0) + 4 >> 2] = Math_fround(HEAPF32[((HEAP32[$5 >> 2] << 3) + 244944 | 0) + 4 >> 2] + HEAPF32[((HEAP32[$5 >> 2] << 3) + 244952 | 0) + 4 >> 2]) * Math_fround(.5);
       HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
       HEAP32[$5 >> 2] = HEAP32[$5 >> 2] + 2;
       continue;
      }
      break;
     };
     HEAP8[244922] = HEAPU8[244922] >>> 1;
     HEAP8[244923] = HEAPU8[244923] + 2;
    }
    HEAPF32[(HEAPU8[244922] << 3) + 244944 >> 2] = HEAPF32[61233] / Math_fround(HEAPU8[244940]);
    HEAPF32[(HEAPU8[244922] << 3) + 244948 >> 2] = HEAPF32[61234] / Math_fround(HEAPU8[244940]);
    HEAP8[244922] = HEAPU8[244922] + 1;
    HEAPF32[61233] = 0;
    HEAPF32[61234] = 0;
    HEAP8[244940] = 0;
   }
   HEAP8[$5 + 31 | 0] = 0;
  }
  __stack_pointer = $5 + 32 | 0;
  return HEAP8[$5 + 31 | 0] & 1;
 }
 
 function unistroke_convert($0) {
  var $1 = 0;
  $1 = __stack_pointer - 352 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 348 >> 2] = $0;
  HEAP32[$1 + 268 >> 2] = jsvIterateCallbackToBytes(HEAP32[$1 + 348 >> 2], $1 + 272 | 0, 64);
  HEAP32[$1 + 264 >> 2] = HEAP32[$1 + 268 >> 2] >>> 1;
  newUnistroke8($1 + 8 | 0, $1 + 272 | 0, HEAP32[$1 + 264 >> 2]);
  $0 = jsvNewStringOfLength(256, $1 + 8 | 0);
  __stack_pointer = $1 + 352 | 0;
  return $0;
 }
 
 function unistroke_recognise_one($0, $1) {
  var $2 = 0, $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  $2 = $3;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAPF32[$2 + 20 >> 2] = 3402823466385288598117041e14;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 28 >> 2], $2 + 16 | 0);
  if (!(HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 28 >> 2])) {
   HEAP32[$2 + 16 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 28 >> 2]);
   block1 : {
    if (HEAP32[$2 + 16 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 20608, 0);
     break block1;
    }
    $3 = $3 - (HEAP32[$2 + 16 >> 2] + 15 & -16) | 0;
    __stack_pointer = $3;
    HEAP32[$2 + 12 >> 2] = $3;
    jsvIterateCallbackToBytes(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
   }
  }
  if (!(!HEAP32[$2 + 12 >> 2] | HEAP32[$2 + 16 >> 2] != 256)) {
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 12 >> 2];
   HEAPF32[$2 + 20 >> 2] = DistanceAtBestAngle(HEAP32[$2 + 24 >> 2], 32, HEAP32[$2 + 8 >> 2], Math_fround(-.785398006439209), Math_fround(.785398006439209), Math_fround(.034906577318906784));
  }
  jsvUnLock(HEAP32[$2 + 28 >> 2]);
  __stack_pointer = $2 + 32 | 0;
  return HEAPF32[$2 + 20 >> 2];
 }
 
 function unistroke_recognise($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAPF32[$2 + 16 >> 2] = 3402823466385288598117041e14;
  jsvObjectIteratorNew($2 + 12 | 0, HEAP32[$2 + 28 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($2 + 12 | 0) & 1) {
    HEAP32[$2 + 8 >> 2] = jsvObjectIteratorGetValue($2 + 12 | 0);
    HEAPF32[$2 + 4 >> 2] = unistroke_recognise_one(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 24 >> 2]);
    if (HEAPF32[$2 + 4 >> 2] < HEAPF32[$2 + 16 >> 2]) {
     HEAPF32[$2 + 16 >> 2] = HEAPF32[$2 + 4 >> 2];
     jsvUnLock(HEAP32[$2 + 20 >> 2]);
     HEAP32[$2 + 20 >> 2] = jsvObjectIteratorGetKey($2 + 12 | 0);
    }
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
    jsvObjectIteratorNext($2 + 12 | 0);
    continue;
   }
   break;
  };
  block : {
   if (HEAP32[$2 + 20 >> 2]) {
    $0 = jsvAsStringAndUnLock(HEAP32[$2 + 20 >> 2]);
    break block;
   }
   $0 = 0;
  }
  __stack_pointer = $2 + 32 | 0;
  return $0;
 }
 
 function jsvObjectIteratorHasValue($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorGetKey($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function unistroke_recognise_xy($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 352 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 348 >> 2] = $0;
  HEAP32[$2 + 344 >> 2] = $1;
  HEAP32[$2 + 268 >> 2] = jsvIterateCallbackToBytes(HEAP32[$2 + 344 >> 2], $2 + 272 | 0, 64);
  HEAP32[$2 + 264 >> 2] = HEAP32[$2 + 268 >> 2] >>> 1;
  newUnistroke8($2 + 8 | 0, $2 + 272 | 0, HEAP32[$2 + 264 >> 2]);
  $0 = unistroke_recognise(HEAP32[$2 + 348 >> 2], $2 + 8 | 0);
  __stack_pointer = $2 + 352 | 0;
  return $0;
 }
 
 function unistroke_getEventVar() {
  var $0 = 0, $1 = 0, $2 = Math_fround(0), $3 = 0, $4 = 0;
  $0 = __stack_pointer - 288 | 0;
  __stack_pointer = $0;
  block : {
   if (!HEAPU8[244922]) {
    HEAP32[$0 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 280 >> 2] = jsvNewObject();
   if (!HEAP32[$0 + 280 >> 2]) {
    HEAP32[$0 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 276 >> 2] = jsvNewTypedArray(1, HEAPU8[244922] << 1);
   if (HEAP32[$0 + 276 >> 2]) {
    HEAP32[$0 + 272 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$0 + 276 >> 2], 0);
    HEAP32[$0 + 268 >> 2] = 0;
    HEAP32[$0 + 264 >> 2] = 0;
    while (1) {
     if (HEAP32[$0 + 264 >> 2] < HEAPU8[244922]) {
      $4 = HEAP32[$0 + 272 >> 2];
      $1 = HEAP32[$0 + 268 >> 2];
      HEAP32[$0 + 268 >> 2] = $1 + 1;
      $2 = HEAPF32[(HEAP32[$0 + 264 >> 2] << 3) + 244944 >> 2];
      if (Math_fround(Math_abs($2)) < Math_fround(2147483648.0)) {
       $3 = ~~$2
      } else {
       $3 = -2147483648
      }
      jsvSetCharInString($4, $1, $3, 0);
      $4 = HEAP32[$0 + 272 >> 2];
      $1 = HEAP32[$0 + 268 >> 2];
      HEAP32[$0 + 268 >> 2] = $1 + 1;
      $2 = HEAPF32[(HEAP32[$0 + 264 >> 2] << 3) + 244948 >> 2];
      if (Math_fround(Math_abs($2)) < Math_fround(2147483648.0)) {
       $3 = ~~$2
      } else {
       $3 = -2147483648
      }
      jsvSetCharInString($4, $1, $3 << 24 >> 24, 0);
      HEAP32[$0 + 264 >> 2] = HEAP32[$0 + 264 >> 2] + 1;
      continue;
     }
     break;
    };
    jsvUnLock(HEAP32[$0 + 272 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 280 >> 2], 3504, HEAP32[$0 + 276 >> 2]);
   }
   HEAP32[$0 + 260 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 17919);
   if (HEAP32[$0 + 260 >> 2]) {
    HEAP32[$0 + 256 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 260 >> 2], 7301);
    if (jsvIsObject(HEAP32[$0 + 256 >> 2]) & 1) {
     newUnistroke($0, 244944, HEAPU8[244922]);
     jsvObjectSetChildAndUnLock(HEAP32[$0 + 280 >> 2], 18046, unistroke_recognise(HEAP32[$0 + 256 >> 2], $0));
    }
    jsvUnLock2(HEAP32[$0 + 260 >> 2], HEAP32[$0 + 256 >> 2]);
   }
   HEAP32[$0 + 284 >> 2] = HEAP32[$0 + 280 >> 2];
  }
  __stack_pointer = $0 + 288 | 0;
  return HEAP32[$0 + 284 >> 2];
 }
 
 function jslSetLex($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[61300];
  HEAP32[61300] = HEAP32[$1 + 12 >> 2];
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jslCharPosFree($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvStringIteratorFree(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorFree($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jslCharPosClear($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = 0;
 }
 
 function jslCharPosFromLex($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvStringIteratorClone(HEAP32[$1 + 12 >> 2], HEAP32[61300] + 88 | 0);
  HEAP8[HEAP32[$1 + 12 >> 2] + 40 | 0] = HEAPU8[HEAP32[61300]];
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jslCharPosNew($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  $0 = jsvStringIteratorGetCharAndNext(HEAP32[$3 + 12 >> 2]);
  HEAP8[HEAP32[$3 + 12 >> 2] + 40 | 0] = $0;
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jslSkipWhiteSpace() {
  var $0 = 0;
  while (1) {
   block : {
    while (1) {
     if (isWhitespaceInline(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
      jslGetNextCh();
      continue;
     }
     break;
    };
    if (HEAPU8[HEAP32[61300]] != 47) {
     break block
    }
    if ((jslNextCh() & 255) == 47) {
     while (1) {
      $0 = 0;
      $0 = HEAP8[HEAP32[61300]] << 24 >> 24 ? HEAPU8[HEAP32[61300]] != 10 : $0;
      if ($0) {
       jslGetNextCh();
       continue;
      }
      break;
     };
     jslGetNextCh();
     continue;
    }
    if ((jslNextCh() & 255) == 42) {
     jslGetNextCh();
     jslGetNextCh();
     while (1) {
      $0 = 0;
      if (HEAP8[HEAP32[61300]] << 24 >> 24) {
       $0 = 0;
       if (HEAPU8[HEAP32[61300]] == 42) {
        $0 = (jslNextCh() & 255) == 47
       }
       $0 = $0 ^ -1;
      }
      if ($0 & 1) {
       jslGetNextCh();
       continue;
      }
      break;
     };
     if (!HEAPU8[HEAP32[61300]]) {
      HEAP16[HEAP32[61300] + 2 >> 1] = 137;
      break block;
     }
     jslGetNextCh();
     jslGetNextCh();
     continue;
    }
   }
   break;
  };
 }
 
 function isWhitespaceInline($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = 1;
  block : {
   if (HEAPU8[$1 + 15 | 0] == 9) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 11) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 12) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 32) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 10) {
    break block
   }
   $0 = HEAPU8[$1 + 15 | 0] == 13;
  }
  return $0;
 }
 
 function jslGetNextCh() {
  var $0 = 0;
  $0 = jslNextCh();
  HEAP8[HEAP32[61300]] = $0;
  $0 = HEAP32[61300];
  HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 88 >> 2] + 1;
  block : {
   if (HEAPU32[HEAP32[61300] + 88 >> 2] < HEAPU32[HEAP32[61300] + 92 >> 2]) {
    break block
   }
   $0 = HEAP32[61300];
   HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 88 >> 2] - HEAP32[HEAP32[61300] + 92 >> 2];
   $0 = HEAP32[61300];
   HEAP32[$0 + 96 >> 2] = HEAP32[HEAP32[61300] + 92 >> 2] + HEAP32[$0 + 96 >> 2];
   if (jsvIsFlashString(HEAP32[HEAP32[61300] + 100 >> 2]) & 1) {
    jsvStringIteratorLoadFlashString(HEAP32[61300] + 88 | 0);
    break block;
   }
   block2 : {
    block1 : {
     if (!HEAP32[HEAP32[61300] + 100 >> 2]) {
      break block1
     }
     if (!(jsvGetLastChild(HEAP32[HEAP32[61300] + 100 >> 2]) & 65535)) {
      break block1
     }
     $0 = _jsvGetAddressOf(jsvGetLastChild(HEAP32[HEAP32[61300] + 100 >> 2]) & 65535);
     HEAP32[HEAP32[61300] + 100 >> 2] = $0;
     HEAP32[HEAP32[61300] + 104 >> 2] = HEAP32[HEAP32[61300] + 100 >> 2];
     $0 = jsvGetCharactersInVar(HEAP32[HEAP32[61300] + 100 >> 2]);
     HEAP32[HEAP32[61300] + 92 >> 2] = $0;
     break block2;
    }
    HEAP32[HEAP32[61300] + 100 >> 2] = 0;
    HEAP32[HEAP32[61300] + 104 >> 2] = 0;
    HEAP32[HEAP32[61300] + 92 >> 2] = 0;
    $0 = HEAP32[61300];
    HEAP32[$0 + 96 >> 2] = HEAP32[HEAP32[61300] + 88 >> 2] + HEAP32[$0 + 96 >> 2];
    HEAP32[HEAP32[61300] + 88 >> 2] = 0;
   }
  }
 }
 
 function jslNextCh() {
  var $0 = 0;
  if (HEAP32[HEAP32[61300] + 104 >> 2]) {
   $0 = HEAP8[HEAP32[HEAP32[61300] + 104 >> 2] + HEAP32[HEAP32[61300] + 88 >> 2] | 0]
  } else {
   $0 = 0
  }
  return $0 << 24 >> 24;
 }
 
 function jslGetNextToken() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16;
  HEAP16[HEAP32[61300] + 2 >> 1] = 0;
  HEAP8[HEAP32[61300] + 80 | 0] = 0;
  if (HEAP32[HEAP32[61300] + 76 >> 2]) {
   jsvUnLock(HEAP32[HEAP32[61300] + 76 >> 2]);
   HEAP32[HEAP32[61300] + 76 >> 2] = 0;
  }
  HEAP32[HEAP32[61300] + 8 >> 2] = HEAP32[HEAP32[61300] + 4 >> 2];
  HEAP8[$0 + 11 | 0] = HEAPU8[HEAP32[61300]];
  if (HEAPU8[$0 + 11 | 0] > 124) {
   HEAP8[$0 + 11 | 0] = 0
  }
  block18 : {
   block17 : {
    block15 : {
     block16 : {
      block11 : {
       block14 : {
        block5 : {
         block12 : {
          block13 : {
           block10 : {
            block9 : {
             block8 : {
              block7 : {
               block6 : {
                block4 : {
                 block3 : {
                  block2 : {
                   while (1) {
                    block : {
                     $1 = jsvStringIteratorGetIndex(HEAP32[61300] + 88 | 0);
                     HEAP32[HEAP32[61300] + 4 >> 2] = $1 - 1;
                     block1 : {
                      switch (HEAPU8[HEAPU8[$0 + 11 | 0] + 146704 | 0]) {
                      case 0:
                       break block;
                      case 1:
                       break block1;
                      case 10:
                       break block10;
                      case 11:
                       break block11;
                      case 12:
                       break block12;
                      case 13:
                       break block13;
                      case 14:
                       break block14;
                      case 15:
                       break block15;
                      case 16:
                       break block16;
                      case 17:
                       break block17;
                      case 2:
                       break block2;
                      case 3:
                       break block3;
                      case 4:
                       break block4;
                      case 5:
                       break block5;
                      case 6:
                       break block6;
                      case 7:
                       break block7;
                      case 8:
                       break block8;
                      case 9:
                       break block9;
                      default:
                       break block18;
                      };
                     }
                     jslSkipWhiteSpace();
                     HEAP8[$0 + 11 | 0] = HEAPU8[HEAP32[61300]];
                     if (HEAPU8[$0 + 11 | 0] > 124) {
                      HEAP8[$0 + 11 | 0] = 0
                     }
                     if (HEAPU8[$0 + 11 | 0] == 47) {
                      HEAP8[$0 + 11 | 0] = 125
                     }
                     continue;
                    }
                    break;
                   };
                   jslSingleChar();
                   block19 : {
                    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 175) {
                     HEAP8[HEAP32[61300] + 81 | 0] = 1;
                     break block19;
                    }
                    if (HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 >= 209) {
                     block21 : {
                      if (!(HEAPU16[HEAP32[61300] + 2 >> 1] != 209 & HEAPU16[HEAP32[61300] + 2 >> 1] != 210)) {
                       jslGetRawString();
                       break block21;
                      }
                      block22 : {
                       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 211) {
                        HEAP16[HEAP32[61300] + 2 >> 1] = 129;
                        $1 = jsvNewFromInteger(0);
                        HEAP32[HEAP32[61300] + 76 >> 2] = $1;
                        break block22;
                       }
                       block23 : {
                        if (HEAPU16[HEAP32[61300] + 2 >> 1] == 212) {
                         HEAP16[HEAP32[61300] + 2 >> 1] = 129;
                         $1 = jsvNewFromInteger(HEAP8[HEAP32[61300]] << 24 >> 24);
                         HEAP32[HEAP32[61300] + 76 >> 2] = $1;
                         jslGetNextCh();
                         break block23;
                        }
                        if (HEAPU16[HEAP32[61300] + 2 >> 1] == 213) {
                         HEAP16[HEAP32[61300] + 2 >> 1] = 129;
                         HEAP16[$0 + 8 >> 1] = HEAPU8[HEAP32[61300]];
                         jslGetNextCh();
                         HEAP16[$0 + 8 >> 1] = HEAP16[$0 + 8 >> 1] << 16 >> 16 | HEAP8[HEAP32[61300]] << 24 >> 24 << 8;
                         jslGetNextCh();
                         $1 = jsvNewFromInteger(HEAP16[$0 + 8 >> 1] << 16 >> 16);
                         HEAP32[HEAP32[61300] + 76 >> 2] = $1;
                        }
                       }
                      }
                     }
                    }
                   }
                   break block18;
                  }
                  while (1) {
                   $1 = 1;
                   block24 : {
                    if (isAlphaInline(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
                     break block24
                    }
                    $1 = 1;
                    if (isNumericInline(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
                     break block24
                    }
                    $1 = HEAPU8[HEAP32[61300]] == 36;
                   }
                   if ($1) {
                    jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24);
                    jslGetNextCh();
                    continue;
                   }
                   break;
                  };
                  HEAP16[HEAP32[61300] + 2 >> 1] = 128;
                  if (!HEAPU8[HEAP32[61300] + 13 | 0]) {
                   break block18
                  }
                  block30 : {
                   block39 : {
                    switch (HEAP8[HEAP32[61300] + 12 | 0] - 98 | 0) {
                    case 0:
                     jslCheckToken(15998, 168);
                     break block30;
                    case 1:
                     if (!(jslCheckToken(17680, 188) & 1)) {
                      if (!(jslCheckToken(16522, 178) & 1)) {
                       if (!(jslCheckToken(6973, 194) & 1)) {
                        if (!(jslCheckToken(4458, 174) & 1)) {
                         jslCheckToken(17319, 169)
                        }
                       }
                      }
                     }
                     break block30;
                    case 2:
                     if (!(jslCheckToken(4770, 189) & 1)) {
                      if (!(jslCheckToken(17540, 190) & 1)) {
                       if (!(jslCheckToken(15123, 165) & 1)) {
                        jslCheckToken(8095, 193)
                       }
                      }
                     }
                     break block30;
                    case 3:
                     if (!(jslCheckToken(17668, 164) & 1)) {
                      jslCheckToken(7533, 195)
                     }
                     break block30;
                    case 4:
                     if (!(jslCheckToken(17667, 181) & 1)) {
                      if (!(jslCheckToken(3625, 179) & 1)) {
                       if (!(jslCheckToken(7897, 167) & 1)) {
                        jslCheckToken(15422, 170)
                       }
                      }
                     }
                     break block30;
                    case 7:
                     if (!(jslCheckToken(17183, 163) & 1)) {
                      if (!(jslCheckToken(15589, 185) & 1)) {
                       jslCheckToken(17084, 186)
                      }
                     }
                     break block30;
                    case 10:
                     jslCheckToken(4995, 173);
                     break block30;
                    case 12:
                     if (!(jslCheckToken(4130, 184) & 1)) {
                      jslCheckToken(15756, 182)
                     }
                     break block30;
                    case 13:
                     jslCheckToken(17183, 198);
                     break block30;
                    case 16:
                     jslCheckToken(15148, 171);
                     break block30;
                    case 17:
                     if (!(jslCheckToken(20458, 197) & 1)) {
                      if (!(jslCheckToken(7942, 196) & 1)) {
                       jslCheckToken(16386, 187)
                      }
                     }
                     break block30;
                    case 18:
                     block41 : {
                      if (jslCheckToken(7208, 175) & 1) {
                       HEAP8[HEAP32[61300] + 81 | 0] = 1;
                       break block41;
                      }
                      if (!(jslCheckToken(3936, 176) & 1)) {
                       if (!(jslCheckToken(17315, 180) & 1)) {
                        if (!(jslCheckToken(3559, 177) & 1)) {
                         jslCheckToken(17078, 191)
                        }
                       }
                      }
                     }
                     break block30;
                    case 19:
                     jslCheckToken(19124, 183);
                     break block30;
                    case 21:
                     jslCheckToken(17842, 166);
                     break block30;
                    case 20:
                     break block39;
                    default:
                     break block30;
                    };
                   }
                   if (!(jslCheckToken(8403, 172) & 1)) {
                    jslCheckToken(18703, 192)
                   }
                  }
                  break block18;
                 }
                 HEAP8[$0 + 7 | 0] = 1;
                 block43 : {
                  if (HEAPU8[HEAP32[61300]] == 46) {
                   jslGetNextCh();
                   block42 : {
                    if (isNumericInline(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
                     HEAP16[HEAP32[61300] + 2 >> 1] = 130;
                     jslTokenAppendChar(46);
                     break block42;
                    }
                    HEAP16[HEAP32[61300] + 2 >> 1] = 46;
                    break block18;
                   }
                   break block43;
                  }
                  if (HEAPU8[HEAP32[61300]] == 48) {
                   jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24);
                   jslGetNextCh();
                   block45 : {
                    block44 : {
                     if (HEAPU8[HEAP32[61300]] == 120 | HEAPU8[HEAP32[61300]] == 88 | (HEAPU8[HEAP32[61300]] == 98 | HEAPU8[HEAP32[61300]] == 66)) {
                      break block44
                     }
                     if (HEAPU8[HEAP32[61300]] == 111) {
                      break block44
                     }
                     if (HEAPU8[HEAP32[61300]] != 79) {
                      break block45
                     }
                    }
                    HEAP8[$0 + 7 | 0] = 0;
                    jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24);
                    jslGetNextCh();
                   }
                  }
                  HEAP16[HEAP32[61300] + 2 >> 1] = 129;
                  while (1) {
                   $1 = 1;
                   block46 : {
                    if (isNumericInline(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
                     break block46
                    }
                    if (!(HEAP8[$0 + 7 | 0] & 1)) {
                     $1 = 1;
                     if (isHexadecimal(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
                      break block46
                     }
                    }
                    $1 = HEAPU8[HEAP32[61300]] == 95;
                   }
                   if ($1) {
                    if (HEAPU8[HEAP32[61300]] != 95) {
                     jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24)
                    }
                    jslGetNextCh();
                    continue;
                   }
                   break;
                  };
                  if (!(!(HEAP8[$0 + 7 | 0] & 1) | HEAPU8[HEAP32[61300]] != 46)) {
                   HEAP16[HEAP32[61300] + 2 >> 1] = 130;
                   jslTokenAppendChar(46);
                   jslGetNextCh();
                  }
                 }
                 if (HEAPU16[HEAP32[61300] + 2 >> 1] == 130) {
                  while (1) {
                   $1 = 1;
                   if (!(isNumeric(HEAP8[HEAP32[61300]] << 24 >> 24) & 1)) {
                    $1 = HEAPU8[HEAP32[61300]] == 95
                   }
                   if ($1) {
                    if (HEAPU8[HEAP32[61300]] != 95) {
                     jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24)
                    }
                    jslGetNextCh();
                    continue;
                   }
                   break;
                  }
                 }
                 if (!(!(HEAP8[$0 + 7 | 0] & 1) | HEAPU8[HEAP32[61300]] != 101 & HEAPU8[HEAP32[61300]] != 69)) {
                  HEAP16[HEAP32[61300] + 2 >> 1] = 130;
                  jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24);
                  jslGetNextCh();
                  if (!(HEAPU8[HEAP32[61300]] != 45 & HEAPU8[HEAP32[61300]] != 43)) {
                   jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24);
                   jslGetNextCh();
                  }
                  while (1) {
                   $1 = 1;
                   if (!(isNumeric(HEAP8[HEAP32[61300]] << 24 >> 24) & 1)) {
                    $1 = HEAPU8[HEAP32[61300]] == 95
                   }
                   if ($1) {
                    if (HEAPU8[HEAP32[61300]] != 95) {
                     jslTokenAppendChar(HEAP8[HEAP32[61300]] << 24 >> 24)
                    }
                    jslGetNextCh();
                    continue;
                   }
                   break;
                  };
                 }
                 break block18;
                }
                jslLexString();
                break block18;
               }
               jslSingleChar();
               if (HEAPU8[HEAP32[61300]] == 61) {
                HEAP16[HEAP32[61300] + 2 >> 1] = 140;
                jslGetNextCh();
                if (HEAPU8[HEAP32[61300]] == 61) {
                 HEAP16[HEAP32[61300] + 2 >> 1] = 141;
                 jslGetNextCh();
                }
               }
               break block18;
              }
              jslSingleChar();
              block50 : {
               if (HEAPU8[HEAP32[61300]] == 61) {
                HEAP16[HEAP32[61300] + 2 >> 1] = 150;
                jslGetNextCh();
                break block50;
               }
               if (HEAPU8[HEAP32[61300]] == 43) {
                HEAP16[HEAP32[61300] + 2 >> 1] = 152;
                jslGetNextCh();
               }
              }
              break block18;
             }
             jslSingleChar();
             block51 : {
              if (HEAPU8[HEAP32[61300]] == 61) {
               HEAP16[HEAP32[61300] + 2 >> 1] = 151;
               jslGetNextCh();
               break block51;
              }
              if (HEAPU8[HEAP32[61300]] == 45) {
               HEAP16[HEAP32[61300] + 2 >> 1] = 153;
               jslGetNextCh();
              }
             }
             break block18;
            }
            jslSingleChar();
            block52 : {
             if (HEAPU8[HEAP32[61300]] == 61) {
              HEAP16[HEAP32[61300] + 2 >> 1] = 157;
              jslGetNextCh();
              break block52;
             }
             if (HEAPU8[HEAP32[61300]] == 38) {
              HEAP16[HEAP32[61300] + 2 >> 1] = 158;
              jslGetNextCh();
             }
            }
            break block18;
           }
           jslSingleChar();
           block53 : {
            if (HEAPU8[HEAP32[61300]] == 61) {
             HEAP16[HEAP32[61300] + 2 >> 1] = 159;
             jslGetNextCh();
             break block53;
            }
            if (HEAPU8[HEAP32[61300]] == 124) {
             HEAP16[HEAP32[61300] + 2 >> 1] = 160;
             jslGetNextCh();
            }
           }
           break block18;
          }
          jslSingleChar();
          if (HEAPU8[HEAP32[61300]] == 61) {
           HEAP16[HEAP32[61300] + 2 >> 1] = 161;
           jslGetNextCh();
          }
          break block18;
         }
         jslSingleChar();
         if (HEAPU8[HEAP32[61300]] == 61) {
          HEAP16[HEAP32[61300] + 2 >> 1] = 154;
          jslGetNextCh();
         }
         break block18;
        }
        jslSingleChar();
        if (HEAPU8[HEAP32[61300]] == 63) {
         HEAP16[HEAP32[61300] + 2 >> 1] = 208;
         jslGetNextCh();
        }
        break block18;
       }
       block57 : {
        block56 : {
         block54 : {
          if (!HEAP32[$0 + 12 >> 2]) {
           break block54
          }
          block55 : {
           if (HEAP32[$0 + 12 >> 2] < 138 | HEAP32[$0 + 12 >> 2] > 208 | (HEAP32[$0 + 12 >> 2] == 180 | HEAP32[$0 + 12 >> 2] == 181)) {
            break block55
           }
           if (HEAP32[$0 + 12 >> 2] == 182) {
            break block55
           }
           if (HEAP32[$0 + 12 >> 2] != 183) {
            break block54
           }
          }
          if (HEAP32[$0 + 12 >> 2] == 33 | HEAP32[$0 + 12 >> 2] == 37 | (HEAP32[$0 + 12 >> 2] == 38 | HEAP32[$0 + 12 >> 2] == 42)) {
           break block54
          }
          if (HEAP32[$0 + 12 >> 2] == 43 | HEAP32[$0 + 12 >> 2] == 45 | (HEAP32[$0 + 12 >> 2] == 47 | HEAP32[$0 + 12 >> 2] == 60)) {
           break block54
          }
          if (HEAP32[$0 + 12 >> 2] == 61 | HEAP32[$0 + 12 >> 2] == 62 | (HEAP32[$0 + 12 >> 2] == 63 | HEAP32[$0 + 12 >> 2] == 91)) {
           break block54
          }
          if (HEAP32[$0 + 12 >> 2] == 123 | HEAP32[$0 + 12 >> 2] == 125 | (HEAP32[$0 + 12 >> 2] == 40 | HEAP32[$0 + 12 >> 2] == 44)) {
           break block54
          }
          if (HEAP32[$0 + 12 >> 2] == 59) {
           break block54
          }
          if (HEAP32[$0 + 12 >> 2] != 58) {
           break block56
          }
         }
         jslLexRegex();
         break block57;
        }
        jslSingleChar();
        if (HEAPU8[HEAP32[61300]] == 61) {
         HEAP16[HEAP32[61300] + 2 >> 1] = 155;
         jslGetNextCh();
        }
       }
       break block18;
      }
      jslSingleChar();
      if (HEAPU8[HEAP32[61300]] == 61) {
       HEAP16[HEAP32[61300] + 2 >> 1] = 156;
       jslGetNextCh();
      }
      break block18;
     }
     jslSingleChar();
     block58 : {
      if (HEAPU8[HEAP32[61300]] == 61) {
       HEAP16[HEAP32[61300] + 2 >> 1] = 138;
       jslGetNextCh();
       if (HEAPU8[HEAP32[61300]] == 61) {
        HEAP16[HEAP32[61300] + 2 >> 1] = 139;
        jslGetNextCh();
       }
       break block58;
      }
      if (HEAPU8[HEAP32[61300]] == 62) {
       HEAP16[HEAP32[61300] + 2 >> 1] = 162;
       jslGetNextCh();
      }
     }
     break block18;
    }
    jslSingleChar();
    block59 : {
     if (HEAPU8[HEAP32[61300]] == 61) {
      HEAP16[HEAP32[61300] + 2 >> 1] = 142;
      jslGetNextCh();
      break block59;
     }
     if (HEAPU8[HEAP32[61300]] == 60) {
      HEAP16[HEAP32[61300] + 2 >> 1] = 143;
      jslGetNextCh();
      if (HEAPU8[HEAP32[61300]] == 61) {
       HEAP16[HEAP32[61300] + 2 >> 1] = 144;
       jslGetNextCh();
      }
     }
    }
    break block18;
   }
   jslSingleChar();
   block60 : {
    if (HEAPU8[HEAP32[61300]] == 61) {
     HEAP16[HEAP32[61300] + 2 >> 1] = 145;
     jslGetNextCh();
     break block60;
    }
    if (HEAPU8[HEAP32[61300]] == 62) {
     HEAP16[HEAP32[61300] + 2 >> 1] = 146;
     jslGetNextCh();
     block61 : {
      if (HEAPU8[HEAP32[61300]] == 61) {
       HEAP16[HEAP32[61300] + 2 >> 1] = 148;
       jslGetNextCh();
       break block61;
      }
      if (HEAPU8[HEAP32[61300]] == 62) {
       jslGetNextCh();
       block62 : {
        if (HEAPU8[HEAP32[61300]] == 61) {
         HEAP16[HEAP32[61300] + 2 >> 1] = 149;
         jslGetNextCh();
         break block62;
        }
        HEAP16[HEAP32[61300] + 2 >> 1] = 147;
       }
      }
     }
    }
   }
  }
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jsvStringIteratorGetIndex($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
 }
 
 function jslSingleChar() {
  HEAP16[HEAP32[61300] + 2 >> 1] = HEAPU8[HEAP32[61300]];
  jslGetNextCh();
 }
 
 function jslGetRawString() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 15 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 210;
  HEAP16[HEAP32[61300] + 2 >> 1] = 131;
  HEAP8[HEAP32[61300] + 82 | 0] = 0;
  HEAP32[$0 + 8 >> 2] = HEAPU8[HEAP32[61300]];
  if (HEAP8[$0 + 15 | 0] & 1) {
   jslGetNextCh();
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] | HEAPU8[HEAP32[61300]] << 8;
  }
  jsvUnLock(HEAP32[HEAP32[61300] + 76 >> 2]);
  block : {
   if (HEAPU32[$0 + 8 >> 2] > 9) {
    HEAP32[$0 + 4 >> 2] = jsvStringIteratorGetIndex(HEAP32[61300] + 88 | 0);
    $1 = jsvNewFromStringVar(HEAP32[HEAP32[61300] + 84 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
    HEAP32[HEAP32[61300] + 76 >> 2] = $1;
    jsvLockAgain(HEAP32[HEAP32[61300] + 100 >> 2]);
    jsvStringIteratorGoto(HEAP32[61300] + 88 | 0, HEAP32[HEAP32[61300] + 84 >> 2], HEAP32[$0 + 4 >> 2] + HEAP32[$0 + 8 >> 2] | 0);
    jsvUnLock(HEAP32[HEAP32[61300] + 100 >> 2]);
    break block;
   }
   $1 = jsvNewWithFlags(HEAP32[$0 + 8 >> 2] + 29 & 65535);
   HEAP32[HEAP32[61300] + 76 >> 2] = $1;
   HEAP32[$0 >> 2] = 0;
   while (1) {
    if (HEAPU32[$0 >> 2] < HEAPU32[$0 + 8 >> 2]) {
     jslGetNextCh();
     HEAP8[HEAP32[HEAP32[61300] + 76 >> 2] + HEAP32[$0 >> 2] | 0] = HEAPU8[HEAP32[61300]];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     continue;
    }
    break;
   };
  }
  jslGetNextCh();
  __stack_pointer = $0 + 16 | 0;
 }
 
 function isAlphaInline($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  block : {
   if (HEAP8[$1 + 15 | 0] << 24 >> 24 >= 97) {
    $0 = 1;
    if (HEAP8[$1 + 15 | 0] << 24 >> 24 <= 122) {
     break block
    }
   }
   if (HEAP8[$1 + 15 | 0] << 24 >> 24 >= 65) {
    $0 = 1;
    if (HEAP8[$1 + 15 | 0] << 24 >> 24 <= 90) {
     break block
    }
   }
   $0 = HEAPU8[$1 + 15 | 0] == 95;
  }
  return $0;
 }
 
 function isNumericInline($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  $2 = HEAP8[$1 + 15 | 0] << 24 >> 24 >= 48 ? HEAP8[$1 + 15 | 0] << 24 >> 24 <= 57 : $2;
  return $2;
 }
 
 function jslTokenAppendChar($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  if (HEAPU8[HEAP32[61300] + 80 | 0] < 63) {
   $2 = HEAPU8[$1 + 15 | 0];
   $0 = HEAP32[61300];
   $1 = HEAPU8[$0 + 80 | 0];
   HEAP8[$0 + 80 | 0] = $1 + 1;
   HEAP8[($0 + 12 | 0) + $1 | 0] = $2;
  }
 }
 
 function jslCheckToken($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP16[$2 + 6 >> 1] = $1;
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] - 1;
  HEAP32[$2 >> 2] = 1;
  block : {
   while (1) {
    if (HEAP32[$2 >> 2] < HEAPU8[HEAP32[61300] + 80 | 0]) {
     if (HEAPU8[HEAP32[$2 >> 2] + (HEAP32[61300] + 12 | 0) | 0] != HEAPU8[HEAP32[$2 + 8 >> 2] + HEAP32[$2 >> 2] | 0]) {
      HEAP8[$2 + 15 | 0] = 0;
      break block;
     } else {
      HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
      continue;
     }
    }
    break;
   };
   if (!HEAPU8[HEAP32[$2 + 8 >> 2] + HEAPU8[HEAP32[61300] + 80 | 0] | 0]) {
    HEAP16[HEAP32[61300] + 2 >> 1] = HEAPU16[$2 + 6 >> 1];
    HEAP8[$2 + 15 | 0] = 1;
    break block;
   }
   HEAP8[$2 + 15 | 0] = 0;
  }
  return HEAP8[$2 + 15 | 0] & 1;
 }
 
 function jslLexString() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 112 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 111 | 0] = HEAPU8[HEAP32[61300]];
  HEAP32[$0 + 80 >> 2] = 0;
  block : {
   if ((HEAP32[103315] & 63) == 1) {
    $1 = jsvNewFromEmptyString();
    HEAP32[HEAP32[61300] + 76 >> 2] = $1;
    if (!HEAP32[HEAP32[61300] + 76 >> 2]) {
     HEAP16[HEAP32[61300] + 2 >> 1] = 0;
     break block;
    }
    jsvStringIteratorNew($0 + 68 | 0, HEAP32[HEAP32[61300] + 76 >> 2], 0);
   }
   jslGetNextCh();
   HEAP8[$0 + 67 | 0] = HEAPU8[$0 + 111 | 0];
   HEAP32[$0 + 60 >> 2] = 0;
   HEAP8[$0 + 59 | 0] = 0;
   HEAP8[$0 + 58 | 0] = 0;
   HEAP32[$0 + 52 >> 2] = 0;
   HEAP8[HEAP32[61300] + 82 | 0] = 0;
   while (1) {
    $1 = 0;
    if (HEAP8[HEAP32[61300]] << 24 >> 24) {
     $1 = 1;
     $1 = HEAPU8[HEAP32[61300]] == HEAPU8[$0 + 111 | 0] ? HEAP32[$0 + 60 >> 2] != 0 : $1;
    }
    block1 : {
     if (!($1 & 1)) {
      break block1
     }
     if (HEAPU8[$0 + 111 | 0] == 96) {
      block3 : {
       if (!(!HEAP32[$0 + 60 >> 2] & HEAPU8[$0 + 67 | 0] != 36 | HEAPU8[HEAP32[61300]] != 123)) {
        HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 60 >> 2] + 1;
        HEAP8[$0 + 59 | 0] = 1;
        break block3;
       }
       if (!(!HEAP32[$0 + 60 >> 2] | HEAPU8[HEAP32[61300]] != 125)) {
        HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 60 >> 2] - 1
       }
      }
     }
     block26 : {
      if (!(HEAP32[$0 + 60 >> 2] | HEAPU8[HEAP32[61300]] != 92)) {
       jslGetNextCh();
       HEAP8[$0 + 51 | 0] = HEAPU8[HEAP32[61300]];
       block14 : {
        block7 : {
         switch (HEAP8[HEAP32[61300]] - 98 | 0) {
         case 12:
          HEAP8[$0 + 51 | 0] = 10;
          jslGetNextCh();
          break block14;
         case 0:
          HEAP8[$0 + 51 | 0] = 8;
          jslGetNextCh();
          break block14;
         case 4:
          HEAP8[$0 + 51 | 0] = 12;
          jslGetNextCh();
          break block14;
         case 16:
          HEAP8[$0 + 51 | 0] = 13;
          jslGetNextCh();
          break block14;
         case 18:
          HEAP8[$0 + 51 | 0] = 9;
          jslGetNextCh();
          break block14;
         case 20:
          HEAP8[$0 + 51 | 0] = 11;
          jslGetNextCh();
          break block14;
         case 19:
         case 22:
          HEAP8[$0 + 45 | 0] = HEAPU8[HEAP32[61300]] == 117;
          jslGetNextCh();
          HEAP32[$0 + 40 >> 2] = HEAP8[$0 + 45 | 0] & 1 ? 4 : 2;
          HEAP32[$0 + 36 >> 2] = 0;
          while (1) {
           block15 : {
            $1 = HEAP32[$0 + 40 >> 2];
            HEAP32[$0 + 40 >> 2] = $1 - 1;
            if (!$1) {
             break block15
            }
            block16 : {
             if (HEAPU8[HEAP32[61300]]) {
              if (isHexadecimal(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
               break block16
              }
             }
             jsExceptionHere(1, 18273, 0);
             break block15;
            }
            $2 = HEAPU8[HEAP32[61300]];
            $1 = HEAP32[$0 + 36 >> 2];
            HEAP32[$0 + 36 >> 2] = $1 + 1;
            HEAP8[($0 + 46 | 0) + $1 | 0] = $2;
            jslGetNextCh();
            continue;
           }
           break;
          };
          HEAP8[HEAP32[$0 + 36 >> 2] + ($0 + 46 | 0) | 0] = 0;
          $1 = stringToIntWithRadix($0 + 46 | 0, 16, 0, 0);
          HEAP32[$0 + 32 >> 2] = $1;
          if (HEAP8[$0 + 45 | 0] & 1) {
           block18 : {
            if (HEAP32[$0 + 52 >> 2]) {
             block17 : {
              if (!(jsUnicodeIsLowSurrogate(HEAP32[$0 + 32 >> 2]) & 1)) {
               jsExceptionHere(1, 17619, 0);
               if (jsUnicodeIsHighSurrogate(HEAP32[$0 + 32 >> 2]) & 1) {
                HEAP32[$0 + 52 >> 2] = HEAP32[$0 + 32 >> 2];
                continue;
               }
               break block17;
              }
              HEAP32[$0 + 32 >> 2] = (HEAP32[$0 + 32 >> 2] & 1023 | (HEAP32[$0 + 52 >> 2] & 1023) << 10) + 65536;
             }
             HEAP32[$0 + 52 >> 2] = 0;
             break block18;
            }
            if (jsUnicodeIsHighSurrogate(HEAP32[$0 + 32 >> 2]) & 1) {
             HEAP32[$0 + 52 >> 2] = HEAP32[$0 + 32 >> 2];
             continue;
            }
            if (jsUnicodeIsLowSurrogate(HEAP32[$0 + 32 >> 2]) & 1) {
             jsExceptionHere(1, 17619, 0)
            }
           }
          }
          block21 : {
           if (HEAP8[$0 + 45 | 0] & 1 | HEAP8[HEAP32[61300] + 82 | 0] & 1) {
            HEAP32[$0 + 40 >> 2] = jsUTF8Encode(HEAP32[$0 + 32 >> 2], $0 + 46 | 0);
            if (jsUTF8IsStartChar(HEAP8[$0 + 46 | 0] << 24 >> 24) & 1) {
             if (!(!(HEAP8[$0 + 58 | 0] & 1) | HEAP8[HEAP32[61300] + 82 | 0] & 1)) {
              jslConvertTokenValueUTF8($0 + 68 | 0)
             }
             HEAP8[HEAP32[61300] + 82 | 0] = 1;
            }
            HEAP8[$0 + 51 | 0] = HEAPU8[(HEAP32[$0 + 40 >> 2] + $0 | 0) + 45 | 0];
            if (HEAPU32[$0 + 40 >> 2] > 1) {
             HEAP32[$0 + 36 >> 2] = 0;
             while (1) {
              if (HEAPU32[$0 + 36 >> 2] < HEAP32[$0 + 40 >> 2] - 1 >>> 0) {
               $1 = HEAP32[$0 + 36 >> 2];
               HEAP32[$0 + 36 >> 2] = $1 + 1;
               HEAP8[$0 + 31 | 0] = HEAPU8[($0 + 46 | 0) + $1 | 0];
               jsvStringIteratorAppend($0 + 68 | 0, HEAP8[$0 + 31 | 0] << 24 >> 24);
               continue;
              }
              break;
             };
            }
            break block21;
           }
           HEAP8[$0 + 58 | 0] = jsUTF8IsStartChar(HEAP32[$0 + 32 >> 2] << 24 >> 24) & 1 | HEAP8[$0 + 58 | 0] & 1;
           HEAP8[$0 + 51 | 0] = HEAP32[$0 + 32 >> 2];
          }
          break block14;
         default:
          break block7;
         };
        }
        block25 : {
         if (!(HEAP8[HEAP32[61300]] << 24 >> 24 < 48 | HEAP8[HEAP32[61300]] << 24 >> 24 > 55)) {
          HEAP8[$0 + 28 | 0] = HEAPU8[147148];
          HEAP32[$0 + 24 >> 2] = HEAPU8[147144] | HEAPU8[147145] << 8 | (HEAPU8[147146] << 16 | HEAPU8[147147] << 24);
          HEAP8[$0 + 25 | 0] = HEAPU8[HEAP32[61300]];
          HEAP32[$0 + 20 >> 2] = 2;
          jslGetNextCh();
          if (!(HEAP8[HEAP32[61300]] << 24 >> 24 < 48 | HEAP8[HEAP32[61300]] << 24 >> 24 > 55)) {
           $2 = HEAPU8[HEAP32[61300]];
           $1 = HEAP32[$0 + 20 >> 2];
           HEAP32[$0 + 20 >> 2] = $1 + 1;
           HEAP8[($0 + 24 | 0) + $1 | 0] = $2;
           jslGetNextCh();
           if (!(HEAP8[HEAP32[61300]] << 24 >> 24 < 48 | HEAP8[HEAP32[61300]] << 24 >> 24 > 55)) {
            $2 = HEAPU8[HEAP32[61300]];
            $1 = HEAP32[$0 + 20 >> 2];
            HEAP32[$0 + 20 >> 2] = $1 + 1;
            HEAP8[($0 + 24 | 0) + $1 | 0] = $2;
            jslGetNextCh();
           }
          }
          HEAP8[HEAP32[$0 + 20 >> 2] + ($0 + 24 | 0) | 0] = 0;
          $1 = stringToInt($0 + 24 | 0);
          HEAP8[$0 + 51 | 0] = $1;
          break block25;
         }
         jslGetNextCh();
        }
       }
       HEAP8[$0 + 67 | 0] = HEAPU8[$0 + 51 | 0];
       jsvStringIteratorAppend($0 + 68 | 0, HEAP8[$0 + 51 | 0] << 24 >> 24);
       break block26;
      }
      if (!(HEAPU8[$0 + 111 | 0] == 96 | HEAPU8[HEAP32[61300]] != 10)) {
       break block1
      }
      block30 : {
       if (jsUTF8IsStartChar(HEAP8[HEAP32[61300]] << 24 >> 24) & 1) {
        HEAP8[$0 + 16 | 0] = HEAPU8[HEAP32[61300]];
        HEAP8[$0 + 15 | 0] = 1;
        HEAP32[$0 + 8 >> 2] = jsUTF8LengthFromChar(HEAP8[HEAP32[61300]] << 24 >> 24);
        HEAP32[$0 + 4 >> 2] = 1;
        while (1) {
         if (HEAPU32[$0 + 4 >> 2] < HEAPU32[$0 + 8 >> 2]) {
          jslGetNextCh();
          HEAP8[HEAP32[$0 + 4 >> 2] + ($0 + 16 | 0) | 0] = HEAPU8[HEAP32[61300]];
          if ((HEAP8[HEAP32[61300]] << 24 >> 24 & 192) != 128) {
           HEAP8[$0 + 15 | 0] = 0;
           HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
          } else {
           HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
           continue;
          }
         }
         break;
        };
        block29 : {
         if (HEAP8[$0 + 15 | 0] & 1) {
          if (!(!(HEAP8[$0 + 58 | 0] & 1) | HEAP8[HEAP32[61300] + 82 | 0] & 1)) {
           jslConvertTokenValueUTF8($0 + 68 | 0)
          }
          HEAP8[HEAP32[61300] + 82 | 0] = 1;
          break block29;
         }
         HEAP8[$0 + 58 | 0] = 1;
        }
        HEAP32[$0 >> 2] = 0;
        while (1) {
         if (HEAPU32[$0 >> 2] < HEAP32[$0 + 8 >> 2] - 1 >>> 0) {
          jsvStringIteratorAppend($0 + 68 | 0, HEAP8[HEAP32[$0 >> 2] + ($0 + 16 | 0) | 0] << 24 >> 24);
          HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
          continue;
         }
         break;
        };
        break block30;
       }
       jsvStringIteratorAppend($0 + 68 | 0, HEAP8[HEAP32[61300]] << 24 >> 24);
       HEAP8[$0 + 67 | 0] = HEAPU8[HEAP32[61300]];
       jslGetNextCh();
      }
     }
     if (HEAP32[$0 + 52 >> 2]) {
      jsExceptionHere(1, 17619, 0);
      HEAP32[$0 + 52 >> 2] = 0;
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree($0 + 68 | 0);
   block32 : {
    if (!(!(HEAP8[$0 + 59 | 0] & 1) | HEAPU8[$0 + 111 | 0] != 96)) {
     HEAP16[HEAP32[61300] + 2 >> 1] = 133;
     break block32;
    }
    HEAP16[HEAP32[61300] + 2 >> 1] = 131;
   }
   if (HEAPU8[HEAP32[61300]] != HEAPU8[$0 + 111 | 0]) {
    HEAP16[HEAP32[61300] + 2 >> 1] = HEAPU8[$0 + 111 | 0] == 96 ? 134 : 132
   }
   jslGetNextCh();
  }
  __stack_pointer = $0 + 112 | 0;
 }
 
 function jslLexRegex() {
  var $0 = 0, $1 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 20 >> 2] = 0;
  block : {
   if ((HEAP32[103315] & 63) == 1) {
    $0 = jsvNewFromEmptyString();
    HEAP32[HEAP32[61300] + 76 >> 2] = $0;
    if (!HEAP32[HEAP32[61300] + 76 >> 2]) {
     HEAP16[HEAP32[61300] + 2 >> 1] = 0;
     break block;
    }
    jsvStringIteratorNew($1 + 8 | 0, HEAP32[HEAP32[61300] + 76 >> 2], 0);
    jsvStringIteratorAppend($1 + 8 | 0, 47);
   }
   jslGetNextCh();
   while (1) {
    $0 = 0;
    block1 : {
     $0 = HEAP8[HEAP32[61300]] << 24 >> 24 ? HEAPU8[HEAP32[61300]] != 47 : $0;
     if (!$0) {
      break block1
     }
     block2 : {
      if (HEAPU8[HEAP32[61300]] == 92) {
       jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[61300]] << 24 >> 24);
       jslGetNextCh();
       break block2;
      }
      if (HEAPU8[HEAP32[61300]] == 10) {
       break block1
      }
     }
     jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[61300]] << 24 >> 24);
     jslGetNextCh();
     continue;
    }
    break;
   };
   HEAP16[HEAP32[61300] + 2 >> 1] = 135;
   block3 : {
    if (HEAPU8[HEAP32[61300]] != 47) {
     $0 = HEAP32[61300];
     HEAP16[$0 + 2 >> 1] = HEAPU16[$0 + 2 >> 1] + 1;
     break block3;
    }
    jsvStringIteratorAppend($1 + 8 | 0, 47);
    jslGetNextCh();
    while (1) {
     $0 = 1;
     block4 : {
      if (HEAPU8[HEAP32[61300]] == 103) {
       break block4
      }
      $0 = 1;
      if (HEAPU8[HEAP32[61300]] == 105) {
       break block4
      }
      $0 = 1;
      if (HEAPU8[HEAP32[61300]] == 109) {
       break block4
      }
      $0 = 1;
      if (HEAPU8[HEAP32[61300]] == 121) {
       break block4
      }
      $0 = HEAPU8[HEAP32[61300]] == 117;
     }
     if ($0) {
      jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[61300]] << 24 >> 24);
      jslGetNextCh();
      continue;
     }
     break;
    };
   }
   jsvStringIteratorFree($1 + 8 | 0);
  }
  __stack_pointer = $1 + 48 | 0;
 }
 
 function jslInit($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
  HEAP32[HEAP32[61300] + 84 >> 2] = $0;
  HEAP16[HEAP32[61300] + 2 >> 1] = 0;
  HEAP32[HEAP32[61300] + 4 >> 2] = 0;
  HEAP32[HEAP32[61300] + 8 >> 2] = 0;
  HEAP8[HEAP32[61300] + 80 | 0] = 0;
  HEAP32[HEAP32[61300] + 76 >> 2] = 0;
  HEAP32[HEAP32[61300] + 128 >> 2] = 0;
  HEAP32[HEAP32[61300] + 132 >> 2] = 0;
  jsvStringIteratorNew(HEAP32[61300] + 88 | 0, HEAP32[HEAP32[61300] + 84 >> 2], 0);
  jsvUnLock(HEAP32[HEAP32[61300] + 100 >> 2]);
  jslPreload();
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jslPreload() {
  jslGetNextCh();
  jslGetNextToken();
 }
 
 function jslKill() {
  HEAP16[HEAP32[61300] + 2 >> 1] = 0;
  if (HEAP32[HEAP32[61300] + 100 >> 2]) {
   jsvLockAgain(HEAP32[HEAP32[61300] + 100 >> 2])
  }
  jsvStringIteratorFree(HEAP32[61300] + 88 | 0);
  if (HEAP32[HEAP32[61300] + 76 >> 2]) {
   jsvUnLock(HEAP32[HEAP32[61300] + 76 >> 2]);
   HEAP32[HEAP32[61300] + 76 >> 2] = 0;
  }
  jsvUnLock(HEAP32[HEAP32[61300] + 84 >> 2]);
 }
 
 function jslSeekToP($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[HEAP32[61300] + 100 >> 2]) {
   jsvLockAgain(HEAP32[HEAP32[61300] + 100 >> 2])
  }
  jsvStringIteratorFree(HEAP32[61300] + 88 | 0);
  jsvStringIteratorClone(HEAP32[61300] + 88 | 0, HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[HEAP32[61300] + 100 >> 2]);
  HEAP8[HEAP32[61300]] = HEAPU8[HEAP32[$1 + 12 >> 2] + 40 | 0];
  HEAP32[HEAP32[61300] + 4 >> 2] = 0;
  HEAP32[HEAP32[61300] + 8 >> 2] = 0;
  HEAP16[HEAP32[61300] + 2 >> 1] = 0;
  jslGetNextToken();
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jslFunctionCharAsString($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 15 | 0] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block : {
   if (HEAPU8[$3 + 15 | 0] >= 128) {
    jslTokenAsString(HEAPU8[$3 + 15 | 0], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
    break block;
   }
   HEAP8[HEAP32[$3 + 8 >> 2]] = HEAPU8[$3 + 15 | 0];
   HEAP8[HEAP32[$3 + 8 >> 2] + 1 | 0] = 0;
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jslTokenAsString($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block1 : {
   if (!(HEAP32[$3 + 12 >> 2] <= 32 | HEAP32[$3 + 12 >> 2] >= 128)) {
    HEAP8[HEAP32[$3 + 8 >> 2]] = 39;
    HEAP8[HEAP32[$3 + 8 >> 2] + 1 | 0] = HEAP32[$3 + 12 >> 2];
    HEAP8[HEAP32[$3 + 8 >> 2] + 2 | 0] = 39;
    HEAP8[HEAP32[$3 + 8 >> 2] + 3 | 0] = 0;
    break block1;
   }
   block13 : {
    block12 : {
     block11 : {
      block10 : {
       block9 : {
        block8 : {
         block7 : {
          block6 : {
           block5 : {
            block4 : {
             block3 : {
              block2 : {
               $0 = HEAP32[$3 + 12 >> 2];
               if ($0) {
                if (($0 | 0) == 128) {
                 break block2
                }
                if (($0 | 0) == 129) {
                 break block3
                }
                if (($0 | 0) == 130) {
                 break block4
                }
                if (($0 | 0) == 131) {
                 break block5
                }
                if (($0 | 0) == 132) {
                 break block6
                }
                if (($0 | 0) == 133) {
                 break block7
                }
                if (($0 | 0) == 134) {
                 break block8
                }
                if (($0 | 0) == 135) {
                 break block9
                }
                if (($0 | 0) == 136) {
                 break block10
                }
                if (($0 | 0) == 137) {
                 break block11
                }
                if (($0 | 0) == 255) {
                 break block12
                }
                break block13;
               }
               strcpy(HEAP32[$3 + 8 >> 2], 21513);
               break block1;
              }
              strcpy(HEAP32[$3 + 8 >> 2], 21571);
              break block1;
             }
             strcpy(HEAP32[$3 + 8 >> 2], 21013);
             break block1;
            }
            strcpy(HEAP32[$3 + 8 >> 2], 21120);
            break block1;
           }
           strcpy(HEAP32[$3 + 8 >> 2], 21498);
           break block1;
          }
          strcpy(HEAP32[$3 + 8 >> 2], 21487);
          break block1;
         }
         strcpy(HEAP32[$3 + 8 >> 2], 21327);
         break block1;
        }
        strcpy(HEAP32[$3 + 8 >> 2], 21316);
        break block1;
       }
       strcpy(HEAP32[$3 + 8 >> 2], 20954);
       break block1;
      }
      strcpy(HEAP32[$3 + 8 >> 2], 20943);
      break block1;
     }
     strcpy(HEAP32[$3 + 8 >> 2], 21017);
     break block1;
    }
    strcpy(HEAP32[$3 + 8 >> 2], 20741);
    break block1;
   }
   if (!(HEAP32[$3 + 12 >> 2] < 138 | HEAP32[$3 + 12 >> 2] > 208)) {
    strcpy(HEAP32[$3 + 8 >> 2], jslReservedWordAsString(HEAP32[$3 + 12 >> 2]));
    break block1;
   }
   $0 = HEAP32[$3 + 8 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   HEAP32[$3 >> 2] = HEAP32[$3 + 12 >> 2];
   espruino_snprintf($0, $1, 20718, $3);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jslReservedWordAsString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 12 >> 2] - 138;
  while (1) {
   $0 = 0;
   $0 = HEAP32[$1 + 4 >> 2] > 0 ? HEAPU32[$1 + 8 >> 2] < 312 : $0;
   if ($0) {
    while (1) {
     $0 = 0;
     $0 = HEAP8[HEAP32[$1 + 8 >> 2] + 146832 | 0] << 24 >> 24 ? HEAPU32[$1 + 8 >> 2] < 312 : $0;
     if ($0) {
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - 1;
    continue;
   }
   break;
  };
  return HEAP32[$1 + 8 >> 2] + 146832 | 0;
 }
 
 function jslGetTokenString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 128) {
    $0 = HEAP32[$2 + 28 >> 2];
    $1 = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 >> 2] = jslGetTokenValueAsString();
    espruino_snprintf($0, $1, 7569, $2);
    break block;
   }
   block1 : {
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 131) {
     $0 = HEAP32[$2 + 28 >> 2];
     $1 = HEAP32[$2 + 24 >> 2];
     HEAP32[$2 + 16 >> 2] = jslGetTokenValueAsString();
     espruino_snprintf($0, $1, 27092, $2 + 16 | 0);
     break block1;
    }
    jslTokenAsString(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16, HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
   }
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jslGetTokenValueAsString() {
  var $0 = 0;
  if (!(HEAPU8[HEAP32[61300] + 80 | 0] | !HEAP32[HEAP32[61300] + 76 >> 2])) {
   $0 = jsvGetString(HEAP32[HEAP32[61300] + 76 >> 2], HEAP32[61300] + 12 | 0, 64);
   HEAP8[HEAP32[61300] + 80 | 0] = $0;
  }
  HEAP8[HEAPU8[HEAP32[61300] + 80 | 0] + (HEAP32[61300] + 12 | 0) | 0] = 0;
  if (!(HEAPU8[HEAP32[61300] + 80 | 0] | HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 < 163 | HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 > 198)) {
   jslTokenAsString(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16, HEAP32[61300] + 12 | 0, 64);
   strcpy(HEAP32[61300] + 12 | 0, jslReservedWordAsString(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16));
   $0 = strlen(HEAP32[61300] + 12 | 0);
   HEAP8[HEAP32[61300] + 80 | 0] = $0;
  }
  return HEAP32[61300] + 12 | 0;
 }
 
 function jslGetTokenLength() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (HEAP32[HEAP32[61300] + 76 >> 2]) {
    HEAP32[$0 + 12 >> 2] = jsvGetStringLength(HEAP32[HEAP32[61300] + 76 >> 2]);
    break block;
   }
   HEAP32[$0 + 12 >> 2] = HEAPU8[HEAP32[61300] + 80 | 0];
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jslGetTokenValueAsVar() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (HEAP32[HEAP32[61300] + 76 >> 2]) {
    HEAP32[$0 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[61300] + 76 >> 2]);
    break block;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 129) {
    HEAP32[$0 + 12 >> 2] = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString()), i64toi32_i32$HIGH_BITS);
    break block;
   }
   if (!(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 < 163 | HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 > 198)) {
    HEAP32[$0 + 12 >> 2] = jsvNewFromString(jslReservedWordAsString(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16));
    break block;
   }
   HEAP8[HEAPU8[HEAP32[61300] + 80 | 0] + (HEAP32[61300] + 12 | 0) | 0] = 0;
   HEAP32[$0 + 12 >> 2] = jsvNewFromString(HEAP32[61300] + 12 | 0);
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jslIsIDOrReservedWord() {
  var $0 = 0, $1 = 0;
  $0 = 1;
  if (HEAPU16[HEAP32[61300] + 2 >> 1] != 128) {
   $1 = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 >= 163 ? HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 <= 198 : $1;
   $0 = $1;
  }
  return $0 & 1;
 }
 
 function jslMatch($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (HEAP32[$1 + 8 >> 2] != HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16) {
    jslMatchError(HEAP32[$1 + 8 >> 2]);
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   jslGetNextToken();
   HEAP8[$1 + 15 | 0] = 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jslMatchError($0) {
  var $1 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 92 >> 2] = $0;
  jslGetTokenString($1 + 48 | 0, 30);
  jslTokenAsString(HEAP32[$1 + 92 >> 2], $1 + 16 | 0, 30);
  HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[61300] + 8 >> 2];
  HEAP32[HEAP32[61300] + 8 >> 2] = HEAP32[HEAP32[61300] + 4 >> 2];
  HEAP32[$1 + 4 >> 2] = $1 + 16;
  HEAP32[$1 >> 2] = $1 + 48;
  jsExceptionHere(2, 7644, $1);
  HEAP32[HEAP32[61300] + 8 >> 2] = HEAP32[$1 + 12 >> 2];
  jslGetNextToken();
  __stack_pointer = $1 + 96 | 0;
 }
 
 function jslNewTokenisedStringFromLexer($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 208 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 204 >> 2] = $0;
  HEAP32[$2 + 200 >> 2] = $1;
  HEAP32[$2 + 196 >> 2] = HEAP32[61300];
  HEAP32[61300] = $2 + 60;
  jslInit(HEAP32[HEAP32[$2 + 196 >> 2] + 84 >> 2]);
  HEAP32[$2 + 56 >> 2] = _jslNewTokenisedStringFromLexer(0, 0, HEAP32[$2 + 204 >> 2], HEAP32[$2 + 200 >> 2]);
  HEAP32[$2 + 52 >> 2] = jsvNewStringOfLength(HEAP32[$2 + 56 >> 2], 0);
  if (HEAP32[$2 + 52 >> 2]) {
   jsvStringIteratorNew($2 + 12 | 0, HEAP32[$2 + 52 >> 2], 0);
   _jslNewTokenisedStringFromLexer($2 + 12 | 0, HEAP32[$2 + 52 >> 2], HEAP32[$2 + 204 >> 2], HEAP32[$2 + 200 >> 2]);
   jsvStringIteratorFree($2 + 12 | 0);
  }
  jslKill();
  HEAP32[61300] = HEAP32[$2 + 196 >> 2];
  __stack_pointer = $2 + 208 | 0;
  return HEAP32[$2 + 52 >> 2];
 }
 
 function _jslNewTokenisedStringFromLexer($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 144 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 140 >> 2] = $0;
  HEAP32[$4 + 136 >> 2] = $1;
  HEAP32[$4 + 132 >> 2] = $2;
  HEAP32[$4 + 128 >> 2] = $3;
  jslSeekToP(HEAP32[$4 + 132 >> 2]);
  HEAP8[$4 + 87 | 0] = HEAPU8[HEAP32[$4 + 132 >> 2] + 40 | 0];
  if (HEAP32[$4 + 140 >> 2]) {
   jsvStringIteratorClone($4 + 88 | 0, HEAP32[$4 + 132 >> 2])
  }
  HEAP32[$4 + 80 >> 2] = 0;
  HEAP32[$4 + 76 >> 2] = 0;
  HEAP32[$4 + 72 >> 2] = 0;
  while (1) {
   $0 = 0;
   if (HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16) {
    $0 = jsvStringIteratorGetIndex(HEAP32[61300] + 88 | 0) >>> 0 <= HEAP32[$4 + 128 >> 2] + 1 >>> 0
   }
   if ($0) {
    if (jslPreserveSpaceBetweenTokens(HEAP32[$4 + 76 >> 2], HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16) & 1) {
     HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + 1;
     if (HEAP32[$4 + 140 >> 2]) {
      jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], 32)
     }
    }
    block2 : {
     block : {
      if (HEAPU16[HEAP32[61300] + 2 >> 1] != 131) {
       break block
      }
      $0 = jslGetTokenLength();
      HEAP32[$4 + 68 >> 2] = $0;
      if (!$0 | HEAP8[HEAP32[61300] + 82 | 0] & 1) {
       break block
      }
      HEAP32[$4 + 64 >> 2] = 0;
      jslSkipWhiteSpace();
      if (!(HEAP32[$4 + 72 >> 2] != 2 | HEAPU8[HEAP32[61300]] != 41)) {
       HEAP32[$4 + 60 >> 2] = jslGetTokenValueAsVar();
       HEAP32[$4 + 64 >> 2] = jswrap_atob(HEAP32[$4 + 60 >> 2]);
       jsvUnLock(HEAP32[$4 + 60 >> 2]);
       HEAP32[$4 + 68 >> 2] = jsvGetStringLength(HEAP32[$4 + 64 >> 2]);
       HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] - 5;
       if (HEAP32[$4 + 140 >> 2]) {
        jsvStringIteratorGoto(HEAP32[$4 + 140 >> 2], HEAP32[$4 + 136 >> 2], HEAP32[$4 + 80 >> 2])
       }
       HEAP8[$4 + 87 | 0] = HEAPU8[HEAP32[61300]];
       jslGetNextToken();
      }
      HEAP32[$4 + 72 >> 2] = 0;
      if (HEAP32[$4 + 140 >> 2]) {
       jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], HEAPU32[$4 + 68 >> 2] < 256 ? -47 : -46);
       jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], (HEAP32[$4 + 68 >> 2] & 255) << 24 >> 24);
       if (HEAPU32[$4 + 68 >> 2] >= 256) {
        jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], HEAP32[$4 + 68 >> 2] >>> 8 << 24 >> 24)
       }
       if (!HEAP32[$4 + 64 >> 2]) {
        HEAP32[$4 + 64 >> 2] = jslGetTokenValueAsVar()
       }
       jsvStringIteratorNew($4 + 20 | 0, HEAP32[$4 + 64 >> 2], 0);
       while (1) {
        if (jsvStringIteratorHasChar($4 + 20 | 0) & 1) {
         jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], jsvStringIteratorGetCharAndNext($4 + 20 | 0) << 24 >> 24);
         continue;
        }
        break;
       };
       jsvStringIteratorFree($4 + 20 | 0);
      }
      jsvUnLock(HEAP32[$4 + 64 >> 2]);
      HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + (HEAP32[$4 + 68 >> 2] + (HEAPU32[$4 + 68 >> 2] < 256 ? 2 : 3) | 0);
      break block2;
     }
     block8 : {
      if (HEAPU16[HEAP32[61300] + 2 >> 1] == 129) {
       $0 = jsvGetLongIntegerAndUnLock(jslGetTokenValueAsVar());
       HEAP32[$4 + 8 >> 2] = $0;
       $1 = i64toi32_i32$HIGH_BITS;
       HEAP32[$4 + 12 >> 2] = $1;
       $1 = HEAP32[$4 + 8 >> 2];
       $0 = HEAP32[$4 + 12 >> 2];
       block3 : {
        if (!($0 | $1)) {
         HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + 1;
         if (HEAP32[$4 + 140 >> 2]) {
          jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], -45)
         }
         break block3;
        }
        $0 = HEAP32[$4 + 8 >> 2];
        block5 : {
         block4 : {
          $1 = HEAP32[$4 + 12 >> 2];
          if (($1 | 0) < -1) {
           $0 = 1
          } else {
           $0 = ($1 | 0) < 0 & $0 >>> 0 < 4294967168
          }
          if ($0) {
           break block4
          }
          $0 = HEAP32[$4 + 8 >> 2];
          $2 = $0;
          $1 = HEAP32[$4 + 12 >> 2];
          if (($1 | 0) > 0) {
           $0 = 1
          } else {
           $0 = ($1 | 0) >= 0 & $2 >>> 0 >= 128
          }
          if ($0) {
           break block4
          }
          HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + 2;
          if (HEAP32[$4 + 140 >> 2]) {
           jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], -44);
           $2 = HEAP32[$4 + 8 >> 2];
           jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], $2 << 24 >> 24);
          }
          break block5;
         }
         $1 = HEAP32[$4 + 8 >> 2];
         $0 = $1;
         block7 : {
          block6 : {
           $2 = HEAP32[$4 + 12 >> 2];
           if (($2 | 0) < -1) {
            $0 = 1
           } else {
            $0 = ($2 | 0) < 0 & $0 >>> 0 < 4294934528
           }
           if ($0) {
            break block6
           }
           $0 = HEAP32[$4 + 8 >> 2];
           $2 = HEAP32[$4 + 12 >> 2];
           if (($2 | 0) > 0) {
            $0 = 1
           } else {
            $0 = ($2 | 0) >= 0 & $0 >>> 0 >= 32768
           }
           if ($0) {
            break block6
           }
           HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + 3;
           if (HEAP32[$4 + 140 >> 2]) {
            jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], -43);
            $0 = HEAP32[$4 + 8 >> 2];
            $1 = $0;
            jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], ($1 & 255) << 24 >> 24);
            $0 = HEAP32[$4 + 8 >> 2];
            $2 = $0;
            $1 = HEAP32[$4 + 12 >> 2];
            jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], (($1 & 255) << 24 | $2 >>> 8) << 24 >> 24);
           }
           break block7;
          }
          _jslNewTokenisedStringFromLexerCopyString($4 + 80 | 0, HEAP32[$4 + 140 >> 2], $4 + 88 | 0, HEAP8[$4 + 87 | 0] << 24 >> 24);
         }
        }
       }
       break block8;
      }
      block13 : {
       block10 : {
        block9 : {
         if (HEAPU16[HEAP32[61300] + 2 >> 1] == 128 | HEAPU16[HEAP32[61300] + 2 >> 1] == 129 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 130 | HEAPU16[HEAP32[61300] + 2 >> 1] == 131)) {
          break block9
         }
         if (HEAPU16[HEAP32[61300] + 2 >> 1] == 133) {
          break block9
         }
         if (HEAPU16[HEAP32[61300] + 2 >> 1] != 135) {
          break block10
         }
        }
        block12 : {
         block11 : {
          if (HEAPU16[HEAP32[61300] + 2 >> 1] != 128) {
           break block11
          }
          if (strcmp(jslGetTokenValueAsString(), 20483)) {
           break block11
          }
          HEAP32[$4 + 72 >> 2] = 1;
          break block12;
         }
         HEAP32[$4 + 72 >> 2] = 0;
        }
        _jslNewTokenisedStringFromLexerCopyString($4 + 80 | 0, HEAP32[$4 + 140 >> 2], $4 + 88 | 0, HEAP8[$4 + 87 | 0] << 24 >> 24);
        break block13;
       }
       block15 : {
        if (!(HEAP32[$4 + 72 >> 2] != 1 | HEAPU16[HEAP32[61300] + 2 >> 1] != 40)) {
         HEAP32[$4 + 72 >> 2] = 2;
         break block15;
        }
        HEAP32[$4 + 72 >> 2] = 0;
       }
       if (HEAP32[$4 + 140 >> 2]) {
        jsvStringIteratorSetCharAndNext(HEAP32[$4 + 140 >> 2], HEAPU16[HEAP32[61300] + 2 >> 1] << 24 >> 24)
       }
       HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + 1;
      }
     }
    }
    HEAP32[$4 + 76 >> 2] = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16;
    jslSkipWhiteSpace();
    if (HEAP32[$4 + 140 >> 2]) {
     jsvStringIteratorFree($4 + 88 | 0);
     jsvStringIteratorClone($4 + 88 | 0, HEAP32[61300] + 88 | 0);
    }
    HEAP8[$4 + 87 | 0] = HEAPU8[HEAP32[61300]];
    jslGetNextToken();
    continue;
   }
   break;
  };
  if (HEAP32[$4 + 140 >> 2]) {
   jsvStringIteratorFree($4 + 88 | 0)
  }
  __stack_pointer = $4 + 144 | 0;
  return HEAP32[$4 + 80 >> 2];
 }
 
 function jslPreserveSpaceBetweenTokens($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block3 : {
   if (!(!(HEAP32[$2 + 8 >> 2] == 128 | HEAP32[$2 + 8 >> 2] == 130) & HEAP32[$2 + 8 >> 2] != 129 | !(HEAP32[$2 + 4 >> 2] == 128 | HEAP32[$2 + 4 >> 2] == 130) & HEAP32[$2 + 4 >> 2] != 129)) {
    HEAP8[$2 + 15 | 0] = 1;
    break block3;
   }
   block5 : {
    block4 : {
     if (HEAP32[$2 + 8 >> 2] == 47 & HEAP32[$2 + 4 >> 2] == 135 | (HEAP32[$2 + 8 >> 2] == 45 & HEAP32[$2 + 4 >> 2] == 45 | HEAP32[$2 + 8 >> 2] == 43 & HEAP32[$2 + 4 >> 2] == 43)) {
      break block4
     }
     if (HEAP32[$2 + 8 >> 2] != 135) {
      break block5
     }
     if (HEAP32[$2 + 4 >> 2] == 47) {
      break block4
     }
     if (HEAP32[$2 + 4 >> 2] != 128) {
      break block5
     }
    }
    HEAP8[$2 + 15 | 0] = 1;
    break block3;
   }
   HEAP8[$2 + 15 | 0] = 0;
  }
  return HEAP8[$2 + 15 | 0] & 1;
 }
 
 function jsvStringIteratorHasChar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function _jslNewTokenisedStringFromLexerCopyString($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  $1 = jsvStringIteratorGetIndex(HEAP32[61300] + 88 | 0);
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + ($1 - (HEAP32[HEAP32[61300] + 4 >> 2] + 1 | 0) | 0);
  if (HEAP32[$4 + 8 >> 2]) {
   jsvStringIteratorSetCharAndNext(HEAP32[$4 + 8 >> 2], HEAP8[$4 + 3 | 0] << 24 >> 24);
   while (1) {
    if (jsvStringIteratorGetIndex(HEAP32[$4 + 4 >> 2]) + 1 >>> 0 < jsvStringIteratorGetIndex(HEAP32[61300] + 88 | 0) >>> 0) {
     jsvStringIteratorSetCharAndNext(HEAP32[$4 + 8 >> 2], jsvStringIteratorGetCharAndNext(HEAP32[$4 + 4 >> 2]) << 24 >> 24);
     continue;
    }
    break;
   };
  }
  __stack_pointer = $4 + 16 | 0;
 }
 
 function jslNewStringFromLexer($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 128 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 120 >> 2] = $0;
  HEAP32[$2 + 116 >> 2] = $1;
  HEAP32[$2 + 112 >> 2] = (HEAP32[$2 + 116 >> 2] + 1 | 0) - jsvStringIteratorGetIndex(HEAP32[$2 + 120 >> 2]);
  HEAP32[$2 + 108 >> 2] = 0;
  block : {
   if (HEAPU32[$2 + 112 >> 2] > 19) {
    HEAP32[$2 + 108 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 112 >> 2]);
    if (HEAP32[$2 + 108 >> 2]) {
     HEAP32[$2 + 104 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 108 >> 2]);
     $1 = HEAPU8[HEAP32[$2 + 120 >> 2] + 40 | 0];
     $0 = HEAP32[$2 + 104 >> 2];
     HEAP32[$2 + 104 >> 2] = $0 + 1;
     HEAP8[$0 | 0] = $1;
     jsvStringIteratorClone($2 - -64 | 0, HEAP32[$2 + 120 >> 2]);
     while (1) {
      $0 = 0;
      if (jsvStringIteratorHasChar($2 - -64 | 0) & 1) {
       $0 = HEAP32[$2 + 112 >> 2] - 1 | 0;
       HEAP32[$2 + 112 >> 2] = $0;
       $0 = ($0 | 0) != 0;
      }
      if ($0) {
       $1 = jsvStringIteratorGetCharAndNext($2 - -64 | 0);
       $0 = HEAP32[$2 + 104 >> 2];
       HEAP32[$2 + 104 >> 2] = $0 + 1;
       HEAP8[$0 | 0] = $1;
       continue;
      }
      break;
     };
     jsvStringIteratorFree($2 - -64 | 0);
     HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 108 >> 2];
     break block;
    }
   }
   HEAP32[$2 + 108 >> 2] = jsvNewFromEmptyString();
   if (!HEAP32[$2 + 108 >> 2]) {
    HEAP32[$2 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 60 >> 2] = jsvLockAgain(HEAP32[$2 + 108 >> 2]);
   HEAP8[HEAP32[$2 + 60 >> 2]] = HEAPU8[HEAP32[$2 + 120 >> 2] + 40 | 0];
   HEAP32[$2 + 56 >> 2] = 1;
   jsvStringIteratorClone($2 + 16 | 0, HEAP32[$2 + 120 >> 2]);
   while (1) {
    $0 = 0;
    if (jsvStringIteratorHasChar($2 + 16 | 0) & 1) {
     $0 = HEAP32[$2 + 112 >> 2] - 1 | 0;
     HEAP32[$2 + 112 >> 2] = $0;
     $0 = ($0 | 0) != 0;
    }
    block1 : {
     if (!$0) {
      break block1
     }
     HEAP8[$2 + 15 | 0] = jsvStringIteratorGetCharAndNext($2 + 16 | 0);
     if (HEAPU32[$2 + 56 >> 2] >= jsvGetMaxCharactersInVar(HEAP32[$2 + 60 >> 2]) >>> 0) {
      jsvSetCharactersInVar(HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
      HEAP32[$2 + 8 >> 2] = jsvNewWithFlags(43);
      if (!HEAP32[$2 + 8 >> 2]) {
       break block1
      }
      jsvSetLastChild(HEAP32[$2 + 60 >> 2], jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535);
      jsvUnLock(HEAP32[$2 + 60 >> 2]);
      HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 8 >> 2];
      HEAP32[$2 + 56 >> 2] = 0;
     }
     $1 = HEAPU8[$2 + 15 | 0];
     $3 = HEAP32[$2 + 60 >> 2];
     $0 = HEAP32[$2 + 56 >> 2];
     HEAP32[$2 + 56 >> 2] = $0 + 1;
     HEAP8[$3 + $0 | 0] = $1;
     continue;
    }
    break;
   };
   jsvSetCharactersInVar(HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
   jsvUnLock(HEAP32[$2 + 60 >> 2]);
   jsvStringIteratorFree($2 + 16 | 0);
   HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 108 >> 2];
  }
  __stack_pointer = $2 + 128 | 0;
  return HEAP32[$2 + 124 >> 2];
 }
 
 function jsvNewFromEmptyString() {
  return jsvNewWithFlags(29);
 }
 
 function jslNeedSpaceBetween($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  block1 : {
   if (!(HEAPU8[$2 + 15 | 0] <= 198 & HEAPU8[$2 + 15 | 0] >= 163)) {
    $0 = 0;
    if (HEAPU8[$2 + 14 | 0] < 163) {
     break block1
    }
    $0 = 0;
    if (HEAPU8[$2 + 14 | 0] > 198) {
     break block1
    }
   }
   block2 : {
    if (HEAPU8[$2 + 15 | 0] >= 163) {
     break block2
    }
    if (isAlpha(HEAP8[$2 + 15 | 0] << 24 >> 24) & 1) {
     break block2
    }
    $0 = 0;
    if (!(isNumeric(HEAP8[$2 + 15 | 0] << 24 >> 24) & 1)) {
     break block1
    }
   }
   $0 = 1;
   block3 : {
    if (HEAPU8[$2 + 14 | 0] >= 163) {
     break block3
    }
    $0 = 1;
    if (isAlpha(HEAP8[$2 + 14 | 0] << 24 >> 24) & 1) {
     break block3
    }
    $0 = isNumeric(HEAP8[$2 + 14 | 0] << 24 >> 24);
   }
  }
  __stack_pointer = $2 + 16 | 0;
  return $0 & 1;
 }
 
 function jslPrintTokenisedString($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  HEAP8[$3 + 51 | 0] = 0;
  HEAP32[$3 + 44 >> 2] = 0;
  HEAP32[$3 + 40 >> 2] = 0;
  jsvStringIteratorNew($3, HEAP32[$3 + 60 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar($3) & 1) {
    jslPrintTokenisedChar($3, $3 + 51 | 0, $3 + 44 | 0, $3 + 40 | 0, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 52 >> 2]);
    continue;
   }
   break;
  };
  jsvStringIteratorFree($3);
  __stack_pointer = $3 - -64 | 0;
 }
 
 function jslPrintTokenisedChar($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 128 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 124 >> 2] = $0;
  HEAP32[$6 + 120 >> 2] = $1;
  HEAP32[$6 + 116 >> 2] = $2;
  HEAP32[$6 + 112 >> 2] = $3;
  HEAP32[$6 + 108 >> 2] = $4;
  HEAP32[$6 + 104 >> 2] = $5;
  HEAP8[$6 + 103 | 0] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 124 >> 2]);
  block1 : {
   if (!(HEAPU8[$6 + 103 | 0] != 209 & HEAPU8[$6 + 103 | 0] != 210)) {
    HEAP32[$6 + 28 >> 2] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 124 >> 2]) & 255;
    if (HEAPU8[$6 + 103 | 0] == 210) {
     $0 = HEAP32[$6 + 112 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     HEAP32[$6 + 28 >> 2] = (jsvStringIteratorGetCharAndNext(HEAP32[$6 + 124 >> 2]) & 255) << 8 | HEAP32[$6 + 28 >> 2];
    }
    $0 = HEAP32[$6 + 112 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 2;
    FUNCTION_TABLE[HEAP32[$6 + 108 >> 2]](27316, HEAP32[$6 + 104 >> 2]);
    while (1) {
     $0 = HEAP32[$6 + 28 >> 2];
     HEAP32[$6 + 28 >> 2] = $0 - 1;
     if ($0) {
      HEAP8[$6 + 27 | 0] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 124 >> 2]);
      HEAP32[$6 + 20 >> 2] = escapeCharacter(HEAP8[$6 + 27 | 0] << 24 >> 24, 0, 0);
      $0 = HEAP32[$6 + 112 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      FUNCTION_TABLE[HEAP32[$6 + 108 >> 2]](HEAP32[$6 + 20 >> 2], HEAP32[$6 + 104 >> 2]);
      continue;
     }
     break;
    };
    FUNCTION_TABLE[HEAP32[$6 + 108 >> 2]](27316, HEAP32[$6 + 104 >> 2]);
    break block1;
   }
   if (HEAPU8[$6 + 103 | 0] == 211) {
    $0 = HEAP32[$6 + 112 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    FUNCTION_TABLE[HEAP32[$6 + 108 >> 2]](22560, HEAP32[$6 + 104 >> 2]);
    break block1;
   }
   if (!(HEAPU8[$6 + 103 | 0] != 212 & HEAPU8[$6 + 103 | 0] != 213)) {
    HEAP16[$6 + 18 >> 1] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 124 >> 2]) & 255;
    if (HEAPU8[$6 + 103 | 0] == 213) {
     HEAP16[$6 + 18 >> 1] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 124 >> 2]) << 24 >> 24 << 8 | HEAP16[$6 + 18 >> 1] << 16 >> 16
    }
    itostr(HEAP16[$6 + 18 >> 1] << 16 >> 16, $6 + 32 | 0, 10);
    $1 = strlen($6 + 32 | 0);
    $0 = HEAP32[$6 + 112 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + $1;
    FUNCTION_TABLE[HEAP32[$6 + 108 >> 2]]($6 + 32 | 0, HEAP32[$6 + 104 >> 2]);
    break block1;
   }
   if (jslNeedSpaceBetween(HEAPU8[HEAP32[$6 + 120 >> 2]], HEAPU8[$6 + 103 | 0]) & 1) {
    $0 = HEAP32[$6 + 116 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    FUNCTION_TABLE[HEAP32[$6 + 108 >> 2]](27706, HEAP32[$6 + 104 >> 2]);
   }
   jslFunctionCharAsString(HEAPU8[$6 + 103 | 0], $6 + 32 | 0, 64);
   HEAP32[$6 + 12 >> 2] = strlen($6 + 32 | 0);
   if (HEAP32[$6 + 12 >> 2]) {
    $0 = HEAP32[$6 + 116 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + (HEAP32[$6 + 12 >> 2] - 1 | 0);
   }
   FUNCTION_TABLE[HEAP32[$6 + 108 >> 2]]($6 + 32 | 0, HEAP32[$6 + 104 >> 2]);
   $0 = HEAP32[$6 + 112 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   HEAP8[HEAP32[$6 + 120 >> 2]] = HEAPU8[$6 + 103 | 0];
  }
  __stack_pointer = $6 + 128 | 0;
 }
 
 function itostr($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jslPrintPosition($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  $4 = __stack_pointer - 144 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 140 >> 2] = $0;
  HEAP32[$4 + 136 >> 2] = $1;
  HEAP32[$4 + 132 >> 2] = $2;
  HEAP32[$4 + 128 >> 2] = $3;
  block1 : {
   block : {
    if (!(jsvIsNativeString(HEAP32[HEAP32[$4 + 132 >> 2] + 84 >> 2]) & 1)) {
     if (!(jsvIsFlashString(HEAP32[HEAP32[$4 + 132 >> 2] + 84 >> 2]) & 1)) {
      break block
     }
    }
    $0 = HEAP32[HEAP32[$4 + 132 >> 2] + 84 >> 2];
    HEAP32[$4 + 112 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    HEAP32[$4 + 76 >> 2] = jsfFindFileFromAddr(HEAP32[$4 + 112 >> 2], $4 + 80 | 0);
    if (HEAP32[$4 + 76 >> 2]) {
     HEAP32[$4 + 72 >> 2] = jsvAddressToVar(HEAP32[$4 + 76 >> 2], jsfGetFileSize($4 + 80 | 0));
     jsvGetLineAndCol(HEAP32[$4 + 72 >> 2], (HEAP32[$4 + 128 >> 2] + HEAP32[$4 + 112 >> 2] | 0) - HEAP32[$4 + 76 >> 2] | 0, $4 + 124 | 0, $4 + 120 | 0, $4 + 116 | 0);
     $1 = $4 + 80 | 0;
     HEAP32[$4 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
     $0 = HEAP32[$1 + 20 >> 2];
     $2 = HEAP32[$1 + 24 >> 2];
     HEAP32[$4 + 16 >> 2] = $0;
     HEAP32[$4 + 20 >> 2] = $2;
     $0 = HEAP32[$1 + 16 >> 2];
     $2 = HEAP32[$1 + 12 >> 2];
     HEAP32[$4 + 8 >> 2] = $2;
     HEAP32[$4 + 12 >> 2] = $0;
     $2 = HEAP32[$1 + 8 >> 2];
     $0 = HEAP32[$1 + 4 >> 2];
     HEAP32[$4 >> 2] = $0;
     HEAP32[$4 + 4 >> 2] = $2;
     HEAP32[$4 + 68 >> 2] = jsfVarFromName($4);
     $0 = HEAP32[$4 + 140 >> 2];
     $1 = HEAP32[$4 + 136 >> 2];
     $2 = HEAP32[$4 + 68 >> 2];
     $3 = HEAP32[$4 + 124 >> 2];
     $5 = HEAP32[$4 + 116 >> 2];
     HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 120 >> 2];
     HEAP32[$4 + 36 >> 2] = $3 - $5;
     HEAP32[$4 + 32 >> 2] = $2;
     cbprintf($0, $1, 19675, $4 + 32 | 0);
     jsvUnLock2(HEAP32[$4 + 72 >> 2], HEAP32[$4 + 68 >> 2]);
     break block1;
    }
   }
   jsvGetLineAndCol(HEAP32[HEAP32[$4 + 132 >> 2] + 84 >> 2], HEAP32[$4 + 128 >> 2], $4 + 124 | 0, $4 + 120 | 0, $4 + 116 | 0);
   $0 = HEAP32[$4 + 140 >> 2];
   $1 = HEAP32[$4 + 136 >> 2];
   $2 = HEAP32[$4 + 124 >> 2];
   $3 = HEAP32[$4 + 116 >> 2];
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 120 >> 2];
   HEAP32[$4 + 48 >> 2] = $2 - $3;
   cbprintf($0, $1, 19677, $4 + 48 | 0);
  }
  __stack_pointer = $4 + 144 | 0;
 }
 
 function jslPrintTokenLineMarker($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 92 >> 2] = $0;
  HEAP32[$5 + 88 >> 2] = $1;
  HEAP32[$5 + 84 >> 2] = $2;
  HEAP32[$5 + 80 >> 2] = $3;
  HEAP32[$5 + 76 >> 2] = $4;
  HEAP32[$5 + 72 >> 2] = 1;
  HEAP32[$5 + 68 >> 2] = 1;
  jsvGetLineAndCol(HEAP32[HEAP32[$5 + 84 >> 2] + 84 >> 2], HEAP32[$5 + 80 >> 2], $5 + 72 | 0, $5 + 68 | 0, 0);
  HEAP32[$5 + 64 >> 2] = jsvGetIndexFromLineAndCol(HEAP32[HEAP32[$5 + 84 >> 2] + 84 >> 2], HEAP32[$5 + 72 >> 2], 1);
  HEAP32[$5 + 60 >> 2] = jsvGetCharsOnLine(HEAP32[HEAP32[$5 + 84 >> 2] + 84 >> 2], HEAP32[$5 + 72 >> 2]);
  if (!(HEAPU32[$5 + 60 >> 2] <= 60 | HEAP32[$5 + 80 >> 2] - HEAP32[$5 + 64 >> 2] >>> 0 <= 30)) {
   cbprintf(HEAP32[$5 + 92 >> 2], HEAP32[$5 + 88 >> 2], 22775, 0);
   HEAP32[$5 + 56 >> 2] = (HEAP32[$5 + 80 >> 2] - 30 | 0) - HEAP32[$5 + 64 >> 2];
   HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 64 >> 2] + (HEAP32[$5 + 56 >> 2] + 3 | 0);
   block1 : {
    if (HEAPU32[$5 + 56 >> 2] <= HEAPU32[$5 + 68 >> 2]) {
     HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 68 >> 2] - HEAP32[$5 + 56 >> 2];
     break block1;
    }
    HEAP32[$5 + 68 >> 2] = 0;
   }
   HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] - HEAP32[$5 + 56 >> 2];
  }
  HEAP32[$5 + 52 >> 2] = 0;
  jsvStringIteratorNew($5 + 12 | 0, HEAP32[HEAP32[$5 + 84 >> 2] + 84 >> 2], HEAP32[$5 + 64 >> 2]);
  HEAP8[$5 + 11 | 0] = 0;
  while (1) {
   block3 : {
    $0 = 0;
    block2 : {
     if (!(jsvStringIteratorHasChar($5 + 12 | 0) & 1)) {
      break block2
     }
     $0 = 0;
     if (HEAPU32[$5 + 52 >> 2] >= 60) {
      break block2
     }
     $0 = HEAPU8[$5 + 11 | 0] != 255;
    }
    if (!$0) {
     break block3
    }
    if ((jsvStringIteratorGetChar($5 + 12 | 0) & 255) == 10) {
     break block3
    }
    jslPrintTokenisedChar($5 + 12 | 0, $5 + 11 | 0, $5 + 68 | 0, $5 + 52 | 0, HEAP32[$5 + 92 >> 2], HEAP32[$5 + 88 >> 2]);
    continue;
   }
   break;
  };
  jsvStringIteratorFree($5 + 12 | 0);
  if (HEAPU32[$5 + 60 >> 2] > 60) {
   FUNCTION_TABLE[HEAP32[$5 + 92 >> 2]](22775, HEAP32[$5 + 88 >> 2])
  }
  FUNCTION_TABLE[HEAP32[$5 + 92 >> 2]](28752, HEAP32[$5 + 88 >> 2]);
  HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 76 >> 2] + HEAP32[$5 + 68 >> 2];
  while (1) {
   $0 = HEAP32[$5 + 68 >> 2];
   HEAP32[$5 + 68 >> 2] = $0 - 1;
   if ($0 >>> 0 > 1) {
    FUNCTION_TABLE[HEAP32[$5 + 92 >> 2]](27706, HEAP32[$5 + 88 >> 2]);
    continue;
   }
   break;
  };
  FUNCTION_TABLE[HEAP32[$5 + 92 >> 2]](28477, HEAP32[$5 + 88 >> 2]);
  __stack_pointer = $5 + 96 | 0;
 }
 
 function jsvStringIteratorGetChar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function jslPrintStackTrace($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 76 >> 2] = $0;
  HEAP32[$3 + 72 >> 2] = $1;
  HEAP32[$3 + 68 >> 2] = $2;
  while (1) {
   if (HEAP32[$3 + 68 >> 2]) {
    FUNCTION_TABLE[HEAP32[$3 + 76 >> 2]](27475, HEAP32[$3 + 72 >> 2]);
    if (HEAP32[HEAP32[$3 + 68 >> 2] + 128 >> 2]) {
     jsvGetString(HEAP32[HEAP32[$3 + 68 >> 2] + 128 >> 2], $3, 64);
     FUNCTION_TABLE[HEAP32[$3 + 76 >> 2]]($3, HEAP32[$3 + 72 >> 2]);
     FUNCTION_TABLE[HEAP32[$3 + 76 >> 2]](27048, HEAP32[$3 + 72 >> 2]);
    }
    jslPrintPosition(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 72 >> 2], HEAP32[$3 + 68 >> 2], HEAP32[HEAP32[$3 + 68 >> 2] + 8 >> 2]);
    FUNCTION_TABLE[HEAP32[$3 + 76 >> 2]](HEAP32[HEAP32[$3 + 68 >> 2] + 128 >> 2] ? 28680 : 28752, HEAP32[$3 + 72 >> 2]);
    jslPrintTokenLineMarker(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 72 >> 2], HEAP32[$3 + 68 >> 2], HEAP32[HEAP32[$3 + 68 >> 2] + 8 >> 2], 0);
    HEAP32[$3 + 68 >> 2] = HEAP32[HEAP32[$3 + 68 >> 2] + 132 >> 2];
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 80 | 0;
 }
 
 function jsvStringIteratorLoadFlashString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
  block : {
   if (HEAPU32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >= HEAPU32[$1 + 8 >> 2]) {
    HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
    HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
    break block;
   }
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = HEAP32[$1 + 8 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
   if (HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] > 16) {
    HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 16
   }
   $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
   jshFlashRead(HEAP32[$1 + 12 >> 2] + 21 | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 12 >> 2] + 21;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsUnicodeIsLowSurrogate($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return (HEAP32[$1 + 12 >> 2] & 64512) == 56320;
 }
 
 function jsUnicodeIsHighSurrogate($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return (HEAP32[$1 + 12 >> 2] & 64512) == 55296;
 }
 
 function jslConvertTokenValueUTF8($0) {
  var $1 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 60 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[61300] + 76 >> 2]) {
    break block
   }
   HEAP32[$1 + 56 >> 2] = jsvNewFromEmptyString();
   if (!HEAP32[$1 + 56 >> 2]) {
    break block
   }
   jsvStringIteratorFree(HEAP32[$1 + 60 >> 2]);
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[HEAP32[61300] + 76 >> 2], 0);
   jsvStringIteratorNew(HEAP32[$1 + 60 >> 2], HEAP32[$1 + 56 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar($1 + 16 | 0) & 1) {
     HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 16 | 0);
     block1 : {
      if (jsUTF8IsStartChar(HEAP8[$1 + 15 | 0] << 24 >> 24) & 1) {
       HEAP32[$1 + 4 >> 2] = jsUTF8Encode(HEAPU8[$1 + 15 | 0], $1 + 11 | 0);
       HEAP32[$1 >> 2] = 0;
       while (1) {
        if (HEAPU32[$1 >> 2] < HEAPU32[$1 + 4 >> 2]) {
         jsvStringIteratorAppend(HEAP32[$1 + 60 >> 2], HEAP8[HEAP32[$1 >> 2] + ($1 + 11 | 0) | 0] << 24 >> 24);
         HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
         continue;
        }
        break;
       };
       break block1;
      }
      jsvStringIteratorAppend(HEAP32[$1 + 60 >> 2], HEAP8[$1 + 15 | 0] << 24 >> 24);
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree($1 + 16 | 0);
   jsvUnLock(HEAP32[HEAP32[61300] + 76 >> 2]);
   HEAP32[HEAP32[61300] + 76 >> 2] = HEAP32[$1 + 56 >> 2];
  }
  __stack_pointer = $1 - -64 | 0;
 }
 
 function jsfGetFlag($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  return (HEAPU8[245204] & HEAPU8[$1 + 15 | 0]) != 0;
 }
 
 function jsfSetFlag($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  block : {
   if (HEAP8[$2 + 14 | 0] & 1) {
    HEAP8[245204] = HEAPU8[$2 + 15 | 0] | HEAPU8[245204];
    break block;
   }
   HEAP8[245204] = HEAPU8[245204] & (HEAPU8[$2 + 15 | 0] ^ -1);
  }
 }
 
 function jsfGetFlags() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = jsvNewWithFlags(5);
  block : {
   if (!HEAP32[$0 + 8 >> 2]) {
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 4 >> 2] = HEAP32[61105];
   HEAP8[$0 + 3 | 0] = 1;
   while (1) {
    if (HEAPU8[HEAP32[$0 + 4 >> 2]]) {
     jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2], jsvNewFromInteger(jsfGetFlag(HEAPU8[$0 + 3 | 0]) & 1));
     HEAP32[$0 + 4 >> 2] = (strlen(HEAP32[$0 + 4 >> 2]) + 1 | 0) + HEAP32[$0 + 4 >> 2];
     HEAP8[$0 + 3 | 0] = HEAPU8[$0 + 3 | 0] << 1;
     continue;
    }
    break;
   };
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jsfSetFlags($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!(jsvIsObject(HEAP32[$1 + 12 >> 2]) & 1)) {
    break block
   }
   HEAP32[$1 + 8 >> 2] = HEAP32[61105];
   HEAP8[$1 + 7 | 0] = 1;
   while (1) {
    if (!HEAPU8[HEAP32[$1 + 8 >> 2]]) {
     break block
    }
    HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
    if (HEAP32[$1 >> 2]) {
     jsfSetFlag(HEAPU8[$1 + 7 | 0], jsvGetBoolAndUnLock(HEAP32[$1 >> 2]) & 1)
    }
    HEAP32[$1 + 8 >> 2] = (strlen(HEAP32[$1 + 8 >> 2]) + 1 | 0) + HEAP32[$1 + 8 >> 2];
    HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 7 | 0] << 1;
    continue;
   };
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvGetFirstChild($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  $1 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
  $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
  $1 = ($1 & 268435455) << 4 | $0 >>> 28;
  return $1 & 16383;
 }
 
 function jsvGetFirstChildSigned($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 8 >> 2] = $0;
  $0 = HEAP32[$3 + 8 >> 2];
  $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
  $2 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
  $0 = $1;
  $2 = ($2 & 268435455) << 4 | $0 >>> 28;
  block : {
   if (($2 & 16383) >>> 0 > 8191) {
    $1 = HEAP32[$3 + 8 >> 2];
    $0 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
    $2 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
    $1 = $0;
    $2 = ($2 & 268435455) << 4 | $1 >>> 28;
    HEAP16[$3 + 14 >> 1] = (($2 & 16383) << 16 >> 16) - 16384;
    break block;
   }
   $0 = HEAP32[$3 + 8 >> 2];
   $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   $2 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
   $0 = $1;
   $2 = ($2 & 268435455) << 4 | $0 >>> 28;
   HEAP16[$3 + 14 >> 1] = $2 & 16383;
  }
  return HEAP16[$3 + 14 >> 1] << 16 >> 16;
 }
 
 function jsvGetLastChild($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return (HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) >>> 18 | 0;
 }
 
 function jsvGetNextSibling($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) & 16383;
 }
 
 function jsvGetPrevSibling($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  $1 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
  $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
  $1 = ($1 & 16383) << 18 | $0 >>> 14;
  return $1 & 16383;
 }
 
 function jsvSetFirstChild($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP16[$3 + 10 >> 1] = $1;
  $4 = HEAP32[$3 + 12 >> 2];
  $2 = $4;
  $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
  $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
  $2 = $0;
  $5 = $2 & 268435455;
  $0 = $1 & -1024;
  $6 = $0;
  $1 = $3;
  $0 = HEAPU16[$1 + 10 >> 1];
  $2 = $0 & 16383;
  $1 = $2 >>> 4 | 0;
  $3 = $1;
  $0 = $5;
  $1 = $2 << 28 | $0;
  $0 = $4;
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  $1 = $6;
  $2 = $3;
  $2 = $1 | $2;
  HEAP8[$0 + 8 | 0] = $2;
  HEAP8[$0 + 9 | 0] = $2 >>> 8;
  HEAP8[$0 + 10 | 0] = $2 >>> 16;
  HEAP8[$0 + 11 | 0] = $2 >>> 24;
 }
 
 function jsvSetLastChild($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $4 = __stack_pointer - 16 | 0;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP16[$4 + 10 >> 1] = $1;
  $5 = HEAP32[$4 + 12 >> 2];
  $2 = $5;
  $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
  $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
  $2 = $0;
  $3 = $2;
  $0 = $1 & 262143;
  $6 = $0;
  $1 = $4;
  $0 = HEAPU16[$1 + 10 >> 1];
  $2 = $0 & 16383;
  $1 = $2 << 18;
  $2 = $1;
  $0 = $5;
  HEAP8[$0 + 4 | 0] = $3;
  HEAP8[$0 + 5 | 0] = $3 >>> 8;
  HEAP8[$0 + 6 | 0] = $3 >>> 16;
  HEAP8[$0 + 7 | 0] = $3 >>> 24;
  $1 = $6;
  $2 = $1 | $2;
  HEAP8[$0 + 8 | 0] = $2;
  HEAP8[$0 + 9 | 0] = $2 >>> 8;
  HEAP8[$0 + 10 | 0] = $2 >>> 16;
  HEAP8[$0 + 11 | 0] = $2 >>> 24;
 }
 
 function jsvSetNextSibling($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP16[$2 + 10 >> 1] = $1;
  $0 = $2;
  $3 = HEAPU16[$0 + 10 >> 1];
  $0 = $3;
  $4 = $0 & 16383;
  $2 = HEAP32[$2 + 12 >> 2];
  $1 = $2;
  $3 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
  $0 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
  $1 = $3;
  $3 = $0;
  $0 = $4;
  $1 = $1 & -16384 | $0;
  $0 = $2;
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  $1 = $3;
  HEAP8[$0 + 8 | 0] = $1;
  HEAP8[$0 + 9 | 0] = $1 >>> 8;
  HEAP8[$0 + 10 | 0] = $1 >>> 16;
  HEAP8[$0 + 11 | 0] = $1 >>> 24;
 }
 
 function jsvSetPrevSibling($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP16[$3 + 10 >> 1] = $1;
  $4 = HEAP32[$3 + 12 >> 2];
  $2 = $4;
  $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
  $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
  $2 = $0;
  $5 = $2 & -268419073;
  $0 = $1;
  $6 = $0;
  $1 = $3;
  $0 = HEAPU16[$1 + 10 >> 1];
  $2 = $0 & 16383;
  $1 = $2 >>> 18 | 0;
  $3 = $1;
  $0 = $5;
  $1 = $2 << 14 | $0;
  $0 = $4;
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  $1 = $6;
  $2 = $3;
  $2 = $1 | $2;
  HEAP8[$0 + 8 | 0] = $2;
  HEAP8[$0 + 9 | 0] = $2 >>> 8;
  HEAP8[$0 + 10 | 0] = $2 >>> 16;
  HEAP8[$0 + 11 | 0] = $2 >>> 24;
 }
 
 function jsvGetRefs($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  $1 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
  $1 = $1 >>> 10 | 0;
  return $1 & 255;
 }
 
 function jsvSetRefs($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $4 = __stack_pointer - 16 | 0;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP16[$4 + 10 >> 1] = $1;
  $5 = HEAP32[$4 + 12 >> 2];
  $2 = $5;
  $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
  $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
  $2 = $0;
  $3 = $2;
  $0 = $1 & -261121;
  $6 = $0;
  $1 = $4;
  $0 = HEAPU16[$1 + 10 >> 1];
  $2 = $0 & 255;
  $1 = $2 << 10;
  $2 = $1;
  $0 = $5;
  HEAP8[$0 + 4 | 0] = $3;
  HEAP8[$0 + 5 | 0] = $3 >>> 8;
  HEAP8[$0 + 6 | 0] = $3 >>> 16;
  HEAP8[$0 + 7 | 0] = $3 >>> 24;
  $1 = $6;
  $2 = $1 | $2;
  HEAP8[$0 + 8 | 0] = $2;
  HEAP8[$0 + 9 | 0] = $2 >>> 8;
  HEAP8[$0 + 10 | 0] = $2 >>> 16;
  HEAP8[$0 + 11 | 0] = $2 >>> 24;
 }
 
 function jsvGetLocks($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) >>> 10 & 15;
 }
 
 function jsvIsRoot($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 7 | 0] == 1;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsPin($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 7 | 0] == 13;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsSimpleInt($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 10;
  }
  return $2;
 }
 
 function jsvIsInt($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   block1 : {
    if (HEAPU8[$1 + 7 | 0] == 10) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 13) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 15) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 16) {
     break block1
    }
    $0 = HEAPU8[$1 + 7 | 0] == 17;
   }
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsFloat($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 11;
  }
  return $2;
 }
 
 function jsvIsBoolean($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   $0 = HEAPU8[$1 + 7 | 0] != 12 ? HEAPU8[$1 + 7 | 0] == 17 : $0;
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsString($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 18 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 42 : $2;
   HEAP8[$1 + 15 | 0] = $2;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsUTF8String($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   $0 = HEAPU8[$1 + 7 | 0] != 41 ? HEAPU8[$1 + 7 | 0] == 23 : $0;
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsBasicString($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 29 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 38 : $2;
   HEAP8[$1 + 15 | 0] = $2;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsStringExt($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 43 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 53 : $2;
   HEAP8[$1 + 15 | 0] = $2;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsFlatString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 7 | 0] == 39;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsNativeString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 7 | 0] == 40;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsFlashString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 7 | 0] == 42;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsConstant($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 64) == 64;
  }
  return $2;
 }
 
 function jsvIsNumeric($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 10 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 17 : $2;
   HEAP8[$1 + 15 | 0] = $2;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsFunction($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   block1 : {
    if (HEAPU8[$1 + 7 | 0] == 7) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 9) {
     break block1
    }
    $0 = HEAPU8[$1 + 7 | 0] == 8;
   }
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsFunctionReturn($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 9;
  }
  return $2;
 }
 
 function jsvIsFunctionParameter($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = 0;
  block : {
   if (!HEAP32[$1 + 12 >> 2]) {
    break block
   }
   $2 = HEAP32[$1 + 12 >> 2];
   $0 = 0;
   if (!((HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8) & 128)) {
    break block
   }
   $0 = jsvIsString(HEAP32[$1 + 12 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jsvIsObject($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   $0 = HEAPU8[$1 + 7 | 0] != 5 ? HEAPU8[$1 + 7 | 0] == 1 : $0;
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsArray($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 3;
  }
  return $2;
 }
 
 function jsvIsArrayBuffer($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 4;
  }
  return $2;
 }
 
 function jsvIsArrayBufferName($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 14;
  }
  return $2;
 }
 
 function jsvIsNativeFunction($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 8;
  }
  return $2;
 }
 
 function jsvIsUndefined($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return !HEAP32[$1 + 12 >> 2];
 }
 
 function jsvIsNull($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 2;
  }
  return $2;
 }
 
 function jsvIsNullish($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 2;
  }
  return $0;
 }
 
 function jsvIsBasic($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   block1 : {
    if (HEAP8[$1 + 7 | 0] << 24 >> 24 >= 10) {
     $0 = 1;
     if (HEAP8[$1 + 7 | 0] << 24 >> 24 <= 17) {
      break block1
     }
    }
    $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 18 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 42 : $2;
    $0 = $2;
   }
   HEAP8[$1 + 15 | 0] = $0 & 1;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsName($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 14 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 28 : $2;
   HEAP8[$1 + 15 | 0] = $2;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsBasicName($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 24 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 28 : $2;
   HEAP8[$1 + 15 | 0] = $2;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsNameWithValue($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 16 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 22 : $2;
   HEAP8[$1 + 15 | 0] = $2;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsNameInt($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   if (HEAPU8[$1 + 7 | 0] != 16) {
    $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 18 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 22 : $2;
    $0 = $2;
   }
   HEAP8[$1 + 15 | 0] = $0 & 1;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsNameIntBool($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 17;
  }
  return $2;
 }
 
 function jsvIsNewChild($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = 0;
  block : {
   if (!(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1)) {
    break block
   }
   $0 = 0;
   if (!(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
    break block
   }
   $0 = (jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535) == (jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535);
  }
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvIsGetterOrSetter($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 7 | 0] == 6;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsIntegerish($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   block1 : {
    if (HEAPU8[$1 + 7 | 0] == 10) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 13) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 15) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 16) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 17) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 13) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 12) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 17) {
     break block1
    }
    $0 = HEAPU8[$1 + 7 | 0] == 2;
   }
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsIterable($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   block1 : {
    if (HEAPU8[$1 + 7 | 0] == 3) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 5) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 1) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 7) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 9) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 8) {
     break block1
    }
    if (HEAP8[$1 + 7 | 0] << 24 >> 24 >= 18) {
     $0 = 1;
     if (HEAP8[$1 + 7 | 0] << 24 >> 24 <= 42) {
      break block1
     }
    }
    $0 = HEAPU8[$1 + 7 | 0] == 4;
   }
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvHasCharacterData($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   block1 : {
    if (HEAP8[$1 + 7 | 0] << 24 >> 24 >= 18) {
     $0 = 1;
     if (HEAP8[$1 + 7 | 0] << 24 >> 24 <= 42) {
      break block1
     }
    }
    $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 43 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 53 : $2;
    $0 = $2;
   }
   HEAP8[$1 + 15 | 0] = $0 & 1;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvHasStringExt($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   block2 : {
    if (!(HEAP8[$1 + 7 | 0] << 24 >> 24 <= 42 & HEAP8[$1 + 7 | 0] << 24 >> 24 >= 18 | HEAP8[$1 + 7 | 0] << 24 >> 24 <= 53 & HEAP8[$1 + 7 | 0] << 24 >> 24 >= 43 | HEAPU8[$1 + 7 | 0] == 41)) {
     $0 = 0;
     if (HEAPU8[$1 + 7 | 0] != 23) {
      break block2
     }
    }
    $0 = 1;
    block3 : {
     if (HEAPU8[$1 + 7 | 0] == 39) {
      break block3
     }
     $0 = 1;
     if (HEAPU8[$1 + 7 | 0] == 40) {
      break block3
     }
     $0 = HEAPU8[$1 + 7 | 0] == 42;
    }
    $0 = $0 ^ -1;
   }
   HEAP8[$1 + 15 | 0] = $0 & 1;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvHasChildren($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   block1 : {
    if (HEAPU8[$1 + 7 | 0] == 7) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 9) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 8) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 5) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 1) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 3) {
     break block1
    }
    $0 = 1;
    if (HEAPU8[$1 + 7 | 0] == 1) {
     break block1
    }
    $0 = HEAPU8[$1 + 7 | 0] == 6;
   }
   HEAP8[$1 + 15 | 0] = $0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvHasSingleChild($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   $0 = 1;
   if (HEAPU8[$1 + 7 | 0] != 4) {
    $0 = 0;
    block1 : {
     if (HEAP8[$1 + 7 | 0] << 24 >> 24 < 14) {
      break block1
     }
     $0 = 0;
     if (HEAP8[$1 + 7 | 0] << 24 >> 24 > 28) {
      break block1
     }
     $2 = HEAP8[$1 + 7 | 0] << 24 >> 24 >= 16 ? HEAP8[$1 + 7 | 0] << 24 >> 24 <= 22 : $2;
     $0 = $2 ^ -1;
    }
   }
   HEAP8[$1 + 15 | 0] = $0 & 1;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function _jsvGetAddressOf($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP16[$1 + 14 >> 1] = $0;
  $0 = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvGetAddressOf($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP16[$1 + 14 >> 1] = $0;
  return Math_imul(HEAPU16[$1 + 14 >> 1], 14) + 245198 | 0;
 }
 
 function jsvCreateEmptyVarList() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP8[245206] = 1;
  HEAP16[122604] = 0;
  jsvSetNextSibling($0 + 18 | 0, 0);
  HEAP32[$0 + 12 >> 2] = $0 + 18;
  HEAP16[$0 + 10 >> 1] = 1;
  while (1) {
   if (HEAPU16[$0 + 10 >> 1] <= 12e3) {
    HEAP32[$0 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 10 >> 1]);
    $1 = HEAP32[$0 + 4 >> 2];
    block : {
     if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63)) {
      jsvSetNextSibling(HEAP32[$0 + 12 >> 2], HEAPU16[$0 + 10 >> 1]);
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
      break block;
     }
     if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
      HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2])
     }
    }
    HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + 1;
    continue;
   }
   break;
  };
  jsvSetNextSibling(HEAP32[$0 + 12 >> 2], 0);
  HEAP16[122604] = jsvGetNextSibling($0 + 18 | 0);
  HEAP8[245206] = 0;
  __stack_pointer = $0 + 32 | 0;
 }
 
 function jsvGetFlatStringBlocks($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + 13 >>> 0) / 14 | 0;
 }
 
 function jsvClearEmptyVarList() {
  var $0 = 0, $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[245206] = 1;
  HEAP16[122604] = 0;
  HEAP16[$1 + 14 >> 1] = 1;
  while (1) {
   if (HEAPU16[$1 + 14 >> 1] <= 12e3) {
    HEAP32[$1 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
    $0 = HEAP32[$1 + 8 >> 2];
    block : {
     if (!((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63)) {
      $0 = HEAP32[$1 + 8 >> 2];
      HEAP8[$0 | 0] = 0;
      HEAP8[$0 + 1 | 0] = 0;
      HEAP8[$0 + 2 | 0] = 0;
      HEAP8[$0 + 3 | 0] = 0;
      HEAP8[$0 + 4 | 0] = 0;
      HEAP8[$0 + 5 | 0] = 0;
      HEAP8[$0 + 6 | 0] = 0;
      HEAP8[$0 + 7 | 0] = 0;
      HEAP8[$0 + 6 | 0] = 0;
      HEAP8[$0 + 7 | 0] = 0;
      HEAP8[$0 + 8 | 0] = 0;
      HEAP8[$0 + 9 | 0] = 0;
      HEAP8[$0 + 10 | 0] = 0;
      HEAP8[$0 + 11 | 0] = 0;
      HEAP8[$0 + 12 | 0] = 0;
      HEAP8[$0 + 13 | 0] = 0;
      break block;
     }
     if (jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1) {
      HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 14 >> 1] + jsvGetFlatStringBlocks(HEAP32[$1 + 8 >> 2])
     }
    }
    HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 14 >> 1] + 1;
    continue;
   }
   break;
  };
  HEAP8[245206] = 0;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvSoftInit() {
  jsvCreateEmptyVarList();
 }
 
 function jsvSoftKill() {
  jsvClearEmptyVarList();
 }
 
 function jsvReset() {
  HEAP16[122604] = 0;
  wasm2js_memory_fill(245212, 0, 168e3);
  jsvSoftInit();
 }
 
 function jsvInit($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvReset();
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvKill() {
  
 }
 
 function jsvFindOrCreateRoot() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP16[$0 + 10 >> 1] = 1;
  block : {
   while (1) {
    if (HEAPU16[$0 + 10 >> 1] <= 12e3) {
     if (jsvIsRoot(jsvGetAddressOf(HEAPU16[$0 + 10 >> 1])) & 1) {
      HEAP32[$0 + 12 >> 2] = jsvLock(HEAPU16[$0 + 10 >> 1]);
      break block;
     } else {
      HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + 1;
      continue;
     }
    }
    break;
   };
   HEAP32[$0 + 12 >> 2] = jsvRef(jsvNewWithFlags(1));
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jsvLock($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP16[$1 + 14 >> 1] = $0;
  HEAP32[$1 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
  $0 = HEAP32[$1 + 8 >> 2];
  if (((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 15360) != 15360) {
   $0 = HEAP32[$1 + 8 >> 2];
   $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) + 1024 | 0;
   HEAP8[$0 + 12 | 0] = $2;
   HEAP8[$0 + 13 | 0] = $2 >>> 8;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvNewWithFlags($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP16[$1 + 10 >> 1] = $0;
  block : {
   if (HEAPU8[245206]) {
    HEAP8[413226] = HEAPU8[413226] | 32;
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 4 >> 2] = 0;
   jshInterruptOff();
   if (HEAPU16[122604]) {
    HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[122604]);
    HEAP16[122604] = jsvGetNextSibling(HEAP32[$1 + 4 >> 2]);
    HEAP8[245205] = 1;
   }
   jshInterruptOn();
   if (HEAP32[$1 + 4 >> 2]) {
    jsvResetVariable(HEAP32[$1 + 4 >> 2], HEAPU16[$1 + 10 >> 1]);
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
    break block;
   }
   HEAP8[413226] = HEAPU8[413226] | 8;
   if (jshIsInInterrupt() & 1) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   if (jsvGarbageCollect()) {
    HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(HEAPU16[$1 + 10 >> 1]);
    break block;
   }
   if (jsiFreeMoreMemory() & 1) {
    HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(HEAPU16[$1 + 10 >> 1]);
    break block;
   }
   if (!(HEAPU8[413226] & 16)) {
    HEAP8[413226] = HEAPU8[413226] | 16;
    jsiConsolePrintString(20835);
    jswrap_console_trace(0);
   }
   HEAP8[413226] = HEAPU8[413226] | 16;
   jspSetInterrupted(1);
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvRef($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if ((jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) >>> 0 < 255) {
   jsvSetRefs(HEAP32[$1 + 12 >> 2], (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) + 1 & 65535)
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvResetVariable($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP16[$2 + 10 >> 1] = $1;
  HEAP32[$2 + 4 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 4 >> 2] < 14) {
    HEAP8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = 0;
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = HEAPU16[$2 + 10 >> 1] | 1024;
  HEAP8[$0 + 12 | 0] = $1;
  HEAP8[$0 + 13 | 0] = $1 >>> 8;
 }
 
 function jsvGarbageCollect() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 48 | 0;
  __stack_pointer = $0;
  block : {
   if (HEAPU8[245206]) {
    HEAP32[$0 + 44 >> 2] = 0;
    break block;
   }
   HEAP8[245206] = 2;
   HEAP16[$0 + 42 >> 1] = 1;
   while (1) {
    if (HEAPU16[$0 + 42 >> 1] <= 12e3) {
     HEAP32[$0 + 36 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
     $1 = HEAP32[$0 + 36 >> 2];
     if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
      $1 = HEAP32[$0 + 36 >> 2];
      $2 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | 256;
      HEAP8[$1 + 12 | 0] = $2;
      HEAP8[$1 + 13 | 0] = $2 >>> 8;
      if (jsvIsFlatString(HEAP32[$0 + 36 >> 2]) & 1) {
       HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 36 >> 2])
      }
     }
     HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
     continue;
    }
    break;
   };
   HEAP16[$0 + 42 >> 1] = 1;
   while (1) {
    if (HEAPU16[$0 + 42 >> 1] <= 12e3) {
     HEAP32[$0 + 32 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
     $1 = HEAP32[$0 + 32 >> 2];
     block1 : {
      if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 256)) {
       break block1
      }
      if (!(jsvGetLocks(HEAP32[$0 + 32 >> 2]) & 255)) {
       break block1
      }
      if (!(jsvGarbageCollectMarkUsed(HEAP32[$0 + 32 >> 2]) & 1)) {
       HEAP8[245206] = 0;
       HEAP32[$0 + 44 >> 2] = 0;
       break block;
      }
     }
     if (jsvIsFlatString(HEAP32[$0 + 32 >> 2]) & 1) {
      HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 32 >> 2])
     }
     HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
     continue;
    }
    break;
   };
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP16[122604] = 0;
   HEAP32[$0 + 24 >> 2] = 0;
   HEAP16[$0 + 42 >> 1] = 1;
   while (1) {
    if (HEAPU16[$0 + 42 >> 1] <= 12e3) {
     HEAP32[$0 + 20 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
     $1 = HEAP32[$0 + 20 >> 2];
     block4 : {
      if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 256) {
       if (jsvIsFlatString(HEAP32[$0 + 20 >> 2]) & 1) {
        HEAP32[$0 + 16 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 20 >> 2]);
        HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 16 >> 2] + HEAP32[$0 + 28 >> 2];
        $1 = HEAP32[$0 + 20 >> 2];
        HEAP8[$1 + 12 | 0] = 0;
        HEAP8[$1 + 13 | 0] = 0;
        block2 : {
         if (HEAP32[$0 + 24 >> 2]) {
          jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
          break block2;
         }
         HEAP16[122604] = HEAPU16[$0 + 42 >> 1];
        }
        HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
        while (1) {
         $1 = HEAP32[$0 + 16 >> 2];
         HEAP32[$0 + 16 >> 2] = $1 - 1;
         if ($1) {
          HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
          HEAP32[$0 + 20 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
          $1 = HEAP32[$0 + 20 >> 2];
          HEAP8[$1 + 12 | 0] = 0;
          HEAP8[$1 + 13 | 0] = 0;
          block3 : {
           if (HEAP32[$0 + 24 >> 2]) {
            jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
            break block3;
           }
           HEAP16[122604] = HEAPU16[$0 + 42 >> 1];
          }
          HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
          continue;
         }
         break;
        };
        break block4;
       }
       if (jsvHasSingleChild(HEAP32[$0 + 20 >> 2]) & 1) {
        HEAP16[$0 + 14 >> 1] = jsvGetFirstChild(HEAP32[$0 + 20 >> 2]);
        if (HEAPU16[$0 + 14 >> 1]) {
         HEAP32[$0 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 14 >> 1]);
         $1 = HEAP32[$0 + 8 >> 2];
         block5 : {
          if (!(HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
           break block5
          }
          $1 = HEAP32[$0 + 8 >> 2];
          if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 256) {
           break block5
          }
          jsvUnRef(HEAP32[$0 + 8 >> 2]);
         }
        }
       }
       $1 = HEAP32[$0 + 20 >> 2];
       HEAP8[$1 + 12 | 0] = 0;
       HEAP8[$1 + 13 | 0] = 0;
       block6 : {
        if (HEAP32[$0 + 24 >> 2]) {
         jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
         break block6;
        }
        HEAP16[122604] = HEAPU16[$0 + 42 >> 1];
       }
       HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
       HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1;
       break block4;
      }
      block7 : {
       if (jsvIsFlatString(HEAP32[$0 + 20 >> 2]) & 1) {
        HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 20 >> 2]);
        break block7;
       }
       $1 = HEAP32[$0 + 20 >> 2];
       if (!(HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
        block8 : {
         if (HEAP32[$0 + 24 >> 2]) {
          jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
          break block8;
         }
         HEAP16[122604] = HEAPU16[$0 + 42 >> 1];
        }
        HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
       }
      }
     }
     HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$0 + 24 >> 2]) {
    jsvSetNextSibling(HEAP32[$0 + 24 >> 2], 0)
   }
   HEAP8[245206] = 0;
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 28 >> 2];
  }
  __stack_pointer = $0 + 48 | 0;
  return HEAP32[$0 + 44 >> 2];
 }
 
 function jsvGetMemoryUsage() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 1;
  while (1) {
   if (HEAPU32[$0 + 8 >> 2] <= 12e3) {
    HEAP32[$0 + 4 >> 2] = jsvGetAddressOf(HEAP32[$0 + 8 >> 2] & 65535);
    $1 = HEAP32[$0 + 4 >> 2];
    if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
     if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
      HEAP32[$0 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2]);
      HEAP32[$0 + 8 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 8 >> 2];
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 12 >> 2];
     }
    }
    HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jsvGetMemoryTotal() {
  return 12e3;
 }
 
 function jsvUpdateMemoryAddress($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 16 >> 2] = 1;
  while (1) {
   if (HEAPU32[$3 + 16 >> 2] <= 12e3) {
    HEAP32[$3 + 12 >> 2] = jsvGetAddressOf(HEAP32[$3 + 16 >> 2] & 65535);
    block3 : {
     block : {
      if (!(jsvIsNativeString(HEAP32[$3 + 12 >> 2]) & 1)) {
       if (!(jsvIsFlashString(HEAP32[$3 + 12 >> 2]) & 1)) {
        break block
       }
      }
      $0 = HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 8 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (!(HEAPU32[$3 + 8 >> 2] < HEAPU32[$3 + 28 >> 2] | HEAPU32[$3 + 8 >> 2] >= HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 24 >> 2] >>> 0)) {
       block2 : {
        if (HEAP32[$3 + 20 >> 2]) {
         $0 = HEAP32[$3 + 12 >> 2];
         $1 = (HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 20 >> 2] | 0) - HEAP32[$3 + 28 >> 2] | 0;
         HEAP8[$0 | 0] = $1;
         HEAP8[$0 + 1 | 0] = $1 >>> 8;
         HEAP8[$0 + 2 | 0] = $1 >>> 16;
         HEAP8[$0 + 3 | 0] = $1 >>> 24;
         break block2;
        }
        $0 = HEAP32[$3 + 12 >> 2];
        $1 = HEAP32[$3 + 12 >> 2];
        $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 2;
        HEAP8[$0 + 12 | 0] = $1;
        HEAP8[$0 + 13 | 0] = $1 >>> 8;
        $0 = HEAP32[$3 + 12 >> 2];
        HEAP8[$0 | 0] = 0;
        HEAP8[$0 + 1 | 0] = 0;
        HEAP8[$0 + 2 | 0] = 0;
        HEAP8[$0 + 3 | 0] = 0;
        $0 = HEAP32[$3 + 12 >> 2];
        HEAP8[$0 + 4 | 0] = 0;
        HEAP8[$0 + 5 | 0] = 0;
        HEAP8[$0 + 6 | 0] = 0;
        HEAP8[$0 + 7 | 0] = 0;
       }
      }
      break block3;
     }
     if (jsvIsFlatString(HEAP32[$3 + 12 >> 2]) & 1) {
      HEAP32[$3 + 16 >> 2] = jsvGetFlatStringBlocks(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 16 >> 2]
     }
    }
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsvMoreFreeVariablesThan($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP16[$1 + 6 >> 1] = HEAPU16[122604];
   while (1) {
    if (HEAPU16[$1 + 6 >> 1]) {
     $0 = HEAP32[$1 + 8 >> 2];
     HEAP32[$1 + 8 >> 2] = $0 - 1;
     if ($0) {
      HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]));
      continue;
     } else {
      HEAP8[$1 + 15 | 0] = 1;
      break block;
     }
    }
    break;
   };
   HEAP8[$1 + 15 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIsMemoryFull() {
  return (HEAPU16[122604] != 0 ^ -1) & 1;
 }
 
 function jsvTrace($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP8[$2 + 7 | 0] = HEAPU8[245206];
  HEAP8[245206] = 0;
  _jsvTrace(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2], 0);
  HEAP8[245206] = HEAPU8[$2 + 7 | 0];
  jsiConsolePrintf(28752, 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function _jsvTrace($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 336 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 332 >> 2] = $0;
  HEAP32[$4 + 328 >> 2] = $1;
  HEAP32[$4 + 324 >> 2] = $2;
  HEAP32[$4 + 320 >> 2] = $3;
  HEAP32[$4 + 316 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 316 >> 2] < HEAP32[$4 + 328 >> 2]) {
    jsiConsolePrintString(27706);
    HEAP32[$4 + 316 >> 2] = HEAP32[$4 + 316 >> 2] + 1;
    continue;
   }
   break;
  };
  block : {
   if (!HEAP32[$4 + 332 >> 2]) {
    jsiConsolePrintString(19123);
    break block;
   }
   if (!(HEAP32[$4 + 332 >> 2] != HEAP32[103307] | HEAP32[$4 + 320 >> 2] <= 0)) {
    jsiConsolePrintString(21008);
    break block;
   }
   jsvTraceLockInfo(HEAP32[$4 + 332 >> 2]);
   HEAP32[$4 + 312 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$4 + 324 >> 2], HEAP32[$4 + 332 >> 2]);
   if (!((HEAP32[$4 + 312 >> 2] < 0 | HEAP32[$4 + 312 >> 2] >= HEAP32[$4 + 320 >> 2]) & HEAP32[$4 + 320 >> 2] <= 16)) {
    jsiConsolePrintString(28675);
    break block;
   }
   block3 : {
    if (jsvIsNewChild(HEAP32[$4 + 332 >> 2]) & 1) {
     jsiConsolePrintString(22221);
     HEAP32[$4 + 308 >> 2] = jsvGetAddressOf(jsvGetNextSibling(HEAP32[$4 + 332 >> 2]) & 65535);
     _jsvTrace(HEAP32[$4 + 308 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
     jsiConsolePrintString(27615);
     break block3;
    }
    if (jsvIsName(HEAP32[$4 + 332 >> 2]) & 1) {
     jsiConsolePrintString(27511)
    }
   }
   HEAP8[$4 + 307 | 0] = 32;
   block4 : {
    if (jsvIsObject(HEAP32[$4 + 332 >> 2]) & 1) {
     jsiConsolePrintString(27408);
     HEAP8[$4 + 307 | 0] = 125;
     break block4;
    }
    block5 : {
     if (jsvIsGetterOrSetter(HEAP32[$4 + 332 >> 2]) & 1) {
      jsiConsolePrintString(27418);
      HEAP8[$4 + 307 | 0] = 125;
      break block5;
     }
     block6 : {
      if (jsvIsArray(HEAP32[$4 + 332 >> 2]) & 1) {
       $0 = HEAP32[$4 + 332 >> 2];
       HEAP32[$4 + 48 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
       jsiConsolePrintf(27552, $4 + 48 | 0);
       HEAP8[$4 + 307 | 0] = 93;
       break block6;
      }
      block7 : {
       if (jsvIsNativeFunction(HEAP32[$4 + 332 >> 2]) & 1) {
        $0 = HEAP32[$4 + 332 >> 2];
        $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
        $0 = HEAP32[$4 + 332 >> 2];
        HEAP32[$4 + 68 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8;
        HEAP32[$4 + 64 >> 2] = $1;
        jsiConsolePrintf(27447, $4 - -64 | 0);
        HEAP8[$4 + 307 | 0] = 125;
        break block7;
       }
       block8 : {
        if (jsvIsFunction(HEAP32[$4 + 332 >> 2]) & 1) {
         jsiConsolePrintString(27435);
         if (jsvIsFunctionReturn(HEAP32[$4 + 332 >> 2]) & 1) {
          jsiConsolePrintString(27493)
         }
         HEAP8[$4 + 307 | 0] = 125;
         break block8;
        }
        block9 : {
         if (jsvIsPin(HEAP32[$4 + 332 >> 2]) & 1) {
          HEAP32[$4 + 80 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
          jsiConsolePrintf(19843, $4 + 80 | 0);
          break block9;
         }
         block10 : {
          if (jsvIsNull(HEAP32[$4 + 332 >> 2]) & 1) {
           jsiConsolePrintf(21279, 0);
           break block10;
          }
          block11 : {
           if (jsvIsInt(HEAP32[$4 + 332 >> 2]) & 1) {
            HEAP32[$4 + 96 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
            jsiConsolePrintf(19775, $4 + 96 | 0);
            break block11;
           }
           block12 : {
            if (jsvIsBoolean(HEAP32[$4 + 332 >> 2]) & 1) {
             HEAP32[$4 + 112 >> 2] = jsvGetBool(HEAP32[$4 + 332 >> 2]) & 1 ? 17314 : 17666;
             jsiConsolePrintf(7605, $4 + 112 | 0);
             break block12;
            }
            block13 : {
             if (jsvIsFloat(HEAP32[$4 + 332 >> 2]) & 1) {
              HEAPF64[$4 + 128 >> 3] = jsvGetFloat(HEAP32[$4 + 332 >> 2]);
              jsiConsolePrintf(17159, $4 + 128 | 0);
              break block13;
             }
             block14 : {
              if (jsvIsFunctionParameter(HEAP32[$4 + 332 >> 2]) & 1) {
               HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 332 >> 2];
               jsiConsolePrintf(27483, $4 + 144 | 0);
               break block14;
              }
              block15 : {
               if (jsvIsArrayBufferName(HEAP32[$4 + 332 >> 2]) & 1) {
                HEAP32[$4 + 160 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
                jsiConsolePrintf(27531, $4 + 160 | 0);
                break block15;
               }
               block17 : {
                if (jsvIsArrayBuffer(HEAP32[$4 + 332 >> 2]) & 1) {
                 block16 : {
                  if (jswGetBasicObjectName(HEAP32[$4 + 332 >> 2])) {
                   $1 = jswGetBasicObjectName(HEAP32[$4 + 332 >> 2]);
                   break block16;
                  }
                  $1 = 8247;
                 }
                 $0 = HEAP32[$4 + 332 >> 2];
                 $2 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
                 HEAP32[$4 + 184 >> 2] = HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8 | HEAPU8[$0 + 4 | 0] << 16;
                 HEAP32[$4 + 180 >> 2] = $2;
                 HEAP32[$4 + 176 >> 2] = $1;
                 jsiConsolePrintf(24901, $4 + 176 | 0);
                 break block17;
                }
                block18 : {
                 if (jsvIsUTF8String(HEAP32[$4 + 332 >> 2]) & 1) {
                  jsiConsolePrintf(16700, 0);
                  HEAP32[$4 + 300 >> 2] = jsvGetUTF8BackingString(HEAP32[$4 + 332 >> 2]);
                  _jsvTrace(HEAP32[$4 + 300 >> 2], 2, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
                  jsvUnLock(HEAP32[$4 + 300 >> 2]);
                  break block18;
                 }
                 block19 : {
                  if (jsvIsString(HEAP32[$4 + 332 >> 2]) & 1) {
                   HEAP32[$4 + 296 >> 2] = 1;
                   if (jsvGetLastChild(HEAP32[$4 + 332 >> 2]) & 65535) {
                    HEAP32[$4 + 292 >> 2] = jsvGetAddressOf(jsvGetLastChild(HEAP32[$4 + 332 >> 2]) & 65535);
                    HEAP32[$4 + 296 >> 2] = jsvCountJsVarsUsed(HEAP32[$4 + 292 >> 2]) + HEAP32[$4 + 296 >> 2];
                   }
                   if (jsvIsFlatString(HEAP32[$4 + 332 >> 2]) & 1) {
                    HEAP32[$4 + 296 >> 2] = jsvGetFlatStringBlocks(HEAP32[$4 + 332 >> 2]) + HEAP32[$4 + 296 >> 2]
                   }
                   HEAP32[$4 + 288 >> 2] = 28753;
                   if (jsvIsFlatString(HEAP32[$4 + 332 >> 2]) & 1) {
                    HEAP32[$4 + 288 >> 2] = 5037
                   }
                   if (jsvIsNativeString(HEAP32[$4 + 332 >> 2]) & 1) {
                    HEAP32[$4 + 288 >> 2] = 17262
                   }
                   if (jsvIsFlashString(HEAP32[$4 + 332 >> 2]) & 1) {
                    HEAP32[$4 + 288 >> 2] = 16324
                   }
                   $0 = HEAP32[$4 + 288 >> 2];
                   $1 = HEAP32[$4 + 296 >> 2];
                   HEAP32[$4 + 200 >> 2] = HEAP32[$4 + 332 >> 2];
                   HEAP32[$4 + 196 >> 2] = $1;
                   HEAP32[$4 + 192 >> 2] = $0;
                   jsiConsolePrintf(14813, $4 + 192 | 0);
                   break block19;
                  }
                  $0 = HEAP32[$4 + 332 >> 2];
                  HEAP32[$4 + 208 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 50175;
                  jsiConsolePrintf(19832, $4 + 208 | 0);
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
   if (jsvIsConstant(HEAP32[$4 + 332 >> 2]) & 1) {
    jsiConsolePrintf(27565, 0)
   }
   if (jsvIsNameInt(HEAP32[$4 + 332 >> 2]) & 1) {
    HEAP32[$4 >> 2] = jsvGetFirstChildSigned(HEAP32[$4 + 332 >> 2]) << 16 >> 16;
    jsiConsolePrintf(28432, $4);
    break block;
   }
   if (jsvIsNameIntBool(HEAP32[$4 + 332 >> 2]) & 1) {
    HEAP32[$4 + 16 >> 2] = jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535 ? 17314 : 17666;
    jsiConsolePrintf(28009, $4 + 16 | 0);
    break block;
   }
   block21 : {
    if (jsvHasSingleChild(HEAP32[$4 + 332 >> 2]) & 1) {
     block20 : {
      if (jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535) {
       $0 = jsvGetAddressOf(jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535);
       break block20;
      }
      $0 = 0;
     }
     HEAP32[$4 + 284 >> 2] = $0;
     _jsvTrace(HEAP32[$4 + 284 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
     break block21;
    }
    if (jsvHasChildren(HEAP32[$4 + 332 >> 2]) & 1) {
     jsvIteratorNew($4 + 220 | 0, HEAP32[$4 + 332 >> 2], 0);
     HEAP8[$4 + 219 | 0] = 1;
     while (1) {
      $0 = 0;
      if (jsvIteratorHasElement($4 + 220 | 0) & 1) {
       $0 = jspIsInterrupted() ^ -1
      }
      if ($0 & 1) {
       if (HEAP8[$4 + 219 | 0] & 1) {
        jsiConsolePrintf(28752, 0)
       }
       HEAP8[$4 + 219 | 0] = 0;
       HEAP32[$4 + 212 >> 2] = jsvIteratorGetKey($4 + 220 | 0);
       _jsvTrace(HEAP32[$4 + 212 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
       jsvUnLock(HEAP32[$4 + 212 >> 2]);
       jsiConsolePrintf(28752, 0);
       jsvIteratorNext($4 + 220 | 0);
       continue;
      }
      break;
     };
     jsvIteratorFree($4 + 220 | 0);
     if (!(HEAP8[$4 + 219 | 0] & 1)) {
      HEAP32[$4 + 316 >> 2] = 0;
      while (1) {
       if (HEAP32[$4 + 316 >> 2] < HEAP32[$4 + 328 >> 2]) {
        jsiConsolePrintString(27706);
        HEAP32[$4 + 316 >> 2] = HEAP32[$4 + 316 >> 2] + 1;
        continue;
       }
       break;
      };
     }
    }
   }
   HEAP32[$4 + 32 >> 2] = HEAP8[$4 + 307 | 0] << 24 >> 24;
   jsiConsolePrintf(20468, $4 + 32 | 0);
  }
  __stack_pointer = $4 + 336 | 0;
 }
 
 function jsvGetMaxCharactersInVar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsStringExt(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 10;
    break block;
   }
   if (jsvIsName(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 4;
    break block;
   }
   block2 : {
    block1 : {
     if (jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1) {
      break block1
     }
     if (jsvIsFlashString(HEAP32[$1 + 8 >> 2]) & 1) {
      break block1
     }
     if (!(jsvIsNativeString(HEAP32[$1 + 8 >> 2]) & 1)) {
      break block2
     }
    }
    HEAP32[$1 + 12 >> 2] = jsvGetCharactersInVar(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 9;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvGetCharactersInVar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 4 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  block : {
   if (HEAP32[$1 + 4 >> 2] == 39) {
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    break block;
   }
   if (!(HEAP32[$1 + 4 >> 2] != 40 & HEAP32[$1 + 4 >> 2] != 42)) {
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$1 + 12 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    break block;
   }
   if (HEAPU32[$1 + 4 >> 2] <= 28) {
    if (HEAPU32[$1 + 4 >> 2] <= 22) {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 18;
     break block;
    }
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 24;
    break block;
   }
   if (HEAPU32[$1 + 4 >> 2] <= 38) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 29;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 43;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvSetCharactersInVar($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$2 + 4 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP16[$2 + 2 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -64;
  block : {
   if (HEAPU32[$2 + 4 >> 2] <= 28) {
    if (HEAPU32[$2 + 4 >> 2] <= 22) {
     $0 = HEAP32[$2 + 12 >> 2];
     $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 18;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     break block;
    }
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 24;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
    break block;
   }
   block1 : {
    if (HEAPU32[$2 + 4 >> 2] <= 38) {
     $0 = HEAP32[$2 + 12 >> 2];
     $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 29;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     break block1;
    }
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 43;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
  }
 }
 
 function jsvFreePtrStringExt($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP16[$1 + 10 >> 1] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
  if (HEAPU16[$1 + 10 >> 1]) {
   HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 10 >> 1]);
   while (1) {
    $0 = HEAP32[$1 + 4 >> 2];
    HEAP8[$0 + 12 | 0] = 0;
    HEAP8[$0 + 13 | 0] = 0;
    HEAP16[$1 + 10 >> 1] = jsvGetLastChild(HEAP32[$1 + 4 >> 2]);
    if (HEAPU16[$1 + 10 >> 1]) {
     jsvSetNextSibling(HEAP32[$1 + 4 >> 2], HEAPU16[$1 + 10 >> 1]);
     HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 10 >> 1]);
     continue;
    }
    break;
   };
   jshInterruptOff();
   jsvSetNextSibling(HEAP32[$1 + 4 >> 2], HEAPU16[122604]);
   HEAP16[122604] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
   HEAP8[245205] = 1;
   jshInterruptOn();
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvFreePtr($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  if (!(jsvIsNameWithValue(HEAP32[$1 + 28 >> 2]) & 1)) {
   if (jsvHasSingleChild(HEAP32[$1 + 28 >> 2]) & 1) {
    if (jsvGetFirstChild(HEAP32[$1 + 28 >> 2]) & 65535) {
     if (jsuGetFreeStack() >>> 0 > 256) {
      HEAP32[$1 + 24 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 28 >> 2]) & 65535);
      jsvUnRef(HEAP32[$1 + 24 >> 2]);
      jsvUnLock(HEAP32[$1 + 24 >> 2]);
     }
    }
   }
  }
  block : {
   if (jsvIsUTF8String(HEAP32[$1 + 28 >> 2]) & 1) {
    jsvUnRefRef(jsvGetLastChild(HEAP32[$1 + 28 >> 2]) & 65535);
    jsvSetLastChild(HEAP32[$1 + 28 >> 2], 0);
    break block;
   }
   block1 : {
    if (jsvHasStringExt(HEAP32[$1 + 28 >> 2]) & 1) {
     jsvFreePtrStringExt(HEAP32[$1 + 28 >> 2]);
     break block1;
    }
    if (jsvIsFlatString(HEAP32[$1 + 28 >> 2]) & 1) {
     HEAP32[$1 + 20 >> 2] = jsvGetFlatStringBlocks(HEAP32[$1 + 28 >> 2]);
     HEAP16[$1 + 18 >> 1] = (jsvGetRef(HEAP32[$1 + 28 >> 2]) & 65535) + HEAP32[$1 + 20 >> 2];
     jshInterruptOff();
     HEAP16[$1 + 16 >> 1] = HEAPU16[122604];
     HEAP16[$1 + 14 >> 1] = 0;
     while (1) {
      $0 = 0;
      $0 = HEAPU16[$1 + 16 >> 1] ? HEAPU16[$1 + 16 >> 1] < HEAPU16[$1 + 18 >> 1] : $0;
      if ($0) {
       HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 16 >> 1];
       HEAP16[$1 + 16 >> 1] = jsvGetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 16 >> 1]));
       continue;
      }
      break;
     };
     while (1) {
      $0 = HEAP32[$1 + 20 >> 2];
      HEAP32[$1 + 20 >> 2] = $0 - 1;
      if ($0) {
       $0 = HEAPU16[$1 + 18 >> 1];
       HEAP16[$1 + 18 >> 1] = $0 - 1;
       HEAP32[$1 + 8 >> 2] = jsvGetAddressOf($0);
       $0 = HEAP32[$1 + 8 >> 2];
       HEAP8[$0 + 12 | 0] = 0;
       HEAP8[$0 + 13 | 0] = 0;
       jsvSetNextSibling(HEAP32[$1 + 8 >> 2], HEAPU16[$1 + 16 >> 1]);
       HEAP16[$1 + 16 >> 1] = jsvGetRef(HEAP32[$1 + 8 >> 2]);
       continue;
      }
      break;
     };
     block2 : {
      if (HEAPU16[$1 + 14 >> 1]) {
       jsvSetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]), HEAPU16[$1 + 16 >> 1]);
       break block2;
      }
      HEAP16[122604] = HEAPU16[$1 + 16 >> 1];
     }
     HEAP8[245205] = 1;
     jshInterruptOn();
    }
   }
  }
  block3 : {
   if (jsvHasChildren(HEAP32[$1 + 28 >> 2]) & 1) {
    HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 28 >> 2]);
    while (1) {
     if (HEAPU16[$1 + 6 >> 1]) {
      HEAP32[$1 >> 2] = jsvLock(HEAPU16[$1 + 6 >> 1]);
      HEAP16[$1 + 6 >> 1] = jsvGetPrevSibling(HEAP32[$1 >> 2]);
      jsvSetPrevSibling(HEAP32[$1 >> 2], 0);
      jsvSetNextSibling(HEAP32[$1 >> 2], 0);
      jsvUnRef(HEAP32[$1 >> 2]);
      jsvUnLock(HEAP32[$1 >> 2]);
      continue;
     }
     break;
    };
    break block3;
   }
   if (jsvIsName(HEAP32[$1 + 28 >> 2]) & 1) {
    if (jsvGetNextSibling(HEAP32[$1 + 28 >> 2]) & 65535) {
     jsvUnRefRef(jsvGetNextSibling(HEAP32[$1 + 28 >> 2]) & 65535);
     jsvUnRefRef(jsvGetPrevSibling(HEAP32[$1 + 28 >> 2]) & 65535);
    }
   }
  }
  jsvFreePtrInternal(HEAP32[$1 + 28 >> 2]);
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsvUnRef($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP16[$1 + 10 >> 1] = jsvGetRefs(HEAP32[$1 + 12 >> 2]);
  if (HEAPU16[$1 + 10 >> 1] < 255) {
   HEAP16[$1 + 10 >> 1] = HEAPU16[$1 + 10 >> 1] - 1;
   jsvSetRefs(HEAP32[$1 + 12 >> 2], HEAPU16[$1 + 10 >> 1]);
   block : {
    if (HEAPU16[$1 + 10 >> 1]) {
     break block
    }
    if (jsvGetLocks(HEAP32[$1 + 12 >> 2]) & 255) {
     break block
    }
    jsvUnLockFreeIfNeeded(HEAP32[$1 + 12 >> 2]);
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvUnLock($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLockInline(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvUnRefRef($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP16[$1 + 14 >> 1] = $0;
  HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 14 >> 1]);
  jsvUnRef(HEAP32[$1 + 8 >> 2]);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return 0;
 }
 
 function jsvGetRef($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP16[$1 + 14 >> 1] = 0;
    break block;
   }
   HEAP16[$1 + 14 >> 1] = ((HEAP32[$1 + 8 >> 2] - 245212 | 0) / 14 | 0) + 1;
  }
  return HEAPU16[$1 + 14 >> 1];
 }
 
 function jsvFreePtrInternal($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 12 | 0] = 0;
  HEAP8[$0 + 13 | 0] = 0;
  jshInterruptOff();
  jsvSetNextSibling(HEAP32[$1 + 12 >> 2], HEAPU16[122604]);
  HEAP16[122604] = jsvGetRef(HEAP32[$1 + 12 >> 2]);
  HEAP8[245205] = 1;
  jshInterruptOn();
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvUnLockFreeIfNeeded($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) {
    break block
   }
   if (!(jsvHasRef(HEAP32[$1 + 12 >> 2]) & 1)) {
    break block
   }
   $0 = HEAP32[$1 + 12 >> 2];
   if (!((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63)) {
    break block
   }
   jsvFreePtr(HEAP32[$1 + 12 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvUnLockInline($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 12 >> 2]) {
    break block
   }
   $0 = HEAP32[$1 + 12 >> 2];
   if (((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 15360) == 15360) {
    break block
   }
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1024 | 0;
   HEAP8[$0 + 12 | 0] = $2;
   HEAP8[$0 + 13 | 0] = $2 >>> 8;
   HEAP16[$1 + 10 >> 1] = $2;
   if (HEAPU16[$1 + 10 >> 1] & 15360) {
    break block
   }
   jsvUnLockFreeIfNeeded(HEAP32[$1 + 12 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvLockSafe($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP16[$1 + 10 >> 1] = $0;
  block : {
   if (!HEAPU16[$1 + 10 >> 1]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLock(HEAPU16[$1 + 10 >> 1]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvLockAgain($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  if (((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 15360) != 15360) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) + 1024 | 0;
   HEAP8[$0 + 12 | 0] = $2;
   HEAP8[$0 + 13 | 0] = $2 >>> 8;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvLockAgainSafe($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (HEAP32[$1 + 12 >> 2]) {
    $0 = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
    break block;
   }
   $0 = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jsvUnLock2($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsvUnLockInline(HEAP32[$2 + 12 >> 2]);
  jsvUnLockInline(HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvUnLock3($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jsvUnLockInline(HEAP32[$3 + 12 >> 2]);
  jsvUnLockInline(HEAP32[$3 + 8 >> 2]);
  jsvUnLockInline(HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvUnLock4($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  jsvUnLockInline(HEAP32[$4 + 12 >> 2]);
  jsvUnLockInline(HEAP32[$4 + 8 >> 2]);
  jsvUnLockInline(HEAP32[$4 + 4 >> 2]);
  jsvUnLockInline(HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function jsvUnLockMany($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  while (1) {
   if (HEAP32[$2 + 12 >> 2]) {
    $1 = HEAP32[$2 + 8 >> 2];
    $0 = HEAP32[$2 + 12 >> 2] - 1 | 0;
    HEAP32[$2 + 12 >> 2] = $0;
    jsvUnLockInline(HEAP32[($0 << 2) + $1 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvHasRef($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvIsStringExt(HEAP32[$1 + 12 >> 2]) ^ -1;
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jsvRefRef($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP16[$1 + 14 >> 1] = $0;
  HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 14 >> 1]);
  jsvRef(HEAP32[$1 + 8 >> 2]);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAPU16[$1 + 14 >> 1];
 }
 
 function jsvNewFlatStringOfLength($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 40 >> 2] = $0;
  HEAP8[$1 + 39 | 0] = 1;
  HEAP32[$1 + 32 >> 2] = ((HEAP32[$1 + 40 >> 2] + 13 >>> 0) / 14 | 0) + 1;
  HEAP32[$1 + 28 >> 2] = 0;
  block : {
   if (HEAPU8[245206]) {
    HEAP8[413226] = HEAPU8[413226] | 32;
    HEAP32[$1 + 44 >> 2] = 0;
    break block;
   }
   while (1) {
    HEAP8[$1 + 27 | 0] = 1;
    while (1) {
     if (HEAP8[$1 + 27 | 0] & 1) {
      HEAP8[$1 + 27 | 0] = 0;
      HEAP8[245205] = 0;
      HEAP16[$1 + 24 >> 1] = 0;
      HEAP16[$1 + 22 >> 1] = HEAPU16[122604];
      HEAP16[$1 + 20 >> 1] = HEAPU16[$1 + 22 >> 1];
      HEAP32[$1 + 16 >> 2] = 0;
      while (1) {
       $0 = 0;
       block1 : {
        $0 = HEAPU16[$1 + 22 >> 1] ? HEAPU8[245205] ^ -1 : $0;
        if (!($0 & 1)) {
         break block1
        }
        HEAP32[$1 + 12 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 22 >> 1]);
        HEAP16[$1 + 10 >> 1] = jsvGetNextSibling(HEAP32[$1 + 12 >> 2]);
        block4 : {
         if (!(!HEAP32[$1 + 16 >> 2] | HEAPU16[$1 + 10 >> 1] != (HEAPU16[$1 + 22 >> 1] + 1 | 0))) {
          HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
          if (HEAPU32[$1 + 16 >> 2] >= HEAPU32[$1 + 32 >> 2]) {
           HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 10 >> 1]);
           HEAP16[$1 + 2 >> 1] = jsvGetNextSibling(HEAP32[$1 + 4 >> 2]);
           jshInterruptOff();
           if (!(HEAP8[245205] & 1)) {
            block3 : {
             if (HEAPU16[$1 + 24 >> 1]) {
              jsvSetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 24 >> 1]), HEAPU16[$1 + 2 >> 1]);
              break block3;
             }
             HEAP16[122604] = HEAPU16[$1 + 2 >> 1];
            }
            HEAP32[$1 + 28 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 20 >> 1]);
            jsvResetVariable(HEAP32[$1 + 28 >> 2], 39);
            $0 = HEAP32[$1 + 28 >> 2];
            $2 = HEAP32[$1 + 40 >> 2];
            HEAP8[$0 | 0] = $2;
            HEAP8[$0 + 1 | 0] = $2 >>> 8;
            HEAP8[$0 + 2 | 0] = $2 >>> 16;
            HEAP8[$0 + 3 | 0] = $2 >>> 24;
           }
           jshInterruptOn();
           if (HEAP32[$1 + 28 >> 2]) {
            break block1
           }
          }
          break block4;
         }
         HEAP16[$1 + 24 >> 1] = HEAPU16[$1 + 22 >> 1];
         HEAP16[$1 + 20 >> 1] = HEAPU16[$1 + 10 >> 1];
         block6 : {
          block5 : {
           if (HEAPU16[$1 + 20 >> 1] != 12e3) {
            if (!(jsvGetAddressOf(HEAPU16[$1 + 20 >> 1] + 1 & 65535) & 3)) {
             break block5
            }
           }
           HEAP32[$1 + 16 >> 2] = 0;
           break block6;
          }
          HEAP32[$1 + 16 >> 2] = 1;
         }
        }
        HEAP16[$1 + 22 >> 1] = HEAPU16[$1 + 10 >> 1];
        continue;
       }
       break;
      };
      if (HEAP8[245205] & 1) {
       HEAP8[$1 + 27 | 0] = 1
      }
      continue;
     }
     break;
    };
    if (!(HEAP32[$1 + 28 >> 2] | !(HEAP8[$1 + 39 | 0] & 1))) {
     HEAP8[$1 + 39 | 0] = 0;
     jsvGarbageCollect();
     continue;
    }
    break;
   };
   if (!HEAP32[$1 + 28 >> 2]) {
    HEAP32[$1 + 44 >> 2] = 0;
    break block;
   }
   $2 = HEAP32[$1 + 28 >> 2];
   $0 = Math_imul(HEAP32[$1 + 32 >> 2] - 1 | 0, 14);
   if ($0) {
    wasm2js_memory_fill($2 + 14 | 0, 0, $0)
   }
   HEAP8[245205] = 1;
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 28 >> 2];
  }
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 44 >> 2];
 }
 
 function jsvNewFromString($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvNewNameOrString(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jsvNewNameOrString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP8[$2 + 23 | 0] = $1;
  HEAP32[$2 + 16 >> 2] = jsvNewWithFlags(HEAP8[$2 + 23 | 0] & 1 ? 24 : 29);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 16 >> 2]);
   while (1) {
    if (HEAPU8[HEAP32[$2 + 24 >> 2]]) {
     HEAP32[$2 + 4 >> 2] = jsvGetMaxCharactersInVar(HEAP32[$2 + 12 >> 2]);
     HEAP32[$2 + 8 >> 2] = 0;
     while (1) {
      $0 = 0;
      $0 = HEAPU32[$2 + 8 >> 2] < HEAPU32[$2 + 4 >> 2] ? HEAPU8[HEAP32[$2 + 24 >> 2]] != 0 : $0;
      if ($0) {
       $0 = HEAP32[$2 + 24 >> 2];
       HEAP32[$2 + 24 >> 2] = $0 + 1;
       HEAP8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0] = HEAPU8[$0 | 0];
       HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
       continue;
      }
      break;
     };
     jsvSetCharactersInVar(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
     if (HEAPU8[HEAP32[$2 + 24 >> 2]]) {
      HEAP32[$2 >> 2] = jsvNewWithFlags(43);
      if (!HEAP32[$2 >> 2]) {
       jsvUnLock(HEAP32[$2 + 12 >> 2]);
       HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
       break block;
      }
      jsvSetLastChild(HEAP32[$2 + 12 >> 2], jsvGetRef(HEAP32[$2 >> 2]) & 65535);
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
     }
     continue;
    }
    break;
   };
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvNewNameFromString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvNewNameOrString(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvNewStringOfLength($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (HEAPU32[$2 + 24 >> 2] > 19) {
    HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 24 >> 2]);
    if (HEAP32[$2 + 16 >> 2]) {
     if (HEAP32[$2 + 20 >> 2]) {
      jsvSetString(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2])
     }
     HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
     break block;
    }
   }
   HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(29);
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 8 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
   while (1) {
    block1 : {
     HEAP32[$2 + 4 >> 2] = jsvGetMaxCharactersInVar(HEAP32[$2 + 8 >> 2]);
     if (HEAPU32[$2 + 4 >> 2] >= HEAPU32[$2 + 24 >> 2]) {
      if (HEAP32[$2 + 20 >> 2]) {
       $1 = HEAP32[$2 + 8 >> 2];
       $3 = HEAP32[$2 + 20 >> 2];
       $0 = HEAP32[$2 + 24 >> 2];
       if ($0) {
        wasm2js_memory_copy($1, $3, $0)
       }
      }
      jsvSetCharactersInVar(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 24 >> 2]);
      break block1;
     }
     if (HEAP32[$2 + 20 >> 2]) {
      $1 = HEAP32[$2 + 8 >> 2];
      $3 = HEAP32[$2 + 20 >> 2];
      $0 = HEAP32[$2 + 4 >> 2];
      if ($0) {
       wasm2js_memory_copy($1, $3, $0)
      }
      HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 4 >> 2] + HEAP32[$2 + 20 >> 2];
     }
     jsvSetCharactersInVar(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
     HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] - HEAP32[$2 + 4 >> 2];
     HEAP32[$2 >> 2] = jsvNewWithFlags(43);
     if (!HEAP32[$2 >> 2]) {
      break block1
     }
     jsvSetLastChild(HEAP32[$2 + 8 >> 2], jsvGetRef(HEAP32[$2 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     HEAP32[$2 + 8 >> 2] = HEAP32[$2 >> 2];
     continue;
    }
    break;
   };
   jsvUnLock(HEAP32[$2 + 8 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvSetString($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  jsvStringIteratorNew($3 + 12 | 0, HEAP32[$3 + 60 >> 2], 0);
  HEAP32[$3 + 8 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 8 >> 2] < HEAPU32[$3 + 52 >> 2]) {
    jsvStringIteratorSetCharAndNext($3 + 12 | 0, HEAP8[HEAP32[$3 + 56 >> 2] + HEAP32[$3 + 8 >> 2] | 0] << 24 >> 24);
    HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($3 + 12 | 0);
  __stack_pointer = $3 - -64 | 0;
 }
 
 function jsvStringIteratorFree_189($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvNewUTF8String($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   if (jsvIsUTF8String(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(41);
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   jsvSetLastChild(HEAP32[$1 + 4 >> 2], jsvGetRef(jsvRef(HEAP32[$1 + 8 >> 2])) & 65535);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvNewUTF8StringAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvNewUTF8String(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvNewFromInteger($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(10);
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 4 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   HEAP8[$0 | 0] = $2;
   HEAP8[$0 + 1 | 0] = $2 >>> 8;
   HEAP8[$0 + 2 | 0] = $2 >>> 16;
   HEAP8[$0 + 3 | 0] = $2 >>> 24;
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvNewFromBool($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 11 | 0] = $0;
  HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(12);
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 4 >> 2];
   $2 = HEAP8[$1 + 11 | 0] & 1;
   HEAP8[$0 | 0] = $2;
   HEAP8[$0 + 1 | 0] = $2 >>> 8;
   HEAP8[$0 + 2 | 0] = $2 >>> 16;
   HEAP8[$0 + 3 | 0] = $2 >>> 24;
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvNewFromFloat($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 16 >> 3] = $0;
  HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(11);
  block : {
   if (!HEAP32[$1 + 12 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   $2 = HEAP32[$1 + 12 >> 2];
   wasm2js_scratch_store_f64(+HEAPF64[$1 + 16 >> 3]);
   $3 = wasm2js_scratch_load_i32(1) | 0;
   $4 = wasm2js_scratch_load_i32(0) | 0;
   HEAP8[$2 | 0] = $4;
   HEAP8[$2 + 1 | 0] = $4 >>> 8;
   HEAP8[$2 + 2 | 0] = $4 >>> 16;
   HEAP8[$2 + 3 | 0] = $4 >>> 24;
   HEAP8[$2 + 4 | 0] = $3;
   HEAP8[$2 + 5 | 0] = $3 >>> 8;
   HEAP8[$2 + 6 | 0] = $3 >>> 16;
   HEAP8[$2 + 7 | 0] = $3 >>> 24;
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvNewFromLongInteger($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  $1 = HEAP32[$2 >> 2];
  block1 : {
   block : {
    $0 = HEAP32[$2 + 4 >> 2];
    if (($0 | 0) < -1) {
     $0 = 1
    } else {
     $0 = ($0 | 0) < 0 & $1 >>> 0 < 2147483648
    }
    if ($0) {
     break block
    }
    $1 = HEAP32[$2 >> 2];
    $0 = HEAP32[$2 + 4 >> 2];
    if (($0 | 0) > 0) {
     $0 = 1
    } else {
     $0 = $1 >>> 0 > 2147483647 & ($0 | 0) >= 0
    }
    if ($0) {
     break block
    }
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 + 12 >> 2] = jsvNewFromInteger($1);
    break block1;
   }
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 12 >> 2] = jsvNewFromFloat(+($0 >>> 0) + +($1 | 0) * 4294967296.0);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvNewFromPin($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvNewFromInteger(HEAP32[$1 + 12 >> 2]);
  if (HEAP32[$1 + 8 >> 2]) {
   $0 = HEAP32[$1 + 8 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   $2 = (HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8) & -64 | 13;
   HEAP8[$0 + 12 | 0] = $2;
   HEAP8[$0 + 13 | 0] = $2 >>> 8;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvNewObject() {
  return jsvNewWithFlags(5);
 }
 
 function jsvNewEmptyArray() {
  return jsvNewWithFlags(3);
 }
 
 function jsvNewArray($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 20 >> 2]) {
     jsvArrayPush(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 24 >> 2] + (HEAP32[$2 + 12 >> 2] << 2) >> 2]);
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvArrayPush($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$2 + 16 >> 2]), HEAP32[$2 + 20 >> 2]);
  block : {
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   jsvAddName(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 28 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvGetArrayLength($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvMakeIntoVariableName($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $0;
  HEAP32[$2 + 100 >> 2] = $1;
  block : {
   if (!HEAP32[$2 + 104 >> 2]) {
    HEAP32[$2 + 108 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$2 + 104 >> 2];
   HEAP16[$2 + 98 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   block3 : {
    if (HEAPU16[$2 + 98 >> 1] == 10) {
     HEAP32[$2 + 92 >> 2] = 15;
     block1 : {
      if (!(jsvIsInt(HEAP32[$2 + 100 >> 2]) & 1)) {
       if (!(jsvIsBoolean(HEAP32[$2 + 100 >> 2]) & 1)) {
        break block1
       }
      }
      if (jsvIsPin(HEAP32[$2 + 100 >> 2]) & 1) {
       break block1
      }
      $0 = HEAP32[$2 + 100 >> 2];
      HEAP32[$2 + 88 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (!(HEAP32[$2 + 88 >> 2] < -8192 | HEAP32[$2 + 88 >> 2] > 8191)) {
       HEAP32[$2 + 92 >> 2] = jsvIsInt(HEAP32[$2 + 100 >> 2]) & 1 ? 16 : 17;
       jsvSetFirstChild(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 88 >> 2] & 65535);
       HEAP32[$2 + 100 >> 2] = 0;
      }
     }
     $0 = HEAP32[$2 + 104 >> 2];
     $1 = HEAP32[$2 + 104 >> 2];
     $1 = HEAP32[$2 + 92 >> 2] | (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     break block3;
    }
    block4 : {
     if (jsvIsUTF8String(HEAP32[$2 + 104 >> 2]) & 1) {
      $0 = HEAP32[$2 + 104 >> 2];
      $1 = HEAP32[$2 + 104 >> 2];
      $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 65472 | 23;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
      break block4;
     }
     if (!(HEAPU16[$2 + 98 >> 1] < 18 | HEAPU16[$2 + 98 >> 1] > 42)) {
      block8 : {
       if (!(!(HEAPU16[$2 + 98 >> 1] == 39 | HEAPU16[$2 + 98 >> 1] == 40) & HEAPU16[$2 + 98 >> 1] != 42)) {
        HEAP32[$2 + 84 >> 2] = jsvNewWithFlags(24);
        jsvAppendStringVarComplete(HEAP32[$2 + 84 >> 2], HEAP32[$2 + 104 >> 2]);
        jsvUnLock(HEAP32[$2 + 104 >> 2]);
        HEAP32[$2 + 104 >> 2] = HEAP32[$2 + 84 >> 2];
        break block8;
       }
       if (jsvGetCharactersInVar(HEAP32[$2 + 104 >> 2]) >>> 0 > 4) {
        jsvStringIteratorNew($2 + 44 | 0, HEAP32[$2 + 104 >> 2], 4);
        HEAP32[$2 + 32 >> 2] = 0;
        while (1) {
         $0 = 0;
         if (HEAP32[$2 + 32 >> 2] < 5) {
          $0 = jsvStringIteratorHasChar_210($2 + 44 | 0)
         }
         if ($0 & 1) {
          $0 = jsvStringIteratorGetCharAndNext($2 + 44 | 0);
          HEAP8[HEAP32[$2 + 32 >> 2] + ($2 + 39 | 0) | 0] = $0;
          HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
          continue;
         }
         break;
        };
        jsvStringIteratorFree_189($2 + 44 | 0);
        HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 104 >> 2];
        while (1) {
         if (jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) {
          HEAP32[$2 + 28 >> 2] = jsvGetAddressOf(jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535);
          continue;
         }
         break;
        };
        if (HEAP32[$2 + 28 >> 2] != HEAP32[$2 + 104 >> 2]) {
         HEAP32[$2 + 24 >> 2] = jsvGetCharactersInVar(HEAP32[$2 + 28 >> 2]) + HEAP32[$2 + 32 >> 2];
         block9 : {
          if (HEAP32[$2 + 24 >> 2] <= 10) {
           jsvSetCharactersInVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
           HEAP32[$2 + 28 >> 2] = 0;
           break block9;
          }
          HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 24 >> 2] - 10;
         }
        }
        if (HEAP32[$2 + 28 >> 2]) {
         jsvSetCharactersInVar(HEAP32[$2 + 28 >> 2], jsvGetMaxCharactersInVar(HEAP32[$2 + 28 >> 2]));
         HEAP32[$2 + 20 >> 2] = jsvNewWithFlags(43);
         if (HEAP32[$2 + 20 >> 2]) {
          jsvSetCharactersInVar(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 32 >> 2]);
          jsvSetLastChild(HEAP32[$2 + 28 >> 2], jsvGetRef(HEAP32[$2 + 20 >> 2]) & 65535);
          jsvUnLock(HEAP32[$2 + 20 >> 2]);
         }
        }
        jsvStringIteratorNew($2 + 44 | 0, HEAP32[$2 + 104 >> 2], 9);
        HEAP32[$2 + 32 >> 2] = 0;
        while (1) {
         if (jsvStringIteratorHasChar_210($2 + 44 | 0) & 1) {
          HEAP8[$2 + 19 | 0] = jsvStringIteratorGetChar_212($2 + 44 | 0);
          jsvStringIteratorSetChar($2 + 44 | 0, HEAP8[HEAP32[$2 + 32 >> 2] + ($2 + 39 | 0) | 0] << 24 >> 24);
          HEAP8[HEAP32[$2 + 32 >> 2] + ($2 + 39 | 0) | 0] = HEAPU8[$2 + 19 | 0];
          jsvStringIteratorNext($2 + 44 | 0);
          HEAP32[$2 + 32 >> 2] = (HEAP32[$2 + 32 >> 2] + 1 | 0) % 5;
          continue;
         }
         break;
        };
        jsvStringIteratorFree_189($2 + 44 | 0);
        jsvSetCharactersInVar(HEAP32[$2 + 104 >> 2], 4);
        jsvSetNextSibling(HEAP32[$2 + 104 >> 2], 0);
        jsvSetPrevSibling(HEAP32[$2 + 104 >> 2], 0);
        jsvSetFirstChild(HEAP32[$2 + 104 >> 2], 0);
       }
      }
      HEAP32[$2 + 12 >> 2] = 24;
      block12 : {
       block10 : {
        if (!(jsvIsInt(HEAP32[$2 + 100 >> 2]) & 1)) {
         break block10
        }
        if (jsvIsPin(HEAP32[$2 + 100 >> 2]) & 1) {
         break block10
        }
        $0 = HEAP32[$2 + 100 >> 2];
        HEAP32[$2 + 8 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
        if (!(HEAP32[$2 + 8 >> 2] < -8192 | HEAP32[$2 + 8 >> 2] > 8191)) {
         HEAP32[$2 + 12 >> 2] = 18;
         jsvSetFirstChild(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 8 >> 2] & 65535);
         HEAP32[$2 + 100 >> 2] = 0;
        }
        break block12;
       }
       jsvSetFirstChild(HEAP32[$2 + 104 >> 2], 0);
      }
      $0 = HEAP32[$2 + 104 >> 2];
      $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
      $3 = HEAP32[$2 + 12 >> 2] + jsvGetCharactersInVar(HEAP32[$2 + 104 >> 2]) | 0;
      $0 = HEAP32[$2 + 104 >> 2];
      $1 = $1 | $3;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
     }
    }
   }
   if (HEAP32[$2 + 100 >> 2]) {
    jsvSetFirstChild(HEAP32[$2 + 104 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 100 >> 2])) & 65535)
   }
   HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 104 >> 2];
  }
  __stack_pointer = $2 + 112 | 0;
  return HEAP32[$2 + 108 >> 2];
 }
 
 function jsvAddName($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 24 >> 2] = jsvRef(HEAP32[$2 + 24 >> 2]);
  block : {
   if (!(jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1)) {
    break block
   }
   if (!(jsvIsInt(HEAP32[$2 + 24 >> 2]) & 1)) {
    break block
   }
   $0 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 20 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   if (HEAP32[$2 + 20 >> 2] >= (jsvGetArrayLength(HEAP32[$2 + 28 >> 2]) | 0)) {
    jsvSetArrayLength(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2] + 1 | 0, 0)
   }
  }
  block3 : {
   if (jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) {
    HEAP32[$2 + 16 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535);
    if (jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1) {
     while (1) {
      $0 = 0;
      if (HEAP32[$2 + 16 >> 2]) {
       $0 = (jsvCompareInteger(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2]) | 0) < 0
      }
      if ($0) {
       HEAP16[$2 + 14 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 16 >> 2]);
       jsvUnLock(HEAP32[$2 + 16 >> 2]);
       HEAP32[$2 + 16 >> 2] = jsvLockSafe(HEAPU16[$2 + 14 >> 1]);
       continue;
      }
      break;
     }
    }
    block2 : {
     if (HEAP32[$2 + 16 >> 2]) {
      block1 : {
       if (jsvGetNextSibling(HEAP32[$2 + 16 >> 2]) & 65535) {
        HEAP32[$2 + 8 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 16 >> 2]) & 65535);
        jsvSetPrevSibling(HEAP32[$2 + 8 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
        jsvSetNextSibling(HEAP32[$2 + 24 >> 2], jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535);
        jsvUnLock(HEAP32[$2 + 8 >> 2]);
        break block1;
       }
       jsvSetLastChild(HEAP32[$2 + 28 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
      }
      jsvSetNextSibling(HEAP32[$2 + 16 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
      jsvSetPrevSibling(HEAP32[$2 + 24 >> 2], jsvGetRef(HEAP32[$2 + 16 >> 2]) & 65535);
      jsvUnLock(HEAP32[$2 + 16 >> 2]);
      break block2;
     }
     HEAP32[$2 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535);
     jsvSetPrevSibling(HEAP32[$2 + 4 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 4 >> 2]);
     jsvSetNextSibling(HEAP32[$2 + 24 >> 2], jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535);
     jsvSetFirstChild(HEAP32[$2 + 28 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
    }
    break block3;
   }
   HEAP16[$2 + 2 >> 1] = jsvGetRef(HEAP32[$2 + 24 >> 2]);
   jsvSetFirstChild(HEAP32[$2 + 28 >> 2], HEAPU16[$2 + 2 >> 1]);
   jsvSetLastChild(HEAP32[$2 + 28 >> 2], HEAPU16[$2 + 2 >> 1]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jsvArrayPushAndUnLock($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvArrayPush(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  jsvUnLock(HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 4 >> 2];
 }
 
 function jsvNewNativeFunction($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP16[$2 + 6 >> 1] = $1;
  HEAP32[$2 >> 2] = jsvNewWithFlags(8);
  block : {
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
   $0 = HEAP32[$2 >> 2];
   $1 = HEAPU16[$2 + 6 >> 1];
   HEAP8[$0 + 4 | 0] = $1;
   HEAP8[$0 + 5 | 0] = $1 >>> 8;
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvNewNativeString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = jsvNewWithFlags(40);
  block : {
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP8[$0 + 4 | 0] = $1;
   HEAP8[$0 + 5 | 0] = $1 >>> 8;
   HEAP8[$0 + 6 | 0] = $1 >>> 16;
   HEAP8[$0 + 7 | 0] = $1 >>> 24;
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvNewFlashString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = jsvNewWithFlags(42);
  block : {
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 8 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP8[$0 + 4 | 0] = $1;
   HEAP8[$0 + 5 | 0] = $1 >>> 8;
   HEAP8[$0 + 6 | 0] = $1 >>> 16;
   HEAP8[$0 + 7 | 0] = $1 >>> 24;
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvNewArrayBufferFromString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = jsvNewWithFlags(4);
  block : {
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   jsvSetFirstChild(HEAP32[$2 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 8 >> 2])) & 65535);
   HEAP8[HEAP32[$2 >> 2] + 5 | 0] = 129;
   if (!HEAP32[$2 + 4 >> 2]) {
    HEAP32[$2 + 4 >> 2] = jsvGetStringLength(HEAP32[$2 + 8 >> 2])
   }
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP8[$0 + 2 | 0] = $1;
   HEAP8[$0 + 3 | 0] = $1 >>> 8;
   HEAP8[$0 + 4 | 0] = $1 >>> 16;
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvGetStringLength($0) {
  var $1 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 56 >> 2] = $0;
  HEAP32[$1 + 52 >> 2] = 0;
  block : {
   if (jsvIsUTF8String(HEAP32[$1 + 56 >> 2]) & 1) {
    jsvStringIteratorNew($1 + 12 | 0, HEAP32[$1 + 56 >> 2], 0);
    while (1) {
     if (jsvStringIteratorHasChar_210($1 + 12 | 0) & 1) {
      jsvStringIteratorNextUTF8($1 + 12 | 0);
      HEAP32[$1 + 52 >> 2] = HEAP32[$1 + 52 >> 2] + 1;
      continue;
     }
     break;
    };
    jsvStringIteratorFree_189($1 + 12 | 0);
    HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 52 >> 2];
    break block;
   }
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 56 >> 2];
   HEAP32[$1 + 4 >> 2] = 0;
   if (!(jsvHasCharacterData(HEAP32[$1 + 56 >> 2]) & 1)) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   while (1) {
    if (HEAP32[$1 + 8 >> 2]) {
     HEAP16[$1 + 2 >> 1] = jsvGetLastChild(HEAP32[$1 + 8 >> 2]);
     HEAP32[$1 + 52 >> 2] = jsvGetCharactersInVar(HEAP32[$1 + 8 >> 2]) + HEAP32[$1 + 52 >> 2];
     jsvUnLock(HEAP32[$1 + 4 >> 2]);
     $0 = jsvLockSafe(HEAPU16[$1 + 2 >> 1]);
     HEAP32[$1 + 4 >> 2] = $0;
     HEAP32[$1 + 8 >> 2] = $0;
     continue;
    }
    break;
   };
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 52 >> 2];
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP32[$1 + 60 >> 2];
 }
 
 function jsvStringIteratorHasChar_210($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvAppendStringVarComplete($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsvAppendStringVar(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 2147483647);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvStringIteratorGetChar_212($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function jsvAppendStringVar($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 112 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 108 >> 2] = $0;
  HEAP32[$4 + 104 >> 2] = $1;
  HEAP32[$4 + 100 >> 2] = $2;
  HEAP32[$4 + 96 >> 2] = $3;
  jsvStringIteratorNew($4 + 56 | 0, HEAP32[$4 + 108 >> 2], 0);
  jsvStringIteratorGotoEnd($4 + 56 | 0);
  jsvStringIteratorNew($4 + 16 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
  while (1) {
   $0 = 0;
   if (jsvStringIteratorHasChar_210($4 + 16 | 0) & 1) {
    $0 = HEAP32[$4 + 96 >> 2];
    HEAP32[$4 + 96 >> 2] = $0 - 1;
    $0 = ($0 | 0) != 0;
   }
   if ($0) {
    HEAP8[$4 + 15 | 0] = jsvStringIteratorGetCharAndNext($4 + 16 | 0);
    jsvStringIteratorAppend($4 + 56 | 0, HEAP8[$4 + 15 | 0] << 24 >> 24);
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($4 + 16 | 0);
  jsvStringIteratorFree_189($4 + 56 | 0);
  __stack_pointer = $4 + 112 | 0;
 }
 
 function jsvMakeFunctionParameter($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (!(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(HEAP32[$1 + 12 >> 2], 0)
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = HEAP32[$1 + 12 >> 2];
  $2 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | 128;
  HEAP8[$0 + 12 | 0] = $2;
  HEAP8[$0 + 13 | 0] = $2 >>> 8;
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvAddFunctionParameter($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  if (!HEAP32[$3 + 8 >> 2]) {
   HEAP32[$3 + 8 >> 2] = jsvNewFromEmptyString_216()
  }
  if (HEAP32[$3 + 8 >> 2]) {
   HEAP32[$3 + 8 >> 2] = jsvMakeFunctionParameter(HEAP32[$3 + 8 >> 2]);
   jsvSetValueOfName(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
   jsvAddName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvNewFromEmptyString_216() {
  return jsvNewWithFlags(29);
 }
 
 function jsvSetValueOfName($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block1 : {
   if (jsvIsNameWithValue(HEAP32[$2 + 24 >> 2]) & 1) {
    block : {
     if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
      $0 = HEAP32[$2 + 24 >> 2];
      $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
      $3 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]) + 24 | 0;
      $0 = HEAP32[$2 + 24 >> 2];
      $1 = $1 | $3;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
      break block;
     }
     $0 = HEAP32[$2 + 24 >> 2];
     $1 = HEAP32[$2 + 24 >> 2];
     $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 65472 | 15;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
    }
    jsvSetFirstChild(HEAP32[$2 + 24 >> 2], 0);
    break block1;
   }
   if (jsvGetFirstChild(HEAP32[$2 + 24 >> 2]) & 65535) {
    jsvUnRefRef(jsvGetFirstChild(HEAP32[$2 + 24 >> 2]) & 65535)
   }
  }
  block4 : {
   if (HEAP32[$2 + 20 >> 2]) {
    block2 : {
     if (jsvIsInt(HEAP32[$2 + 24 >> 2]) & 1) {
      if (!(jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1)) {
       if (!(jsvIsBoolean(HEAP32[$2 + 20 >> 2]) & 1)) {
        break block2
       }
      }
      if (jsvIsPin(HEAP32[$2 + 20 >> 2]) & 1) {
       break block2
      }
      $0 = HEAP32[$2 + 20 >> 2];
      HEAP32[$2 + 16 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (!(HEAP32[$2 + 16 >> 2] < -8192 | HEAP32[$2 + 16 >> 2] > 8191)) {
       $0 = HEAP32[$2 + 24 >> 2];
       $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
       $3 = jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1 ? 16 : 17;
       $0 = HEAP32[$2 + 24 >> 2];
       $1 = $1 | $3;
       HEAP8[$0 + 12 | 0] = $1;
       HEAP8[$0 + 13 | 0] = $1 >>> 8;
       jsvSetFirstChild(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2] & 65535);
       break block4;
      }
      break block2;
     }
     block5 : {
      if (!(jsvIsString(HEAP32[$2 + 24 >> 2]) & 1)) {
       break block5
      }
      if (jsvIsUTF8String(HEAP32[$2 + 24 >> 2]) & 1) {
       break block5
      }
      block6 : {
       if (!(jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1)) {
        break block6
       }
       if (jsvIsPin(HEAP32[$2 + 20 >> 2]) & 1) {
        break block6
       }
       $0 = HEAP32[$2 + 20 >> 2];
       HEAP32[$2 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
       if (!(HEAP32[$2 + 12 >> 2] < -8192 | HEAP32[$2 + 12 >> 2] > 8191)) {
        $0 = HEAP32[$2 + 24 >> 2];
        $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
        $3 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]) + 18 | 0;
        $0 = HEAP32[$2 + 24 >> 2];
        $1 = $1 | $3;
        HEAP8[$0 + 12 | 0] = $1;
        HEAP8[$0 + 13 | 0] = $1 >>> 8;
        jsvSetFirstChild(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2] & 65535);
        break block4;
       }
      }
     }
    }
    jsvSetFirstChild(HEAP32[$2 + 24 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 20 >> 2])) & 65535);
    break block4;
   }
   jsvSetFirstChild(HEAP32[$2 + 24 >> 2], 0);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvSetArrayLength($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  block : {
   if (!(HEAP8[$3 + 7 | 0] & 1)) {
    break block
   }
   $0 = HEAP32[$3 + 12 >> 2];
   if (HEAP32[$3 + 8 >> 2] >= (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
    break block
   }
  }
  $0 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  return HEAP32[$3 + 8 >> 2];
 }
 
 function jsvCompareInteger($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block1 : {
   block : {
    if (!(jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1)) {
     break block
    }
    if (!(jsvIsInt(HEAP32[$2 + 4 >> 2]) & 1)) {
     break block
    }
    HEAP32[$2 + 12 >> 2] = jsvGetInteger(HEAP32[$2 + 8 >> 2]) - jsvGetInteger(HEAP32[$2 + 4 >> 2]);
    break block1;
   }
   if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
    HEAP32[$2 + 12 >> 2] = -1;
    break block1;
   }
   if (jsvIsInt(HEAP32[$2 + 4 >> 2]) & 1) {
    HEAP32[$2 + 12 >> 2] = 1;
    break block1;
   }
   HEAP32[$2 + 12 >> 2] = 0;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvGetNativeFunctionPtr($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = jsvFindChildFromString(HEAP32[$1 + 8 >> 2], 18659);
  block : {
   if (HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 4 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 4 >> 2]);
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$1 >> 2] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + jsvGetFlatStringPointer(HEAP32[$1 + 4 >> 2]);
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvFindChildFromString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP8[$2 + 15 | 0] = 1;
  HEAP8[$2 + 16 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2]];
  if (HEAPU8[HEAP32[$2 + 20 >> 2]]) {
   HEAP8[$2 + 17 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + 1 | 0];
   if (HEAPU8[HEAP32[$2 + 20 >> 2] + 1 | 0]) {
    HEAP8[$2 + 18 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + 2 | 0];
    if (HEAPU8[HEAP32[$2 + 20 >> 2] + 2 | 0]) {
     HEAP8[$2 + 19 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + 3 | 0];
     if (HEAPU8[HEAP32[$2 + 20 >> 2] + 3 | 0]) {
      HEAP8[$2 + 15 | 0] = !HEAPU8[HEAP32[$2 + 20 >> 2] + 4 | 0]
     }
    }
   }
  }
  HEAP16[$2 + 12 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
  block1 : {
   block2 : {
    if (!(HEAP8[$2 + 15 | 0] & 1)) {
     while (1) {
      if (HEAPU16[$2 + 12 >> 1]) {
       HEAP32[$2 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 12 >> 1]);
       block : {
        $0 = HEAP32[$2 + 8 >> 2];
        if ((HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24)) != (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
         break block
        }
        if (!(jsvIsStringEqual(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2]) & 1)) {
         break block
        }
        HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 + 8 >> 2]);
        break block1;
       }
       HEAP16[$2 + 12 >> 1] = jsvGetNextSibling(HEAP32[$2 + 8 >> 2]);
       continue;
      }
      break;
     };
     break block2;
    }
    HEAP32[$2 + 4 >> 2] = 0;
    while (1) {
     if (HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 4 >> 2] | 0]) {
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
      continue;
     }
     break;
    };
    while (1) {
     if (HEAPU16[$2 + 12 >> 1]) {
      HEAP32[$2 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 12 >> 1]);
      block3 : {
       $0 = HEAP32[$2 >> 2];
       if ((HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24)) != (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
        break block3
       }
       $0 = HEAP32[$2 >> 2];
       if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) >>> 18 | 0) {
        break block3
       }
       if ((jsvGetCharactersInVar(HEAP32[$2 >> 2]) | 0) != HEAP32[$2 + 4 >> 2]) {
        break block3
       }
       HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 >> 2]);
       break block1;
      }
      HEAP16[$2 + 12 >> 1] = jsvGetNextSibling(HEAP32[$2 >> 2]);
      continue;
     }
     break;
    };
   }
   HEAP32[$2 + 28 >> 2] = 0;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvSkipNameAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvSkipName(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvGetFlatStringPointer($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 14;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvIsStringEqual($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jsvIsStringEqualOrStartsWith(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
  __stack_pointer = $2 + 16 | 0;
  return $0 & 1;
 }
 
 function jsvSkipName($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvSkipNameWithParent(HEAP32[$1 + 12 >> 2], 1, 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jsvIsBasicVarEqual($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0.0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $0;
  HEAP32[$2 + 100 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 104 >> 2] == HEAP32[$2 + 100 >> 2]) {
    HEAP8[$2 + 111 | 0] = 1;
    break block;
   }
   if (!(HEAP32[$2 + 100 >> 2] ? HEAP32[$2 + 104 >> 2] : 0)) {
    HEAP8[$2 + 111 | 0] = 0;
    break block;
   }
   block2 : {
    if (!(jsvIsNumeric(HEAP32[$2 + 104 >> 2]) & 1)) {
     break block2
    }
    if (!(jsvIsNumeric(HEAP32[$2 + 100 >> 2]) & 1)) {
     break block2
    }
    if (jsvIsIntegerish(HEAP32[$2 + 104 >> 2]) & 1) {
     if (jsvIsIntegerish(HEAP32[$2 + 100 >> 2]) & 1) {
      $0 = HEAP32[$2 + 104 >> 2];
      $1 = HEAP32[$2 + 100 >> 2];
      HEAP8[$2 + 111 | 0] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24));
      break block;
     }
     $0 = HEAP32[$2 + 100 >> 2];
     $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     $3 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
     wasm2js_scratch_store_i32(0, $1 | 0);
     wasm2js_scratch_store_i32(1, $3 | 0);
     $4 = +wasm2js_scratch_load_f64();
     $0 = HEAP32[$2 + 104 >> 2];
     HEAP8[$2 + 111 | 0] = $4 == +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
     break block;
    }
    if (jsvIsIntegerish(HEAP32[$2 + 100 >> 2]) & 1) {
     $0 = HEAP32[$2 + 104 >> 2];
     $3 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
     wasm2js_scratch_store_i32(0, $3 | 0);
     wasm2js_scratch_store_i32(1, $1 | 0);
     $4 = +wasm2js_scratch_load_f64();
     $0 = HEAP32[$2 + 100 >> 2];
     HEAP8[$2 + 111 | 0] = $4 == +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
     break block;
    }
    $0 = HEAP32[$2 + 104 >> 2];
    $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    $3 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, $1 | 0);
    wasm2js_scratch_store_i32(1, $3 | 0);
    $4 = +wasm2js_scratch_load_f64();
    $0 = HEAP32[$2 + 100 >> 2];
    $3 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, $3 | 0);
    wasm2js_scratch_store_i32(1, $1 | 0);
    HEAP8[$2 + 111 | 0] = +wasm2js_scratch_load_f64() == $4;
    break block;
   }
   block3 : {
    if (!(jsvIsString(HEAP32[$2 + 104 >> 2]) & 1)) {
     break block3
    }
    if (!(jsvIsString(HEAP32[$2 + 100 >> 2]) & 1)) {
     break block3
    }
    jsvStringIteratorNew($2 + 60 | 0, HEAP32[$2 + 104 >> 2], 0);
    jsvStringIteratorNew($2 + 20 | 0, HEAP32[$2 + 100 >> 2], 0);
    while (1) {
     HEAP32[$2 + 16 >> 2] = jsvStringIteratorGetCharOrMinusOne($2 + 60 | 0);
     jsvStringIteratorNext($2 + 60 | 0);
     HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetCharOrMinusOne($2 + 20 | 0);
     jsvStringIteratorNext($2 + 20 | 0);
     if (HEAP32[$2 + 16 >> 2] != HEAP32[$2 + 12 >> 2]) {
      jsvStringIteratorFree_189($2 + 60 | 0);
      jsvStringIteratorFree_189($2 + 20 | 0);
      HEAP8[$2 + 111 | 0] = 0;
      break block;
     }
     if (HEAP32[$2 + 16 >> 2] >= 0) {
      continue
     }
     break;
    };
    jsvStringIteratorFree_189($2 + 60 | 0);
    jsvStringIteratorFree_189($2 + 20 | 0);
    HEAP8[$2 + 111 | 0] = 1;
    break block;
   }
   HEAP8[$2 + 111 | 0] = 0;
  }
  __stack_pointer = $2 + 112 | 0;
  return HEAP8[$2 + 111 | 0] & 1;
 }
 
 function jsvIsEqual($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block1 : {
   block : {
    if (!(jsvIsBasic(HEAP32[$2 + 8 >> 2]) & 1)) {
     break block
    }
    if (!(jsvIsBasic(HEAP32[$2 + 4 >> 2]) & 1)) {
     break block
    }
    HEAP8[$2 + 15 | 0] = jsvIsBasicVarEqual(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 1;
    break block1;
   }
   HEAP8[$2 + 15 | 0] = (jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535) == (jsvGetRef(HEAP32[$2 + 4 >> 2]) & 65535);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP8[$2 + 15 | 0] & 1;
 }
 
 function jsvGetConstString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 19123;
    break block;
   }
   if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 15755;
    break block;
   }
   block1 : {
    if (!(jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1)) {
     break block1
    }
    if (jsvIsNameIntBool(HEAP32[$1 + 8 >> 2]) & 1) {
     break block1
    }
    HEAP32[$1 + 12 >> 2] = jsvGetBool(HEAP32[$1 + 8 >> 2]) & 1 ? 17314 : 17666;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvGetBool($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (jsvIsString(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP8[$1 + 31 | 0] = (jsvIsEmptyString(HEAP32[$1 + 24 >> 2]) ^ -1) & 1;
    break block;
   }
   if (jsvIsPin(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP8[$1 + 31 | 0] = jshIsPinValid(jshGetPinFromVar(HEAP32[$1 + 24 >> 2]) & 255) & 1;
    break block;
   }
   block2 : {
    block1 : {
     if (jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1) {
      break block1
     }
     if (jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1) {
      break block1
     }
     if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
      break block1
     }
     if (!(jsvIsArrayBuffer(HEAP32[$1 + 24 >> 2]) & 1)) {
      break block2
     }
    }
    HEAP8[$1 + 31 | 0] = 1;
    break block;
   }
   if (jsvIsFloat(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAPF64[$1 + 16 >> 3] = jsvGetFloat(HEAP32[$1 + 24 >> 2]);
    $2 = __DOUBLE_BITS(HEAPF64[$1 + 16 >> 3]);
    $0 = $2;
    $3 = i64toi32_i32$HIGH_BITS;
    $2 = $3 & 2147483647;
    $3 = $0;
    HEAP8[$1 + 31 | 0] = ($2 | 0) == 2146435072 & ($3 | 0) != 0 | $2 >>> 0 > 2146435072 ? 0 : HEAPF64[$1 + 16 >> 3] != 0.0;
    break block;
   }
   HEAP8[$1 + 31 | 0] = (jsvGetInteger(HEAP32[$1 + 24 >> 2]) | 0) != 0;
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP8[$1 + 31 | 0] & 1;
 }
 
 function jsvIsEmptyString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(jsvHasCharacterData(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP8[$1 + 15 | 0] = 1;
    break block;
   }
   HEAP8[$1 + 15 | 0] = !jsvGetCharactersInVar(HEAP32[$1 + 8 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvGetFloat($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 84 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 84 >> 2]) {
    HEAPF64[$1 + 88 >> 3] = NaN;
    break block;
   }
   if (jsvIsFloat(HEAP32[$1 + 84 >> 2]) & 1) {
    $0 = HEAP32[$1 + 84 >> 2];
    $2 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    wasm2js_scratch_store_i32(1, $2 | 0);
    HEAPF64[$1 + 88 >> 3] = wasm2js_scratch_load_f64();
    break block;
   }
   if (jsvIsIntegerish(HEAP32[$1 + 84 >> 2]) & 1) {
    $0 = HEAP32[$1 + 84 >> 2];
    HEAPF64[$1 + 88 >> 3] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    break block;
   }
   block1 : {
    if (!(jsvIsArray(HEAP32[$1 + 84 >> 2]) & 1)) {
     if (!(jsvIsArrayBuffer(HEAP32[$1 + 84 >> 2]) & 1)) {
      break block1
     }
    }
    HEAP32[$1 + 80 >> 2] = jsvGetLength(HEAP32[$1 + 84 >> 2]);
    if (!HEAP32[$1 + 80 >> 2]) {
     HEAPF64[$1 + 88 >> 3] = 0;
     break block;
    }
    if (HEAP32[$1 + 80 >> 2] == 1) {
     if (jsvIsArrayBuffer(HEAP32[$1 + 84 >> 2]) & 1) {
      HEAPF64[$1 + 88 >> 3] = jsvGetFloatAndUnLock(jsvArrayBufferGet(HEAP32[$1 + 84 >> 2], 0));
      break block;
     }
     HEAPF64[$1 + 88 >> 3] = jsvGetFloatAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 84 >> 2], 0)));
     break block;
    }
   }
   if (jsvIsString(HEAP32[$1 + 84 >> 2]) & 1) {
    block2 : {
     if ((jsvGetString(HEAP32[$1 + 84 >> 2], $1 + 16 | 0, 64) | 0) == 64) {
      jsExceptionHere(1, 8306, 0);
      break block2;
     }
     if (!HEAPU8[$1 + 16 | 0]) {
      HEAPF64[$1 + 88 >> 3] = 0;
      break block;
     }
     if (!strcmp($1 + 16 | 0, 3527)) {
      HEAPF64[$1 + 88 >> 3] = Infinity;
      break block;
     }
     if (!strcmp($1 + 16 | 0, 3526)) {
      HEAPF64[$1 + 88 >> 3] = -Infinity;
      break block;
     }
     HEAP32[$1 + 12 >> 2] = 0;
     HEAPF64[$1 >> 3] = stringToFloatWithRadix($1 + 16 | 0, 0, $1 + 12 | 0);
     if (!HEAPU8[HEAP32[$1 + 12 >> 2]]) {
      HEAPF64[$1 + 88 >> 3] = HEAPF64[$1 >> 3];
      break block;
     }
    }
   }
   HEAPF64[$1 + 88 >> 3] = NaN;
  }
  __stack_pointer = $1 + 96 | 0;
  return +HEAPF64[$1 + 88 >> 3];
 }
 
 function __DOUBLE_BITS($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jsvGetInteger($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 56 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 56 >> 2]) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   if (jsvIsNull(HEAP32[$1 + 56 >> 2]) & 1) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   if (jsvIsUndefined(HEAP32[$1 + 56 >> 2]) & 1) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   block1 : {
    if (!(jsvIsIntegerish(HEAP32[$1 + 56 >> 2]) & 1)) {
     if (!(jsvIsArrayBufferName(HEAP32[$1 + 56 >> 2]) & 1)) {
      break block1
     }
    }
    $0 = HEAP32[$1 + 56 >> 2];
    HEAP32[$1 + 60 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    break block;
   }
   block2 : {
    if (!(jsvIsArray(HEAP32[$1 + 56 >> 2]) & 1)) {
     if (!(jsvIsArrayBuffer(HEAP32[$1 + 56 >> 2]) & 1)) {
      break block2
     }
    }
    HEAP32[$1 + 52 >> 2] = jsvGetLength(HEAP32[$1 + 56 >> 2]);
    if (!HEAP32[$1 + 52 >> 2]) {
     HEAP32[$1 + 60 >> 2] = 0;
     break block;
    }
    if (HEAP32[$1 + 52 >> 2] == 1) {
     if (jsvIsArrayBuffer(HEAP32[$1 + 56 >> 2]) & 1) {
      HEAP32[$1 + 60 >> 2] = jsvGetIntegerAndUnLock(jsvArrayBufferGet(HEAP32[$1 + 56 >> 2], 0));
      break block;
     }
     HEAP32[$1 + 60 >> 2] = jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 56 >> 2], 0)));
     break block;
    }
   }
   if (jsvIsFloat(HEAP32[$1 + 56 >> 2]) & 1) {
    $2 = HEAP32[$1 + 56 >> 2];
    $4 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
    $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, $4 | 0);
    wasm2js_scratch_store_i32(1, $0 | 0);
    $0 = __DOUBLE_BITS(+wasm2js_scratch_load_f64());
    $2 = $0;
    $4 = i64toi32_i32$HIGH_BITS;
    $0 = $4 & 2147483647;
    if (!(($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072)) {
     $0 = HEAP32[$1 + 56 >> 2];
     $4 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
     wasm2js_scratch_store_i32(0, $4 | 0);
     wasm2js_scratch_store_i32(1, $0 | 0);
     $3 = +wasm2js_scratch_load_f64();
     if (Math_abs($3) < 9223372036854775808.0) {
      if (Math_abs($3) >= 1.0) {
       $0 = ~~($3 > 0.0 ? Math_min(Math_floor($3 * 2.3283064365386963e-10), 4294967295.0) : Math_ceil(($3 - +(~~$3 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0
      } else {
       $0 = 0
      }
      $5 = ~~$3 >>> 0;
     } else {
      $0 = -2147483648
     }
     HEAP32[$1 + 60 >> 2] = $5;
     break block;
    }
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   block4 : {
    if (!(jsvIsString(HEAP32[$1 + 56 >> 2]) & 1)) {
     break block4
    }
    if (!(jsvIsStringNumericInt(HEAP32[$1 + 56 >> 2], 1) & 1)) {
     break block4
    }
    block5 : {
     if ((jsvGetString(HEAP32[$1 + 56 >> 2], $1 + 16 | 0, 32) | 0) == 32) {
      jsExceptionHere(1, 8306, 0);
      break block5;
     }
     $0 = stringToInt($1 + 16 | 0);
     HEAP32[$1 + 60 >> 2] = $0;
     break block;
    }
   }
   HEAP32[$1 + 60 >> 2] = 0;
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP32[$1 + 60 >> 2];
 }
 
 function jsvGetTypeOf($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 19123;
    break block;
   }
   block2 : {
    block1 : {
     if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
      break block1
     }
     if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
      break block1
     }
     if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
      break block1
     }
     if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
      break block2
     }
    }
    HEAP32[$1 + 12 >> 2] = 4998;
    break block;
   }
   if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 15412;
    break block;
   }
   if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 16684;
    break block;
   }
   if (jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 15567;
    break block;
   }
   if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 8377;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 21716;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvGetValueOf($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 12 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   HEAP32[$1 + 4 >> 2] = jspGetNamedField(HEAP32[$1 + 8 >> 2], 17151, 0);
   if (!(jsvIsFunction(HEAP32[$1 + 4 >> 2]) & 1)) {
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   HEAP32[$1 + 8 >> 2] = jspeFunctionCall(HEAP32[$1 + 4 >> 2], 0, HEAP32[$1 + 8 >> 2], 0, 0, 0);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvGetValueOfAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvGetValueOf(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvGetString($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 72 >> 2] = $0;
  HEAP32[$3 + 68 >> 2] = $1;
  HEAP32[$3 + 64 >> 2] = $2;
  HEAP32[$3 + 60 >> 2] = jsvGetConstString(HEAP32[$3 + 72 >> 2]);
  block : {
   if (HEAP32[$3 + 60 >> 2]) {
    HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 64 >> 2] - 1;
    HEAP32[$3 + 56 >> 2] = 0;
    while (1) {
     $0 = 0;
     $0 = HEAP8[HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 56 >> 2] | 0] << 24 >> 24 ? HEAPU32[$3 + 56 >> 2] < HEAPU32[$3 + 64 >> 2] : $0;
     if ($0) {
      HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 56 >> 2] | 0] = HEAPU8[HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 56 >> 2] | 0];
      HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 56 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 56 >> 2] | 0] = 0;
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 56 >> 2];
    break block;
   }
   if (jsvIsInt(HEAP32[$3 + 72 >> 2]) & 1) {
    $0 = HEAP32[$3 + 72 >> 2];
    itostr_239(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$3 + 68 >> 2], 10);
    HEAP32[$3 + 76 >> 2] = strlen(HEAP32[$3 + 68 >> 2]);
    break block;
   }
   if (jsvIsFloat(HEAP32[$3 + 72 >> 2]) & 1) {
    $0 = HEAP32[$3 + 72 >> 2];
    $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    wasm2js_scratch_store_i32(1, $1 | 0);
    ftoa_bounded(+wasm2js_scratch_load_f64(), HEAP32[$3 + 68 >> 2], HEAP32[$3 + 64 >> 2]);
    HEAP32[$3 + 76 >> 2] = strlen(HEAP32[$3 + 68 >> 2]);
    break block;
   }
   if (jsvHasCharacterData(HEAP32[$3 + 72 >> 2]) & 1) {
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 64 >> 2];
    jsvStringIteratorNew($3 + 12 | 0, HEAP32[$3 + 72 >> 2], 0);
    while (1) {
     if (jsvStringIteratorHasChar_210($3 + 12 | 0) & 1) {
      $0 = HEAP32[$3 + 52 >> 2];
      HEAP32[$3 + 52 >> 2] = $0 - 1;
      if ($0 >>> 0 <= 1) {
       HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
       jsvStringIteratorFree_189($3 + 12 | 0);
       HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 64 >> 2];
       break block;
      } else {
       $1 = jsvStringIteratorGetChar_212($3 + 12 | 0);
       $0 = HEAP32[$3 + 68 >> 2];
       HEAP32[$3 + 68 >> 2] = $0 + 1;
       HEAP8[$0 | 0] = $1;
       jsvStringIteratorNext($3 + 12 | 0);
       continue;
      }
     }
     break;
    };
    jsvStringIteratorFree_189($3 + 12 | 0);
    HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 64 >> 2] - HEAP32[$3 + 52 >> 2];
    break block;
   }
   HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 72 >> 2]);
   if (HEAP32[$3 + 8 >> 2]) {
    HEAP32[$3 + 4 >> 2] = jsvGetStringChars(HEAP32[$3 + 8 >> 2], 0, HEAP32[$3 + 68 >> 2], HEAP32[$3 + 64 >> 2]);
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
    if (HEAPU32[$3 + 4 >> 2] >= HEAPU32[$3 + 64 >> 2]) {
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 64 >> 2] - 1
    }
    HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 4 >> 2] | 0] = 0;
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 4 >> 2];
    break block;
   }
   HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
   jsExceptionHere(4, 16613, 0);
   HEAP32[$3 + 76 >> 2] = 0;
  }
  __stack_pointer = $3 + 80 | 0;
  return HEAP32[$3 + 76 >> 2];
 }
 
 function itostr_239($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvAsString($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 108 >> 2] = $0;
  HEAP32[$1 + 104 >> 2] = 0;
  block1 : {
   block : {
    if (!(jsvHasCharacterData(HEAP32[$1 + 108 >> 2]) & 1)) {
     break block
    }
    if (!(jsvIsName(HEAP32[$1 + 108 >> 2]) & 1)) {
     break block
    }
    HEAP32[$1 + 104 >> 2] = jsvNewFromStringVarComplete(HEAP32[$1 + 108 >> 2]);
    break block1;
   }
   block2 : {
    if (jsvIsString(HEAP32[$1 + 108 >> 2]) & 1) {
     HEAP32[$1 + 104 >> 2] = jsvLockAgain(HEAP32[$1 + 108 >> 2]);
     break block2;
    }
    block5 : {
     if (jsvIsObject(HEAP32[$1 + 108 >> 2]) & 1) {
      HEAP32[$1 + 100 >> 2] = jspGetNamedField(HEAP32[$1 + 108 >> 2], 16691, 0);
      block4 : {
       block3 : {
        if (!HEAP32[$1 + 100 >> 2]) {
         break block3
        }
        $0 = HEAP32[$1 + 100 >> 2];
        if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 1) {
         break block3
        }
        HEAP32[$1 + 96 >> 2] = jspExecuteFunction(HEAP32[$1 + 100 >> 2], HEAP32[$1 + 108 >> 2], 0, 0);
        jsvUnLock(HEAP32[$1 + 100 >> 2]);
        HEAP32[$1 + 104 >> 2] = jsvAsStringAndUnLock(HEAP32[$1 + 96 >> 2]);
        break block4;
       }
       jsvUnLock(HEAP32[$1 + 100 >> 2]);
       HEAP32[$1 + 104 >> 2] = jsvNewFromString(20695);
      }
      break block5;
     }
     HEAP32[$1 + 92 >> 2] = jsvGetConstString(HEAP32[$1 + 108 >> 2]);
     block6 : {
      if (HEAP32[$1 + 92 >> 2]) {
       HEAP32[$1 + 104 >> 2] = jsvNewFromString(HEAP32[$1 + 92 >> 2]);
       break block6;
      }
      block7 : {
       if (jsvIsPin(HEAP32[$1 + 108 >> 2]) & 1) {
        $0 = HEAP32[$1 + 108 >> 2];
        jshGetPinString($1 + 16 | 0, (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) & 255);
        HEAP32[$1 + 104 >> 2] = jsvNewFromString($1 + 16 | 0);
        break block7;
       }
       block8 : {
        if (jsvIsInt(HEAP32[$1 + 108 >> 2]) & 1) {
         $0 = HEAP32[$1 + 108 >> 2];
         itostr_239(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), $1 + 16 | 0, 10);
         HEAP32[$1 + 104 >> 2] = jsvNewFromString($1 + 16 | 0);
         break block8;
        }
        block9 : {
         if (jsvIsFloat(HEAP32[$1 + 108 >> 2]) & 1) {
          $0 = HEAP32[$1 + 108 >> 2];
          $2 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
          wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
          wasm2js_scratch_store_i32(1, $2 | 0);
          ftoa_bounded(+wasm2js_scratch_load_f64(), $1 + 16 | 0, 70);
          HEAP32[$1 + 104 >> 2] = jsvNewFromString($1 + 16 | 0);
          break block9;
         }
         block11 : {
          block10 : {
           if (!(jsvIsArray(HEAP32[$1 + 108 >> 2]) & 1)) {
            if (!(jsvIsArrayBuffer(HEAP32[$1 + 108 >> 2]) & 1)) {
             break block10
            }
           }
           HEAP32[$1 + 12 >> 2] = jsvNewFromString(22853);
           HEAP32[$1 + 104 >> 2] = jsvArrayJoin(HEAP32[$1 + 108 >> 2], HEAP32[$1 + 12 >> 2], 1);
           jsvUnLock(HEAP32[$1 + 12 >> 2]);
           break block11;
          }
          block12 : {
           if (jsvIsFunction(HEAP32[$1 + 108 >> 2]) & 1) {
            HEAP32[$1 + 104 >> 2] = jsvNewFromEmptyString_216();
            if (HEAP32[$1 + 104 >> 2]) {
             jsfGetJSON(HEAP32[$1 + 108 >> 2], HEAP32[$1 + 104 >> 2], 0)
            }
            break block12;
           }
           jsExceptionHere(4, 16613, 0);
          }
         }
        }
       }
      }
     }
    }
   }
  }
  __stack_pointer = $1 + 112 | 0;
  return HEAP32[$1 + 104 >> 2];
 }
 
 function jsvGetStringChars($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 56 >> 2] = $0;
  HEAP32[$4 + 52 >> 2] = $1;
  HEAP32[$4 + 48 >> 2] = $2;
  HEAP32[$4 + 44 >> 2] = $3;
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 44 >> 2];
  jsvStringIteratorNew($4, HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2]);
  block : {
   while (1) {
    if (jsvStringIteratorHasChar_210($4) & 1) {
     $0 = HEAP32[$4 + 40 >> 2];
     HEAP32[$4 + 40 >> 2] = $0 - 1;
     if ($0) {
      $1 = jsvStringIteratorGetCharAndNext($4);
      $0 = HEAP32[$4 + 48 >> 2];
      HEAP32[$4 + 48 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = $1;
      continue;
     } else {
      jsvStringIteratorFree_189($4);
      HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 44 >> 2];
      break block;
     }
    }
    break;
   };
   jsvStringIteratorFree_189($4);
   HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 44 >> 2] - HEAP32[$4 + 40 >> 2];
  }
  __stack_pointer = $4 - -64 | 0;
  return HEAP32[$4 + 60 >> 2];
 }
 
 function jsvNewFromStringVarComplete($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvNewWritableStringFromStringVar(HEAP32[$1 + 12 >> 2], 0, 2147483647);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvAsStringAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvArrayJoin($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 144 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 136 >> 2] = $0;
  HEAP32[$3 + 132 >> 2] = $1;
  HEAP8[$3 + 131 | 0] = $2;
  HEAP32[$3 + 124 >> 2] = jsvNewFromEmptyString_216();
  block : {
   if (!HEAP32[$3 + 124 >> 2]) {
    HEAP32[$3 + 140 >> 2] = 0;
    break block;
   }
   HEAP8[$3 + 123 | 0] = 0;
   jsvIteratorNew($3 + 56 | 0, HEAP32[$3 + 136 >> 2], 1);
   jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 124 >> 2], 0);
   HEAP8[$3 + 15 | 0] = 1;
   while (1) {
    $0 = 0;
    if (!(jspIsInterrupted() & 1)) {
     $0 = jsvIteratorHasElement($3 + 56 | 0)
    }
    if ($0 & 1) {
     HEAP32[$3 + 8 >> 2] = jsvIteratorGetKey($3 + 56 | 0);
     if (jsvIsInt(HEAP32[$3 + 8 >> 2]) & 1) {
      if (!(!HEAP32[$3 + 132 >> 2] | HEAP8[$3 + 15 | 0] & 1)) {
       jsvStringIteratorAppendString($3 + 16 | 0, HEAP32[$3 + 132 >> 2], 0, 2147483647)
      }
      HEAP8[$3 + 15 | 0] = 0;
      HEAP32[$3 + 4 >> 2] = jsvIteratorGetValue($3 + 56 | 0);
      block2 : {
       if (!HEAP32[$3 + 4 >> 2]) {
        break block2
       }
       if (HEAP8[$3 + 131 | 0] & 1) {
        if (jsvIsNull(HEAP32[$3 + 4 >> 2]) & 1) {
         break block2
        }
       }
       HEAP32[$3 >> 2] = jsvAsString(HEAP32[$3 + 4 >> 2]);
       if (HEAP32[$3 >> 2]) {
        HEAP8[$3 + 123 | 0] = jsvIsUTF8String(HEAP32[$3 >> 2]) & 1 | HEAP8[$3 + 123 | 0] & 1;
        jsvStringIteratorAppendString($3 + 16 | 0, HEAP32[$3 >> 2], 0, 2147483647);
        jsvUnLock(HEAP32[$3 >> 2]);
       }
      }
      jsvUnLock(HEAP32[$3 + 4 >> 2]);
     }
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
     jsvIteratorNext($3 + 56 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 56 | 0);
   jsvStringIteratorFree_189($3 + 16 | 0);
   if (HEAP8[$3 + 123 | 0] & 1) {
    HEAP32[$3 + 124 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$3 + 124 >> 2])
   }
   HEAP32[$3 + 140 >> 2] = HEAP32[$3 + 124 >> 2];
  }
  __stack_pointer = $3 + 144 | 0;
  return HEAP32[$3 + 140 >> 2];
 }
 
 function jsvNewWritableStringFromStringVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = jsvNewFromEmptyString_216();
  jsvAppendStringVar(HEAP32[$3 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  if (jsvIsUTF8String(HEAP32[$3 + 12 >> 2]) & 1) {
   HEAP32[$3 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$3 >> 2])
  }
  __stack_pointer = $3 + 16 | 0;
  return HEAP32[$3 >> 2];
 }
 
 function jsvAsFlatString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 >> 2] = jsvNewFlatStringFromStringVar(HEAP32[$1 + 4 >> 2], 0, 2147483647);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvNewFlatStringFromStringVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 112 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 108 >> 2] = $0;
  HEAP32[$3 + 104 >> 2] = $1;
  HEAP32[$3 + 100 >> 2] = $2;
  HEAP32[$3 + 96 >> 2] = jsvGetStringLength(HEAP32[$3 + 108 >> 2]);
  block : {
   if (HEAPU32[$3 + 104 >> 2] > HEAPU32[$3 + 96 >> 2]) {
    HEAP32[$3 + 96 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 96 >> 2] = HEAP32[$3 + 96 >> 2] - HEAP32[$3 + 104 >> 2];
  }
  if (HEAPU32[$3 + 96 >> 2] > HEAPU32[$3 + 100 >> 2]) {
   HEAP32[$3 + 96 >> 2] = HEAP32[$3 + 100 >> 2]
  }
  HEAP32[$3 + 92 >> 2] = jsvNewFlatStringOfLength(HEAP32[$3 + 96 >> 2]);
  if (HEAP32[$3 + 92 >> 2]) {
   jsvStringIteratorNew($3 + 52 | 0, HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2]);
   jsvStringIteratorNew($3 + 12 | 0, HEAP32[$3 + 92 >> 2], 0);
   while (1) {
    $0 = HEAP32[$3 + 96 >> 2];
    HEAP32[$3 + 96 >> 2] = $0 - 1;
    if ($0) {
     jsvStringIteratorSetCharAndNext($3 + 12 | 0, jsvStringIteratorGetCharAndNext($3 + 52 | 0) << 24 >> 24);
     continue;
    }
    break;
   };
   jsvStringIteratorFree_189($3 + 52 | 0);
   jsvStringIteratorFree_189($3 + 12 | 0);
  }
  __stack_pointer = $3 + 112 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jsvAsArrayIndex($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block1 : {
   block : {
    if (!(jsvIsSimpleInt(HEAP32[$1 + 24 >> 2]) & 1)) {
     break block
    }
    if ((jsvGetInteger(HEAP32[$1 + 24 >> 2]) | 0) < 0) {
     break block
    }
    HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
    break block1;
   }
   if (jsvIsString(HEAP32[$1 + 24 >> 2]) & 1) {
    if (jsvIsStringNumericStrict(HEAP32[$1 + 24 >> 2]) & 1) {
     HEAP32[$1 + 20 >> 2] = jsvNewFromInteger(jsvGetInteger(HEAP32[$1 + 24 >> 2]));
     HEAP32[$1 + 16 >> 2] = jsvAsString(HEAP32[$1 + 20 >> 2]);
     if (!jsvCompareString(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 16 >> 2], 0, 0, 0)) {
      jsvUnLock(HEAP32[$1 + 16 >> 2]);
      HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
      break block1;
     }
     jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
    }
    HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
    break block1;
   }
   if (jsvIsFloat(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAPF64[$1 + 8 >> 3] = jsvGetFloat(HEAP32[$1 + 24 >> 2]);
    HEAP32[$1 + 4 >> 2] = jsvGetInteger(HEAP32[$1 + 24 >> 2]);
    if (HEAPF64[$1 + 8 >> 3] == +HEAP32[$1 + 4 >> 2]) {
     HEAP32[$1 + 28 >> 2] = jsvNewFromInteger(HEAP32[$1 + 4 >> 2]);
     break block1;
    }
   }
   HEAP32[$1 + 28 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvIsStringNumericStrict($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 56 >> 2] = $0;
  jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 56 >> 2], 0);
  HEAP8[$1 + 15 | 0] = 0;
  HEAP8[$1 + 14 | 0] = 0;
  HEAP32[$1 + 8 >> 2] = 0;
  block : {
   while (1) {
    if (jsvStringIteratorHasChar_210($1 + 16 | 0) & 1) {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     HEAP8[$1 + 7 | 0] = jsvStringIteratorGetCharAndNext($1 + 16 | 0);
     if (!(isNumeric(HEAP8[$1 + 7 | 0] << 24 >> 24) & 1)) {
      jsvStringIteratorFree_189($1 + 16 | 0);
      HEAP8[$1 + 63 | 0] = 0;
      break block;
     }
     if (!(HEAP8[$1 + 15 | 0] & 1 | HEAPU8[$1 + 7 | 0] != 48)) {
      HEAP8[$1 + 14 | 0] = 1
     }
     if (HEAPU8[$1 + 7 | 0] != 48) {
      HEAP8[$1 + 15 | 0] = 1
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_189($1 + 16 | 0);
   if (HEAP32[$1 + 8 >> 2] > 0) {
    $2 = 1;
    $2 = HEAP8[$1 + 14 | 0] & 1 ? HEAP32[$1 + 8 >> 2] == 1 : $2;
   }
   HEAP8[$1 + 63 | 0] = $2 & 1;
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP8[$1 + 63 | 0] & 1;
 }
 
 function jsvCompareString($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer + -64 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 60 >> 2] = $0;
  HEAP32[$5 + 56 >> 2] = $1;
  HEAP32[$5 + 52 >> 2] = $2;
  HEAP32[$5 + 48 >> 2] = $3;
  HEAP8[$5 + 47 | 0] = $4;
  jsvStringIteratorNewUTF8($5 + 4 | 0, HEAP32[$5 + 60 >> 2], HEAP32[$5 + 52 >> 2]);
  HEAP32[$5 >> 2] = jsvCompareStringIt($5 + 4 | 0, HEAP32[$5 + 56 >> 2], HEAP32[$5 + 48 >> 2], HEAP8[$5 + 47 | 0] & 1);
  jsvStringIteratorFree_189($5 + 4 | 0);
  __stack_pointer = $5 - -64 | 0;
  return HEAP32[$5 >> 2];
 }
 
 function jsvGetLength($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvGetStringLength(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   block1 : {
    if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
     if (!(jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1)) {
      break block1
     }
    }
    HEAP32[$1 + 12 >> 2] = jsvGetChildren(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvArrayBufferGet($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 76 >> 2] = $0;
  HEAP32[$2 + 72 >> 2] = $1;
  jsvArrayBufferIteratorNew($2 + 12 | 0, HEAP32[$2 + 76 >> 2], HEAP32[$2 + 72 >> 2]);
  HEAP32[$2 + 8 >> 2] = jsvArrayBufferIteratorGetValue($2 + 12 | 0, 0);
  jsvArrayBufferIteratorFree($2 + 12 | 0);
  __stack_pointer = $2 + 80 | 0;
  return HEAP32[$2 + 8 >> 2];
 }
 
 function jsvGetIntegerAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = _jsvGetIntegerAndUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvGetArrayItem($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jsvSkipNameAndUnLock(jsvGetArrayIndex(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]));
  __stack_pointer = $2 + 16 | 0;
  return $0;
 }
 
 function jsvIsStringNumericInt($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP8[$2 + 71 | 0] = $1;
  jsvStringIteratorNew($2 + 28 | 0, HEAP32[$2 + 72 >> 2], 0);
  while (1) {
   $0 = 0;
   if (jsvStringIteratorHasChar_210($2 + 28 | 0) & 1) {
    $0 = isWhitespace(jsvStringIteratorGetChar_212($2 + 28 | 0) << 24 >> 24)
   }
   if ($0 & 1) {
    jsvStringIteratorNext($2 + 28 | 0);
    continue;
   }
   break;
  };
  block : {
   if ((jsvStringIteratorGetChar_212($2 + 28 | 0) & 255) != 45) {
    if ((jsvStringIteratorGetChar_212($2 + 28 | 0) & 255) != 43) {
     break block
    }
   }
   jsvStringIteratorNext($2 + 28 | 0);
  }
  HEAP32[$2 + 24 >> 2] = 0;
  if ((jsvStringIteratorGetChar_212($2 + 28 | 0) & 255) == 48) {
   jsvStringIteratorNext($2 + 28 | 0);
   HEAP8[$2 + 21 | 0] = 48;
   HEAP8[$2 + 22 | 0] = jsvStringIteratorGetChar_212($2 + 28 | 0);
   HEAP8[$2 + 23 | 0] = 0;
   HEAP32[$2 + 16 >> 2] = $2 + 21;
   HEAP32[$2 + 24 >> 2] = getRadix($2 + 16 | 0);
   if (HEAPU32[$2 + 16 >> 2] > $2 + 22 >>> 0) {
    jsvStringIteratorNext($2 + 28 | 0)
   }
  }
  if (!HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 24 >> 2] = 10
  }
  HEAP32[$2 + 12 >> 2] = 0;
  block4 : {
   while (1) {
    if (jsvStringIteratorHasChar_210($2 + 28 | 0) & 1) {
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     HEAP8[$2 + 11 | 0] = jsvStringIteratorGetCharAndNext($2 + 28 | 0);
     block2 : {
      if (!(!(HEAP8[$2 + 71 | 0] & 1) | HEAPU8[$2 + 11 | 0] != 46)) {
       HEAP8[$2 + 71 | 0] = 0;
       break block2;
      }
      HEAP32[$2 + 4 >> 2] = chtod(HEAP8[$2 + 11 | 0] << 24 >> 24);
      if (!(HEAP32[$2 + 4 >> 2] < HEAP32[$2 + 24 >> 2] & HEAP32[$2 + 4 >> 2] >= 0)) {
       jsvStringIteratorFree_189($2 + 28 | 0);
       HEAP8[$2 + 79 | 0] = 0;
       break block4;
      }
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_189($2 + 28 | 0);
   HEAP8[$2 + 79 | 0] = HEAP32[$2 + 12 >> 2] > 0;
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAP8[$2 + 79 | 0] & 1;
 }
 
 function jsvGetFloatAndUnLock($0) {
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = _jsvGetFloatAndUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $2;
 }
 
 function jsvAsArrayIndexAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvAsArrayIndex(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvGetFlatStringFromPointer($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 8 >> 2] - 14;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function jsvGetDataPointer($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (jsvIsArrayBuffer(HEAP32[$2 + 24 >> 2]) & 1) {
    HEAP32[$2 + 16 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 24 >> 2], 0);
    HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    if (HEAP32[$2 + 12 >> 2]) {
     $0 = HEAP32[$2 + 24 >> 2];
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8);
     $0 = HEAP32[$2 + 24 >> 2];
     HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8);
    }
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
    break block;
   }
   if (jsvIsNativeString(HEAP32[$2 + 24 >> 2]) & 1) {
    $0 = HEAP32[$2 + 24 >> 2];
    HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    $0 = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 + 28 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    break block;
   }
   if (jsvIsFlatString(HEAP32[$2 + 24 >> 2]) & 1) {
    $0 = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
    HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
    HEAP32[$2 + 28 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 24 >> 2]);
    break block;
   }
   block1 : {
    if (!(jsvIsBasicString(HEAP32[$2 + 24 >> 2]) & 1)) {
     break block1
    }
    if (jsvGetLastChild(HEAP32[$2 + 24 >> 2]) & 65535) {
     break block1
    }
    $0 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]);
    HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
    break block;
   }
   HEAP32[$2 + 28 >> 2] = 0;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvGetArrayBufferBackingString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (!HEAP32[$2 + 8 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   jsvLockAgain(HEAP32[$2 + 8 >> 2]);
   if (HEAP32[$2 + 4 >> 2]) {
    HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 0
   }
   while (1) {
    if (jsvIsArrayBuffer(HEAP32[$2 + 8 >> 2]) & 1) {
     if (HEAP32[$2 + 4 >> 2]) {
      $0 = HEAP32[$2 + 4 >> 2];
      $1 = HEAP32[$2 + 8 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8);
     }
     HEAP32[$2 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 8 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     HEAP32[$2 + 8 >> 2] = HEAP32[$2 >> 2];
     continue;
    }
    break;
   };
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvGetLinesInString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 44 >> 2] = $0;
  HEAP32[$1 + 40 >> 2] = 1;
  jsvStringIteratorNew($1, HEAP32[$1 + 44 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_210($1) & 1) {
    if ((jsvStringIteratorGetCharAndNext($1) & 255) == 10) {
     HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 40 >> 2] + 1
    }
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($1);
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 40 >> 2];
 }
 
 function jsvGetCharsOnLine($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 60 >> 2] = $0;
  HEAP32[$2 + 56 >> 2] = $1;
  HEAP32[$2 + 52 >> 2] = 1;
  HEAP32[$2 + 48 >> 2] = 0;
  jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 60 >> 2], 0);
  while (1) {
   block : {
    if (!(jsvStringIteratorHasChar_210($2 + 8 | 0) & 1)) {
     break block
    }
    block1 : {
     if ((jsvStringIteratorGetCharAndNext($2 + 8 | 0) & 255) == 10) {
      HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
      if (HEAPU32[$2 + 52 >> 2] > HEAPU32[$2 + 56 >> 2]) {
       break block
      }
      break block1;
     }
     if (HEAP32[$2 + 52 >> 2] == HEAP32[$2 + 56 >> 2]) {
      HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1
     }
    }
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($2 + 8 | 0);
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 48 >> 2];
 }
 
 function jsvGetLineAndCol($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 92 >> 2] = $0;
  HEAP32[$5 + 88 >> 2] = $1;
  HEAP32[$5 + 84 >> 2] = $2;
  HEAP32[$5 + 80 >> 2] = $3;
  HEAP32[$5 + 76 >> 2] = $4;
  HEAP32[$5 + 72 >> 2] = 1;
  HEAP32[$5 + 68 >> 2] = 1;
  HEAP32[$5 + 64 >> 2] = 0;
  HEAP32[$5 + 60 >> 2] = 19244;
  HEAP32[$5 + 56 >> 2] = 0;
  if (HEAP32[$5 + 76 >> 2]) {
   HEAP32[HEAP32[$5 + 76 >> 2] >> 2] = 0
  }
  jsvStringIteratorNew($5 + 16 | 0, HEAP32[$5 + 92 >> 2], 0);
  while (1) {
   block : {
    if (!(jsvStringIteratorHasChar_210($5 + 16 | 0) & 1)) {
     break block
    }
    HEAP8[$5 + 15 | 0] = jsvStringIteratorGetCharAndNext($5 + 16 | 0);
    if (!(!HEAP32[$5 + 76 >> 2] | HEAP32[$5 + 68 >> 2] != (HEAP32[HEAP32[$5 + 76 >> 2] >> 2] + 1 | 0) | (HEAPU8[$5 + 15 | 0] != HEAPU8[HEAP32[$5 + 60 >> 2] + HEAP32[$5 + 56 >> 2] | 0] | HEAP32[$5 + 56 >> 2] < 0))) {
     HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
     if (!HEAPU8[HEAP32[$5 + 60 >> 2] + HEAP32[$5 + 56 >> 2] | 0]) {
      HEAP32[$5 + 56 >> 2] = -1;
      $0 = HEAP32[$5 + 76 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     }
    }
    if (HEAP32[$5 + 64 >> 2] == HEAP32[$5 + 88 >> 2]) {
     break block
    }
    HEAP32[$5 + 72 >> 2] = HEAP32[$5 + 72 >> 2] + 1;
    if (HEAPU8[$5 + 15 | 0] == 10) {
     HEAP32[$5 + 72 >> 2] = 1;
     HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 68 >> 2] + 1;
     HEAP32[$5 + 56 >> 2] = 0;
    }
    HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 64 >> 2] + 1;
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($5 + 16 | 0);
  HEAP32[HEAP32[$5 + 84 >> 2] >> 2] = HEAP32[$5 + 68 >> 2];
  HEAP32[HEAP32[$5 + 80 >> 2] >> 2] = HEAP32[$5 + 72 >> 2];
  __stack_pointer = $5 + 96 | 0;
 }
 
 function jsvGetIndexFromLineAndCol($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 72 >> 2] = $0;
  HEAP32[$3 + 68 >> 2] = $1;
  HEAP32[$3 + 64 >> 2] = $2;
  HEAP32[$3 + 60 >> 2] = 1;
  HEAP32[$3 + 56 >> 2] = 1;
  HEAP32[$3 + 52 >> 2] = 0;
  jsvStringIteratorNew($3 + 12 | 0, HEAP32[$3 + 72 >> 2], 0);
  block3 : {
   while (1) {
    if (jsvStringIteratorHasChar_210($3 + 12 | 0) & 1) {
     HEAP8[$3 + 11 | 0] = jsvStringIteratorGetCharAndNext($3 + 12 | 0);
     if (!(!(HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 68 >> 2] & HEAPU32[$3 + 60 >> 2] >= HEAPU32[$3 + 64 >> 2]) & HEAPU32[$3 + 56 >> 2] <= HEAPU32[$3 + 68 >> 2])) {
      jsvStringIteratorFree_189($3 + 12 | 0);
      if (HEAPU32[$3 + 56 >> 2] > HEAPU32[$3 + 68 >> 2]) {
       $0 = HEAP32[$3 + 52 >> 2] - 1 | 0
      } else {
       $0 = HEAP32[$3 + 52 >> 2]
      }
      HEAP32[$3 + 76 >> 2] = $0;
      break block3;
     }
     HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 60 >> 2] + 1;
     if (HEAPU8[$3 + 11 | 0] == 10) {
      HEAP32[$3 + 60 >> 2] = 1;
      HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 56 >> 2] + 1;
     }
     HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
     continue;
    }
    break;
   };
   jsvStringIteratorFree_189($3 + 12 | 0);
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 52 >> 2];
  }
  __stack_pointer = $3 + 80 | 0;
  return HEAP32[$3 + 76 >> 2];
 }
 
 function jsvAppendString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP32[$2 + 40 >> 2] = $1;
  jsvStringIteratorNew($2, HEAP32[$2 + 44 >> 2], 0);
  jsvStringIteratorGotoEnd($2);
  while (1) {
   if (HEAPU8[HEAP32[$2 + 40 >> 2]]) {
    $0 = HEAP32[$2 + 40 >> 2];
    HEAP32[$2 + 40 >> 2] = $0 + 1;
    jsvStringIteratorAppend($2, HEAP8[$0 | 0] << 24 >> 24);
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($2);
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jsvAppendStringBuf($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  jsvStringIteratorNew($3 + 12 | 0, HEAP32[$3 + 60 >> 2], 0);
  jsvStringIteratorGotoEnd($3 + 12 | 0);
  while (1) {
   if (HEAP32[$3 + 52 >> 2]) {
    $0 = HEAP32[$3 + 56 >> 2];
    HEAP32[$3 + 56 >> 2] = $0 + 1;
    jsvStringIteratorAppend($3 + 12 | 0, HEAP8[$0 | 0] << 24 >> 24);
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] - 1;
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($3 + 12 | 0);
  __stack_pointer = $3 - -64 | 0;
 }
 
 function jsvStringIteratorPrintfCallback($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  while (1) {
   if (HEAPU8[HEAP32[$2 + 12 >> 2]]) {
    $1 = HEAP32[$2 + 8 >> 2];
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $0 + 1;
    jsvStringIteratorAppend($1, HEAP8[$0 | 0] << 24 >> 24);
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvVarPrintf($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = jsvNewFromEmptyString_216();
  block : {
   if (!HEAP32[$2 + 52 >> 2]) {
    HEAP32[$2 + 60 >> 2] = 0;
    break block;
   }
   jsvStringIteratorNew($2 + 12 | 0, HEAP32[$2 + 52 >> 2], 0);
   jsvStringIteratorGotoEnd($2 + 12 | 0);
   HEAP32[$2 + 8 >> 2] = $1;
   vcbprintf(2, $2 + 12 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 8 >> 2]);
   jsvStringIteratorFree_189($2 + 12 | 0);
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 52 >> 2];
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jsvNewFromStringVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block1 : {
   block : {
    if (!(jsvIsNativeString(HEAP32[$3 + 24 >> 2]) & 1)) {
     if (!(jsvIsFlashString(HEAP32[$3 + 24 >> 2]) & 1)) {
      break block
     }
    }
    HEAP32[$3 + 12 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]);
    if (HEAPU32[$3 + 20 >> 2] > HEAPU32[$3 + 12 >> 2]) {
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 12 >> 2]
    }
    if (HEAPU32[$3 + 12 >> 2] < HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 16 >> 2] >>> 0) {
     HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 12 >> 2] - HEAP32[$3 + 20 >> 2]
    }
    $0 = HEAP32[$3 + 24 >> 2];
    HEAP32[$3 + 8 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63);
    $0 = HEAP32[$3 + 8 >> 2];
    $1 = HEAP32[$3 + 24 >> 2];
    $1 = HEAP32[$3 + 20 >> 2] + (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24)) | 0;
    HEAP8[$0 | 0] = $1;
    HEAP8[$0 + 1 | 0] = $1 >>> 8;
    HEAP8[$0 + 2 | 0] = $1 >>> 16;
    HEAP8[$0 + 3 | 0] = $1 >>> 24;
    $0 = HEAP32[$3 + 8 >> 2];
    $1 = HEAP32[$3 + 16 >> 2];
    HEAP8[$0 + 4 | 0] = $1;
    HEAP8[$0 + 5 | 0] = $1 >>> 8;
    HEAP8[$0 + 6 | 0] = $1 >>> 16;
    HEAP8[$0 + 7 | 0] = $1 >>> 24;
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
    break block1;
   }
   if (jsvIsFlatString(HEAP32[$3 + 24 >> 2]) & 1) {
    HEAP32[$3 + 4 >> 2] = jsvGetCharactersInVar(HEAP32[$3 + 24 >> 2]);
    block2 : {
     if (HEAPU32[$3 + 20 >> 2] >= HEAPU32[$3 + 4 >> 2]) {
      HEAP32[$3 + 4 >> 2] = 0;
      break block2;
     }
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] - HEAP32[$3 + 20 >> 2];
    }
    if (HEAPU32[$3 + 4 >> 2] > HEAPU32[$3 + 16 >> 2]) {
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 16 >> 2]
    }
    if (HEAPU32[$3 + 4 >> 2] > 19) {
     HEAP32[$3 >> 2] = jsvNewFlatStringFromStringVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 4 >> 2]);
     if (HEAP32[$3 >> 2]) {
      HEAP32[$3 + 28 >> 2] = HEAP32[$3 >> 2];
      break block1;
     }
    }
   }
   HEAP32[$3 + 28 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvGetCharInString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  block : {
   if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
    HEAP32[$2 + 60 >> 2] = 0;
    break block;
   }
   jsvStringIteratorNewUTF8($2 + 12 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
   HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 12 | 0);
   jsvStringIteratorFree_189($2 + 12 | 0);
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 8 >> 2];
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jsvSetCharInString($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP8[$4 + 55 | 0] = $2;
  HEAP8[$4 + 54 | 0] = $3;
  if (jsvIsString(HEAP32[$4 + 60 >> 2]) & 1) {
   jsvStringIteratorNew($4 + 12 | 0, HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2]);
   if (HEAP8[$4 + 54 | 0] & 1) {
    HEAP8[$4 + 55 | 0] = jsvStringIteratorGetChar_212($4 + 12 | 0) << 24 >> 24 | HEAP8[$4 + 55 | 0] << 24 >> 24
   }
   jsvStringIteratorSetChar($4 + 12 | 0, HEAP8[$4 + 55 | 0] << 24 >> 24);
   jsvStringIteratorFree_189($4 + 12 | 0);
  }
  __stack_pointer = $4 - -64 | 0;
 }
 
 function jsvGetStringIndexOf($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP8[$2 + 55 | 0] = $1;
  jsvStringIteratorNew($2 + 12 | 0, HEAP32[$2 + 56 >> 2], 0);
  block : {
   while (1) {
    if (jsvStringIteratorHasChar_210($2 + 12 | 0) & 1) {
     if ((jsvStringIteratorGetChar_212($2 + 12 | 0) & 255) == HEAPU8[$2 + 55 | 0]) {
      HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetIndex_273($2 + 12 | 0);
      jsvStringIteratorFree_189($2 + 12 | 0);
      HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 8 >> 2];
      break block;
     } else {
      jsvStringIteratorNext($2 + 12 | 0);
      continue;
     }
    }
    break;
   };
   jsvStringIteratorFree_189($2 + 12 | 0);
   HEAP32[$2 + 60 >> 2] = -1;
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jsvStringIteratorGetIndex_273($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
 }
 
 function jsvGetUTF8BackingString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   if (!(jsvIsUTF8String(HEAP32[$1 + 8 >> 2]) & 1)) {
    block : {
     if (HEAP32[$1 + 8 >> 2]) {
      $0 = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
      break block;
     }
     $0 = 0;
    }
    HEAP32[$1 + 12 >> 2] = $0;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$1 + 8 >> 2]) & 65535);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvConvertToUTF8AndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 104 >> 2] = $0;
  HEAP32[$1 + 100 >> 2] = jsvNewFromEmptyString_216();
  block : {
   if (!HEAP32[$1 + 100 >> 2]) {
    HEAP32[$1 + 108 >> 2] = 0;
    break block;
   }
   jsvStringIteratorNew($1 + 60 | 0, HEAP32[$1 + 104 >> 2], 0);
   jsvStringIteratorNew($1 + 20 | 0, HEAP32[$1 + 100 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_210($1 + 60 | 0) & 1) {
     HEAP8[$1 + 19 | 0] = jsvStringIteratorGetCharAndNext($1 + 60 | 0);
     block1 : {
      if (jsUTF8IsStartChar(HEAP8[$1 + 19 | 0] << 24 >> 24) & 1) {
       HEAP32[$1 + 8 >> 2] = jsUTF8Encode(HEAPU8[$1 + 19 | 0], $1 + 15 | 0);
       HEAP32[$1 + 4 >> 2] = 0;
       while (1) {
        if (HEAPU32[$1 + 4 >> 2] < HEAPU32[$1 + 8 >> 2]) {
         jsvStringIteratorAppend($1 + 20 | 0, HEAP8[HEAP32[$1 + 4 >> 2] + ($1 + 15 | 0) | 0] << 24 >> 24);
         HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
         continue;
        }
        break;
       };
       break block1;
      }
      jsvStringIteratorAppend($1 + 20 | 0, HEAP8[$1 + 19 | 0] << 24 >> 24);
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_189($1 + 60 | 0);
   jsvStringIteratorFree_189($1 + 20 | 0);
   jsvUnLock(HEAP32[$1 + 104 >> 2]);
   HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 100 >> 2];
  }
  __stack_pointer = $1 + 112 | 0;
  return HEAP32[$1 + 108 >> 2];
 }
 
 function jsvConvertFromUTF8Index($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  if (jsvIsUTF8String(HEAP32[$2 + 56 >> 2]) & 1) {
   jsvStringIteratorNewUTF8($2 + 12 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
   HEAP32[$2 + 52 >> 2] = jsvStringIteratorGetIndex_273($2 + 12 | 0);
   jsvStringIteratorFree_189($2 + 12 | 0);
  }
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 52 >> 2];
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jsvConvertToUTF8Index($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  block : {
   if (!(jsvIsUTF8String(HEAP32[$2 + 56 >> 2]) & 1)) {
    HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 52 >> 2];
    break block;
   }
   HEAP32[$2 + 48 >> 2] = 0;
   jsvStringIteratorNewUTF8($2 + 8 | 0, HEAP32[$2 + 56 >> 2], 0);
   while (1) {
    if ((jsvStringIteratorGetIndex_273($2 + 8 | 0) | 0) < HEAP32[$2 + 52 >> 2]) {
     jsvStringIteratorNextUTF8($2 + 8 | 0);
     HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
     continue;
    }
    break;
   };
   jsvStringIteratorFree_189($2 + 8 | 0);
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jsvGetArrayBufferLength($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8);
 }
 
 function jsvGetChildren($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP16[$1 + 6 >> 1] = jsvGetFirstChild(HEAP32[$1 + 12 >> 2]);
  while (1) {
   if (HEAPU16[$1 + 6 >> 1]) {
    HEAP32[$1 >> 2] = jsvLock(HEAPU16[$1 + 6 >> 1]);
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(HEAP32[$1 >> 2]);
    jsvUnLock(HEAP32[$1 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function _jsvGetIntegerAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvGetInteger(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvGetArrayIndex($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP16[$2 + 18 >> 1] = jsvGetLastChild(HEAP32[$2 + 24 >> 2]);
  HEAP32[$2 + 12 >> 2] = 0;
  block : {
   while (1) {
    if (HEAPU16[$2 + 18 >> 1]) {
     HEAP32[$2 + 8 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
     if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
      $0 = HEAP32[$2 + 8 >> 2];
      HEAP32[$2 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (HEAP32[$2 + 12 >> 2] == HEAP32[$2 + 20 >> 2]) {
       HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
       break block;
      }
      jsvUnLock(HEAP32[$2 + 8 >> 2]);
     } else {
      HEAP16[$2 + 18 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 8 >> 2]);
      jsvUnLock(HEAP32[$2 + 8 >> 2]);
      continue;
     }
    }
    break;
   };
   if (HEAP32[$2 + 20 >> 2] > HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   block1 : {
    if (HEAP32[$2 + 20 >> 2] > (HEAP32[$2 + 12 >> 2] / 2 | 0)) {
     while (1) {
      if (HEAPU16[$2 + 18 >> 1]) {
       HEAP32[$2 + 4 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
       $0 = HEAP32[$2 + 4 >> 2];
       if (HEAP32[$2 + 20 >> 2] == (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
        HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
        break block;
       } else {
        HEAP16[$2 + 18 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 4 >> 2]);
        jsvUnLock(HEAP32[$2 + 4 >> 2]);
        continue;
       }
      }
      break;
     };
     break block1;
    }
    HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
    while (1) {
     if (HEAPU16[$2 + 18 >> 1]) {
      HEAP32[$2 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
      $0 = HEAP32[$2 >> 2];
      if (HEAP32[$2 + 20 >> 2] == (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
       HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
       break block;
      } else {
       HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 >> 2]);
       jsvUnLock(HEAP32[$2 >> 2]);
       continue;
      }
     }
     break;
    };
   }
   HEAP32[$2 + 28 >> 2] = 0;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvGetLongInteger($0) {
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 4 >> 2] = $0;
  block : {
   if (jsvIsInt(HEAP32[$1 + 4 >> 2]) & 1) {
    $2 = jsvGetInteger(HEAP32[$1 + 4 >> 2]);
    $0 = $2 >> 31;
    HEAP32[$1 + 8 >> 2] = $2;
    HEAP32[$1 + 12 >> 2] = $0;
    break block;
   }
   $2 = $1;
   $3 = jsvGetFloat(HEAP32[$1 + 4 >> 2]);
   if (Math_abs($3) < 9223372036854775808.0) {
    if (Math_abs($3) >= 1.0) {
     $0 = ~~($3 > 0.0 ? Math_min(Math_floor($3 * 2.3283064365386963e-10), 4294967295.0) : Math_ceil(($3 - +(~~$3 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0
    } else {
     $0 = 0
    }
    $4 = ~~$3 >>> 0;
   } else {
    $0 = -2147483648
   }
   HEAP32[$2 + 8 >> 2] = $4;
   HEAP32[$2 + 12 >> 2] = $0;
  }
  __stack_pointer = $1 + 16 | 0;
  $2 = HEAP32[$1 + 12 >> 2];
  i64toi32_i32$HIGH_BITS = $2;
  $0 = HEAP32[$1 + 8 >> 2];
  return $0;
 }
 
 function jsvGetLongIntegerAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 >> 2] = jsvGetLongInteger(HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jsvSetInteger($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
 }
 
 function _jsvGetFloatAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAPF64[$1 >> 3] = jsvGetFloat(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAPF64[$1 >> 3];
 }
 
 function jsvAsNumber($0) {
  var $1 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  block1 : {
   block : {
    if (!(jsvIsInt(HEAP32[$1 + 72 >> 2]) & 1)) {
     if (!(jsvIsFloat(HEAP32[$1 + 72 >> 2]) & 1)) {
      break block
     }
    }
    HEAP32[$1 + 76 >> 2] = jsvLockAgain(HEAP32[$1 + 72 >> 2]);
    break block1;
   }
   block3 : {
    block2 : {
     if (jsvIsBoolean(HEAP32[$1 + 72 >> 2]) & 1) {
      break block2
     }
     if (jsvIsPin(HEAP32[$1 + 72 >> 2]) & 1) {
      break block2
     }
     if (jsvIsNull(HEAP32[$1 + 72 >> 2]) & 1) {
      break block2
     }
     if (jsvIsBoolean(HEAP32[$1 + 72 >> 2]) & 1) {
      break block2
     }
     if (!(jsvIsArrayBufferName(HEAP32[$1 + 72 >> 2]) & 1)) {
      break block3
     }
    }
    HEAP32[$1 + 76 >> 2] = jsvNewFromInteger(jsvGetInteger(HEAP32[$1 + 72 >> 2]));
    break block1;
   }
   block4 : {
    if (!(jsvIsString(HEAP32[$1 + 72 >> 2]) & 1)) {
     break block4
    }
    if (!(jsvIsEmptyString(HEAP32[$1 + 72 >> 2]) & 1)) {
     if (!(jsvIsStringNumericInt(HEAP32[$1 + 72 >> 2], 0) & 1)) {
      break block4
     }
    }
    if ((jsvGetString(HEAP32[$1 + 72 >> 2], $1, 64) | 0) == 64) {
     jsExceptionHere(1, 8306, 0);
     HEAP32[$1 + 76 >> 2] = jsvNewFromFloat(NaN);
     break block1;
    }
    HEAP32[$1 + 76 >> 2] = jsvNewFromLongInteger(stringToInt($1), i64toi32_i32$HIGH_BITS);
    break block1;
   }
   HEAP32[$1 + 76 >> 2] = jsvNewFromFloat(jsvGetFloat(HEAP32[$1 + 72 >> 2]));
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jsvAsNumberAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvAsNumber(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvGetBoolAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = _jsvGetBoolAndUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function _jsvGetBoolAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jsvGetBool(HEAP32[$1 + 12 >> 2]) & 1;
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 11 | 0] & 1;
 }
 
 function jsvExecuteGetter($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (!(jsvIsGetterOrSetter(HEAP32[$2 + 20 >> 2]) & 1)) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 20 >> 2], 4994);
   if (!(jsvIsFunction(HEAP32[$2 + 16 >> 2]) & 1)) {
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jspExecuteFunction(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2], 0, 0);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvObjectGetChildIfExists($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (!HEAP32[$2 + 8 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]));
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvExecuteSetter($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block : {
   if (!(jsvIsGetterOrSetter(HEAP32[$3 + 8 >> 2]) & 1)) {
    break block
   }
   HEAP32[$3 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 8 >> 2], 4980);
   if (!(jsvIsFunction(HEAP32[$3 >> 2]) & 1)) {
    jsvUnLock(HEAP32[$3 >> 2]);
    break block;
   }
   if (!HEAP32[$3 >> 2]) {
    break block
   }
   jsvUnLock2(jspExecuteFunction(HEAP32[$3 >> 2], HEAP32[$3 + 12 >> 2], 1, $3 + 4 | 0), HEAP32[$3 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvAddGetterOrSetter($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP8[$4 + 23 | 0] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], 1);
  if (jsvIsName(HEAP32[$4 + 12 >> 2]) & 1) {
   HEAP32[$4 + 8 >> 2] = jsvGetValueOfName(HEAP32[$4 + 12 >> 2]);
   if (!(jsvIsGetterOrSetter(HEAP32[$4 + 8 >> 2]) & 1)) {
    jsvUnLock(HEAP32[$4 + 8 >> 2]);
    HEAP32[$4 + 8 >> 2] = jsvNewWithFlags(6);
    jsvSetValueOfName(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
   }
   if (jsvIsGetterOrSetter(HEAP32[$4 + 8 >> 2]) & 1) {
    jsvObjectSetChild(HEAP32[$4 + 8 >> 2], HEAP8[$4 + 23 | 0] & 1 ? 4994 : 4980, HEAP32[$4 + 16 >> 2])
   }
   jsvUnLock(HEAP32[$4 + 8 >> 2]);
  }
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jsvFindChildFromVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP8[$3 + 19 | 0] = $2;
  HEAP16[$3 + 10 >> 1] = jsvGetFirstChild(HEAP32[$3 + 24 >> 2]);
  block : {
   while (1) {
    if (HEAPU16[$3 + 10 >> 1]) {
     HEAP32[$3 + 12 >> 2] = jsvLock(HEAPU16[$3 + 10 >> 1]);
     if (jsvIsBasicVarEqual(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 20 >> 2]) & 1) {
      break block
     }
     HEAP16[$3 + 10 >> 1] = jsvGetNextSibling(HEAP32[$3 + 12 >> 2]);
     jsvUnLock(HEAP32[$3 + 12 >> 2]);
     continue;
    }
    break;
   };
   HEAP32[$3 + 12 >> 2] = 0;
   if (!(!(HEAP8[$3 + 19 | 0] & 1) | !HEAP32[$3 + 20 >> 2])) {
    HEAP32[$3 + 12 >> 2] = jsvAsName(HEAP32[$3 + 20 >> 2]);
    jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
   }
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvGetValueOfName($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP16[$1 + 6 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   if (HEAPU16[$1 + 6 >> 1] == 14) {
    HEAP32[$1 + 12 >> 2] = jsvArrayBufferGetFromName(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   if (!((HEAPU16[$1 + 6 >> 1] < 18 | HEAPU16[$1 + 6 >> 1] > 22) & HEAPU16[$1 + 6 >> 1] != 16)) {
    HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(jsvGetFirstChildSigned(HEAP32[$1 + 8 >> 2]) << 16 >> 16);
    break block;
   }
   if (HEAPU16[$1 + 6 >> 1] == 17) {
    HEAP32[$1 + 12 >> 2] = jsvNewFromBool((jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) != 0);
    break block;
   }
   if (!(HEAPU16[$1 + 6 >> 1] < 14 | HEAPU16[$1 + 6 >> 1] > 28)) {
    HEAP32[$1 + 12 >> 2] = jsvLockSafe(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectSetChild($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block : {
   if (!(jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1)) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 12 >> 2] = jsvFindOrAddChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvAsName($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   if (!(jsvGetRefs(HEAP32[$1 + 8 >> 2]) & 65535)) {
    if (!(jsvIsName(HEAP32[$1 + 8 >> 2]) & 1)) {
     HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvLockAgain(HEAP32[$1 + 8 >> 2]), 0);
     break block;
    }
    HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvCopy(HEAP32[$1 + 8 >> 2], 0), 0);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvArrayBufferGetFromName($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvGetInteger(HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
  HEAP32[$1 >> 2] = jsvArrayBufferGet(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 >> 2];
 }
 
 function jsvFindOrAddChildFromString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvFindChildFromString(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 4 >> 2] = jsvNewNameFromString(HEAP32[$2 + 8 >> 2]);
   if (HEAP32[$2 + 4 >> 2]) {
    jsvAddName(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2])
   }
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 4 >> 2];
 }
 
 function jsvReplaceWith($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP32[$2 + 40 >> 2] = $1;
  block : {
   if (jsvIsArrayBufferName(HEAP32[$2 + 44 >> 2]) & 1) {
    HEAP32[$2 + 36 >> 2] = jsvGetInteger(HEAP32[$2 + 44 >> 2]);
    HEAP32[$2 + 32 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 44 >> 2]) & 65535);
    jsvArrayBufferSet(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
    jsvUnLock(HEAP32[$2 + 32 >> 2]);
    break block;
   }
   if (!(jsvIsName(HEAP32[$2 + 44 >> 2]) & 1)) {
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 44 >> 2];
    jsExceptionHere(1, 6403, $2 + 16 | 0);
    break block;
   }
   if (jsvIsConstant(HEAP32[$2 + 44 >> 2]) & 1) {
    jsExceptionHere(3, 4716, 0);
    break block;
   }
   HEAP32[$2 + 28 >> 2] = jsvGetValueOfName(HEAP32[$2 + 44 >> 2]);
   if (jsvIsGetterOrSetter(HEAP32[$2 + 28 >> 2]) & 1) {
    block1 : {
     if (jsvIsNewChild(HEAP32[$2 + 44 >> 2]) & 1) {
      $0 = jsvLock(jsvGetNextSibling(HEAP32[$2 + 44 >> 2]) & 65535);
      break block1;
     }
     $0 = 0;
    }
    HEAP32[$2 + 24 >> 2] = $0;
    jsvExecuteSetter(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 40 >> 2]);
    jsvUnLock2(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
    break block;
   }
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   jsvSetValueOfName(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 40 >> 2]);
   if (!(jsvIsNewChild(HEAP32[$2 + 44 >> 2]) & 1)) {
    break block
   }
   HEAP32[$2 + 20 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 44 >> 2]) & 65535);
   if (!(jsvIsString(HEAP32[$2 + 20 >> 2]) & 1)) {
    block2 : {
     if (!(jsvHasChildren(HEAP32[$2 + 20 >> 2]) & 1)) {
      $0 = HEAP32[$2 + 44 >> 2];
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 20 >> 2];
      HEAP32[$2 >> 2] = $0;
      jsExceptionHere(1, 6296, $2);
      break block2;
     }
     jsvUnRef(HEAP32[$2 + 20 >> 2]);
     jsvSetNextSibling(HEAP32[$2 + 44 >> 2], 0);
     jsvUnRef(HEAP32[$2 + 20 >> 2]);
     jsvSetPrevSibling(HEAP32[$2 + 44 >> 2], 0);
     jsvAddName(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 44 >> 2]);
    }
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
  }
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jsvArrayBufferSet($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 76 >> 2] = $0;
  HEAP32[$3 + 72 >> 2] = $1;
  HEAP32[$3 + 68 >> 2] = $2;
  jsvArrayBufferIteratorNew($3 + 8 | 0, HEAP32[$3 + 76 >> 2], HEAP32[$3 + 72 >> 2]);
  jsvArrayBufferIteratorSetValue($3 + 8 | 0, HEAP32[$3 + 68 >> 2], 0);
  jsvArrayBufferIteratorFree($3 + 8 | 0);
  __stack_pointer = $3 + 80 | 0;
 }
 
 function jsvReplaceWithOrAddToRoot($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block : {
   if (jsvGetRefs(HEAP32[$2 + 12 >> 2]) & 65535) {
    break block
   }
   if (!(jsvIsName(HEAP32[$2 + 12 >> 2]) & 1)) {
    break block
   }
   block1 : {
    if (jsvIsArrayBufferName(HEAP32[$2 + 12 >> 2]) & 1) {
     break block1
    }
    if (jsvIsNewChild(HEAP32[$2 + 12 >> 2]) & 1) {
     break block1
    }
    jsvAddName(HEAP32[103307], HEAP32[$2 + 12 >> 2]);
   }
  }
  jsvReplaceWith(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvGetFunctionArgumentLength($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_304($1 + 16 | 0) & 1) {
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetKey_305($1 + 16 | 0);
     if (jsvIsFunctionParameter(HEAP32[$1 + 12 >> 2]) & 1) {
      HEAP32[$1 + 8 >> 2] = jsvSkipOneName(HEAP32[$1 + 12 >> 2]);
      jsvArrayPushAndUnLock(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 8 >> 2]);
     }
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
     jsvObjectIteratorNext($1 + 16 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree($1 + 16 | 0);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvObjectIteratorHasValue_304($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetKey_305($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvSkipOneName($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvSkipNameWithParent(HEAP32[$1 + 12 >> 2], 0, 0);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvObjectIteratorFree($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvSkipNameWithParent($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 40 >> 2] = $0;
  HEAP8[$3 + 39 | 0] = $1;
  HEAP32[$3 + 32 >> 2] = $2;
  block : {
   if (!HEAP32[$3 + 40 >> 2]) {
    HEAP32[$3 + 44 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$3 + 40 >> 2];
   HEAP16[$3 + 30 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   if (HEAPU16[$3 + 30 >> 1] == 14) {
    HEAP32[$3 + 44 >> 2] = jsvArrayBufferGetFromName(HEAP32[$3 + 40 >> 2]);
    break block;
   }
   if (!((HEAPU16[$3 + 30 >> 1] < 18 | HEAPU16[$3 + 30 >> 1] > 22) & HEAPU16[$3 + 30 >> 1] != 16)) {
    HEAP32[$3 + 44 >> 2] = jsvNewFromInteger(jsvGetFirstChildSigned(HEAP32[$3 + 40 >> 2]) << 16 >> 16);
    break block;
   }
   if (HEAPU16[$3 + 30 >> 1] == 17) {
    HEAP32[$3 + 44 >> 2] = jsvNewFromBool((jsvGetFirstChild(HEAP32[$3 + 40 >> 2]) & 65535) != 0);
    break block;
   }
   HEAP32[$3 + 24 >> 2] = jsvLockAgain(HEAP32[$3 + 40 >> 2]);
   while (1) {
    $0 = 0;
    block2 : {
     $0 = HEAPU16[$3 + 30 >> 1] >= 14 ? HEAPU16[$3 + 30 >> 1] <= 28 : $0;
     if (!$0) {
      break block2
     }
     HEAP16[$3 + 22 >> 1] = jsvGetFirstChild(HEAP32[$3 + 24 >> 2]);
     jsvUnLock(HEAP32[$3 + 24 >> 2]);
     if (!HEAPU16[$3 + 22 >> 1]) {
      if (HEAP32[$3 + 24 >> 2] == HEAP32[$3 + 40 >> 2]) {
       jsvCheckReferenceError(HEAP32[$3 + 40 >> 2])
      }
      HEAP32[$3 + 44 >> 2] = 0;
      break block;
     }
     HEAP32[$3 + 24 >> 2] = jsvLock(HEAPU16[$3 + 22 >> 1]);
     $0 = HEAP32[$3 + 24 >> 2];
     HEAP16[$3 + 30 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
     if (!(HEAP8[$3 + 39 | 0] & 1)) {
      break block2
     }
     continue;
    }
    break;
   };
   if (jsvIsGetterOrSetter(HEAP32[$3 + 24 >> 2]) & 1) {
    block3 : {
     if (jsvIsNewChild(HEAP32[$3 + 40 >> 2]) & 1) {
      $0 = jsvLock(jsvGetNextSibling(HEAP32[$3 + 40 >> 2]) & 65535);
      break block3;
     }
     $0 = 0;
    }
    HEAP32[$3 + 16 >> 2] = $0;
    if (HEAP32[$3 + 16 >> 2]) {
     $0 = HEAP32[$3 + 16 >> 2]
    } else {
     $0 = HEAP32[$3 + 32 >> 2]
    }
    HEAP32[$3 + 12 >> 2] = jsvExecuteGetter($0, HEAP32[$3 + 24 >> 2]);
    jsvUnLock2(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 12 >> 2];
   }
   HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 44 >> 2];
 }
 
 function jsvIsVariableDefined($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = 1;
  block : {
   if (!(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1)) {
    break block
   }
   $0 = 1;
   if (jsvIsNameWithValue(HEAP32[$1 + 12 >> 2]) & 1) {
    break block
   }
   $0 = (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) != 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvCheckReferenceError($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!(jsvIsBasicName(HEAP32[$1 + 12 >> 2]) & 1)) {
    break block
   }
   if (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) {
    break block
   }
   if (jsvIsNewChild(HEAP32[$1 + 12 >> 2]) & 1) {
    break block
   }
   if (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) {
    break block
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
   jsExceptionHere(5, 19133, $1);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvSkipToLastName($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
  while (1) {
   block : {
    if (!(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535)) {
     break block
    }
    HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
    block1 : {
     if (jsvIsName(HEAP32[$1 + 4 >> 2]) & 1) {
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 4 >> 2];
      break block1;
     }
     jsvUnLock(HEAP32[$1 + 4 >> 2]);
     break block;
    }
    continue;
   }
   break;
  };
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvSkipOneNameAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvSkipOneName(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvIsStringEqualOrStartsWithOffset($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 80 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 72 >> 2] = $0;
  HEAP32[$5 + 68 >> 2] = $1;
  HEAP8[$5 + 67 | 0] = $2;
  HEAP32[$5 + 60 >> 2] = $3;
  HEAP8[$5 + 59 | 0] = $4;
  block : {
   if (!(jsvHasCharacterData(HEAP32[$5 + 72 >> 2]) & 1)) {
    HEAP8[$5 + 79 | 0] = 0;
    break block;
   }
   jsvStringIteratorNew($5 + 16 | 0, HEAP32[$5 + 72 >> 2], HEAP32[$5 + 60 >> 2]);
   block2 : {
    if (HEAP8[$5 + 59 | 0] & 1) {
     while (1) {
      $0 = 0;
      block1 : {
       if (!(jsvStringIteratorHasChar_210($5 + 16 | 0) & 1)) {
        break block1
       }
       $0 = 0;
       if (!HEAPU8[HEAP32[$5 + 68 >> 2]]) {
        break block1
       }
       $0 = (charToLowerCase(jsvStringIteratorGetChar_212($5 + 16 | 0) << 24 >> 24) & 255) == (charToLowerCase(HEAP8[HEAP32[$5 + 68 >> 2]] << 24 >> 24) & 255);
      }
      if ($0) {
       HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 68 >> 2] + 1;
       jsvStringIteratorNext($5 + 16 | 0);
       continue;
      }
      break;
     };
     break block2;
    }
    while (1) {
     $0 = 0;
     block3 : {
      if (!(jsvStringIteratorHasChar_210($5 + 16 | 0) & 1)) {
       break block3
      }
      $0 = 0;
      if (!HEAPU8[HEAP32[$5 + 68 >> 2]]) {
       break block3
      }
      $0 = (jsvStringIteratorGetChar_212($5 + 16 | 0) & 255) == HEAPU8[HEAP32[$5 + 68 >> 2]];
     }
     if ($0) {
      HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 68 >> 2] + 1;
      jsvStringIteratorNext($5 + 16 | 0);
      continue;
     }
     break;
    };
   }
   block4 : {
    if (HEAP8[$5 + 67 | 0] & 1) {
     $0 = 1;
     if (!HEAPU8[HEAP32[$5 + 68 >> 2]]) {
      break block4
     }
    }
    $0 = (jsvStringIteratorGetChar_212($5 + 16 | 0) & 255) == HEAPU8[HEAP32[$5 + 68 >> 2]];
   }
   HEAP8[$5 + 15 | 0] = $0;
   jsvStringIteratorFree_189($5 + 16 | 0);
   HEAP8[$5 + 79 | 0] = HEAP8[$5 + 15 | 0] & 1;
  }
  __stack_pointer = $5 + 80 | 0;
  return HEAP8[$5 + 79 | 0] & 1;
 }
 
 function jsvIsStringEqualOrStartsWith($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jsvIsStringEqualOrStartsWithOffset(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0, 0);
  __stack_pointer = $3 + 16 | 0;
  return $0 & 1;
 }
 
 function jsvIsStringIEqual($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jsvIsStringEqualOrStartsWithOffset(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 0, 1);
  __stack_pointer = $2 + 16 | 0;
  return $0 & 1;
 }
 
 function jsvGetCommonCharacters($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $0;
  HEAP32[$2 + 100 >> 2] = $1;
  HEAP32[$2 + 96 >> 2] = jsvNewFromEmptyString_216();
  block : {
   if (!HEAP32[$2 + 96 >> 2]) {
    HEAP32[$2 + 108 >> 2] = 0;
    break block;
   }
   jsvStringIteratorNewUTF8($2 + 56 | 0, HEAP32[$2 + 104 >> 2], 0);
   jsvStringIteratorNewUTF8($2 + 16 | 0, HEAP32[$2 + 100 >> 2], 0);
   HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 56 | 0);
   HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 16 | 0);
   while (1) {
    $0 = 0;
    block1 : {
     if (HEAP32[$2 + 12 >> 2] <= 0) {
      break block1
     }
     $0 = 0;
     if (HEAP32[$2 + 8 >> 2] <= 0) {
      break block1
     }
     $0 = HEAP32[$2 + 12 >> 2] == HEAP32[$2 + 8 >> 2];
    }
    if ($0) {
     jsvAppendCharacter(HEAP32[$2 + 96 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
     HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 56 | 0);
     HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 16 | 0);
     continue;
    }
    break;
   };
   jsvStringIteratorFree_189($2 + 56 | 0);
   jsvStringIteratorFree_189($2 + 16 | 0);
   HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 96 >> 2];
  }
  __stack_pointer = $2 + 112 | 0;
  return HEAP32[$2 + 108 >> 2];
 }
 
 function jsvAppendCharacter($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 11 | 0, 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvCopyNameOnly($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP8[$3 + 23 | 0] = $1;
  HEAP8[$3 + 22 | 0] = $2;
  $0 = HEAP32[$3 + 24 >> 2];
  HEAP16[$3 + 20 >> 1] = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
  HEAP32[$3 + 16 >> 2] = 0;
  block2 : {
   if (!(HEAP8[$3 + 22 | 0] & 1)) {
    $0 = HEAP32[$3 + 24 >> 2];
    HEAP16[$3 + 14 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
    block1 : {
     if (!(HEAPU16[$3 + 14 >> 1] < 15 | HEAPU16[$3 + 14 >> 1] > 17)) {
      HEAP16[$3 + 20 >> 1] = HEAPU16[$3 + 20 >> 1] & -64 | 10;
      break block1;
     }
     block3 : {
      if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
       HEAP32[$3 + 16 >> 2] = jsvNewFromStringVarComplete(HEAP32[$3 + 24 >> 2]);
       if (!HEAP32[$3 + 16 >> 2]) {
        HEAP32[$3 + 28 >> 2] = 0;
        break block2;
       }
       break block3;
      }
      HEAP16[$3 + 20 >> 1] = HEAPU16[$3 + 20 >> 1] & 65472 | jsvGetCharactersInVar(HEAP32[$3 + 24 >> 2]) + 29;
     }
    }
   }
   if (!HEAP32[$3 + 16 >> 2]) {
    HEAP32[$3 + 16 >> 2] = jsvNewWithFlags(HEAPU16[$3 + 20 >> 1] & 255);
    if (!HEAP32[$3 + 16 >> 2]) {
     HEAP32[$3 + 28 >> 2] = 0;
     break block2;
    }
    $0 = HEAP32[$3 + 16 >> 2];
    $1 = HEAP32[$3 + 24 >> 2];
    $1 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
    HEAP8[$0 | 0] = $1;
    HEAP8[$0 + 1 | 0] = $1 >>> 8;
    HEAP8[$0 + 2 | 0] = $1 >>> 16;
    HEAP8[$0 + 3 | 0] = $1 >>> 24;
    if (jsvHasStringExt(HEAP32[$3 + 24 >> 2]) & 1) {
     if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
      HEAP32[$3 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535);
      HEAP32[$3 + 4 >> 2] = jsvCopy(HEAP32[$3 + 8 >> 2], 1);
      if (HEAP32[$3 + 4 >> 2]) {
       jsvSetLastChild(HEAP32[$3 + 16 >> 2], jsvGetRef(HEAP32[$3 + 4 >> 2]) & 65535);
       jsvUnLock(HEAP32[$3 + 4 >> 2]);
      }
      jsvUnLock(HEAP32[$3 + 8 >> 2]);
     }
    }
   }
   block4 : {
    if (!(HEAP8[$3 + 23 | 0] & 1)) {
     break block4
    }
    if (!(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535)) {
     break block4
    }
    block5 : {
     if (jsvIsNameWithValue(HEAP32[$3 + 24 >> 2]) & 1) {
      jsvSetFirstChild(HEAP32[$3 + 16 >> 2], jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535);
      break block5;
     }
     jsvSetFirstChild(HEAP32[$3 + 16 >> 2], jsvRefRef(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535) & 65535);
    }
   }
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvCopy($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP8[$2 + 55 | 0] = $1;
  block : {
   if (jsvIsFlatString(HEAP32[$2 + 56 >> 2]) & 1) {
    HEAP32[$2 + 60 >> 2] = jsvNewFromStringVarComplete(HEAP32[$2 + 56 >> 2]);
    break block;
   }
   $0 = HEAP32[$2 + 56 >> 2];
   HEAP32[$2 + 48 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 255);
   if (!HEAP32[$2 + 48 >> 2]) {
    HEAP32[$2 + 60 >> 2] = 0;
    break block;
   }
   block3 : {
    if (!(jsvIsStringExt(HEAP32[$2 + 56 >> 2]) & 1)) {
     $0 = 1;
     block1 : {
      if (jsvIsBasicString(HEAP32[$2 + 56 >> 2]) & 1) {
       break block1
      }
      $0 = 1;
      if (jsvIsNativeString(HEAP32[$2 + 56 >> 2]) & 1) {
       break block1
      }
      $0 = 1;
      if (jsvIsFlashString(HEAP32[$2 + 56 >> 2]) & 1) {
       break block1
      }
      $0 = jsvIsNativeFunction(HEAP32[$2 + 56 >> 2]);
     }
     HEAP8[$2 + 47 | 0] = $0 & 1;
     $1 = HEAP32[$2 + 48 >> 2];
     $4 = HEAP32[$2 + 56 >> 2];
     $0 = HEAP8[$2 + 47 | 0] & 1 ? 9 : 4;
     if ($0) {
      wasm2js_memory_copy($1, $4, $0)
     }
     if (jsvIsNativeFunction(HEAP32[$2 + 56 >> 2]) & 1) {
      jsvSetFirstChild(HEAP32[$2 + 48 >> 2], 0)
     }
     block2 : {
      if (HEAP8[$2 + 47 | 0] & 1) {
       break block2
      }
     }
     break block3;
    }
    $3 = HEAP32[$2 + 56 >> 2];
    $1 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
    $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
    $0 = $1;
    $1 = HEAP32[$2 + 48 >> 2];
    HEAP8[$1 | 0] = $0;
    HEAP8[$1 + 1 | 0] = $0 >>> 8;
    HEAP8[$1 + 2 | 0] = $0 >>> 16;
    HEAP8[$1 + 3 | 0] = $0 >>> 24;
    HEAP8[$1 + 4 | 0] = $4;
    HEAP8[$1 + 5 | 0] = $4 >>> 8;
    HEAP8[$1 + 6 | 0] = $4 >>> 16;
    HEAP8[$1 + 7 | 0] = $4 >>> 24;
    $0 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8;
    HEAP8[$1 + 8 | 0] = $0;
    HEAP8[$1 + 9 | 0] = $0 >>> 8;
   }
   block4 : {
    if (!(HEAP8[$2 + 55 | 0] & 1)) {
     break block4
    }
    if (!(jsvIsName(HEAP32[$2 + 56 >> 2]) & 1)) {
     break block4
    }
    if (jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535) {
     block5 : {
      if (jsvIsNameWithValue(HEAP32[$2 + 56 >> 2]) & 1) {
       jsvSetFirstChild(HEAP32[$2 + 48 >> 2], jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535);
       break block5;
      }
      HEAP32[$2 + 40 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535);
      HEAP32[$2 + 36 >> 2] = jsvRef(jsvCopy(HEAP32[$2 + 40 >> 2], 1));
      jsvUnLock(HEAP32[$2 + 40 >> 2]);
      if (HEAP32[$2 + 36 >> 2]) {
       jsvSetFirstChild(HEAP32[$2 + 48 >> 2], jsvGetRef(HEAP32[$2 + 36 >> 2]) & 65535);
       jsvUnLock(HEAP32[$2 + 36 >> 2]);
      }
     }
    }
   }
   block7 : {
    if (jsvHasStringExt(HEAP32[$2 + 56 >> 2]) & 1) {
     HEAP32[$2 + 56 >> 2] = jsvLockAgain(HEAP32[$2 + 56 >> 2]);
     HEAP32[$2 + 32 >> 2] = jsvLockAgain(HEAP32[$2 + 48 >> 2]);
     while (1) {
      if (jsvGetLastChild(HEAP32[$2 + 56 >> 2]) & 65535) {
       HEAP32[$2 + 28 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$2 + 56 >> 2]) & 65535);
       block6 : {
        if (jsvIsStringExt(HEAP32[$2 + 28 >> 2]) & 1) {
         $0 = HEAP32[$2 + 28 >> 2];
         HEAP32[$2 + 24 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 255);
         if (HEAP32[$2 + 24 >> 2]) {
          $3 = HEAP32[$2 + 28 >> 2];
          $4 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
          $1 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
          $0 = $4;
          $4 = HEAP32[$2 + 24 >> 2];
          HEAP8[$4 | 0] = $0;
          HEAP8[$4 + 1 | 0] = $0 >>> 8;
          HEAP8[$4 + 2 | 0] = $0 >>> 16;
          HEAP8[$4 + 3 | 0] = $0 >>> 24;
          HEAP8[$4 + 4 | 0] = $1;
          HEAP8[$4 + 5 | 0] = $1 >>> 8;
          HEAP8[$4 + 6 | 0] = $1 >>> 16;
          HEAP8[$4 + 7 | 0] = $1 >>> 24;
          $0 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8;
          HEAP8[$4 + 8 | 0] = $0;
          HEAP8[$4 + 9 | 0] = $0 >>> 8;
          jsvSetLastChild(HEAP32[$2 + 32 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
         }
         jsvUnLock2(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2]);
         HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 28 >> 2];
         HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 24 >> 2];
         break block6;
        }
        HEAP32[$2 + 20 >> 2] = jsvCopy(HEAP32[$2 + 28 >> 2], 1);
        if (HEAP32[$2 + 20 >> 2]) {
         jsvSetLastChild(HEAP32[$2 + 32 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 20 >> 2])) & 65535);
         jsvUnLock(HEAP32[$2 + 20 >> 2]);
        }
        jsvUnLock3(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2]);
        HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
        break block;
       }
       continue;
      }
      break;
     };
     jsvUnLock2(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2]);
     break block7;
    }
    if (jsvHasChildren(HEAP32[$2 + 56 >> 2]) & 1 & (HEAP8[$2 + 55 | 0] & 1)) {
     HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 56 >> 2]);
     while (1) {
      if (HEAPU16[$2 + 18 >> 1]) {
       HEAP32[$2 + 12 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
       HEAP32[$2 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$2 + 12 >> 2], 1, 1);
       if (HEAP32[$2 + 8 >> 2]) {
        jsvAddName(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 8 >> 2]);
        jsvUnLock(HEAP32[$2 + 8 >> 2]);
       }
       HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
       jsvUnLock(HEAP32[$2 + 12 >> 2]);
       continue;
      }
      break;
     };
    }
   }
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jsvAddNamedChild($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = jsvNewNameFromString(HEAP32[$3 + 16 >> 2]);
  block : {
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   if (HEAP32[$3 + 20 >> 2]) {
    jsvSetFirstChild(HEAP32[$3 + 12 >> 2], jsvGetRef(jsvRef(HEAP32[$3 + 20 >> 2])) & 65535)
   }
   jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvAddNamedChildAndUnLock($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jsvUnLock2(jsvAddNamedChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]), HEAP32[$3 + 8 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvFindChildFromStringI($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
  block1 : {
   while (1) {
    if (HEAPU16[$2 + 18 >> 1]) {
     HEAP32[$2 + 12 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 18 >> 1]);
     block : {
      if (!(jsvHasCharacterData(HEAP32[$2 + 12 >> 2]) & 1)) {
       break block
      }
      if (!(jsvIsStringEqualOrStartsWithOffset(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2], 0, 0, 1) & 1)) {
       break block
      }
      HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
      break block1;
     }
     HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
     continue;
    }
    break;
   };
   HEAP32[$2 + 28 >> 2] = 0;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvCreateNewChild($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = jsvAsName(HEAP32[$3 + 20 >> 2]);
  block : {
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   if (HEAP32[$3 + 16 >> 2]) {
    jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2])
   }
   HEAP16[$3 + 10 >> 1] = jsvGetRef(jsvRef(jsvRef(HEAP32[$3 + 24 >> 2])));
   jsvSetNextSibling(HEAP32[$3 + 12 >> 2], HEAPU16[$3 + 10 >> 1]);
   jsvSetPrevSibling(HEAP32[$3 + 12 >> 2], HEAPU16[$3 + 10 >> 1]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvRemoveChild($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP16[$2 + 22 >> 1] = jsvGetRef(HEAP32[$2 + 24 >> 2]);
  HEAP8[$2 + 21 | 0] = 0;
  if ((jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535) == HEAPU16[$2 + 22 >> 1]) {
   jsvSetFirstChild(HEAP32[$2 + 28 >> 2], jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
   HEAP8[$2 + 21 | 0] = 1;
  }
  if ((jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) == HEAPU16[$2 + 22 >> 1]) {
   jsvSetLastChild(HEAP32[$2 + 28 >> 2], jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
   HEAP8[$2 + 21 | 0] = 1;
   if (jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1) {
    HEAP32[$2 + 16 >> 2] = 0;
    if (jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) {
     HEAP32[$2 + 16 >> 2] = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535)) + 1
    }
    jsvSetArrayLength(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2], 0);
   }
  }
  if (jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535) {
   HEAP32[$2 + 12 >> 2] = jsvLock(jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
   jsvSetNextSibling(HEAP32[$2 + 12 >> 2], jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP8[$2 + 21 | 0] = 1;
  }
  if (jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535) {
   HEAP32[$2 + 8 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
   jsvSetPrevSibling(HEAP32[$2 + 8 >> 2], jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
   jsvUnLock(HEAP32[$2 + 8 >> 2]);
   HEAP8[$2 + 21 | 0] = 1;
  }
  jsvSetPrevSibling(HEAP32[$2 + 24 >> 2], 0);
  jsvSetNextSibling(HEAP32[$2 + 24 >> 2], 0);
  if (HEAP8[$2 + 21 | 0] & 1) {
   jsvUnRef(HEAP32[$2 + 24 >> 2])
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jsvRemoveChildAndUnLock($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsvRemoveChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  jsvUnLock(HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvRemoveAllChildren($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  while (1) {
   if (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) {
    HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
    jsvRemoveChildAndUnLock(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvIsChild($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP16[$2 + 18 >> 1] = jsvGetRef(HEAP32[$2 + 20 >> 2]);
  HEAP16[$2 + 16 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
  block : {
   while (1) {
    if (HEAPU16[$2 + 16 >> 1]) {
     if (HEAPU16[$2 + 16 >> 1] == HEAPU16[$2 + 18 >> 1]) {
      HEAP8[$2 + 31 | 0] = 1;
      break block;
     } else {
      HEAP32[$2 + 12 >> 2] = jsvLock(HEAPU16[$2 + 16 >> 1]);
      HEAP16[$2 + 16 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      continue;
     }
    }
    break;
   };
   HEAP8[$2 + 31 | 0] = 0;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP8[$2 + 31 | 0] & 1;
 }
 
 function jsvObjectGetChild($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP16[$3 + 18 >> 1] = $2;
  block : {
   if (!HEAP32[$3 + 24 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   block1 : {
    if (HEAPU16[$3 + 18 >> 1]) {
     $0 = jsvFindOrAddChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
     break block1;
    }
    $0 = jsvFindChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   }
   HEAP32[$3 + 12 >> 2] = $0;
   HEAP32[$3 + 8 >> 2] = jsvSkipName(HEAP32[$3 + 12 >> 2]);
   if (!(!HEAP32[$3 + 12 >> 2] | (HEAP32[$3 + 8 >> 2] | !HEAPU16[$3 + 18 >> 1]))) {
    HEAP32[$3 + 8 >> 2] = jsvNewWithFlags(HEAPU16[$3 + 18 >> 1]);
    jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
    break block;
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvObjectGetChildI($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (!HEAP32[$2 + 8 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromStringI(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]));
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsvObjectGetBoolChild($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jsvObjectGetIntegerChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return ($0 | 0) != 0;
 }
 
 function jsvObjectGetIntegerChild($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (!HEAP32[$2 + 24 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
   block1 : {
    if (!(jsvIsNameInt(HEAP32[$2 + 16 >> 2]) & 1)) {
     if (!(jsvIsNameIntBool(HEAP32[$2 + 16 >> 2]) & 1)) {
      break block1
     }
    }
    HEAP32[$2 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[$2 + 16 >> 2]) << 16 >> 16;
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
    break block;
   }
   HEAP32[$2 + 28 >> 2] = jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(HEAP32[$2 + 16 >> 2]));
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvObjectGetFloatChild($0, $1) {
  var $2 = 0, $3 = 0.0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $3 = jsvGetFloatAndUnLock(jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]));
  __stack_pointer = $2 + 16 | 0;
  return $3;
 }
 
 function jsvObjectSetChildVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block : {
   if (!(jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1)) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 1);
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvObjectSetChildAndUnLock($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jsvObjectSetChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  jsvUnLock(HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvObjectRemoveChild($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvFindChildFromString(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  if (HEAP32[$2 + 4 >> 2]) {
   jsvRemoveChildAndUnLock(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2])
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvObjectSetOrRemoveChild($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block : {
   if (HEAP32[$3 + 4 >> 2]) {
    jsvObjectSetChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
    break block;
   }
   jsvObjectRemoveChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
  return HEAP32[$3 + 4 >> 2];
 }
 
 function jsvObjectAppendAll($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  jsvObjectIteratorNew($2 + 20 | 0, HEAP32[$2 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_304($2 + 20 | 0) & 1) {
    HEAP32[$2 + 16 >> 2] = jsvObjectIteratorGetKey_305($2 + 20 | 0);
    HEAP32[$2 + 12 >> 2] = jsvSkipName(HEAP32[$2 + 16 >> 2]);
    if (!(jsvIsInternalObjectKey(HEAP32[$2 + 16 >> 2]) & 1)) {
     jsvObjectSetChildVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2])
    }
    jsvUnLock2(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]);
    jsvObjectIteratorNext($2 + 20 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree($2 + 20 | 0);
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jsvIsInternalObjectKey($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (jsvIsString(HEAP32[$1 + 12 >> 2]) & 1) {
   $2 = 1;
   block : {
    if (HEAPU8[HEAP32[$1 + 12 >> 2]] == 255) {
     break block
    }
    $2 = 1;
    if (jsvIsStringEqual(HEAP32[$1 + 12 >> 2], 20670) & 1) {
     break block
    }
    $2 = jsvIsStringEqual(HEAP32[$1 + 12 >> 2], 7797);
   }
  }
  __stack_pointer = $1 + 16 | 0;
  return $2 & 1;
 }
 
 function jsvCountJsVarsUsed($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (!(!HEAP32[103307] | HEAP32[$1 + 12 >> 2] == HEAP32[103307])) {
   $0 = HEAP32[103307];
   $2 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
   HEAP8[$0 + 12 | 0] = $2;
   HEAP8[$0 + 13 | 0] = $2 >>> 8;
  }
  HEAP32[$1 + 8 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$1 + 12 >> 2], 0);
  _jsvCountJsVarsUsedRecursive(HEAP32[$1 + 12 >> 2], 1);
  if (!(!HEAP32[103307] | HEAP32[$1 + 12 >> 2] == HEAP32[103307])) {
   $0 = HEAP32[103307];
   $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
   HEAP8[$0 + 12 | 0] = $2;
   HEAP8[$0 + 13 | 0] = $2 >>> 8;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function _jsvCountJsVarsUsedRecursive($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP8[$2 + 39 | 0] = $1;
  block : {
   if (!HEAP32[$2 + 40 >> 2]) {
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   block1 : {
    if (HEAP8[$2 + 39 | 0] & 1) {
     $0 = HEAP32[$2 + 40 >> 2];
     if (!((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512)) {
      HEAP32[$2 + 44 >> 2] = 0;
      break block;
     }
     $0 = HEAP32[$2 + 40 >> 2];
     $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     break block1;
    }
    $0 = HEAP32[$2 + 40 >> 2];
    if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512) {
     HEAP32[$2 + 44 >> 2] = 0;
     break block;
    }
    $0 = HEAP32[$2 + 40 >> 2];
    $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
   HEAP32[$2 + 32 >> 2] = 1;
   block4 : {
    block2 : {
     if (!(jsvHasSingleChild(HEAP32[$2 + 40 >> 2]) & 1)) {
      if (!(jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1)) {
       break block2
      }
     }
     HEAP16[$2 + 30 >> 1] = jsvGetFirstChild(HEAP32[$2 + 40 >> 2]);
     while (1) {
      if (HEAPU16[$2 + 30 >> 1]) {
       HEAP32[$2 + 24 >> 2] = jsvLock(HEAPU16[$2 + 30 >> 1]);
       HEAP32[$2 + 32 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$2 + 24 >> 2], HEAP8[$2 + 39 | 0] & 1) + HEAP32[$2 + 32 >> 2];
       block3 : {
        if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
         HEAP16[$2 + 30 >> 1] = jsvGetNextSibling(HEAP32[$2 + 24 >> 2]);
         break block3;
        }
        HEAP16[$2 + 30 >> 1] = 0;
       }
       jsvUnLock(HEAP32[$2 + 24 >> 2]);
       continue;
      }
      break;
     };
     break block4;
    }
    if (jsvIsFlatString(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jsvGetFlatStringBlocks(HEAP32[$2 + 40 >> 2]) + HEAP32[$2 + 32 >> 2]
    }
   }
   if (jsvHasCharacterData(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP16[$2 + 22 >> 1] = jsvGetLastChild(HEAP32[$2 + 40 >> 2]);
    while (1) {
     if (HEAPU16[$2 + 22 >> 1]) {
      HEAP32[$2 + 16 >> 2] = jsvLock(HEAPU16[$2 + 22 >> 1]);
      HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
      HEAP16[$2 + 22 >> 1] = jsvGetLastChild(HEAP32[$2 + 16 >> 2]);
      jsvUnLock(HEAP32[$2 + 16 >> 2]);
      continue;
     }
     break;
    };
   }
   block5 : {
    if (!(jsvIsName(HEAP32[$2 + 40 >> 2]) & 1)) {
     break block5
    }
    if (jsvIsNameWithValue(HEAP32[$2 + 40 >> 2]) & 1) {
     break block5
    }
    if (!(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535)) {
     break block5
    }
    HEAP32[$2 + 12 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535);
    HEAP32[$2 + 32 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 39 | 0] & 1) + HEAP32[$2 + 32 >> 2];
    jsvUnLock(HEAP32[$2 + 12 >> 2]);
   }
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jsvGetLastArrayItem($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 8 >> 2]);
  block : {
   if (!HEAPU16[$1 + 6 >> 1]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipNameAndUnLock(jsvLock(HEAPU16[$1 + 6 >> 1]));
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvSetArrayItem($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = jsvGetArrayIndex(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  block : {
   if (HEAP32[$3 >> 2]) {
    jsvSetValueOfName(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2]);
    break block;
   }
   HEAP32[$3 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$3 + 8 >> 2]), HEAP32[$3 + 4 >> 2]);
   if (HEAP32[$3 >> 2]) {
    jsvAddName(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2])
   }
  }
  jsvUnLock(HEAP32[$3 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvRemoveArrayItem($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvGetArrayIndex(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  if (HEAP32[$2 + 4 >> 2]) {
   jsvRemoveChildAndUnLock(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2])
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvGetArrayItems($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  jsvObjectIteratorNew($3 + 16 | 0, HEAP32[$3 + 28 >> 2]);
  HEAP32[$3 + 12 >> 2] = 0;
  while (1) {
   if (jsvObjectIteratorHasValue_304($3 + 16 | 0) & 1) {
    if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 24 >> 2]) {
     $1 = jsvObjectIteratorGetValue_345($3 + 16 | 0);
     $2 = HEAP32[$3 + 20 >> 2];
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 12 >> 2] = $0 + 1;
     HEAP32[($0 << 2) + $2 >> 2] = $1;
    }
    jsvObjectIteratorNext($3 + 16 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree($3 + 16 | 0);
  while (1) {
   if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 24 >> 2]) {
    $1 = HEAP32[$3 + 20 >> 2];
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $0 + 1;
    HEAP32[($0 << 2) + $1 >> 2] = 0;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsvObjectIteratorGetValue_345($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvGetIndexOfFull($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 88 >> 2] = $0;
  HEAP32[$5 + 84 >> 2] = $1;
  HEAP8[$5 + 83 | 0] = $2;
  HEAP8[$5 + 82 | 0] = $3;
  HEAP32[$5 + 76 >> 2] = $4;
  block : {
   if (!(jsvIsIterable(HEAP32[$5 + 88 >> 2]) & 1)) {
    HEAP32[$5 + 92 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($5 + 12 | 0, HEAP32[$5 + 88 >> 2], 0);
   while (1) {
    if (jsvIteratorHasElement($5 + 12 | 0) & 1) {
     HEAP32[$5 + 8 >> 2] = jsvIteratorGetKey($5 + 12 | 0);
     block1 : {
      if (HEAP8[$5 + 82 | 0] & 1) {
       if (!(jsvIsInt(HEAP32[$5 + 8 >> 2]) & 1)) {
        break block1
       }
       if ((jsvGetInteger(HEAP32[$5 + 8 >> 2]) | 0) < HEAP32[$5 + 76 >> 2]) {
        break block1
       }
      }
      HEAP32[$5 + 4 >> 2] = jsvIteratorGetValue($5 + 12 | 0);
      block2 : {
       if (HEAP32[$5 + 4 >> 2] != HEAP32[$5 + 84 >> 2]) {
        if (HEAP8[$5 + 83 | 0] & 1) {
         break block2
        }
        if (!(jsvMathsOpTypeEqual(HEAP32[$5 + 4 >> 2], HEAP32[$5 + 84 >> 2]) & 1)) {
         break block2
        }
       }
       jsvUnLock(HEAP32[$5 + 4 >> 2]);
       jsvIteratorFree($5 + 12 | 0);
       HEAP32[$5 + 92 >> 2] = HEAP32[$5 + 8 >> 2];
       break block;
      }
      jsvUnLock(HEAP32[$5 + 4 >> 2]);
     }
     jsvUnLock(HEAP32[$5 + 8 >> 2]);
     jsvIteratorNext($5 + 12 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($5 + 12 | 0);
   HEAP32[$5 + 92 >> 2] = 0;
  }
  __stack_pointer = $5 + 96 | 0;
  return HEAP32[$5 + 92 >> 2];
 }
 
 function jsvMathsOpTypeEqual($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP8[$2 + 7 | 0] = (!HEAP32[$2 + 12 >> 2] | 0) == (!HEAP32[$2 + 8 >> 2] | 0);
  if (!(!HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 8 >> 2])) {
   block2 : {
    block1 : {
     if (!(jsvIsInt(HEAP32[$2 + 12 >> 2]) & 1)) {
      if (!(jsvIsFloat(HEAP32[$2 + 12 >> 2]) & 1)) {
       break block1
      }
     }
     $0 = 1;
     if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
      break block2
     }
     $0 = 1;
     if (jsvIsFloat(HEAP32[$2 + 8 >> 2]) & 1) {
      break block2
     }
    }
    if (jsvIsString(HEAP32[$2 + 12 >> 2]) & 1) {
     $0 = 1;
     if (jsvIsString(HEAP32[$2 + 8 >> 2]) & 1) {
      break block2
     }
    }
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAP32[$2 + 8 >> 2];
    $0 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63);
   }
   HEAP8[$2 + 7 | 0] = $0;
  }
  if (HEAP8[$2 + 7 | 0] & 1) {
   HEAP32[$2 >> 2] = jsvMathsOp(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 138);
   if (!(jsvGetBool(HEAP32[$2 >> 2]) & 1)) {
    HEAP8[$2 + 7 | 0] = 0
   }
   jsvUnLock(HEAP32[$2 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP8[$2 + 7 | 0] & 1;
 }
 
 function jsvMathsOp($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 72 >> 2] = $0;
  HEAP32[$3 + 68 >> 2] = $1;
  HEAP32[$3 + 64 >> 2] = $2;
  block1 : {
   if (!(HEAP32[$3 + 64 >> 2] != 139 & HEAP32[$3 + 64 >> 2] != 141)) {
    HEAP8[$3 + 63 | 0] = jsvMathsOpTypeEqual(HEAP32[$3 + 72 >> 2], HEAP32[$3 + 68 >> 2]) & 1;
    if (HEAP32[$3 + 64 >> 2] == 139) {
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP8[$3 + 63 | 0] & 1);
     break block1;
    }
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool((HEAPU8[$3 + 63 | 0] ^ -1) & 1);
    break block1;
   }
   $0 = 1;
   block2 : {
    if (HEAP32[$3 + 64 >> 2] == 38) {
     break block2
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 124) {
     break block2
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 94) {
     break block2
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 143) {
     break block2
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 146) {
     break block2
    }
    $0 = HEAP32[$3 + 64 >> 2] == 147;
   }
   HEAP8[$3 + 62 | 0] = $0;
   $0 = 1;
   block3 : {
    if (HEAP8[$3 + 62 | 0] & 1) {
     break block3
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 42) {
     break block3
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 47) {
     break block3
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 37) {
     break block3
    }
    $0 = HEAP32[$3 + 64 >> 2] == 45;
   }
   HEAP8[$3 + 61 | 0] = $0;
   $0 = 1;
   block4 : {
    if (HEAP32[$3 + 64 >> 2] == 138) {
     break block4
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 140) {
     break block4
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 60) {
     break block4
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 142) {
     break block4
    }
    $0 = 1;
    if (HEAP32[$3 + 64 >> 2] == 62) {
     break block4
    }
    $0 = HEAP32[$3 + 64 >> 2] == 145;
   }
   HEAP8[$3 + 60 | 0] = $0;
   if (HEAP8[$3 + 60 | 0] & 1) {
    block6 : {
     block5 : {
      if (!(jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1)) {
       break block5
      }
      if (!(jsvIsString(HEAP32[$3 + 68 >> 2]) & 1)) {
       break block5
      }
      HEAP8[$3 + 61 | 0] = 1;
      if (jsvIsIntegerish(HEAP32[$3 + 72 >> 2]) & 1) {
       $5 = jsvIsStringNumericInt(HEAP32[$3 + 68 >> 2], 0)
      }
      HEAP8[$3 + 62 | 0] = $5 & 1;
      break block6;
     }
     block7 : {
      if (!(jsvIsNumeric(HEAP32[$3 + 68 >> 2]) & 1)) {
       break block7
      }
      if (!(jsvIsString(HEAP32[$3 + 72 >> 2]) & 1)) {
       break block7
      }
      HEAP8[$3 + 61 | 0] = 1;
      if (jsvIsIntegerish(HEAP32[$3 + 68 >> 2]) & 1) {
       $5 = jsvIsStringNumericInt(HEAP32[$3 + 72 >> 2], 0)
      }
      HEAP8[$3 + 62 | 0] = $5 & 1;
     }
    }
   }
   block8 : {
    if (!(jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1)) {
     break block8
    }
    if (!(jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1)) {
     break block8
    }
    if (HEAP32[$3 + 64 >> 2] == 138) {
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(1);
     break block1;
    }
    if (HEAP32[$3 + 64 >> 2] == 140) {
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(0);
     break block1;
    }
    HEAP32[$3 + 76 >> 2] = 0;
    break block1;
   }
   block11 : {
    block9 : {
     if (HEAP8[$3 + 61 | 0] & 1) {
      break block9
     }
     block10 : {
      if (jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1) {
       break block10
      }
      if (jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1) {
       break block10
      }
      if (!(jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1)) {
       break block11
      }
     }
     if (jsvIsNumeric(HEAP32[$3 + 68 >> 2]) & 1) {
      break block9
     }
     if (jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1) {
      break block9
     }
     if (!(jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)) {
      break block11
     }
    }
    block12 : {
     if (!(HEAP8[$3 + 62 | 0] & 1)) {
      if (!(jsvIsIntegerish(HEAP32[$3 + 72 >> 2]) & 1)) {
       break block12
      }
      if (!(jsvIsIntegerish(HEAP32[$3 + 68 >> 2]) & 1)) {
       break block12
      }
     }
     HEAP32[$3 + 56 >> 2] = jsvGetInteger(HEAP32[$3 + 72 >> 2]);
     HEAP32[$3 + 52 >> 2] = jsvGetInteger(HEAP32[$3 + 68 >> 2]);
     block15 : {
      switch (HEAP32[$3 + 64 >> 2] - 37 | 0) {
      case 6:
       $0 = HEAP32[$3 + 56 >> 2];
       $4 = $0 >> 31;
       $1 = $0;
       $5 = $4;
       $4 = HEAP32[$3 + 52 >> 2];
       $0 = $4 >> 31;
       $2 = $0;
       $6 = $4;
       $1 = $1 + $4 | 0;
       $0 = $5;
       $4 = $2;
       $2 = $0 + $4 | 0;
       $2 = $1 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($1, $2);
       break block1;
      case 8:
       $2 = HEAP32[$3 + 56 >> 2];
       $1 = $2 >> 31;
       $0 = $2;
       $7 = $1;
       $1 = HEAP32[$3 + 52 >> 2];
       $2 = $1 >> 31;
       $5 = $2;
       $6 = $1;
       $4 = $0 - $1 | 0;
       $2 = $7;
       $1 = $5;
       $1 = $1 + ($0 >>> 0 < $6 >>> 0) | 0;
       $1 = $2 - $1 | 0;
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($4, $1);
       break block1;
      case 5:
       $1 = HEAP32[$3 + 56 >> 2];
       $0 = $1 >> 31;
       $5 = $1;
       $4 = $0;
       $0 = HEAP32[$3 + 52 >> 2];
       $1 = $0 >> 31;
       $2 = $1;
       $1 = $4;
       $4 = $0;
       $0 = $2;
       $0 = __wasm_i64_mul($5, $1, $4, $0);
       $1 = i64toi32_i32$HIGH_BITS;
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($0, $1);
       break block1;
      case 10:
       HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(+HEAP32[$3 + 56 >> 2] / +HEAP32[$3 + 52 >> 2]);
       break block1;
      case 1:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] & HEAP32[$3 + 52 >> 2]);
       break block1;
      case 87:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] | HEAP32[$3 + 52 >> 2]);
       break block1;
      case 57:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] ^ HEAP32[$3 + 52 >> 2]);
       break block1;
      case 0:
       if (HEAP32[$3 + 52 >> 2] < 0) {
        HEAP32[$3 + 52 >> 2] = 0 - HEAP32[$3 + 52 >> 2]
       }
       block31 : {
        if (HEAP32[$3 + 52 >> 2]) {
         $0 = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] % HEAP32[$3 + 52 >> 2] | 0);
         break block31;
        }
        $0 = jsvNewFromFloat(NaN);
       }
       HEAP32[$3 + 76 >> 2] = $0;
       break block1;
      case 106:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] << HEAP32[$3 + 52 >> 2]);
       break block1;
      case 109:
       HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] >> HEAP32[$3 + 52 >> 2]);
       break block1;
      case 110:
       HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger(HEAP32[$3 + 56 >> 2] >>> HEAP32[$3 + 52 >> 2] | 0, 0);
       break block1;
      case 101:
       if (HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 52 >> 2]) {
        $4 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) == (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)
       }
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool($4);
       break block1;
      case 103:
       $0 = 1;
       if (HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 52 >> 2]) {
        $0 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) != (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)
       }
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool($0);
       break block1;
      case 23:
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] < HEAP32[$3 + 52 >> 2]);
       break block1;
      case 105:
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] <= HEAP32[$3 + 52 >> 2]);
       break block1;
      case 25:
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] > HEAP32[$3 + 52 >> 2]);
       break block1;
      case 108:
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] >= HEAP32[$3 + 52 >> 2]);
       break block1;
      default:
       break block15;
      };
     }
     HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 8145);
     break block1;
    }
    HEAPF64[$3 + 40 >> 3] = jsvGetFloat(HEAP32[$3 + 72 >> 2]);
    HEAPF64[$3 + 32 >> 3] = jsvGetFloat(HEAP32[$3 + 68 >> 2]);
    block33 : {
     switch (HEAP32[$3 + 64 >> 2] - 37 | 0) {
     case 6:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] + HEAPF64[$3 + 32 >> 3]);
      break block1;
     case 8:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] - HEAPF64[$3 + 32 >> 3]);
      break block1;
     case 5:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] * HEAPF64[$3 + 32 >> 3]);
      break block1;
     case 10:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] / HEAPF64[$3 + 32 >> 3]);
      break block1;
     case 0:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(jswrap_math_mod(HEAPF64[$3 + 40 >> 3], HEAPF64[$3 + 32 >> 3]));
      break block1;
     case 101:
     case 103:
      if (HEAPF64[$3 + 40 >> 3] == HEAPF64[$3 + 32 >> 3]) {
       $4 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) == (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)
      }
      HEAP8[$3 + 31 | 0] = $4;
      block44 : {
       block43 : {
        if (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) {
         if (jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1) {
          break block43
         }
        }
        if (!(jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)) {
         break block44
        }
        if (!(jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1)) {
         break block44
        }
       }
       HEAP8[$3 + 31 | 0] = 1;
      }
      if (HEAP32[$3 + 64 >> 2] == 138) {
       $0 = HEAP8[$3 + 31 | 0] & 1
      } else {
       $0 = (HEAPU8[$3 + 31 | 0] ^ -1) & 1
      }
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool($0);
      break block1;
     case 23:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] < HEAPF64[$3 + 32 >> 3]);
      break block1;
     case 105:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] <= HEAPF64[$3 + 32 >> 3]);
      break block1;
     case 25:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] > HEAPF64[$3 + 32 >> 3]);
      break block1;
     case 108:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] >= HEAPF64[$3 + 32 >> 3]);
      break block1;
     default:
      break block33;
     };
    }
    HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 17933);
    break block1;
   }
   block47 : {
    block46 : {
     if (jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1) {
      break block46
     }
     if (jsvIsObject(HEAP32[$3 + 72 >> 2]) & 1) {
      break block46
     }
     if (jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1) {
      break block46
     }
     if (jsvIsArray(HEAP32[$3 + 68 >> 2]) & 1) {
      break block46
     }
     if (jsvIsObject(HEAP32[$3 + 68 >> 2]) & 1) {
      break block46
     }
     if (!(jsvIsFunction(HEAP32[$3 + 68 >> 2]) & 1)) {
      break block47
     }
    }
    if ((jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1) != (jsvIsArray(HEAP32[$3 + 68 >> 2]) & 1) | HEAP32[$3 + 64 >> 2] != 138 & HEAP32[$3 + 64 >> 2] != 140) {
     break block47
    }
    HEAP8[$3 + 30 | 0] = HEAP32[$3 + 72 >> 2] == HEAP32[$3 + 68 >> 2];
    block48 : {
     if (!(jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1)) {
      if (!(jsvIsNativeFunction(HEAP32[$3 + 68 >> 2]) & 1)) {
       break block48
      }
     }
     $2 = 0;
     block49 : {
      if (!HEAP32[$3 + 72 >> 2]) {
       break block49
      }
      $2 = 0;
      if (!HEAP32[$3 + 68 >> 2]) {
       break block49
      }
      $1 = HEAP32[$3 + 72 >> 2];
      $0 = HEAP32[$3 + 68 >> 2];
      $2 = 0;
      if ((HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24)) != (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
       break block49
      }
      $1 = HEAP32[$3 + 72 >> 2];
      $0 = HEAP32[$3 + 68 >> 2];
      $2 = 0;
      if ((HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8) != (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8)) {
       break block49
      }
      $2 = (jsvGetFirstChild(HEAP32[$3 + 72 >> 2]) & 65535) == (jsvGetFirstChild(HEAP32[$3 + 68 >> 2]) & 65535);
     }
     HEAP8[$3 + 30 | 0] = $2;
    }
    block51 : {
     switch (HEAP32[$3 + 64 >> 2] - 138 | 0) {
     case 0:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP8[$3 + 30 | 0] & 1);
      break block1;
     case 2:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool((HEAPU8[$3 + 30 | 0] ^ -1) & 1);
      break block1;
     default:
      break block51;
     };
    }
    HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1 ? 3797 : 5005);
    break block1;
   }
   HEAP32[$3 + 24 >> 2] = jsvAsString(HEAP32[$3 + 72 >> 2]);
   HEAP32[$3 + 20 >> 2] = jsvAsString(HEAP32[$3 + 68 >> 2]);
   if (!(HEAP32[$3 + 20 >> 2] ? HEAP32[$3 + 24 >> 2] : 0)) {
    jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
    HEAP32[$3 + 76 >> 2] = 0;
    break block1;
   }
   if (HEAP32[$3 + 64 >> 2] == 43) {
    $0 = 1;
    if (!(jsvIsUTF8String(HEAP32[$3 + 24 >> 2]) & 1)) {
     $0 = jsvIsUTF8String(HEAP32[$3 + 20 >> 2])
    }
    HEAP8[$3 + 15 | 0] = $0 & 1;
    if (HEAP8[$3 + 15 | 0] & 1) {
     if (!(jsvIsUTF8String(HEAP32[$3 + 24 >> 2]) & 1)) {
      HEAP32[$3 + 24 >> 2] = jsvConvertToUTF8AndUnLock(HEAP32[$3 + 24 >> 2])
     }
     if (!(jsvIsUTF8String(HEAP32[$3 + 20 >> 2]) & 1)) {
      HEAP32[$3 + 20 >> 2] = jsvConvertToUTF8AndUnLock(HEAP32[$3 + 20 >> 2])
     }
    }
    $0 = HEAP32[$3 + 24 >> 2];
    HEAP16[$3 + 12 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
    block55 : {
     block54 : {
      if (HEAPU16[$3 + 12 >> 1] < 29 | HEAPU16[$3 + 12 >> 1] > 38) {
       break block54
      }
      if ((jsvGetLocks(HEAP32[$3 + 24 >> 2]) & 255) != 1) {
       break block54
      }
      if (jsvGetRefs(HEAP32[$3 + 24 >> 2]) & 65535) {
       break block54
      }
      HEAP32[$3 + 16 >> 2] = jsvLockAgain(HEAP32[$3 + 24 >> 2]);
      break block55;
     }
     block58 : {
      block57 : {
       if (!(HEAPU16[$3 + 12 >> 1] == 39 | HEAPU16[$3 + 12 >> 1] == 40 | (HEAPU16[$3 + 12 >> 1] == 42 | HEAPU16[$3 + 12 >> 1] == 41))) {
        if (HEAPU16[$3 + 12 >> 1] != 23) {
         break block57
        }
       }
       HEAP32[$3 + 16 >> 2] = jsvNewFromStringVarComplete(HEAP32[$3 + 24 >> 2]);
       break block58;
      }
      HEAP32[$3 + 16 >> 2] = jsvCopy(HEAP32[$3 + 24 >> 2], 0);
     }
    }
    if (HEAP32[$3 + 16 >> 2]) {
     jsvAppendStringVarComplete(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 20 >> 2])
    }
    block59 : {
     if (!(HEAP8[$3 + 15 | 0] & 1)) {
      break block59
     }
     if (jsvIsUTF8String(HEAP32[$3 + 16 >> 2]) & 1) {
      break block59
     }
     HEAP32[$3 + 16 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$3 + 16 >> 2]);
    }
    jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 16 >> 2];
    break block1;
   }
   HEAP32[$3 + 8 >> 2] = jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0, 0, 0);
   jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   block62 : {
    block64 : {
     block60 : {
      block63 : {
       $0 = HEAP32[$3 + 64 >> 2];
       if (($0 | 0) != 60) {
        if (($0 | 0) == 62) {
         break block60
        }
        block61 : {
         if (($0 | 0) != 138) {
          switch ($0 - 140 | 0) {
          case 0:
           break block61;
          case 2:
           break block63;
          case 5:
           break block64;
          default:
           break block62;
          }
         }
         HEAP32[$3 + 76 >> 2] = jsvNewFromBool(!HEAP32[$3 + 8 >> 2]);
         break block1;
        }
        HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] != 0);
        break block1;
       }
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] < 0);
       break block1;
      }
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] <= 0);
      break block1;
     }
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] > 0);
     break block1;
    }
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] >= 0);
    break block1;
   }
   HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 16889);
  }
  __stack_pointer = $3 + 80 | 0;
  return HEAP32[$3 + 76 >> 2];
 }
 
 function jsvGetIndexOf($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jsvGetIndexOfFull(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0, 0);
  __stack_pointer = $3 + 16 | 0;
  return $0;
 }
 
 function jsvArrayAddToEnd($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2];
  if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
   HEAP32[$3 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535);
   HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 8 >> 2]) + 1;
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
  }
  HEAP32[$3 + 4 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$3 + 12 >> 2]), HEAP32[$3 + 20 >> 2]);
  block : {
   if (!HEAP32[$3 + 4 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 4 >> 2]);
   jsvUnLock(HEAP32[$3 + 4 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvArrayPushString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jsvArrayPushAndUnLock(HEAP32[$2 + 12 >> 2], jsvNewFromString(HEAP32[$2 + 8 >> 2]));
  __stack_pointer = $2 + 16 | 0;
  return $0;
 }
 
 function jsvArrayPush2Int($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jsvArrayPushAndUnLock(HEAP32[$3 + 12 >> 2], jsvNewFromInteger(HEAP32[$3 + 8 >> 2]));
  jsvArrayPushAndUnLock(HEAP32[$3 + 12 >> 2], jsvNewFromInteger(HEAP32[$3 + 4 >> 2]));
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvArrayPushAll($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP8[$3 + 23 | 0] = $2;
  jsvObjectIteratorNew($3 + 16 | 0, HEAP32[$3 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_304($3 + 16 | 0) & 1) {
    HEAP32[$3 + 12 >> 2] = jsvObjectIteratorGetValue_345($3 + 16 | 0);
    HEAP8[$3 + 11 | 0] = 1;
    if (HEAP8[$3 + 23 | 0] & 1) {
     HEAP32[$3 + 4 >> 2] = jsvGetIndexOf(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2], 0);
     if (HEAP32[$3 + 4 >> 2]) {
      HEAP8[$3 + 11 | 0] = 0;
      jsvUnLock(HEAP32[$3 + 4 >> 2]);
     }
    }
    if (HEAP8[$3 + 11 | 0] & 1) {
     jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2])
    }
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    jsvObjectIteratorNext($3 + 16 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree($3 + 16 | 0);
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsvArrayPop($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 12 >> 2]);
  if (HEAP32[$1 + 4 >> 2] > 0) {
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - 1;
   if (jsvGetLastChild(HEAP32[$1 + 12 >> 2]) & 65535) {
    HEAP16[$1 + 2 >> 1] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
    HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 2 >> 1]);
    while (1) {
     $0 = 0;
     if (HEAP32[$1 + 8 >> 2]) {
      $0 = jsvIsInt(HEAP32[$1 + 8 >> 2]) ^ -1
     }
     if ($0 & 1) {
      HEAP16[$1 + 2 >> 1] = jsvGetPrevSibling(HEAP32[$1 + 8 >> 2]);
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
      block : {
       if (HEAPU16[$1 + 2 >> 1]) {
        HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 2 >> 1]);
        break block;
       }
       HEAP32[$1 + 8 >> 2] = 0;
      }
      continue;
     }
     break;
    };
    if (HEAP32[$1 + 8 >> 2]) {
     block1 : {
      if ((jsvGetInteger(HEAP32[$1 + 8 >> 2]) | 0) == HEAP32[$1 + 4 >> 2]) {
       jsvRemoveChild(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
       break block1;
      }
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
      HEAP32[$1 + 8 >> 2] = 0;
     }
    }
   }
   jsvSetArrayLength(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 4 >> 2], 0);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvArrayPopFirst($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) {
    HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
    if ((jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) == (jsvGetLastChild(HEAP32[$1 + 8 >> 2]) & 65535)) {
     jsvSetLastChild(HEAP32[$1 + 8 >> 2], 0)
    }
    jsvSetFirstChild(HEAP32[$1 + 8 >> 2], jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535);
    jsvUnRef(HEAP32[$1 + 4 >> 2]);
    if (jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535) {
     HEAP32[$1 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535);
     jsvSetPrevSibling(HEAP32[$1 >> 2], 0);
     jsvUnLock(HEAP32[$1 >> 2]);
    }
    jsvSetNextSibling(HEAP32[$1 + 4 >> 2], 0);
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvArrayAddUnique($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvGetIndexOf(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
  block : {
   if (!HEAP32[$2 + 4 >> 2]) {
    jsvArrayPush(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
    break block;
   }
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvArrayInsertBefore($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (HEAP32[$3 + 24 >> 2]) {
    HEAP32[$3 + 16 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(0), HEAP32[$3 + 20 >> 2]);
    if (!HEAP32[$3 + 16 >> 2]) {
     break block
    }
    HEAP16[$3 + 14 >> 1] = jsvGetRef(jsvRef(HEAP32[$3 + 16 >> 2]));
    HEAP16[$3 + 12 >> 1] = jsvGetPrevSibling(HEAP32[$3 + 24 >> 2]);
    block1 : {
     if (HEAPU16[$3 + 12 >> 1]) {
      HEAP32[$3 + 8 >> 2] = jsvRef(jsvLock(HEAPU16[$3 + 12 >> 1]));
      jsvSetInteger(HEAP32[$3 + 16 >> 2], jsvGetInteger(HEAP32[$3 + 8 >> 2]) + 1 | 0);
      jsvSetNextSibling(HEAP32[$3 + 8 >> 2], HEAPU16[$3 + 14 >> 1]);
      jsvUnLock(HEAP32[$3 + 8 >> 2]);
      jsvSetPrevSibling(HEAP32[$3 + 16 >> 2], HEAPU16[$3 + 12 >> 1]);
      break block1;
     }
     jsvSetPrevSibling(HEAP32[$3 + 16 >> 2], 0);
     jsvSetFirstChild(HEAP32[$3 + 28 >> 2], HEAPU16[$3 + 14 >> 1]);
    }
    jsvSetPrevSibling(HEAP32[$3 + 24 >> 2], HEAPU16[$3 + 14 >> 1]);
    jsvSetNextSibling(HEAP32[$3 + 16 >> 2], jsvGetRef(jsvRef(HEAP32[$3 + 24 >> 2])) & 65535);
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    break block;
   }
   jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsvMathsOpSkipNames($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 16 >> 2] = jsvSkipName(HEAP32[$3 + 28 >> 2]);
  HEAP32[$3 + 12 >> 2] = jsvSkipName(HEAP32[$3 + 24 >> 2]);
  HEAP32[$3 + 8 >> 2] = jsvGetValueOfAndUnLock(HEAP32[$3 + 16 >> 2]);
  HEAP32[$3 + 4 >> 2] = jsvGetValueOfAndUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 >> 2] = jsvMathsOp(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 20 >> 2]);
  jsvUnLock2(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 >> 2];
 }
 
 function jsvMathsOpError($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 60 >> 2] = $0;
  HEAP32[$2 + 56 >> 2] = $1;
  jslTokenAsString(HEAP32[$2 + 60 >> 2], $2 + 16 | 0, 32);
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 56 >> 2];
  HEAP32[$2 >> 2] = $2 + 16;
  jsError(17737, $2);
  __stack_pointer = $2 - -64 | 0;
  return 0;
 }
 
 function jsvNegateAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvNewFromInteger(0);
  HEAP32[$1 + 4 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 45);
  jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function jsvGetPathTo($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = 0;
  $0 = jsvGetPathTo_int(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], $4 + 12 | 0);
  __stack_pointer = $4 + 32 | 0;
  return $0;
 }
 
 function jsvGetPathTo_int($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 128 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 120 >> 2] = $0;
  HEAP32[$5 + 116 >> 2] = $1;
  HEAP32[$5 + 112 >> 2] = $2;
  HEAP32[$5 + 108 >> 2] = $3;
  HEAP32[$5 + 104 >> 2] = $4;
  block : {
   if (HEAP32[$5 + 112 >> 2] <= 0) {
    HEAP32[$5 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 112 >> 2] + 1;
   HEAP32[$5 + 96 >> 2] = 0;
   jsvIteratorNew($5 + 32 | 0, HEAP32[$5 + 120 >> 2], 0);
   while (1) {
    if (jsvIteratorHasElement($5 + 32 | 0) & 1) {
     HEAP32[$5 + 28 >> 2] = jsvIteratorGetValue($5 + 32 | 0);
     if (!(HEAP32[$5 + 120 >> 2] == HEAP32[$5 + 108 >> 2] | HEAP32[$5 + 28 >> 2] != HEAP32[$5 + 116 >> 2])) {
      HEAP32[$5 + 24 >> 2] = jsvAsStringAndUnLock(jsvIteratorGetKey($5 + 32 | 0));
      jsvIteratorFree($5 + 32 | 0);
      HEAP32[$5 + 124 >> 2] = HEAP32[$5 + 24 >> 2];
      break block;
     }
     block3 : {
      block2 : {
       if (jsvIsObject(HEAP32[$5 + 28 >> 2]) & 1) {
        break block2
       }
       if (jsvIsArray(HEAP32[$5 + 28 >> 2]) & 1) {
        break block2
       }
       if (!(jsvIsFunction(HEAP32[$5 + 28 >> 2]) & 1)) {
        break block3
       }
      }
      HEAP32[$5 + 16 >> 2] = jsvGetPathTo_int(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 116 >> 2], HEAP32[$5 + 112 >> 2] - 1 | 0, HEAP32[$5 + 108 >> 2], $5 + 20 | 0);
      if (!(!HEAP32[$5 + 16 >> 2] | HEAP32[$5 + 20 >> 2] >= HEAP32[$5 + 100 >> 2])) {
       HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 20 >> 2];
       HEAP32[$5 + 12 >> 2] = jsvIteratorGetKey($5 + 32 | 0);
       jsvUnLock(HEAP32[$5 + 96 >> 2]);
       $0 = jsvIsObject(HEAP32[$5 + 28 >> 2]) & 1;
       $1 = HEAP32[$5 + 12 >> 2];
       HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 16 >> 2];
       HEAP32[$5 >> 2] = $1;
       HEAP32[$5 + 96 >> 2] = jsvVarPrintf($0 ? 4167 : 20711, $5);
       jsvUnLock(HEAP32[$5 + 12 >> 2]);
      }
      jsvUnLock(HEAP32[$5 + 16 >> 2]);
     }
     jsvIteratorNext($5 + 32 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($5 + 32 | 0);
   HEAP32[HEAP32[$5 + 104 >> 2] >> 2] = HEAP32[$5 + 100 >> 2];
   HEAP32[$5 + 124 >> 2] = HEAP32[$5 + 96 >> 2];
  }
  __stack_pointer = $5 + 128 | 0;
  return HEAP32[$5 + 124 >> 2];
 }
 
 function jsvTraceLockInfo($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvGetRef(HEAP32[$1 + 12 >> 2]);
  $2 = jsvGetRefs(HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 8 >> 2] = jsvGetLocks(HEAP32[$1 + 12 >> 2]) & 255;
  HEAP32[$1 + 4 >> 2] = $2 & 65535;
  HEAP32[$1 >> 2] = $0 & 65535;
  jsiConsolePrintf(27517, $1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jsvTraceGetLowestLevel($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 40 >> 2] == HEAP32[$2 + 36 >> 2]) {
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 32 >> 2] = -1;
   $0 = HEAP32[$2 + 40 >> 2];
   if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512) {
    HEAP32[$2 + 44 >> 2] = -1;
    break block;
   }
   $0 = HEAP32[$2 + 40 >> 2];
   $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
   block1 : {
    if (!(jsvHasSingleChild(HEAP32[$2 + 40 >> 2]) & 1)) {
     break block1
    }
    if (!(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535)) {
     break block1
    }
    HEAP32[$2 + 28 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535);
    HEAP32[$2 + 24 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 36 >> 2]);
    jsvUnLock(HEAP32[$2 + 28 >> 2]);
    if (!(HEAP32[$2 + 32 >> 2] >= 0 & HEAP32[$2 + 24 >> 2] >= HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 24 >> 2] < 0)) {
     HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 24 >> 2] + 1
    }
   }
   if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP16[$2 + 22 >> 1] = jsvGetFirstChild(HEAP32[$2 + 40 >> 2]);
    while (1) {
     if (HEAPU16[$2 + 22 >> 1]) {
      HEAP32[$2 + 16 >> 2] = jsvLock(HEAPU16[$2 + 22 >> 1]);
      HEAP32[$2 + 12 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 36 >> 2]);
      if (!(HEAP32[$2 + 32 >> 2] >= 0 & HEAP32[$2 + 12 >> 2] >= HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 12 >> 2] < 0)) {
       HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 12 >> 2] + 1
      }
      HEAP16[$2 + 22 >> 1] = jsvGetNextSibling(HEAP32[$2 + 16 >> 2]);
      jsvUnLock(HEAP32[$2 + 16 >> 2]);
      continue;
     }
     break;
    };
   }
   $0 = HEAP32[$2 + 40 >> 2];
   $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jsvGarbageCollectMarkUsed($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  $0 = HEAP32[$1 + 8 >> 2];
  $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65279;
  HEAP8[$0 + 12 | 0] = $2;
  HEAP8[$0 + 13 | 0] = $2 >>> 8;
  if (jsvHasStringExt(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 8 >> 2]);
   while (1) {
    if (HEAPU16[$1 + 6 >> 1]) {
     HEAP32[$1 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]);
     $0 = HEAP32[$1 >> 2];
     $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65279;
     HEAP8[$0 + 12 | 0] = $2;
     HEAP8[$0 + 13 | 0] = $2 >>> 8;
     HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 >> 2]);
     continue;
    }
    break;
   };
  }
  block : {
   block1 : {
    if (jsvHasSingleChild(HEAP32[$1 + 8 >> 2]) & 1) {
     if (jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) {
      HEAP32[$1 >> 2] = jsvGetAddressOf(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
      $0 = HEAP32[$1 >> 2];
      if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 256) {
       if (!(jsvGarbageCollectMarkUsed(HEAP32[$1 >> 2]) & 1)) {
        HEAP8[$1 + 15 | 0] = 0;
        break block;
       }
      }
     }
     break block1;
    }
    if (jsvHasChildren(HEAP32[$1 + 8 >> 2]) & 1) {
     if (jsuGetFreeStack() >>> 0 < 256) {
      HEAP8[$1 + 15 | 0] = 0;
      break block;
     }
     HEAP16[$1 + 6 >> 1] = jsvGetFirstChild(HEAP32[$1 + 8 >> 2]);
     while (1) {
      if (HEAPU16[$1 + 6 >> 1]) {
       HEAP32[$1 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]);
       $0 = HEAP32[$1 >> 2];
       if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 256) {
        if (!(jsvGarbageCollectMarkUsed(HEAP32[$1 >> 2]) & 1)) {
         HEAP8[$1 + 15 | 0] = 0;
         break block;
        }
       }
       HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(HEAP32[$1 >> 2]);
       continue;
      }
      break;
     };
    }
   }
   HEAP8[$1 + 15 | 0] = 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvDefragment() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  $0 = __stack_pointer - 48 | 0;
  __stack_pointer = $0;
  block : {
   if (HEAPU8[245206]) {
    break block
   }
   jsvGarbageCollect();
   HEAP8[245206] = 3;
   HEAP32[$0 + 44 >> 2] = 20;
   HEAP32[$0 + 40 >> 2] = 0;
   HEAP16[$0 + 38 >> 1] = 1;
   while (1) {
    if (HEAPU16[$0 + 38 >> 1] <= 12e3) {
     HEAP32[$0 + 32 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 38 >> 1]);
     $1 = HEAP32[$0 + 32 >> 2];
     if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
      HEAP32[$0 + 40 >> 2] = HEAPU16[$0 + 38 >> 1];
      if (jsvIsFlatString(HEAP32[$0 + 32 >> 2]) & 1) {
       HEAP16[$0 + 38 >> 1] = jsvGetFlatStringBlocks(HEAP32[$0 + 32 >> 2]) + HEAPU16[$0 + 38 >> 1]
      }
     }
     HEAP16[$0 + 38 >> 1] = HEAPU16[$0 + 38 >> 1] + 1;
     continue;
    }
    break;
   };
   HEAP16[$0 + 30 >> 1] = 1;
   HEAP16[$0 + 28 >> 1] = 1;
   while (1) {
    if (HEAPU16[$0 + 28 >> 1] <= HEAPU32[$0 + 40 >> 2]) {
     HEAP32[$0 + 24 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 30 >> 1]);
     while (1) {
      $1 = HEAP32[$0 + 24 >> 2];
      if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
       block1 : {
        if (jsvIsFlatString(HEAP32[$0 + 24 >> 2]) & 1) {
         HEAP16[$0 + 30 >> 1] = (jsvGetFlatStringBlocks(HEAP32[$0 + 24 >> 2]) + 1 | 0) + HEAPU16[$0 + 30 >> 1];
         break block1;
        }
        HEAP16[$0 + 30 >> 1] = HEAPU16[$0 + 30 >> 1] + 1;
       }
       if (HEAPU16[$0 + 30 >> 1] > HEAPU32[$0 + 40 >> 2]) {
        HEAP8[245206] = 0;
        jsvCreateEmptyVarList();
        break block;
       } else {
        HEAP32[$0 + 24 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 30 >> 1]);
        continue;
       }
      }
      break;
     };
     HEAP32[$0 + 20 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 28 >> 1]);
     $1 = HEAP32[$0 + 20 >> 2];
     if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
      HEAP8[$0 + 19 | 0] = !(jsvGetLocks(HEAP32[$0 + 20 >> 2]) & 255);
      if ((HEAPU16[$0 + 28 >> 1] - HEAPU16[$0 + 30 >> 1] | 0) < 32) {
       HEAP8[$0 + 19 | 0] = 0
      }
      block5 : {
       if (jsvIsFlatString(HEAP32[$0 + 20 >> 2]) & 1) {
        HEAP32[$0 + 12 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 20 >> 2]) + 1;
        if (HEAP8[$0 + 19 | 0] & 1) {
         HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 30 >> 1];
         HEAP8[$0 + 9 | 0] = 0;
         while (1) {
          $1 = 0;
          $1 = HEAP8[$0 + 9 | 0] & 1 ? $1 : HEAPU16[$0 + 28 >> 1] > HEAPU16[$0 + 10 >> 1] + 20 >>> 0;
          if ($1) {
           HEAP8[$0 + 9 | 0] = 1;
           HEAP32[$0 + 4 >> 2] = 0;
           while (1) {
            if (HEAPU32[$0 + 4 >> 2] < HEAPU32[$0 + 12 >> 2]) {
             $1 = _jsvGetAddressOf(HEAPU16[$0 + 10 >> 1] + HEAP32[$0 + 4 >> 2] & 65535);
             if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
              HEAP8[$0 + 9 | 0] = 0;
              HEAP16[$0 + 10 >> 1] = HEAP32[$0 + 4 >> 2] + HEAPU16[$0 + 10 >> 1];
             } else {
              HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
              continue;
             }
            }
            break;
           };
           if (!(HEAP8[$0 + 9 | 0] & 1)) {
            HEAP32[$0 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 10 >> 1]);
            while (1) {
             block2 : {
              $1 = HEAP32[$0 >> 2];
              if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63)) {
               break block2
              }
              block3 : {
               if (jsvIsFlatString(HEAP32[$0 >> 2]) & 1) {
                HEAP16[$0 + 10 >> 1] = (jsvGetFlatStringBlocks(HEAP32[$0 >> 2]) + 1 | 0) + HEAPU16[$0 + 10 >> 1];
                break block3;
               }
               HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + 1;
              }
              if (HEAPU16[$0 + 10 >> 1] > HEAPU32[$0 + 40 >> 2]) {
               break block2
              }
              HEAP32[$0 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 10 >> 1]);
              continue;
             }
             break;
            };
           }
           continue;
          }
          break;
         };
         if (!(!(HEAP8[$0 + 9 | 0] & 1) | HEAPU16[$0 + 28 >> 1] <= HEAPU16[$0 + 10 >> 1] + 20 >>> 0)) {
          HEAP32[$0 + 24 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 10 >> 1]);
          jshInterruptOff();
          $2 = HEAP32[$0 + 24 >> 2];
          $3 = HEAP32[$0 + 20 >> 2];
          $1 = Math_imul(HEAP32[$0 + 12 >> 2], 14);
          if ($1) {
           wasm2js_memory_copy($2, $3, $1)
          }
          $2 = HEAP32[$0 + 20 >> 2];
          $1 = Math_imul(HEAP32[$0 + 12 >> 2], 14);
          if ($1) {
           wasm2js_memory_fill($2, 0, $1)
          }
          _jsvDefragment_moveReferences(HEAPU16[$0 + 28 >> 1], HEAPU16[$0 + 10 >> 1], HEAP32[$0 + 40 >> 2]);
          jshInterruptOn();
         }
        }
        HEAP16[$0 + 28 >> 1] = HEAPU16[$0 + 28 >> 1] + (HEAP32[$0 + 12 >> 2] - 1 | 0);
        break block5;
       }
       if (HEAP8[$0 + 19 | 0] & 1 & HEAPU16[$0 + 28 >> 1] > HEAPU16[$0 + 30 >> 1] + 20 >>> 0) {
        jshInterruptOff();
        $3 = HEAP32[$0 + 20 >> 2];
        $2 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
        $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
        $1 = $2;
        $2 = HEAP32[$0 + 24 >> 2];
        HEAP8[$2 | 0] = $1;
        HEAP8[$2 + 1 | 0] = $1 >>> 8;
        HEAP8[$2 + 2 | 0] = $1 >>> 16;
        HEAP8[$2 + 3 | 0] = $1 >>> 24;
        HEAP8[$2 + 4 | 0] = $4;
        HEAP8[$2 + 5 | 0] = $4 >>> 8;
        HEAP8[$2 + 6 | 0] = $4 >>> 16;
        HEAP8[$2 + 7 | 0] = $4 >>> 24;
        $1 = HEAPU8[$3 + 12 | 0] | HEAPU8[$3 + 13 | 0] << 8;
        HEAP8[$2 + 12 | 0] = $1;
        HEAP8[$2 + 13 | 0] = $1 >>> 8;
        $1 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8 | (HEAPU8[$3 + 10 | 0] << 16 | HEAPU8[$3 + 11 | 0] << 24);
        HEAP8[$2 + 8 | 0] = $1;
        HEAP8[$2 + 9 | 0] = $1 >>> 8;
        HEAP8[$2 + 10 | 0] = $1 >>> 16;
        HEAP8[$2 + 11 | 0] = $1 >>> 24;
        $2 = HEAP32[$0 + 20 >> 2];
        HEAP8[$2 | 0] = 0;
        HEAP8[$2 + 1 | 0] = 0;
        HEAP8[$2 + 2 | 0] = 0;
        HEAP8[$2 + 3 | 0] = 0;
        HEAP8[$2 + 4 | 0] = 0;
        HEAP8[$2 + 5 | 0] = 0;
        HEAP8[$2 + 6 | 0] = 0;
        HEAP8[$2 + 7 | 0] = 0;
        HEAP8[$2 + 6 | 0] = 0;
        HEAP8[$2 + 7 | 0] = 0;
        HEAP8[$2 + 8 | 0] = 0;
        HEAP8[$2 + 9 | 0] = 0;
        HEAP8[$2 + 10 | 0] = 0;
        HEAP8[$2 + 11 | 0] = 0;
        HEAP8[$2 + 12 | 0] = 0;
        HEAP8[$2 + 13 | 0] = 0;
        _jsvDefragment_moveReferences(HEAPU16[$0 + 28 >> 1], HEAPU16[$0 + 30 >> 1], HEAP32[$0 + 40 >> 2]);
        jshInterruptOn();
       }
      }
     }
     jshKickWatchDog();
     jshKickSoftWatchDog();
     HEAP16[$0 + 28 >> 1] = HEAPU16[$0 + 28 >> 1] + 1;
     continue;
    }
    break;
   };
   HEAP8[245206] = 0;
   jsvCreateEmptyVarList();
  }
  __stack_pointer = $0 + 48 | 0;
 }
 
 function _jsvDefragment_moveReferences($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP16[$3 + 14 >> 1] = $0;
  HEAP16[$3 + 12 >> 1] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP16[$3 + 6 >> 1] = 1;
  while (1) {
   if (HEAPU16[$3 + 6 >> 1] <= HEAPU32[$3 + 8 >> 2]) {
    HEAP32[$3 >> 2] = _jsvGetAddressOf(HEAPU16[$3 + 6 >> 1]);
    $0 = HEAP32[$3 >> 2];
    if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) {
     block : {
      if (jsvIsFlatString(HEAP32[$3 >> 2]) & 1) {
       HEAP16[$3 + 6 >> 1] = jsvGetFlatStringBlocks(HEAP32[$3 >> 2]) + HEAPU16[$3 + 6 >> 1];
       break block;
      }
      block1 : {
       if (!(jsvHasSingleChild(HEAP32[$3 >> 2]) & 1)) {
        if (!(jsvHasChildren(HEAP32[$3 >> 2]) & 1)) {
         break block1
        }
       }
       if ((jsvGetFirstChild(HEAP32[$3 >> 2]) & 65535) == HEAPU16[$3 + 14 >> 1]) {
        jsvSetFirstChild(HEAP32[$3 >> 2], HEAPU16[$3 + 12 >> 1])
       }
      }
      block2 : {
       if (!(jsvHasStringExt(HEAP32[$3 >> 2]) & 1)) {
        if (!(jsvHasChildren(HEAP32[$3 >> 2]) & 1)) {
         break block2
        }
       }
       if ((jsvGetLastChild(HEAP32[$3 >> 2]) & 65535) == HEAPU16[$3 + 14 >> 1]) {
        jsvSetLastChild(HEAP32[$3 >> 2], HEAPU16[$3 + 12 >> 1])
       }
      }
      if (jsvIsName(HEAP32[$3 >> 2]) & 1) {
       if ((jsvGetNextSibling(HEAP32[$3 >> 2]) & 65535) == HEAPU16[$3 + 14 >> 1]) {
        jsvSetNextSibling(HEAP32[$3 >> 2], HEAPU16[$3 + 12 >> 1])
       }
       if ((jsvGetPrevSibling(HEAP32[$3 >> 2]) & 65535) == HEAPU16[$3 + 14 >> 1]) {
        jsvSetPrevSibling(HEAP32[$3 >> 2], HEAPU16[$3 + 12 >> 1])
       }
      }
     }
    }
    HEAP16[$3 + 6 >> 1] = HEAPU16[$3 + 6 >> 1] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringTrimRight($0) {
  var $1 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 92 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvNewFromEmptyString_216();
  jsvStringIteratorNew($1 + 52 | 0, HEAP32[$1 + 92 >> 2], 0);
  jsvStringIteratorNew($1 + 12 | 0, HEAP32[$1 + 8 >> 2], 0);
  HEAP32[$1 + 4 >> 2] = 0;
  while (1) {
   if (jsvStringIteratorHasChar_210($1 + 52 | 0) & 1) {
    HEAP8[$1 + 3 | 0] = jsvStringIteratorGetCharAndNext($1 + 52 | 0);
    block : {
     if (HEAPU8[$1 + 3 | 0] == 32) {
      HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
      break block;
     }
     block1 : {
      if (HEAPU8[$1 + 3 | 0] == 10) {
       HEAP32[$1 + 4 >> 2] = 0;
       break block1;
      }
      while (1) {
       if (HEAP32[$1 + 4 >> 2] > 0) {
        jsvStringIteratorAppend($1 + 12 | 0, 32);
        HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - 1;
        continue;
       }
       break;
      };
     }
     jsvStringIteratorAppend($1 + 12 | 0, HEAP8[$1 + 3 | 0] << 24 >> 24);
    }
    continue;
   }
   break;
  };
  jsvStringIteratorFree_189($1 + 52 | 0);
  jsvStringIteratorFree_189($1 + 12 | 0);
  __stack_pointer = $1 + 96 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvIsInternalFunctionKey($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (jsvIsString(HEAP32[$1 + 12 >> 2]) & 1) {
    $0 = 1;
    if (HEAPU8[HEAP32[$1 + 12 >> 2]] == 255) {
     break block
    }
   }
   $0 = jsvIsFunctionParameter(HEAP32[$1 + 12 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jsvGetInternalFunctionCheckerFor($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 3;
    break block;
   }
   if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 4;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvReadConfigObject($0, $1, $2) {
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 56 >> 2] = $0;
  HEAP32[$3 + 52 >> 2] = $1;
  HEAP32[$3 + 48 >> 2] = $2;
  block : {
   if (jsvIsUndefined(HEAP32[$3 + 56 >> 2]) & 1) {
    HEAP8[$3 + 63 | 0] = 1;
    break block;
   }
   if (!(jsvIsObject(HEAP32[$3 + 56 >> 2]) & 1)) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 56 >> 2];
    jsExceptionHere(1, 6180, $3 + 16 | 0);
    HEAP8[$3 + 63 | 0] = 0;
    break block;
   }
   jsvObjectIteratorNew($3 + 44 | 0, HEAP32[$3 + 56 >> 2]);
   HEAP8[$3 + 43 | 0] = 1;
   while (1) {
    $0 = 0;
    if (HEAP8[$3 + 43 | 0] & 1) {
     $0 = jsvObjectIteratorHasValue_304($3 + 44 | 0)
    }
    if ($0 & 1) {
     HEAP32[$3 + 36 >> 2] = jsvObjectIteratorGetKey_305($3 + 44 | 0);
     HEAP8[$3 + 35 | 0] = 0;
     HEAP32[$3 + 28 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 28 >> 2] < HEAP32[$3 + 48 >> 2]) {
       if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], HEAP32[HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) >> 2]) & 1) {
        HEAP8[$3 + 35 | 0] = 1;
        if (HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2]) {
         HEAP32[$3 + 24 >> 2] = jsvObjectIteratorGetValue_345($3 + 44 | 0);
         block2 : {
          block4 : {
           switch (HEAPU16[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 4 >> 1] - 3 | 0) {
           case 0:
           case 2:
           case 4:
           case 26:
            if (HEAP32[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2] >> 2]) {
             jsvUnLock(HEAP32[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2] >> 2])
            }
            $0 = jsvLockAgain(HEAP32[$3 + 24 >> 2]);
            HEAP32[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2] >> 2] = $0;
            break block2;
           case 10:
            $0 = jshGetPinFromVar(HEAP32[$3 + 24 >> 2]);
            HEAP8[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2]] = $0;
            break block2;
           case 9:
            $0 = jsvGetBool(HEAP32[$3 + 24 >> 2]);
            HEAP8[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2]] = $0 & 1;
            break block2;
           case 7:
            $0 = jsvGetInteger(HEAP32[$3 + 24 >> 2]);
            HEAP32[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2] >> 2] = $0;
            break block2;
           case 8:
            break block4;
           default:
            break block2;
           };
          }
          $4 = jsvGetFloat(HEAP32[$3 + 24 >> 2]);
          HEAPF64[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0) + 8 >> 2] >> 3] = $4;
         }
         jsvUnLock(HEAP32[$3 + 24 >> 2]);
        }
       }
       HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
       continue;
      }
      break;
     };
     if (!(HEAP8[$3 + 35 | 0] & 1)) {
      HEAP32[$3 >> 2] = HEAP32[$3 + 36 >> 2];
      jsExceptionHere(1, 14680, $3);
      HEAP8[$3 + 43 | 0] = 0;
     }
     jsvUnLock(HEAP32[$3 + 36 >> 2]);
     jsvObjectIteratorNext($3 + 44 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree($3 + 44 | 0);
   HEAP8[$3 + 63 | 0] = HEAP8[$3 + 43 | 0] & 1;
  }
  __stack_pointer = $3 - -64 | 0;
  return HEAP8[$3 + 63 | 0] & 1;
 }
 
 function jsvCreateConfigObject($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jsvNewObject();
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 20 >> 2]) {
     if (HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2]) {
      HEAP32[$2 + 8 >> 2] = 0;
      block2 : {
       block4 : {
        switch (HEAPU16[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 4 >> 1] - 3 | 0) {
        case 0:
        case 2:
        case 4:
        case 26:
         HEAP32[$2 + 8 >> 2] = jsvLockAgain(HEAP32[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2] >> 2]);
         break block2;
        case 10:
         HEAP32[$2 + 8 >> 2] = jsvNewFromPin(HEAPU8[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2]]);
         break block2;
        case 9:
         HEAP32[$2 + 8 >> 2] = jsvNewFromBool(HEAP8[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2]] & 1);
         break block2;
        case 7:
         HEAP32[$2 + 8 >> 2] = jsvNewFromInteger(HEAP32[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2] >> 2]);
         break block2;
        case 8:
         break block4;
        default:
         break block2;
        };
       }
       HEAP32[$2 + 8 >> 2] = jsvNewFromFloat(HEAPF64[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2] >> 3]);
      }
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) >> 2], HEAP32[$2 + 8 >> 2]);
     }
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvIsInstanceOf($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP8[$2 + 19 | 0] = 0;
  block : {
   if (!(jsvHasChildren(HEAP32[$2 + 24 >> 2]) & 1)) {
    HEAP8[$2 + 31 | 0] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 24 >> 2], 20670);
   if (jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1) {
    HEAP32[$2 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 7797);
    if (HEAP32[$2 + 8 >> 2]) {
     HEAP8[$2 + 19 | 0] = jspIsConstructor(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2]) & 1
    }
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP8[$2 + 31 | 0] = HEAP8[$2 + 19 | 0] & 1;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP8[$2 + 31 | 0] & 1;
 }
 
 function jsvNewTypedArray($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 27 | 0] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jsvNewFromInteger(HEAP32[$2 + 20 >> 2]);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jswrap_typedarray_constructor(HEAPU8[$2 + 27 | 0], HEAP32[$2 + 16 >> 2], 0, 0);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvNewArrayBufferWithPtr($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 24 >> 2]);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewArrayBufferFromString(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2]);
   if (!HEAP32[$2 + 12 >> 2]) {
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   $0 = jsvGetFlatStringPointer(HEAP32[$2 + 16 >> 2]);
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvNewArrayBufferWithData($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 24 >> 2] < 0) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 16 >> 2] = 0;
   HEAP32[$2 + 12 >> 2] = jsvNewArrayBufferWithPtr(HEAP32[$2 + 24 >> 2], $2 + 16 | 0);
   if (!HEAP32[$2 + 16 >> 2]) {
    jsvUnLock(HEAP32[$2 + 12 >> 2]);
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   $1 = HEAP32[$2 + 16 >> 2];
   $3 = HEAP32[$2 + 20 >> 2];
   $0 = HEAP32[$2 + 24 >> 2];
   if ($0) {
    wasm2js_memory_copy($1, $3, $0)
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvMalloc($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 12 >> 2]);
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[413226] = HEAPU8[413226] | 8;
   while (1) {
    if (jsiFreeMoreMemory() & 1) {
     continue
    }
    break;
   };
   jsvGarbageCollect();
   HEAP32[$1 + 8 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 12 >> 2]);
  }
  HEAP32[$1 + 4 >> 2] = jsvGetFlatStringPointer(HEAP32[$1 + 8 >> 2]);
  if (HEAP32[$1 + 4 >> 2]) {
   $2 = HEAP32[$1 + 4 >> 2];
   $0 = HEAP32[$1 + 12 >> 2];
   if ($0) {
    wasm2js_memory_fill($2, 0, $0)
   }
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function jsvFree($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvGetFlatStringFromPointer(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvIterateCallback($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 256 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 248 >> 2] = $0;
  HEAP32[$3 + 244 >> 2] = $1;
  HEAP32[$3 + 240 >> 2] = $2;
  HEAP8[$3 + 239 | 0] = 1;
  block1 : {
   block : {
    if (jsvIsNumeric(HEAP32[$3 + 248 >> 2]) & 1) {
     $0 = HEAP32[$3 + 244 >> 2];
     FUNCTION_TABLE[$0 | 0](jsvGetInteger(HEAP32[$3 + 248 >> 2]), HEAP32[$3 + 240 >> 2]);
     break block;
    }
    block4 : {
     if (jsvIsObject(HEAP32[$3 + 248 >> 2]) & 1) {
      HEAP32[$3 + 232 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 248 >> 2], 15989);
      if (jsvIsFunction(HEAP32[$3 + 232 >> 2]) & 1) {
       HEAP32[$3 + 228 >> 2] = jspExecuteFunction(HEAP32[$3 + 232 >> 2], 0, 0, 0);
       jsvUnLock(HEAP32[$3 + 232 >> 2]);
       if (HEAP32[$3 + 228 >> 2]) {
        HEAP8[$3 + 227 | 0] = jsvIterateCallback(HEAP32[$3 + 228 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
        jsvUnLock(HEAP32[$3 + 228 >> 2]);
        HEAP8[$3 + 255 | 0] = HEAP8[$3 + 227 | 0] & 1;
        break block1;
       }
       HEAP8[$3 + 255 | 0] = 1;
       break block1;
      }
      jsvUnLock(HEAP32[$3 + 232 >> 2]);
      HEAP32[$3 + 220 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 248 >> 2], 4505);
      HEAP32[$3 + 216 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 248 >> 2], 20636);
      block3 : {
       block2 : {
        if (!HEAP32[$3 + 220 >> 2] | !HEAP32[$3 + 216 >> 2]) {
         break block2
        }
        if (!(jsvIsNumeric(HEAP32[$3 + 220 >> 2]) & 1)) {
         break block2
        }
        HEAP32[$3 + 212 >> 2] = jsvGetInteger(HEAP32[$3 + 220 >> 2]);
        while (1) {
         $0 = 0;
         if (HEAP8[$3 + 239 | 0] & 1) {
          $0 = HEAP32[$3 + 212 >> 2];
          HEAP32[$3 + 212 >> 2] = $0 - 1;
          $0 = ($0 | 0) > 0;
         }
         if ($0) {
          HEAP8[$3 + 239 | 0] = jsvIterateCallback(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
          continue;
         }
         break;
        };
        break block3;
       }
       HEAP32[$3 >> 2] = HEAP32[$3 + 248 >> 2];
       jsExceptionHere(3, 16010, $3);
       HEAP8[$3 + 239 | 0] = 0;
      }
      jsvUnLock2(HEAP32[$3 + 220 >> 2], HEAP32[$3 + 216 >> 2]);
      break block4;
     }
     block5 : {
      if (jsvIsString(HEAP32[$3 + 248 >> 2]) & 1) {
       jsvStringIteratorNew($3 + 172 | 0, HEAP32[$3 + 248 >> 2], 0);
       while (1) {
        $0 = 0;
        if (jsvStringIteratorHasChar_381($3 + 172 | 0) & 1) {
         $0 = HEAPU8[$3 + 239 | 0]
        }
        if ($0 & 1) {
         HEAP8[$3 + 171 | 0] = jsvStringIteratorGetCharAndNext($3 + 172 | 0);
         FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]](HEAP8[$3 + 171 | 0] << 24 >> 24, HEAP32[$3 + 240 >> 2]);
         continue;
        }
        break;
       };
       jsvStringIteratorFree_383($3 + 172 | 0);
       break block5;
      }
      block8 : {
       if (jsvIsArrayBuffer(HEAP32[$3 + 248 >> 2]) & 1) {
        jsvArrayBufferIteratorNew($3 + 108 | 0, HEAP32[$3 + 248 >> 2], 0);
        block7 : {
         if (!(HEAPU8[$3 + 148 | 0] & 16 | (HEAPU8[$3 + 148 | 0] & 15) != 1)) {
          HEAP32[$3 + 104 >> 2] = $3 + 108;
          HEAP32[$3 + 100 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 248 >> 2]);
          while (1) {
           $0 = HEAP32[$3 + 100 >> 2];
           HEAP32[$3 + 100 >> 2] = $0 - 1;
           if ($0) {
            $0 = HEAP32[$3 + 244 >> 2];
            FUNCTION_TABLE[$0 | 0](jsvStringIteratorGetChar_385(HEAP32[$3 + 104 >> 2]) & 255, HEAP32[$3 + 240 >> 2]);
            jsvStringIteratorNextInline(HEAP32[$3 + 104 >> 2]);
            continue;
           }
           break;
          };
          break block7;
         }
         while (1) {
          if (jsvArrayBufferIteratorHasElement($3 + 108 | 0) & 1) {
           $0 = HEAP32[$3 + 244 >> 2];
           FUNCTION_TABLE[$0 | 0](jsvArrayBufferIteratorGetIntegerValue($3 + 108 | 0), HEAP32[$3 + 240 >> 2]);
           jsvArrayBufferIteratorNext($3 + 108 | 0);
           continue;
          }
          break;
         };
        }
        jsvArrayBufferIteratorFree($3 + 108 | 0);
        break block8;
       }
       block9 : {
        if (jsvIsIterable(HEAP32[$3 + 248 >> 2]) & 1) {
         jsvIteratorNew($3 + 36 | 0, HEAP32[$3 + 248 >> 2], 1);
         while (1) {
          $0 = 0;
          if (jsvIteratorHasElement($3 + 36 | 0) & 1) {
           $0 = HEAPU8[$3 + 239 | 0]
          }
          if ($0 & 1) {
           HEAP32[$3 + 32 >> 2] = jsvIteratorGetValue($3 + 36 | 0);
           HEAP8[$3 + 239 | 0] = jsvIterateCallback(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
           jsvUnLock(HEAP32[$3 + 32 >> 2]);
           jsvIteratorNext($3 + 36 | 0);
           continue;
          }
          break;
         };
         jsvIteratorFree($3 + 36 | 0);
         break block9;
        }
        HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 248 >> 2];
        jsExceptionHere(3, 6047, $3 + 16 | 0);
        HEAP8[$3 + 239 | 0] = 0;
       }
      }
     }
    }
   }
   HEAP8[$3 + 255 | 0] = HEAP8[$3 + 239 | 0] & 1;
  }
  __stack_pointer = $3 + 256 | 0;
  return HEAP8[$3 + 255 | 0] & 1;
 }
 
 function jsvStringIteratorNew($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2] = 0;
  block : {
   if (!(jsvHasCharacterData(HEAP32[$3 + 8 >> 2]) & 1)) {
    HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = 0;
    HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] = 0;
    HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] = 0;
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 0;
    break block;
   }
   $0 = jsvIsUTF8String(HEAP32[$3 + 8 >> 2]);
   HEAP8[HEAP32[$3 + 12 >> 2] + 20 | 0] = $0 & 1;
   block1 : {
    if (HEAP8[HEAP32[$3 + 12 >> 2] + 20 | 0] & 1) {
     $0 = jsvGetUTF8BackingString(HEAP32[$3 + 8 >> 2]);
     HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = $0;
     break block1;
    }
    $0 = jsvLockAgain(HEAP32[$3 + 8 >> 2]);
    HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = $0;
   }
   $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] = $0;
   if (jsvIsFlashString(HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]) & 1) {
    HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] = 0;
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2];
    jsvStringIteratorLoadFlashString_396(HEAP32[$3 + 12 >> 2]);
    break block;
   }
   jsvStringIteratorUpdatePtr(HEAP32[$3 + 12 >> 2]);
   HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2];
   jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringIteratorHasChar_381($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorGetCharAndNext($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jsvStringIteratorGetChar_385(HEAP32[$1 + 12 >> 2]);
  jsvStringIteratorNextInline(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 11 | 0] << 24 >> 24;
 }
 
 function jsvStringIteratorFree_383($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorNew($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[HEAP32[$3 + 12 >> 2] + 52 >> 2] = HEAP32[$3 + 4 >> 2];
  HEAP8[HEAP32[$3 + 12 >> 2] + 40 | 0] = HEAPU8[HEAP32[$3 + 8 >> 2] + 5 | 0];
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] = Math_imul(HEAPU8[HEAP32[$3 + 12 >> 2] + 40 | 0] & 15, HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8));
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[HEAP32[$3 + 12 >> 2] + 48 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
  HEAP32[$3 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 8 >> 2], 0);
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$0 + 44 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 48 >> 2] + HEAP32[$0 + 44 >> 2];
  HEAP32[HEAP32[$3 + 12 >> 2] + 48 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 48 >> 2] + Math_imul(HEAP32[$3 + 4 >> 2], HEAPU8[HEAP32[$3 + 12 >> 2] + 40 | 0] & 15);
  block : {
   if (HEAPU32[HEAP32[$3 + 12 >> 2] + 48 >> 2] >= (HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] + 1 | 0) - (HEAPU8[HEAP32[$3 + 12 >> 2] + 40 | 0] & 15) >>> 0) {
    jsvUnLock(HEAP32[$3 >> 2]);
    HEAP8[HEAP32[$3 + 12 >> 2] + 40 | 0] = 0;
    break block;
   }
   jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[HEAP32[$3 + 12 >> 2] + 48 >> 2]);
   jsvUnLock(HEAP32[$3 >> 2]);
   HEAP8[HEAP32[$3 + 12 >> 2] + 56 | 0] = 0;
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringIteratorGetChar_385($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function jsvStringIteratorNextInline($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
  if (HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] >= HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
   jsvStringIteratorLoadInline(HEAP32[$1 + 12 >> 2])
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorHasElement($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 40 | 0]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   if (HEAP8[HEAP32[$1 + 8 >> 2] + 56 | 0] & 1) {
    HEAP8[$1 + 15 | 0] = 1;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU32[HEAP32[$1 + 8 >> 2] + 44 >> 2] >= HEAP32[HEAP32[$1 + 8 >> 2] + 48 >> 2] + (HEAPU8[HEAP32[$1 + 8 >> 2] + 40 | 0] & 15) >>> 0;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvArrayBufferIteratorGetIntegerValue($0) {
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 40 | 0]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   jsvArrayBufferIteratorGetValueData(HEAP32[$1 + 8 >> 2], $1);
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 40 | 0] & 32) {
    $2 = jsvArrayBufferIteratorDataToFloat(HEAP32[$1 + 8 >> 2], $1);
    if (Math_abs($2) < 2147483647.0) {
     $0 = ~~$2
    } else {
     $0 = -2147483648
    }
    HEAP32[$1 + 12 >> 2] = $0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorDataToInt(HEAP32[$1 + 8 >> 2], $1);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvArrayBufferIteratorNext($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 52 >> 2] = HEAP32[$0 + 52 >> 2] + 1;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + (HEAPU8[HEAP32[$1 + 12 >> 2] + 40 | 0] & 15);
  block : {
   if (!(HEAP8[HEAP32[$1 + 12 >> 2] + 56 | 0] & 1)) {
    HEAP32[$1 + 8 >> 2] = HEAPU8[HEAP32[$1 + 12 >> 2] + 40 | 0] & 15;
    while (1) {
     $0 = HEAP32[$1 + 8 >> 2];
     HEAP32[$1 + 8 >> 2] = $0 - 1;
     if ($0) {
      jsvStringIteratorNext(HEAP32[$1 + 12 >> 2]);
      continue;
     }
     break;
    };
    break block;
   }
   HEAP8[HEAP32[$1 + 12 >> 2] + 56 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorFree($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAPU8[HEAP32[$1 + 12 >> 2] + 40 | 0]) {
   jsvStringIteratorFree_383(HEAP32[$1 + 12 >> 2])
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvIteratorNew($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block3 : {
   block1 : {
    block : {
     if (jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) {
      break block
     }
     if (jsvIsObject(HEAP32[$3 + 8 >> 2]) & 1) {
      break block
     }
     if (jsvIsFunction(HEAP32[$3 + 8 >> 2]) & 1) {
      break block
     }
     if (!(jsvIsGetterOrSetter(HEAP32[$3 + 8 >> 2]) & 1)) {
      break block1
     }
    }
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 2;
    if (!(!(jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) | !(HEAP32[$3 + 4 >> 2] & 1))) {
     HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 4;
     HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = 0;
     $0 = jsvLockAgain(HEAP32[$3 + 8 >> 2]);
     HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2] = $0;
    }
    jsvObjectIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2]);
    break block3;
   }
   block4 : {
    if (jsvIsArrayBuffer(HEAP32[$3 + 8 >> 2]) & 1) {
     HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 3;
     jsvArrayBufferIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2], 0);
     break block4;
    }
    block5 : {
     if (jsvIsUTF8String(HEAP32[$3 + 8 >> 2]) & 1) {
      HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 5;
      HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] = 0;
      jsvStringIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, jsvGetUTF8BackingString(HEAP32[$3 + 8 >> 2]), 0);
      jsvIteratorUTF8Next(HEAP32[$3 + 12 >> 2]);
      break block5;
     }
     block6 : {
      if (jsvHasCharacterData(HEAP32[$3 + 8 >> 2]) & 1) {
       HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 1;
       jsvStringIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2], 0);
       break block6;
      }
      HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 0;
     }
    }
   }
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvIteratorHasElement($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block6 : {
   block5 : {
    switch (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] - 1 | 0) {
    case 3:
     HEAP8[$1 + 15 | 0] = HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2] < (jsvGetArrayLength(HEAP32[HEAP32[$1 + 8 >> 2] + 8 >> 2]) | 0);
     break block6;
    case 1:
     HEAP8[$1 + 15 | 0] = jsvObjectIteratorHasValue_406(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
     break block6;
    case 0:
     HEAP8[$1 + 15 | 0] = jsvStringIteratorHasChar_381(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
     break block6;
    case 2:
     HEAP8[$1 + 15 | 0] = jsvArrayBufferIteratorHasElement(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
     break block6;
    case 4:
     HEAP8[$1 + 15 | 0] = HEAP32[HEAP32[$1 + 8 >> 2] + 48 >> 2] >= 0;
     break block6;
    default:
     break block5;
    };
   }
   HEAP8[$1 + 15 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsvIteratorGetValue($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block7 : {
   block5 : {
    switch (HEAP32[HEAP32[$1 + 24 >> 2] >> 2] - 1 | 0) {
    case 3:
     block6 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 24 >> 2] + 4 >> 2]) & 1)) {
       break block6
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 24 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 24 >> 2] + 12 >> 2]) {
       break block6
      }
      HEAP32[$1 + 28 >> 2] = jsvObjectIteratorGetValue_407(HEAP32[$1 + 24 >> 2] + 4 | 0);
      break block7;
     }
     HEAP32[$1 + 28 >> 2] = 0;
     break block7;
    case 1:
     HEAP32[$1 + 28 >> 2] = jsvObjectIteratorGetValue_407(HEAP32[$1 + 24 >> 2] + 4 | 0);
     break block7;
    case 0:
     HEAP8[$1 + 23 | 0] = jsvStringIteratorGetChar_385(HEAP32[$1 + 24 >> 2] + 4 | 0);
     HEAP32[$1 + 28 >> 2] = jsvNewStringOfLength(1, $1 + 23 | 0);
     break block7;
    case 2:
     HEAP32[$1 + 28 >> 2] = jsvArrayBufferIteratorGetValueAndRewind(HEAP32[$1 + 24 >> 2] + 4 | 0);
     break block7;
    case 4:
     HEAP32[$1 + 12 >> 2] = jsUTF8Encode(HEAP32[HEAP32[$1 + 24 >> 2] + 48 >> 2], $1 + 19 | 0);
     HEAP32[$1 + 28 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 12 >> 2], $1 + 19 | 0);
     break block7;
    default:
     break block5;
    };
   }
   HEAP32[$1 + 28 >> 2] = 0;
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvIteratorNext($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block5 : {
   block4 : {
    switch (HEAP32[HEAP32[$1 + 12 >> 2] >> 2] - 1 | 0) {
    case 3:
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
     block6 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) & 1)) {
       break block6
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) | 0) >= HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
       break block6
      }
      jsvObjectIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
     }
     break block5;
    case 1:
     jsvObjectIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
     break block5;
    case 0:
     jsvStringIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
     break block5;
    case 2:
     jsvArrayBufferIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
     break block5;
    case 4:
     break block4;
    default:
     break block5;
    };
   }
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 1;
   jsvIteratorUTF8Next(HEAP32[$1 + 12 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvIteratorFree($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block5 : {
   block4 : {
    switch (HEAP32[HEAP32[$1 + 12 >> 2] >> 2] - 1 | 0) {
    case 3:
     jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]);
     jsvObjectIteratorFree_410(HEAP32[$1 + 12 >> 2] + 4 | 0);
     break block5;
    case 1:
     jsvObjectIteratorFree_410(HEAP32[$1 + 12 >> 2] + 4 | 0);
     break block5;
    case 0:
     jsvStringIteratorFree_383(HEAP32[$1 + 12 >> 2] + 4 | 0);
     break block5;
    case 2:
     jsvArrayBufferIteratorFree(HEAP32[$1 + 12 >> 2] + 4 | 0);
     break block5;
    case 4:
     break block4;
    default:
     break block5;
    };
   }
   jsvStringIteratorFree_383(HEAP32[$1 + 12 >> 2] + 4 | 0);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorLoadFlashString_396($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
  block : {
   if (HEAPU32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >= HEAPU32[$1 + 8 >> 2]) {
    HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
    HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
    break block;
   }
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = HEAP32[$1 + 8 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
   if (HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] > 16) {
    HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 16
   }
   $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
   jshFlashRead(HEAP32[$1 + 12 >> 2] + 21 | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 12 >> 2] + 21;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorUpdatePtr($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (jsvIsFlatString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1) {
    $0 = jsvGetFlatStringPointer(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = $0;
    break block;
   }
   block1 : {
    if (jsvIsNativeString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1) {
     $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
     HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     break block1;
    }
    if (!(jsvIsFlashString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1)) {
     block2 : {
      if (HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
       HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
       break block2;
      }
      HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
     }
    }
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorCatchUp($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  while (1) {
   $0 = 0;
   $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] ? HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] >= HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] : $0;
   if ($0) {
    jsvStringIteratorLoadInline(HEAP32[$1 + 12 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorLoadInline($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + HEAP32[$0 + 8 >> 2];
  block : {
   if (jsvIsFlashString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1) {
    jsvStringIteratorLoadFlashString_396(HEAP32[$1 + 12 >> 2]);
    break block;
   }
   block1 : {
    if (!HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
     break block1
    }
    if (!(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535)) {
     break block1
    }
    HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535);
    jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = HEAP32[$1 + 8 >> 2];
    HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 8 >> 2];
    $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = $0;
    break block;
   }
   jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = 0;
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
   HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorGetValueData($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block : {
   if (!HEAPU8[HEAP32[$2 + 12 >> 2] + 40 | 0]) {
    break block
   }
   HEAP32[$2 >> 2] = HEAPU8[HEAP32[$2 + 12 >> 2] + 40 | 0] & 15;
   HEAP32[$2 + 4 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 4 >> 2] < HEAP32[$2 >> 2]) {
     $0 = jsvStringIteratorGetChar_385(HEAP32[$2 + 12 >> 2]);
     HEAP8[HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = $0;
     if (HEAP32[$2 >> 2] != 1) {
      jsvStringIteratorNext(HEAP32[$2 + 12 >> 2])
     }
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$2 >> 2] == 1) {
    break block
   }
   HEAP8[HEAP32[$2 + 12 >> 2] + 56 | 0] = 1;
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorDataToFloat($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0] & 15;
  HEAPF64[$2 + 8 >> 3] = 0;
  block : {
   if (HEAP32[$2 + 20 >> 2] == 4) {
    HEAPF64[$2 + 8 >> 3] = HEAPF32[HEAP32[$2 + 24 >> 2] >> 2];
    break block;
   }
   if (HEAP32[$2 + 20 >> 2] == 8) {
    HEAPF64[$2 + 8 >> 3] = HEAPF64[HEAP32[$2 + 24 >> 2] >> 3]
   }
  }
  return HEAPF64[$2 + 8 >> 3];
 }
 
 function jsvArrayBufferIteratorDataToInt($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0] & 15;
  HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 20 >> 2] << 3;
  $0 = HEAP32[$2 + 16 >> 2];
  HEAP32[$2 + 12 >> 2] = (($0 & 63) >>> 0 < 32 ? 1 << $0 : 0) - 1;
  HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 24 >> 2] >> 2];
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] & HEAP32[$2 + 12 >> 2];
  if (!(!(HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0] & 16) | !(HEAP32[$2 + 8 >> 2] & 1 << HEAP32[$2 + 16 >> 2] - 1))) {
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] | HEAP32[$2 + 12 >> 2] ^ -1
  }
  return HEAP32[$2 + 8 >> 2];
 }
 
 function jsvStringIteratorNext($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvStringIteratorNextInline(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvObjectIteratorNew($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block : {
   if (jsvHasChildren(HEAP32[$2 + 8 >> 2]) & 1) {
    $0 = jsvLockSafe(jsvGetFirstChild(HEAP32[$2 + 8 >> 2]) & 65535);
    break block;
   }
   $0 = 0;
  }
  HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = $0;
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvIteratorUTF8Next($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!(jsvStringIteratorHasChar_381(HEAP32[$1 + 12 >> 2] + 4 | 0) & 1)) {
    HEAP32[HEAP32[$1 + 12 >> 2] + 48 >> 2] = -1;
    break block;
   }
   $0 = jsvStringIteratorGetUTF8CharAndNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
   HEAP32[HEAP32[$1 + 12 >> 2] + 48 >> 2] = $0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvObjectIteratorHasValue_406($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_407($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvArrayBufferIteratorGetValueAndRewind($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 44 >> 2] = $0;
  jsvStringIteratorClone($1 + 4 | 0, HEAP32[$1 + 44 >> 2]);
  HEAP32[$1 >> 2] = jsvArrayBufferIteratorGetValue(HEAP32[$1 + 44 >> 2], 0);
  jsvStringIteratorFree_383(HEAP32[$1 + 44 >> 2]);
  $2 = HEAP32[$1 + 8 >> 2];
  $0 = HEAP32[$1 + 4 >> 2];
  $3 = $0;
  $4 = HEAP32[$1 + 44 >> 2];
  $0 = $4;
  HEAP32[$0 >> 2] = $3;
  HEAP32[$0 + 4 >> 2] = $2;
  $0 = HEAP32[$1 + 40 >> 2];
  $2 = HEAP32[$1 + 36 >> 2];
  $3 = $2;
  $2 = $4;
  HEAP32[$2 + 32 >> 2] = $3;
  HEAP32[$2 + 36 >> 2] = $0;
  $2 = HEAP32[$1 + 32 >> 2];
  $0 = HEAP32[$1 + 28 >> 2];
  $3 = $0;
  $0 = $4;
  HEAP32[$0 + 24 >> 2] = $3;
  HEAP32[$0 + 28 >> 2] = $2;
  $0 = HEAP32[$1 + 24 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  $3 = $2;
  $2 = $4;
  HEAP32[$2 + 16 >> 2] = $3;
  HEAP32[$2 + 20 >> 2] = $0;
  $2 = HEAP32[$1 + 16 >> 2];
  $0 = HEAP32[$1 + 12 >> 2];
  $3 = $0;
  $0 = $4;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $2;
  HEAP8[HEAP32[$1 + 44 >> 2] + 56 | 0] = 0;
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 >> 2];
 }
 
 function jsvObjectIteratorNext($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[HEAP32[$1 + 12 >> 2] >> 2]) {
   HEAP16[$1 + 10 >> 1] = jsvGetNextSibling(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
   jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
   $0 = jsvLockSafe(HEAPU16[$1 + 10 >> 1]);
   HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = $0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvObjectIteratorFree_410($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvIterateBufferCallback($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 272 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 264 >> 2] = $0;
  HEAP32[$3 + 260 >> 2] = $1;
  HEAP32[$3 + 256 >> 2] = $2;
  HEAP8[$3 + 255 | 0] = 1;
  block1 : {
   block : {
    if (jsvIsNumeric(HEAP32[$3 + 264 >> 2]) & 1) {
     HEAP8[$3 + 254 | 0] = jsvGetInteger(HEAP32[$3 + 264 >> 2]);
     FUNCTION_TABLE[HEAP32[$3 + 260 >> 2]]($3 + 254 | 0, 1, HEAP32[$3 + 256 >> 2]);
     break block;
    }
    block4 : {
     if (jsvIsObject(HEAP32[$3 + 264 >> 2]) & 1) {
      HEAP32[$3 + 248 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 264 >> 2], 15989);
      if (jsvIsFunction(HEAP32[$3 + 248 >> 2]) & 1) {
       HEAP32[$3 + 244 >> 2] = jspExecuteFunction(HEAP32[$3 + 248 >> 2], 0, 0, 0);
       jsvUnLock(HEAP32[$3 + 248 >> 2]);
       if (HEAP32[$3 + 244 >> 2]) {
        HEAP8[$3 + 243 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 244 >> 2], HEAP32[$3 + 260 >> 2], HEAP32[$3 + 256 >> 2]) & 1;
        jsvUnLock(HEAP32[$3 + 244 >> 2]);
        HEAP8[$3 + 271 | 0] = HEAP8[$3 + 243 | 0] & 1;
        break block1;
       }
       HEAP8[$3 + 271 | 0] = 1;
       break block1;
      }
      jsvUnLock(HEAP32[$3 + 248 >> 2]);
      HEAP32[$3 + 236 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 264 >> 2], 4505);
      HEAP32[$3 + 232 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 264 >> 2], 20636);
      block3 : {
       block2 : {
        if (!HEAP32[$3 + 236 >> 2] | !HEAP32[$3 + 232 >> 2]) {
         break block2
        }
        if (!(jsvIsNumeric(HEAP32[$3 + 236 >> 2]) & 1)) {
         break block2
        }
        HEAP32[$3 + 228 >> 2] = jsvGetInteger(HEAP32[$3 + 236 >> 2]);
        while (1) {
         $0 = 0;
         if (HEAP8[$3 + 255 | 0] & 1) {
          $0 = HEAP32[$3 + 228 >> 2];
          HEAP32[$3 + 228 >> 2] = $0 - 1;
          $0 = ($0 | 0) > 0;
         }
         if ($0) {
          HEAP8[$3 + 255 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 232 >> 2], HEAP32[$3 + 260 >> 2], HEAP32[$3 + 256 >> 2]) & 1;
          continue;
         }
         break;
        };
        break block3;
       }
       HEAP32[$3 >> 2] = HEAP32[$3 + 264 >> 2];
       jsExceptionHere(3, 16010, $3);
       HEAP8[$3 + 255 | 0] = 0;
      }
      jsvUnLock2(HEAP32[$3 + 236 >> 2], HEAP32[$3 + 232 >> 2]);
      break block4;
     }
     block5 : {
      if (jsvIsString(HEAP32[$3 + 264 >> 2]) & 1) {
       jsvStringIteratorNew($3 + 188 | 0, HEAP32[$3 + 264 >> 2], 0);
       while (1) {
        $0 = 0;
        if (jsvStringIteratorHasChar_381($3 + 188 | 0) & 1) {
         $0 = HEAPU8[$3 + 255 | 0]
        }
        if ($0 & 1) {
         jsvStringIteratorGetPtrAndNext($3 + 188 | 0, $3 + 184 | 0, $3 + 180 | 0);
         FUNCTION_TABLE[HEAP32[$3 + 260 >> 2]](HEAP32[$3 + 184 >> 2], HEAP32[$3 + 180 >> 2], HEAP32[$3 + 256 >> 2]);
         continue;
        }
        break;
       };
       jsvStringIteratorFree_383($3 + 188 | 0);
       break block5;
      }
      block8 : {
       if (jsvIsArrayBuffer(HEAP32[$3 + 264 >> 2]) & 1) {
        jsvArrayBufferIteratorNew($3 + 120 | 0, HEAP32[$3 + 264 >> 2], 0);
        block7 : {
         if (!(HEAPU8[$3 + 160 | 0] & 16 | (HEAPU8[$3 + 160 | 0] & 15) != 1)) {
          HEAP32[$3 + 116 >> 2] = $3 + 120;
          HEAP32[$3 + 112 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 264 >> 2]);
          while (1) {
           if (HEAP32[$3 + 112 >> 2]) {
            jsvStringIteratorGetPtrAndNext(HEAP32[$3 + 116 >> 2], $3 + 108 | 0, $3 + 104 | 0);
            if (HEAPU32[$3 + 104 >> 2] > HEAPU32[$3 + 112 >> 2]) {
             HEAP32[$3 + 104 >> 2] = HEAP32[$3 + 112 >> 2]
            }
            FUNCTION_TABLE[HEAP32[$3 + 260 >> 2]](HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 256 >> 2]);
            HEAP32[$3 + 112 >> 2] = HEAP32[$3 + 112 >> 2] - HEAP32[$3 + 104 >> 2];
            continue;
           }
           break;
          };
          break block7;
         }
         while (1) {
          if (jsvArrayBufferIteratorHasElement($3 + 120 | 0) & 1) {
           HEAP8[$3 + 103 | 0] = jsvArrayBufferIteratorGetIntegerValue($3 + 120 | 0);
           FUNCTION_TABLE[HEAP32[$3 + 260 >> 2]]($3 + 103 | 0, 1, HEAP32[$3 + 256 >> 2]);
           jsvArrayBufferIteratorNext($3 + 120 | 0);
           continue;
          }
          break;
         };
        }
        jsvArrayBufferIteratorFree($3 + 120 | 0);
        break block8;
       }
       block9 : {
        if (jsvIsIterable(HEAP32[$3 + 264 >> 2]) & 1) {
         jsvIteratorNew($3 + 36 | 0, HEAP32[$3 + 264 >> 2], 1);
         while (1) {
          $0 = 0;
          if (jsvIteratorHasElement($3 + 36 | 0) & 1) {
           $0 = HEAPU8[$3 + 255 | 0]
          }
          if ($0 & 1) {
           HEAP32[$3 + 32 >> 2] = jsvIteratorGetValue($3 + 36 | 0);
           HEAP8[$3 + 255 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 260 >> 2], HEAP32[$3 + 256 >> 2]) & 1;
           jsvUnLock(HEAP32[$3 + 32 >> 2]);
           jsvIteratorNext($3 + 36 | 0);
           continue;
          }
          break;
         };
         jsvIteratorFree($3 + 36 | 0);
         break block9;
        }
        HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 264 >> 2];
        jsExceptionHere(3, 6047, $3 + 16 | 0);
        HEAP8[$3 + 255 | 0] = 0;
       }
      }
     }
    }
   }
   HEAP8[$3 + 271 | 0] = HEAP8[$3 + 255 | 0] & 1;
  }
  __stack_pointer = $3 + 272 | 0;
  return HEAP8[$3 + 271 | 0] & 1;
 }
 
 function jsvStringIteratorGetPtrAndNext($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$3 + 12 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] - HEAP32[HEAP32[$3 + 12 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] - 1;
  jsvStringIteratorNextInline(HEAP32[$3 + 12 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvIterateCallbackCount($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 0;
  jsvIterateBufferCallback(HEAP32[$1 + 12 >> 2], 5, $1 + 8 | 0);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jsvIterateCallbackCountCb($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = HEAP32[$3 + 4 >> 2];
  $0 = HEAP32[$3 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 >> 2];
 }
 
 function jsvIterateCallbackToBytes($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 24 >> 2];
  HEAP32[$3 + 12 >> 2] = 0;
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2];
  jsvIterateCallback(HEAP32[$3 + 28 >> 2], 6, $3 + 8 | 0);
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 12 >> 2];
 }
 
 function jsvIterateCallbackToBytesCb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  if (HEAPU32[HEAP32[$2 + 4 >> 2] + 4 >> 2] < HEAPU32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
   HEAP8[HEAP32[HEAP32[$2 + 4 >> 2] >> 2] + HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] | 0] = HEAP32[$2 + 12 >> 2]
  }
  $0 = HEAP32[$2 + 4 >> 2];
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
 }
 
 function jsvStringIteratorNewUTF8($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 0);
  block : {
   if (HEAP8[HEAP32[$3 + 12 >> 2] + 20 | 0] & 1) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 4 >> 2]) {
      jsvStringIteratorNextUTF8(HEAP32[$3 + 12 >> 2]);
      HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] - 1;
      continue;
     }
     break;
    };
    break block;
   }
   HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2];
  }
  jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringIteratorNextUTF8($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!(HEAP8[HEAP32[$1 + 12 >> 2] + 20 | 0] & 1)) {
    jsvStringIteratorNext(HEAP32[$1 + 12 >> 2]);
    break block;
   }
   HEAP32[$1 + 8 >> 2] = jsUTF8LengthFromChar(jsvStringIteratorGetChar_385(HEAP32[$1 + 12 >> 2]) << 24 >> 24);
   while (1) {
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$1 + 8 >> 2] = $0 - 1;
    if (!$0) {
     break block
    }
    jsvStringIteratorNext(HEAP32[$1 + 12 >> 2]);
    continue;
   };
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorClone($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  $4 = HEAP32[$3 + 8 >> 2];
  $0 = HEAP32[$4 >> 2];
  $2 = HEAP32[$4 + 4 >> 2];
  $5 = $0;
  $1 = HEAP32[$3 + 12 >> 2];
  $0 = $1;
  HEAP32[$0 >> 2] = $5;
  HEAP32[$0 + 4 >> 2] = $2;
  $0 = HEAP32[$4 + 36 >> 2];
  $2 = HEAP32[$4 + 32 >> 2];
  $5 = $2;
  $2 = $1;
  HEAP32[$2 + 32 >> 2] = $5;
  HEAP32[$2 + 36 >> 2] = $0;
  $2 = HEAP32[$4 + 28 >> 2];
  $0 = HEAP32[$4 + 24 >> 2];
  $5 = $0;
  $0 = $1;
  HEAP32[$0 + 24 >> 2] = $5;
  HEAP32[$0 + 28 >> 2] = $2;
  $0 = HEAP32[$4 + 20 >> 2];
  $2 = HEAP32[$4 + 16 >> 2];
  $5 = $2;
  $2 = $1;
  HEAP32[$2 + 16 >> 2] = $5;
  HEAP32[$2 + 20 >> 2] = $0;
  $2 = HEAP32[$4 + 12 >> 2];
  $0 = HEAP32[$4 + 8 >> 2];
  $5 = $0;
  $0 = $1;
  HEAP32[$0 + 8 >> 2] = $5;
  HEAP32[$0 + 12 >> 2] = $2;
  if (HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]) {
   jsvLockAgain(HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]);
   if (HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2] == (HEAP32[$3 + 8 >> 2] + 21 | 0)) {
    HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] = HEAP32[$3 + 12 >> 2] + 21
   }
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringIteratorGetUTF8CharAndNext($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (!(jsvStringIteratorHasChar_381(HEAP32[$1 + 24 >> 2]) & 1)) {
    jsvStringIteratorNext(HEAP32[$1 + 24 >> 2]);
    HEAP32[$1 + 28 >> 2] = -1;
    break block;
   }
   HEAP8[$1 + 23 | 0] = jsvStringIteratorGetCharAndNext(HEAP32[$1 + 24 >> 2]);
   if (!(HEAP8[HEAP32[$1 + 24 >> 2] + 20 | 0] & 1)) {
    HEAP32[$1 + 28 >> 2] = HEAPU8[$1 + 23 | 0];
    break block;
   }
   HEAP32[$1 + 16 >> 2] = HEAPU8[$1 + 23 | 0];
   HEAP32[$1 + 12 >> 2] = 0;
   if (!(HEAPU8[$1 + 23 | 0] <= 127 | HEAPU8[$1 + 23 | 0] > 244)) {
    block2 : {
     if ((HEAPU8[$1 + 23 | 0] & 224) == 192) {
      HEAP32[$1 + 16 >> 2] = HEAPU8[$1 + 23 | 0] & 31;
      HEAP32[$1 + 12 >> 2] = 1;
      break block2;
     }
     block3 : {
      if ((HEAPU8[$1 + 23 | 0] & 240) == 224) {
       HEAP32[$1 + 16 >> 2] = HEAPU8[$1 + 23 | 0] & 15;
       HEAP32[$1 + 12 >> 2] = 2;
       break block3;
      }
      if ((HEAPU8[$1 + 23 | 0] & 248) == 240) {
       HEAP32[$1 + 16 >> 2] = HEAPU8[$1 + 23 | 0] & 7;
       HEAP32[$1 + 12 >> 2] = 3;
      }
     }
    }
    while (1) {
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP32[$1 + 12 >> 2] = $0 - 1;
     if ($0) {
      HEAP8[$1 + 23 | 0] = jsvStringIteratorGetCharAndNext(HEAP32[$1 + 24 >> 2]);
      HEAP32[$1 + 16 >> 2] = HEAPU8[$1 + 23 | 0] & 63 | HEAP32[$1 + 16 >> 2] << 6;
      continue;
     }
     break;
    };
   }
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvStringIteratorGetCharOrMinusOne($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   if (!(HEAPU32[HEAP32[$1 + 8 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 8 >> 2] + 4 >> 2] ? HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] : 0)) {
    HEAP32[$1 + 12 >> 2] = -1;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvStringIteratorSetChar($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  if (jsvStringIteratorHasChar_381(HEAP32[$2 + 12 >> 2]) & 1) {
   HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0]
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvStringIteratorSetCharAndNext($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  if (jsvStringIteratorHasChar_381(HEAP32[$2 + 12 >> 2]) & 1) {
   HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0]
  }
  jsvStringIteratorNextInline(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvStringIteratorGotoEnd($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  while (1) {
   if (jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535) {
    HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535);
    jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = HEAP32[$1 + 8 >> 2];
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + HEAP32[$0 + 8 >> 2];
    $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = $0;
    continue;
   }
   break;
  };
  HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
  block : {
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
    HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] - 1;
    break block;
   }
   HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorGoto($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block : {
   if (HEAPU32[$3 + 4 >> 2] >= HEAPU32[HEAP32[$3 + 12 >> 2] + 8 >> 2]) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2] - HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2];
    jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
    break block;
   }
   jsvStringIteratorFree_383(HEAP32[$3 + 12 >> 2]);
   jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringIteratorGotoUTF8($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block1 : {
   if (!(HEAP8[HEAP32[$3 + 12 >> 2] + 20 | 0] & 1 | HEAPU32[$3 + 4 >> 2] < HEAPU32[HEAP32[$3 + 12 >> 2] + 8 >> 2])) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2] - HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2];
    jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
    break block1;
   }
   jsvStringIteratorFree_383(HEAP32[$3 + 12 >> 2]);
   jsvStringIteratorNewUTF8(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringIteratorAppend($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  block : {
   if (!HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
    break block
   }
   if (HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) {
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   }
   if (HEAPU32[HEAP32[$2 + 12 >> 2] >> 2] >= jsvGetMaxCharactersInVar(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) >>> 0) {
    if (!(jsvHasStringExt(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) & 1)) {
     break block
    }
    HEAP32[$2 + 4 >> 2] = jsvNewWithFlags(43);
    if (!HEAP32[$2 + 4 >> 2]) {
     jsvUnLock(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
     HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = 0;
     HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 0;
     HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
     break block;
    }
    jsvSetLastChild(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], jsvGetRef(HEAP32[$2 + 4 >> 2]) & 65535);
    jsvUnLock(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[$2 + 4 >> 2];
    HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = HEAP32[$2 + 4 >> 2];
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
    HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
   }
   HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0];
   HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + 1;
   jsvSetCharactersInVar(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvStringIteratorAppendString($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP32[$4 + 48 >> 2] = $3;
  jsvStringIteratorNew($4 + 8 | 0, HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2]);
  while (1) {
   $0 = 0;
   if (jsvStringIteratorHasChar_381($4 + 8 | 0) & 1) {
    $0 = HEAP32[$4 + 48 >> 2] > 0
   }
   if ($0) {
    jsvStringIteratorAppend(HEAP32[$4 + 60 >> 2], jsvStringIteratorGetCharAndNext($4 + 8 | 0) << 24 >> 24);
    HEAP32[$4 + 48 >> 2] = HEAP32[$4 + 48 >> 2] - 1;
    continue;
   }
   break;
  };
  jsvStringIteratorFree_383($4 + 8 | 0);
  __stack_pointer = $4 - -64 | 0;
 }
 
 function jsvObjectIteratorClone($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
  jsvLockAgainSafe(HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvObjectIteratorSetValue($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  if (HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
   jsvSetValueOfName(HEAP32[HEAP32[$2 + 12 >> 2] >> 2], HEAP32[$2 + 8 >> 2])
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvObjectIteratorRemoveAndGotoNext($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  if (HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
   HEAP16[$2 + 6 >> 1] = jsvGetNextSibling(HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
   jsvRemoveChildAndUnLock(HEAP32[$2 + 8 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
   $0 = jsvLockSafe(HEAPU16[$2 + 6 >> 1]);
   HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = $0;
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorClone($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $5 = __stack_pointer - 16 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 12 >> 2] = $0;
  HEAP32[$5 + 8 >> 2] = $1;
  $3 = HEAP32[$5 + 8 >> 2];
  $0 = HEAP32[$3 >> 2];
  $2 = HEAP32[$3 + 4 >> 2];
  $4 = $0;
  $1 = HEAP32[$5 + 12 >> 2];
  $0 = $1;
  HEAP32[$0 >> 2] = $4;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 56 >> 2] = HEAP32[$3 + 56 >> 2];
  $0 = HEAP32[$3 + 52 >> 2];
  $2 = HEAP32[$3 + 48 >> 2];
  $4 = $2;
  $2 = $1;
  HEAP32[$2 + 48 >> 2] = $4;
  HEAP32[$2 + 52 >> 2] = $0;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$3 + 40 >> 2];
  $4 = $0;
  $0 = $1;
  HEAP32[$0 + 40 >> 2] = $4;
  HEAP32[$0 + 44 >> 2] = $2;
  $0 = HEAP32[$3 + 36 >> 2];
  $2 = HEAP32[$3 + 32 >> 2];
  $4 = $2;
  $2 = $1;
  HEAP32[$2 + 32 >> 2] = $4;
  HEAP32[$2 + 36 >> 2] = $0;
  $2 = HEAP32[$3 + 28 >> 2];
  $0 = HEAP32[$3 + 24 >> 2];
  $4 = $0;
  $0 = $1;
  HEAP32[$0 + 24 >> 2] = $4;
  HEAP32[$0 + 28 >> 2] = $2;
  $0 = HEAP32[$3 + 20 >> 2];
  $2 = HEAP32[$3 + 16 >> 2];
  $4 = $2;
  $2 = $1;
  HEAP32[$2 + 16 >> 2] = $4;
  HEAP32[$2 + 20 >> 2] = $0;
  $2 = HEAP32[$3 + 12 >> 2];
  $0 = HEAP32[$3 + 8 >> 2];
  $4 = $0;
  $0 = $1;
  HEAP32[$0 + 8 >> 2] = $4;
  HEAP32[$0 + 12 >> 2] = $2;
  jsvStringIteratorClone(HEAP32[$5 + 12 >> 2], HEAP32[$5 + 8 >> 2]);
  __stack_pointer = $5 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorGetValue($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP8[$2 + 23 | 0] = $1;
  block : {
   if (!HEAPU8[HEAP32[$2 + 24 >> 2] + 40 | 0]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   jsvArrayBufferIteratorGetValueData(HEAP32[$2 + 24 >> 2], $2 + 12 | 0);
   if (HEAP8[$2 + 23 | 0] & 1) {
    reverseBytes($2 + 12 | 0, HEAPU8[HEAP32[$2 + 24 >> 2] + 40 | 0] & 15)
   }
   if (HEAPU8[HEAP32[$2 + 24 >> 2] + 40 | 0] & 32) {
    HEAP32[$2 + 28 >> 2] = jsvNewFromFloat(jsvArrayBufferIteratorDataToFloat(HEAP32[$2 + 24 >> 2], $2 + 12 | 0));
    break block;
   }
   HEAP32[$2 + 8 >> 2] = jsvArrayBufferIteratorDataToInt(HEAP32[$2 + 24 >> 2], $2 + 12 | 0);
   if (HEAPU8[HEAP32[$2 + 24 >> 2] + 40 | 0] == 4) {
    HEAP32[$2 + 28 >> 2] = jsvNewFromLongInteger(HEAP32[$2 + 8 >> 2], 0);
    break block;
   }
   HEAP32[$2 + 28 >> 2] = jsvNewFromInteger(HEAP32[$2 + 8 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvArrayBufferIteratorGetFloatValue($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 20 >> 2] = $0;
  block : {
   if (!HEAPU8[HEAP32[$1 + 20 >> 2] + 40 | 0]) {
    HEAPF64[$1 + 24 >> 3] = 0;
    break block;
   }
   jsvArrayBufferIteratorGetValueData(HEAP32[$1 + 20 >> 2], $1 + 12 | 0);
   if (HEAPU8[HEAP32[$1 + 20 >> 2] + 40 | 0] & 32) {
    HEAPF64[$1 + 24 >> 3] = jsvArrayBufferIteratorDataToFloat(HEAP32[$1 + 20 >> 2], $1 + 12 | 0);
    break block;
   }
   HEAPF64[$1 + 24 >> 3] = jsvArrayBufferIteratorDataToInt(HEAP32[$1 + 20 >> 2], $1 + 12 | 0) | 0;
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAPF64[$1 + 24 >> 3];
 }
 
 function jsvArrayBufferIteratorSetIntegerValue($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block : {
   if (!HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0]) {
    break block
   }
   HEAP32[$2 + 8 >> 2] = HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0] & 15;
   block1 : {
    if (HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0] & 32) {
     jsvArrayBufferIteratorFloatToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0], +HEAP32[$2 + 24 >> 2]);
     break block1;
    }
    jsvArrayBufferIteratorIntToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU8[HEAP32[$2 + 28 >> 2] + 40 | 0], HEAP32[$2 + 24 >> 2]);
   }
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 8 >> 2]) {
     jsvStringIteratorSetChar(HEAP32[$2 + 28 >> 2], HEAP8[HEAP32[$2 + 12 >> 2] + ($2 + 16 | 0) | 0] << 24 >> 24);
     if (HEAP32[$2 + 8 >> 2] != 1) {
      jsvStringIteratorNext(HEAP32[$2 + 28 >> 2])
     }
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$2 + 8 >> 2] == 1) {
    break block
   }
   HEAP8[HEAP32[$2 + 28 >> 2] + 56 | 0] = 1;
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jsvArrayBufferIteratorFloatToData($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAPF64[$4 + 8 >> 3] = $3;
  block : {
   if (HEAP32[$4 + 24 >> 2] == 4) {
    HEAPF32[HEAP32[$4 + 28 >> 2] >> 2] = HEAPF64[$4 + 8 >> 3];
    break block;
   }
   if (HEAP32[$4 + 24 >> 2] == 8) {
    HEAPF64[HEAP32[$4 + 28 >> 2] >> 3] = HEAPF64[$4 + 8 >> 3]
   }
  }
 }
 
 function jsvArrayBufferIteratorIntToData($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  if (HEAP32[$4 + 4 >> 2] & 64) {
   if (HEAP32[$4 >> 2] < 0) {
    HEAP32[$4 >> 2] = 0
   }
   if (HEAP32[$4 >> 2] > 255) {
    HEAP32[$4 >> 2] = 255
   }
  }
  block : {
   if (HEAP32[$4 + 8 >> 2] == 8) {
    $0 = HEAP32[$4 >> 2];
    $2 = $0 >> 31;
    $1 = $0;
    $0 = HEAP32[$4 + 12 >> 2];
    HEAP32[$0 >> 2] = $1;
    HEAP32[$0 + 4 >> 2] = $2;
    break block;
   }
   HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[$4 >> 2];
  }
 }
 
 function jsvArrayBufferIteratorSetValue($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP8[$3 + 23 | 0] = $2;
  block : {
   if (!HEAPU8[HEAP32[$3 + 28 >> 2] + 40 | 0]) {
    break block
   }
   HEAP32[$3 + 4 >> 2] = HEAPU8[HEAP32[$3 + 28 >> 2] + 40 | 0] & 15;
   block1 : {
    if (HEAPU8[HEAP32[$3 + 28 >> 2] + 40 | 0] & 32) {
     jsvArrayBufferIteratorFloatToData($3 + 12 | 0, HEAP32[$3 + 4 >> 2], HEAPU8[HEAP32[$3 + 28 >> 2] + 40 | 0], jsvGetFloat(HEAP32[$3 + 24 >> 2]));
     break block1;
    }
    jsvArrayBufferIteratorIntToData($3 + 12 | 0, HEAP32[$3 + 4 >> 2], HEAPU8[HEAP32[$3 + 28 >> 2] + 40 | 0], jsvGetInteger(HEAP32[$3 + 24 >> 2]));
   }
   if (HEAP8[$3 + 23 | 0] & 1) {
    reverseBytes($3 + 12 | 0, HEAP32[$3 + 4 >> 2])
   }
   HEAP32[$3 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 8 >> 2] < HEAP32[$3 + 4 >> 2]) {
     jsvStringIteratorSetChar(HEAP32[$3 + 28 >> 2], HEAP8[HEAP32[$3 + 8 >> 2] + ($3 + 12 | 0) | 0] << 24 >> 24);
     if (HEAP32[$3 + 4 >> 2] != 1) {
      jsvStringIteratorNext(HEAP32[$3 + 28 >> 2])
     }
     HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$3 + 4 >> 2] == 1) {
    break block
   }
   HEAP8[HEAP32[$3 + 28 >> 2] + 56 | 0] = 1;
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsvArrayBufferIteratorSetByteValue($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  if ((HEAPU8[HEAP32[$2 + 12 >> 2] + 40 | 0] & 15) == 1) {
   jsvStringIteratorSetChar(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0] << 24 >> 24)
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvArrayBufferIteratorSetValueAndRewind($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP32[$2 + 40 >> 2] = $1;
  jsvStringIteratorClone($2, HEAP32[$2 + 44 >> 2]);
  jsvArrayBufferIteratorSetValue(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 40 >> 2], 0);
  jsvStringIteratorFree_383(HEAP32[$2 + 44 >> 2]);
  jsvStringIteratorClone(HEAP32[$2 + 44 >> 2], $2);
  jsvStringIteratorFree_383($2);
  HEAP8[HEAP32[$2 + 44 >> 2] + 56 | 0] = 0;
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jsvArrayBufferIteratorGetIndex($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvNewFromInteger(HEAP32[HEAP32[$1 + 12 >> 2] + 52 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvIteratorGetKey($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block6 : {
   block5 : {
    switch (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] - 1 | 0) {
    case 3:
     HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]);
     break block6;
    case 1:
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetKey_443(HEAP32[$1 + 8 >> 2] + 4 | 0);
     break block6;
    case 0:
     HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(jsvStringIteratorGetIndex_444(HEAP32[$1 + 8 >> 2] + 4 | 0)), 0);
     break block6;
    case 2:
     HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvArrayBufferIteratorGetIndex(HEAP32[$1 + 8 >> 2] + 4 | 0), 0);
     break block6;
    case 4:
     HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 44 >> 2]), 0);
     break block6;
    default:
     break block5;
    };
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorGetKey_443($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvStringIteratorGetIndex_444($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
 }
 
 function jsvIteratorGetIntegerValue($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block7 : {
   block5 : {
    switch (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] - 1 | 0) {
    case 3:
     block6 : {
      if (!(jsvIsNameInt(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
       break block6
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
       break block6
      }
      HEAP32[$1 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) << 16 >> 16;
      break block7;
     }
     block8 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
       break block8
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
       break block8
      }
      HEAP32[$1 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue_407(HEAP32[$1 + 8 >> 2] + 4 | 0));
      break block7;
     }
     HEAP32[$1 + 12 >> 2] = 0;
     break block7;
    case 1:
     if (jsvIsNameInt(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1) {
      HEAP32[$1 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) << 16 >> 16;
      break block7;
     }
     HEAP32[$1 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue_407(HEAP32[$1 + 8 >> 2] + 4 | 0));
     break block7;
    case 0:
     HEAP32[$1 + 12 >> 2] = jsvStringIteratorGetChar_385(HEAP32[$1 + 8 >> 2] + 4 | 0) << 24 >> 24;
     break block7;
    case 2:
     HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorGetIntegerValue(HEAP32[$1 + 8 >> 2] + 4 | 0);
     break block7;
    case 4:
     HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 8 >> 2] + 48 >> 2];
     break block7;
    default:
     break block5;
    };
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvIteratorGetFloatValue($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 4 >> 2] = $0;
  block5 : {
   block3 : {
    switch (HEAP32[HEAP32[$1 + 4 >> 2] >> 2] - 2 | 0) {
    case 2:
     block4 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 4 >> 2] + 4 >> 2]) & 1)) {
       break block4
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$1 + 4 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 4 >> 2] + 12 >> 2]) {
       break block4
      }
      HEAPF64[$1 + 8 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_407(HEAP32[$1 + 4 >> 2] + 4 | 0));
      break block5;
     }
     HEAPF64[$1 + 8 >> 3] = NaN;
     break block5;
    case 0:
     HEAPF64[$1 + 8 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_407(HEAP32[$1 + 4 >> 2] + 4 | 0));
     break block5;
    case 1:
     HEAPF64[$1 + 8 >> 3] = jsvArrayBufferIteratorGetFloatValue(HEAP32[$1 + 4 >> 2] + 4 | 0);
     break block5;
    default:
     break block3;
    };
   }
   HEAPF64[$1 + 8 >> 3] = jsvIteratorGetIntegerValue(HEAP32[$1 + 4 >> 2]) | 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAPF64[$1 + 8 >> 3];
 }
 
 function jsvIteratorSetValue($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block4 : {
   block2 : {
    switch (HEAP32[HEAP32[$2 + 12 >> 2] >> 2] - 1 | 0) {
    case 3:
     block5 : {
      if (!(jsvIsIntegerish(HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) & 1)) {
       break block5
      }
      if ((jsvGetInteger(HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
       break block5
      }
      jsvObjectIteratorSetValue(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
     }
     jsvSetArrayItem(HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], HEAP32[$2 + 8 >> 2]);
     break block4;
    case 1:
     jsvObjectIteratorSetValue(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
     break block4;
    case 0:
     $1 = HEAP32[$2 + 12 >> 2] + 4 | 0;
     block6 : {
      if (jsvIsString(HEAP32[$2 + 8 >> 2]) & 1) {
       $0 = HEAP8[HEAP32[$2 + 8 >> 2]] << 24 >> 24;
       break block6;
      }
      $0 = jsvGetInteger(HEAP32[$2 + 8 >> 2]) << 24 >> 24;
     }
     jsvStringIteratorSetChar($1, $0);
     break block4;
    case 2:
     break block2;
    default:
     break block4;
    };
   }
   jsvArrayBufferIteratorSetValueAndRewind(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 8 >> 2];
 }
 
 function jsvIteratorClone($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
  block5 : {
   block4 : {
    switch (HEAP32[HEAP32[$2 + 8 >> 2] >> 2] - 1 | 0) {
    case 3:
     HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2];
     $0 = jsvLockAgain(HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]);
     HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = $0;
     jsvObjectIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
     break block5;
    case 1:
     jsvObjectIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
     break block5;
    case 0:
     jsvStringIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
     break block5;
    case 2:
     jsvArrayBufferIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
     break block5;
    case 4:
     break block4;
    default:
     break block5;
    };
   }
   jsvStringIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
   HEAP32[HEAP32[$2 + 12 >> 2] + 48 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] + 48 >> 2];
   HEAP32[HEAP32[$2 + 12 >> 2] + 44 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] + 44 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvCompareStringIt($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 80 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 72 >> 2] = $0;
  HEAP32[$4 + 68 >> 2] = $1;
  HEAP32[$4 + 64 >> 2] = $2;
  HEAP8[$4 + 63 | 0] = $3;
  jsvStringIteratorNewUTF8($4 + 20 | 0, HEAP32[$4 + 68 >> 2], HEAP32[$4 + 64 >> 2]);
  while (1) {
   block1 : {
    HEAP32[$4 + 16 >> 2] = jsvStringIteratorGetUTF8CharAndNext(HEAP32[$4 + 72 >> 2]);
    HEAP32[$4 + 12 >> 2] = jsvStringIteratorGetUTF8CharAndNext($4 + 20 | 0);
    if (HEAP32[$4 + 16 >> 2] != HEAP32[$4 + 12 >> 2]) {
     jsvStringIteratorFree_383($4 + 20 | 0);
     if (!(!(HEAP8[$4 + 63 | 0] & 1) | (HEAP32[$4 + 16 >> 2] | HEAP32[$4 + 12 >> 2]) >= 0)) {
      HEAP32[$4 + 76 >> 2] = 0;
      break block1;
     }
     HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 16 >> 2] - HEAP32[$4 + 12 >> 2];
     break block1;
    }
    if (HEAP32[$4 + 16 >> 2] >= 0) {
     continue
    }
    jsvStringIteratorFree_383($4 + 20 | 0);
    HEAP32[$4 + 76 >> 2] = 0;
   }
   break;
  };
  __stack_pointer = $4 + 80 | 0;
  return HEAP32[$4 + 76 >> 2];
 }
 
 function isWhitespace($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = isWhitespaceInline_451(HEAP8[$1 + 15 | 0] << 24 >> 24);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function isWhitespaceInline_451($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = 1;
  block : {
   if (HEAPU8[$1 + 15 | 0] == 9) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 11) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 12) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 32) {
    break block
   }
   $0 = 1;
   if (HEAPU8[$1 + 15 | 0] == 10) {
    break block
   }
   $0 = HEAPU8[$1 + 15 | 0] == 13;
  }
  return $0;
 }
 
 function isHexadecimal($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  block : {
   if (HEAP8[$1 + 15 | 0] << 24 >> 24 >= 48) {
    $0 = 1;
    if (HEAP8[$1 + 15 | 0] << 24 >> 24 <= 57) {
     break block
    }
   }
   if (HEAP8[$1 + 15 | 0] << 24 >> 24 >= 97) {
    $0 = 1;
    if (HEAP8[$1 + 15 | 0] << 24 >> 24 <= 102) {
     break block
    }
   }
   $2 = HEAP8[$1 + 15 | 0] << 24 >> 24 >= 65 ? HEAP8[$1 + 15 | 0] << 24 >> 24 <= 70 : $2;
   $0 = $2;
  }
  return $0 & 1;
 }
 
 function isAlpha($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = isAlphaInline_454(HEAP8[$1 + 15 | 0] << 24 >> 24);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function isAlphaInline_454($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  block : {
   if (HEAP8[$1 + 15 | 0] << 24 >> 24 >= 97) {
    $0 = 1;
    if (HEAP8[$1 + 15 | 0] << 24 >> 24 <= 122) {
     break block
    }
   }
   if (HEAP8[$1 + 15 | 0] << 24 >> 24 >= 65) {
    $0 = 1;
    if (HEAP8[$1 + 15 | 0] << 24 >> 24 <= 90) {
     break block
    }
   }
   $0 = HEAPU8[$1 + 15 | 0] == 95;
  }
  return $0;
 }
 
 function isNumeric($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = isNumericInline_456(HEAP8[$1 + 15 | 0] << 24 >> 24);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function isNumericInline_456($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  $2 = HEAP8[$1 + 15 | 0] << 24 >> 24 >= 48 ? HEAP8[$1 + 15 | 0] << 24 >> 24 <= 57 : $2;
  return $2;
 }
 
 function isIDString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(isAlpha(HEAP8[HEAP32[$1 + 8 >> 2]] << 24 >> 24) & 1)) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   while (1) {
    if (HEAPU8[HEAP32[$1 + 8 >> 2]]) {
     block1 : {
      if (isAlpha(HEAP8[HEAP32[$1 + 8 >> 2]] << 24 >> 24) & 1) {
       break block1
      }
      if (isNumeric(HEAP8[HEAP32[$1 + 8 >> 2]] << 24 >> 24) & 1) {
       break block1
      }
      HEAP8[$1 + 15 | 0] = 0;
      break block;
     }
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP8[$1 + 15 | 0] = 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function dtohex($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] & 15;
  if (HEAP32[$1 + 12 >> 2] < 10) {
   $0 = HEAP32[$1 + 12 >> 2] + 48 | 0
  } else {
   $0 = HEAP32[$1 + 12 >> 2] + 55 | 0
  }
  return $0 << 24 >> 24;
 }
 
 function charToUpperCase($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  block2 : {
   block1 : {
    if (!(HEAP8[$1 + 15 | 0] << 24 >> 24 <= 122 & HEAP8[$1 + 15 | 0] << 24 >> 24 >= 97 | HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 <= 246 & HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 >= 224)) {
     if (HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 < 248 | HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 > 254) {
      break block1
     }
    }
    $0 = (HEAP8[$1 + 15 | 0] << 24 >> 24) - 32 | 0;
    break block2;
   }
   $0 = HEAP8[$1 + 15 | 0] << 24 >> 24;
  }
  return $0 << 24 >> 24;
 }
 
 function charToLowerCase($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  block2 : {
   block1 : {
    if (!(HEAP8[$1 + 15 | 0] << 24 >> 24 <= 90 & HEAP8[$1 + 15 | 0] << 24 >> 24 >= 65 | HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 <= 214 & HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 >= 192)) {
     if (HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 < 216 | HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 0 > 222) {
      break block1
     }
    }
    $0 = (HEAP8[$1 + 15 | 0] << 24 >> 24) + 32 | 0;
    break block2;
   }
   $0 = HEAP8[$1 + 15 | 0] << 24 >> 24;
  }
  return $0 << 24 >> 24;
 }
 
 function escapeCharacter($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP8[$3 + 19 | 0] = $2;
  block : {
   if (HEAP32[$3 + 24 >> 2] == 10) {
    HEAP32[$3 + 28 >> 2] = 15575;
    break block;
   }
   if (HEAP32[$3 + 24 >> 2] == 9) {
    HEAP32[$3 + 28 >> 2] = 5054;
    break block;
   }
   if (HEAP32[$3 + 24 >> 2] == 8) {
    HEAP32[$3 + 28 >> 2] = 20523;
    break block;
   }
   if (!(HEAP8[$3 + 19 | 0] & 1 | HEAP32[$3 + 24 >> 2] != 11)) {
    HEAP32[$3 + 28 >> 2] = 4148;
    break block;
   }
   if (HEAP32[$3 + 24 >> 2] == 12) {
    HEAP32[$3 + 28 >> 2] = 17128;
    break block;
   }
   if (HEAP32[$3 + 24 >> 2] == 13) {
    HEAP32[$3 + 28 >> 2] = 8406;
    break block;
   }
   if (HEAP32[$3 + 24 >> 2] == 92) {
    HEAP32[$3 + 28 >> 2] = 20753;
    break block;
   }
   if (HEAP32[$3 + 24 >> 2] == 34) {
    HEAP32[$3 + 28 >> 2] = 27315;
    break block;
   }
   if (!(HEAP32[$3 + 20 >> 2] <= 55 & HEAP32[$3 + 20 >> 2] >= 48 | (HEAP8[$3 + 19 | 0] & 1 | HEAP32[$3 + 24 >> 2] >= 8))) {
    HEAP8[413212] = 92;
    HEAP8[413213] = HEAP32[$3 + 24 >> 2] + 48;
    HEAP8[413214] = 0;
    HEAP32[$3 + 28 >> 2] = 413212;
    break block;
   }
   if (!(HEAP32[$3 + 24 >> 2] < 127 & HEAP32[$3 + 24 >> 2] >= 32)) {
    HEAP32[$3 + 12 >> 2] = 413212;
    if (HEAP32[$3 + 24 >> 2] >= 65536) {
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - 65536;
     HEAP32[$3 + 12 >> 2] = numericEscapeChar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2] >> 10 & 1023 | 55296, 1);
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] & 1023 | 56320;
     HEAP8[$3 + 19 | 0] = 1;
    }
    $0 = 1;
    $0 = HEAP8[$3 + 19 | 0] & 1 ? $0 : HEAP32[$3 + 24 >> 2] > 255;
    HEAP32[$3 + 12 >> 2] = numericEscapeChar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], $0);
    HEAP8[HEAP32[$3 + 12 >> 2]] = 0;
    HEAP32[$3 + 28 >> 2] = 413212;
    break block;
   }
   HEAP8[413213] = 0;
   HEAP8[413212] = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 28 >> 2] = 413212;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function numericEscapeChar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 1;
  HEAP8[$0 | 0] = 92;
  block : {
   if (HEAP8[$3 + 7 | 0] & 1) {
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 117;
    $1 = dtohex(HEAP32[$3 + 8 >> 2] >> 12);
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = $1;
    $1 = dtohex(HEAP32[$3 + 8 >> 2] >> 8);
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = $1;
    break block;
   }
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 120;
  }
  $1 = dtohex(HEAP32[$3 + 8 >> 2] >> 4);
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 1;
  HEAP8[$0 | 0] = $1;
  $1 = dtohex(HEAP32[$3 + 8 >> 2]);
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 1;
  HEAP8[$0 | 0] = $1;
  __stack_pointer = $3 + 16 | 0;
  return HEAP32[$3 + 12 >> 2];
 }
 
 function getRadix($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 10;
  if (HEAPU8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] == 48) {
   HEAP32[$1 + 8 >> 2] = 8;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   block1 : {
    if (!(HEAPU8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 111 & HEAPU8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 79)) {
     HEAP32[$1 + 8 >> 2] = 8;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     break block1;
    }
    block3 : {
     if (!(HEAPU8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 120 & HEAPU8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 88)) {
      HEAP32[$1 + 8 >> 2] = 16;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      break block3;
     }
     block5 : {
      if (!(HEAPU8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 98 & HEAPU8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 66)) {
       HEAP32[$1 + 8 >> 2] = 2;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
       break block5;
      }
      HEAP32[$1 + 4 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
      while (1) {
       block6 : {
        if (!HEAPU8[HEAP32[$1 + 4 >> 2]]) {
         break block6
        }
        block9 : {
         if (!(!(HEAPU8[HEAP32[$1 + 4 >> 2]] == 46 | HEAPU8[HEAP32[$1 + 4 >> 2]] == 56) & HEAPU8[HEAP32[$1 + 4 >> 2]] != 57)) {
          HEAP32[$1 + 8 >> 2] = 10;
          break block9;
         }
         if (HEAP8[HEAP32[$1 + 4 >> 2]] << 24 >> 24 < 48 | HEAP8[HEAP32[$1 + 4 >> 2]] << 24 >> 24 > 57) {
          break block6
         }
        }
        HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
        continue;
       }
       break;
      };
     }
    }
   }
  }
  return HEAP32[$1 + 8 >> 2];
 }
 
 function chtod($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 11 | 0] = $0;
  block1 : {
   if (!(HEAP8[$1 + 11 | 0] << 24 >> 24 < 48 | HEAP8[$1 + 11 | 0] << 24 >> 24 > 57)) {
    HEAP32[$1 + 12 >> 2] = (HEAP8[$1 + 11 | 0] << 24 >> 24) - 48;
    break block1;
   }
   if (!(HEAP8[$1 + 11 | 0] << 24 >> 24 < 97 | HEAP8[$1 + 11 | 0] << 24 >> 24 > 122)) {
    HEAP32[$1 + 12 >> 2] = (HEAP8[$1 + 11 | 0] << 24 >> 24) - 87;
    break block1;
   }
   if (!(HEAP8[$1 + 11 | 0] << 24 >> 24 < 65 | HEAP8[$1 + 11 | 0] << 24 >> 24 > 90)) {
    HEAP32[$1 + 12 >> 2] = (HEAP8[$1 + 11 | 0] << 24 >> 24) - 55;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = -1;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function hexToByte($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 11 | 0] = $0;
  HEAP8[$2 + 10 | 0] = $1;
  HEAP32[$2 + 4 >> 2] = chtod(HEAP8[$2 + 11 | 0] << 24 >> 24);
  HEAP32[$2 >> 2] = chtod(HEAP8[$2 + 10 | 0] << 24 >> 24);
  block1 : {
   if ((HEAP32[$2 + 4 >> 2] | HEAP32[$2 >> 2]) < 0) {
    HEAP32[$2 + 12 >> 2] = -1;
    break block1;
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2] | HEAP32[$2 + 4 >> 2] << 4;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function stringToIntWithRadix($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 52 >> 2] = $0;
  HEAP32[$4 + 48 >> 2] = $1;
  HEAP32[$4 + 44 >> 2] = $2;
  HEAP32[$4 + 40 >> 2] = $3;
  while (1) {
   if (isWhitespace(HEAP8[HEAP32[$4 + 52 >> 2]] << 24 >> 24) & 1) {
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP8[$4 + 39 | 0] = 0;
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 28 >> 2] = 0;
  block : {
   if (HEAPU8[HEAP32[$4 + 52 >> 2]] == 45) {
    HEAP8[$4 + 39 | 0] = 1;
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
    break block;
   }
   if (HEAPU8[HEAP32[$4 + 52 >> 2]] == 43) {
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1
   }
  }
  HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 52 >> 2];
  if (HEAP32[$4 + 40 >> 2]) {
   HEAP32[HEAP32[$4 + 40 >> 2] >> 2] = HEAP32[$4 + 52 >> 2]
  }
  if (HEAP32[$4 + 48 >> 2]) {
   $0 = HEAP32[$4 + 48 >> 2]
  } else {
   $0 = getRadix($4 + 52 | 0)
  }
  HEAP32[$4 + 16 >> 2] = $0;
  block2 : {
   if (!HEAP32[$4 + 16 >> 2]) {
    HEAP32[$4 + 56 >> 2] = 0;
    HEAP32[$4 + 60 >> 2] = 0;
    break block2;
   }
   while (1) {
    block3 : {
     if (!HEAPU8[HEAP32[$4 + 52 >> 2]]) {
      break block3
     }
     HEAP32[$4 + 12 >> 2] = chtod(HEAP8[HEAP32[$4 + 52 >> 2]] << 24 >> 24);
     if (HEAP32[$4 + 12 >> 2] < 0 | HEAP32[$4 + 12 >> 2] >= HEAP32[$4 + 16 >> 2]) {
      break block3
     }
     $1 = HEAP32[$4 + 12 >> 2];
     $0 = $1 >> 31;
     $6 = $1;
     $2 = $0;
     $0 = HEAP32[$4 + 24 >> 2];
     $7 = $0;
     $1 = HEAP32[$4 + 28 >> 2];
     $3 = $1;
     $1 = HEAP32[$4 + 16 >> 2];
     $0 = $1 >> 31;
     $5 = $0;
     $0 = $3;
     $3 = $1;
     $1 = $5;
     $1 = __wasm_i64_mul($7, $0, $3, $1);
     $3 = $1;
     $5 = $1 + $6 | 0;
     $0 = i64toi32_i32$HIGH_BITS;
     $1 = $0;
     $0 = $2;
     $0 = $1 + $0 | 0;
     HEAP32[$4 + 24 >> 2] = $5;
     $0 = $5 >>> 0 < $3 >>> 0 ? $0 + 1 | 0 : $0;
     HEAP32[$4 + 28 >> 2] = $0;
     HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$4 + 44 >> 2]) {
    HEAP8[HEAP32[$4 + 44 >> 2]] = HEAP32[$4 + 52 >> 2] == HEAP32[$4 + 20 >> 2]
   }
   if (HEAP32[$4 + 40 >> 2]) {
    HEAP32[HEAP32[$4 + 40 >> 2] >> 2] = HEAP32[$4 + 52 >> 2]
   }
   if (HEAP8[$4 + 39 | 0] & 1) {
    $2 = HEAP32[$4 + 28 >> 2];
    $0 = HEAP32[$4 + 24 >> 2];
    $3 = $0;
    $1 = 0 - $0 | 0;
    HEAP32[$4 + 56 >> 2] = $1;
    $0 = $2;
    $5 = $0 + (($3 | 0) != 0) | 0;
    $5 = 0 - $5 | 0;
    HEAP32[$4 + 60 >> 2] = $5;
    break block2;
   }
   $0 = HEAP32[$4 + 28 >> 2];
   $5 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 56 >> 2] = $5;
   HEAP32[$4 + 60 >> 2] = $0;
  }
  __stack_pointer = $4 - -64 | 0;
  $5 = HEAP32[$4 + 60 >> 2];
  i64toi32_i32$HIGH_BITS = $5;
  $0 = HEAP32[$4 + 56 >> 2];
  return $0;
 }
 
 function stringToInt($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = stringToIntWithRadix(HEAP32[$1 + 12 >> 2], 0, 0, 0);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsError($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  jsiConsoleRemoveInputLine();
  jsiConsolePrintString(27597);
  HEAP32[$2 + 8 >> 2] = $1;
  vcbprintf(7, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  jsiConsolePrintString(28752);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function vcbprintf($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 144 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 140 >> 2] = $0;
  HEAP32[$4 + 136 >> 2] = $1;
  HEAP32[$4 + 132 >> 2] = $2;
  HEAP32[$4 + 128 >> 2] = $3;
  while (1) {
   block : {
    if (!HEAPU8[HEAP32[$4 + 132 >> 2]]) {
     break block
    }
    block16 : {
     if (HEAPU8[HEAP32[$4 + 132 >> 2]] == 37) {
      HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
      $0 = HEAP32[$4 + 132 >> 2];
      HEAP32[$4 + 132 >> 2] = $0 + 1;
      HEAP8[$4 + 95 | 0] = HEAPU8[$0 | 0];
      block12 : {
       block8 : {
        switch (HEAP8[$4 + 95 | 0] - 32 | 0) {
        case 0:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
         HEAP32[$4 + 88 >> 2] = 27706;
         if (!HEAPU8[HEAP32[$4 + 132 >> 2]]) {
          break block12
         }
         if (HEAPU8[$4 + 95 | 0] == 48) {
          HEAP32[$4 + 88 >> 2] = 22560;
          $0 = HEAP32[$4 + 132 >> 2];
          HEAP32[$4 + 132 >> 2] = $0 + 1;
          HEAP8[$4 + 95 | 0] = HEAPU8[$0 | 0];
          if (!HEAPU8[HEAP32[$4 + 132 >> 2]]) {
           break block12
          }
         }
         HEAP32[$4 + 84 >> 2] = (HEAP8[$4 + 95 | 0] << 24 >> 24) - 48;
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         HEAP32[$4 + 80 >> 2] = HEAP32[$0 >> 2];
         block13 : {
          if (HEAPU8[HEAP32[$4 + 132 >> 2]] == 120) {
           itostr_extra(HEAP32[$4 + 80 >> 2], $4 + 96 | 0, 0, 16);
           break block13;
          }
          itostr_471(HEAP32[$4 + 80 >> 2], $4 + 96 | 0, 10);
         }
         HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
         HEAP32[$4 + 76 >> 2] = strlen($4 + 96 | 0);
         while (1) {
          if (HEAP32[$4 + 76 >> 2] < HEAP32[$4 + 84 >> 2]) {
           FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](HEAP32[$4 + 88 >> 2], HEAP32[$4 + 136 >> 2]);
           HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] + 1;
           continue;
          }
          break;
         };
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
         break block12;
        case 68:
        case 73:
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         itostr_471(HEAP32[$0 >> 2], $4 + 96 | 0, 10);
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
         break block12;
        case 88:
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         itostr_extra(HEAP32[$0 >> 2], $4 + 96 | 0, 0, 16);
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
         break block12;
        case 44:
         HEAP32[$4 + 72 >> 2] = 10;
         HEAP8[$4 + 71 | 0] = 1;
         if (HEAPU8[HEAP32[$4 + 132 >> 2]] == 120) {
          HEAP32[$4 + 72 >> 2] = 16;
          HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
          HEAP8[$4 + 71 | 0] = 0;
         }
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         itostr_extra(HEAP32[$0 >> 2], $4 + 96 | 0, HEAP8[$4 + 71 | 0] & 1, HEAP32[$4 + 72 >> 2]);
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
         break block12;
        case 70:
         $0 = HEAP32[$4 + 128 >> 2] + 7 & -8;
         HEAP32[$4 + 128 >> 2] = $0 + 8;
         ftoa_bounded(HEAPF64[$0 >> 3], $4 + 96 | 0, 32);
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
         break block12;
        case 83:
         $1 = HEAP32[$4 + 140 >> 2];
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         FUNCTION_TABLE[$1 | 0](HEAP32[$0 >> 2], HEAP32[$4 + 136 >> 2]);
         break block12;
        case 67:
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         HEAP8[$4 + 96 | 0] = HEAP32[$0 >> 2];
         HEAP8[$4 + 97 | 0] = 0;
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
         break block12;
        case 49:
        case 81:
        case 86:
         HEAP8[$4 + 70 | 0] = HEAPU8[$4 + 95 | 0] != 118;
         HEAP8[$4 + 69 | 0] = HEAPU8[$4 + 95 | 0] == 81;
         if (HEAP8[$4 + 70 | 0] & 1) {
          FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](27316, HEAP32[$4 + 136 >> 2])
         }
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         HEAP32[$4 + 64 >> 2] = jsvAsString(HEAP32[$0 >> 2]);
         if (jsvIsUTF8String(HEAP32[$4 + 64 >> 2]) & 1) {
          HEAP8[$4 + 69 | 0] = 1
         }
         HEAP8[$4 + 97 | 0] = 0;
         if (jsvIsString(HEAP32[$4 + 64 >> 2]) & 1) {
          jsvStringIteratorNewUTF8($4 + 24 | 0, HEAP32[$4 + 64 >> 2], 0);
          block15 : {
           if (HEAP8[$4 + 70 | 0] & 1) {
            HEAP32[$4 + 20 >> 2] = jsvStringIteratorGetUTF8CharAndNext($4 + 24 | 0);
            while (1) {
             $0 = 1;
             if (!(jsvStringIteratorHasChar_473($4 + 24 | 0) & 1)) {
              $0 = HEAP32[$4 + 20 >> 2] >= 0
             }
             if ($0) {
              HEAP32[$4 + 16 >> 2] = jsvStringIteratorGetUTF8CharAndNext($4 + 24 | 0);
              block14 : {
               if (HEAP8[$4 + 70 | 0] & 1) {
                $0 = HEAP32[$4 + 140 >> 2];
                FUNCTION_TABLE[$0 | 0](escapeCharacter(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], HEAP8[$4 + 69 | 0] & 1), HEAP32[$4 + 136 >> 2]);
                break block14;
               }
               FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
              }
              HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 16 >> 2];
              continue;
             }
             break;
            };
            break block15;
           }
           while (1) {
            if (jsvStringIteratorHasChar_473($4 + 24 | 0) & 1) {
             HEAP8[$4 + 96 | 0] = jsvStringIteratorGetCharAndNext($4 + 24 | 0);
             FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
             continue;
            }
            break;
           };
          }
          jsvStringIteratorFree_474($4 + 24 | 0);
          jsvUnLock(HEAP32[$4 + 64 >> 2]);
         }
         if (HEAP8[$4 + 70 | 0] & 1) {
          FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](27316, HEAP32[$4 + 136 >> 2])
         }
         break block12;
        case 74:
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         HEAP32[$4 + 12 >> 2] = HEAP32[$0 >> 2];
         jsfGetJSONWithCallback(HEAP32[$4 + 12 >> 2], 0, 8229, 0, HEAP32[$4 + 140 >> 2], HEAP32[$4 + 136 >> 2]);
         break block12;
        case 84:
         $0 = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 128 >> 2] = $0 + 4;
         HEAP32[$4 + 8 >> 2] = HEAP32[$0 >> 2];
         if (jsvIsNull(HEAP32[$4 + 8 >> 2]) & 1) {
          $0 = 15755
         } else {
          $0 = jswGetBasicObjectName(HEAP32[$4 + 8 >> 2])
         }
         HEAP32[$4 + 4 >> 2] = $0;
         if (!HEAP32[$4 + 4 >> 2]) {
          HEAP32[$4 + 4 >> 2] = jsvGetTypeOf(HEAP32[$4 + 8 >> 2])
         }
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](HEAP32[$4 + 4 >> 2], HEAP32[$4 + 136 >> 2]);
         break block12;
        case 80:
         break block8;
        default:
         break block;
        };
       }
       $0 = HEAP32[$4 + 128 >> 2];
       HEAP32[$4 + 128 >> 2] = $0 + 4;
       jshGetPinString($4 + 96 | 0, HEAP32[$0 >> 2] & 255);
       FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
      }
      break block16;
     }
     $0 = HEAP32[$4 + 132 >> 2];
     HEAP32[$4 + 132 >> 2] = $0 + 1;
     HEAP8[$4 + 96 | 0] = HEAPU8[$0 | 0];
     HEAP8[$4 + 97 | 0] = 0;
     FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
    }
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 144 | 0;
 }
 
 function itostr_extra($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP8[$4 + 23 | 0] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  block1 : {
   if (!(!(HEAP8[$4 + 23 | 0] & 1) | HEAP32[$4 + 28 >> 2] >= 0)) {
    $0 = HEAP32[$4 + 24 >> 2];
    HEAP32[$4 + 24 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 45;
    HEAP32[$4 + 12 >> 2] = 0 - HEAP32[$4 + 28 >> 2];
    break block1;
   }
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2];
  }
  HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 12 >> 2];
  HEAP32[$4 + 4 >> 2] = 1;
  while (1) {
   if (HEAPU32[$4 + 8 >> 2] >= HEAPU32[$4 + 16 >> 2]) {
    HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] + 1;
    HEAP32[$4 + 8 >> 2] = HEAPU32[$4 + 8 >> 2] / HEAPU32[$4 + 16 >> 2];
    continue;
   }
   break;
  };
  HEAP32[$4 >> 2] = HEAP32[$4 + 4 >> 2] - 1;
  while (1) {
   if (HEAP32[$4 >> 2] >= 0) {
    $0 = itoch(HEAPU32[$4 + 12 >> 2] % HEAPU32[$4 + 16 >> 2] | 0);
    HEAP8[HEAP32[$4 + 24 >> 2] + HEAP32[$4 >> 2] | 0] = $0;
    HEAP32[$4 + 12 >> 2] = HEAPU32[$4 + 12 >> 2] / HEAPU32[$4 + 16 >> 2];
    HEAP32[$4 >> 2] = HEAP32[$4 >> 2] - 1;
    continue;
   }
   break;
  };
  HEAP8[HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 4 >> 2] | 0] = 0;
  __stack_pointer = $4 + 32 | 0;
 }
 
 function itostr_471($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function ftoa_bounded($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAPF64[$3 + 8 >> 3] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 >> 2] = $2;
  ftoa_bounded_extra(HEAPF64[$3 + 8 >> 3], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2], 10, -1);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsvStringIteratorHasChar_473($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorFree_474($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsWarn($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  jsiConsoleRemoveInputLine();
  jsiConsolePrintString(27605);
  HEAP32[$2 + 8 >> 2] = $1;
  vcbprintf(7, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  jsiConsolePrintString(28752);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsExceptionHere($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  block : {
   if (jspHasError() & 1) {
    break block
   }
   jsiConsoleRemoveInputLine();
   HEAP32[$3 + 52 >> 2] = jsvNewFromEmptyString_477();
   if (!HEAP32[$3 + 52 >> 2]) {
    jspSetError();
    break block;
   }
   jsvStringIteratorNew($3 + 12 | 0, HEAP32[$3 + 52 >> 2], 0);
   jsvStringIteratorGotoEnd($3 + 12 | 0);
   HEAP32[$3 + 8 >> 2] = 2;
   HEAP32[$3 + 4 >> 2] = $2;
   vcbprintf(HEAP32[$3 + 8 >> 2], $3 + 12 | 0, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 4 >> 2]);
   jsvStringIteratorFree_474($3 + 12 | 0);
   if (HEAP32[$3 + 60 >> 2]) {
    HEAP32[$3 >> 2] = 0;
    block1 : {
     if (HEAP32[$3 + 60 >> 2] == 1) {
      HEAP32[$3 >> 2] = jswrap_error_constructor(HEAP32[$3 + 52 >> 2]);
      break block1;
     }
     block2 : {
      if (HEAP32[$3 + 60 >> 2] == 2) {
       HEAP32[$3 >> 2] = jswrap_syntaxerror_constructor(HEAP32[$3 + 52 >> 2]);
       break block2;
      }
      block3 : {
       if (HEAP32[$3 + 60 >> 2] == 3) {
        HEAP32[$3 >> 2] = jswrap_typeerror_constructor(HEAP32[$3 + 52 >> 2]);
        break block3;
       }
       block4 : {
        if (HEAP32[$3 + 60 >> 2] == 4) {
         HEAP32[$3 >> 2] = jswrap_internalerror_constructor(HEAP32[$3 + 52 >> 2]);
         break block4;
        }
        if (HEAP32[$3 + 60 >> 2] == 5) {
         HEAP32[$3 >> 2] = jswrap_referenceerror_constructor(HEAP32[$3 + 52 >> 2])
        }
       }
      }
     }
    }
    jsvUnLock(HEAP32[$3 + 52 >> 2]);
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 >> 2];
   }
   jspSetException(HEAP32[$3 + 52 >> 2]);
   jsvUnLock(HEAP32[$3 + 52 >> 2]);
  }
  __stack_pointer = $3 - -64 | 0;
 }
 
 function jsvNewFromEmptyString_477() {
  return jsvNewWithFlags(29);
 }
 
 function stringToFloatWithRadix($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 52 >> 2] = $0;
  HEAP32[$3 + 48 >> 2] = $1;
  HEAP32[$3 + 44 >> 2] = $2;
  while (1) {
   if (isWhitespace(HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24) & 1) {
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP8[$3 + 43 | 0] = 0;
  block : {
   if (HEAPU8[HEAP32[$3 + 52 >> 2]] == 45) {
    HEAP8[$3 + 43 | 0] = 1;
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    break block;
   }
   if (HEAPU8[HEAP32[$3 + 52 >> 2]] == 43) {
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1
   }
  }
  HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 52 >> 2];
  if (HEAP32[$3 + 44 >> 2]) {
   HEAP32[HEAP32[$3 + 44 >> 2] >> 2] = HEAP32[$3 + 52 >> 2]
  }
  if (HEAP32[$3 + 48 >> 2]) {
   $0 = HEAP32[$3 + 48 >> 2]
  } else {
   $0 = getRadix($3 + 52 | 0)
  }
  HEAP32[$3 + 32 >> 2] = $0;
  block2 : {
   if (!HEAP32[$3 + 32 >> 2]) {
    HEAPF64[$3 + 56 >> 3] = NaN;
    break block2;
   }
   HEAPF64[$3 + 24 >> 3] = 0;
   HEAPF64[$3 + 16 >> 3] = .1;
   while (1) {
    block3 : {
     if (!HEAPU8[HEAP32[$3 + 52 >> 2]]) {
      break block3
     }
     HEAP32[$3 + 12 >> 2] = chtod(HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24);
     if (HEAP32[$3 + 12 >> 2] < 0 | HEAP32[$3 + 12 >> 2] >= HEAP32[$3 + 32 >> 2]) {
      break block3
     }
     HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] * +HEAP32[$3 + 32 >> 2] + +HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$3 + 32 >> 2] == 10) {
    if (HEAPU8[HEAP32[$3 + 52 >> 2]] == 46) {
     HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
     while (1) {
      if (!(!HEAPU8[HEAP32[$3 + 52 >> 2]] | HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24 < 48 | HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24 > 57)) {
       HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 16 >> 3] * +((HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24) - 48 | 0) + HEAPF64[$3 + 24 >> 3];
       HEAPF64[$3 + 16 >> 3] = HEAPF64[$3 + 16 >> 3] / 10.0;
       HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
       continue;
      }
      break;
     };
    }
    if (!(HEAPU8[HEAP32[$3 + 52 >> 2]] != 101 & HEAPU8[HEAP32[$3 + 52 >> 2]] != 69)) {
     HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
     HEAP8[$3 + 11 | 0] = 0;
     if (!(HEAPU8[HEAP32[$3 + 52 >> 2]] != 45 & HEAPU8[HEAP32[$3 + 52 >> 2]] != 43)) {
      HEAP8[$3 + 11 | 0] = HEAPU8[HEAP32[$3 + 52 >> 2]] == 45;
      HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
     }
     HEAP32[$3 + 4 >> 2] = 0;
     while (1) {
      if (!(!HEAPU8[HEAP32[$3 + 52 >> 2]] | HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24 < 48 | HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24 > 57)) {
       HEAP32[$3 + 4 >> 2] = ((HEAP8[HEAP32[$3 + 52 >> 2]] << 24 >> 24) - 48 | 0) + Math_imul(HEAP32[$3 + 4 >> 2], 10);
       HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
       continue;
      }
      break;
     };
     if (HEAP8[$3 + 11 | 0] & 1) {
      HEAP32[$3 + 4 >> 2] = 0 - HEAP32[$3 + 4 >> 2]
     }
     while (1) {
      if (HEAP32[$3 + 4 >> 2] > 0) {
       HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] * 10.0;
       HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] - 1;
       continue;
      }
      break;
     };
     while (1) {
      if (HEAP32[$3 + 4 >> 2] < 0) {
       HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] / 10.0;
       HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
       continue;
      }
      break;
     };
    }
   }
   if (HEAP32[$3 + 44 >> 2]) {
    HEAP32[HEAP32[$3 + 44 >> 2] >> 2] = HEAP32[$3 + 52 >> 2]
   }
   block8 : {
    if (HEAP32[$3 + 36 >> 2] != HEAP32[$3 + 52 >> 2]) {
     if (HEAPU8[HEAP32[$3 + 36 >> 2]] != 46 | HEAP32[$3 + 52 >> 2] != (HEAP32[$3 + 36 >> 2] + 1 | 0)) {
      break block8
     }
    }
    HEAPF64[$3 + 56 >> 3] = NaN;
    break block2;
   }
   if (HEAP8[$3 + 43 | 0] & 1) {
    HEAPF64[$3 + 56 >> 3] = -HEAPF64[$3 + 24 >> 3];
    break block2;
   }
   HEAPF64[$3 + 56 >> 3] = HEAPF64[$3 + 24 >> 3];
  }
  __stack_pointer = $3 - -64 | 0;
  return HEAPF64[$3 + 56 >> 3];
 }
 
 function stringToFloat($0) {
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = stringToFloatWithRadix(HEAP32[$1 + 12 >> 2], 0, 0);
  __stack_pointer = $1 + 16 | 0;
  return $2;
 }
 
 function itoch($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (HEAP32[$1 + 8 >> 2] < 10) {
    HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 48;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 87;
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function ftoa_bounded_extra($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAPF64[$5 + 88 >> 3] = $0;
  HEAP32[$5 + 84 >> 2] = $1;
  HEAP32[$5 + 80 >> 2] = $2;
  HEAP32[$5 + 76 >> 2] = $3;
  HEAP32[$5 + 72 >> 2] = $4;
  HEAPF64[$5 + 64 >> 3] = 1e-07;
  $2 = __DOUBLE_BITS_483(HEAPF64[$5 + 88 >> 3]);
  $3 = $2;
  $1 = i64toi32_i32$HIGH_BITS;
  $2 = $1 & 2147483647;
  $1 = $3;
  block1 : {
   if (!(!$1 & ($2 | 0) == 2146435072 | $2 >>> 0 < 2146435072)) {
    strcpy(HEAP32[$5 + 84 >> 2], 21183);
    break block1;
   }
   $1 = __DOUBLE_BITS_483(HEAPF64[$5 + 88 >> 3]);
   $3 = $1;
   $2 = i64toi32_i32$HIGH_BITS;
   $1 = $2 & 2147483647;
   block3 : {
    if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
     if (HEAPF64[$5 + 88 >> 3] < 0.0) {
      strcpy(HEAP32[$5 + 84 >> 2], 3526);
      break block3;
     }
     strcpy(HEAP32[$5 + 84 >> 2], 3527);
     break block3;
    }
    if (HEAPF64[$5 + 88 >> 3] < 0.0) {
     $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
     HEAP32[$5 + 80 >> 2] = $1;
     if (!$1) {
      HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
      break block1;
     }
     $1 = HEAP32[$5 + 84 >> 2];
     HEAP32[$5 + 84 >> 2] = $1 + 1;
     HEAP8[$1 | 0] = 45;
     HEAPF64[$5 + 88 >> 3] = -HEAPF64[$5 + 88 >> 3];
    }
    HEAP32[$5 + 60 >> 2] = 0;
    if (!(!(HEAPF64[$5 + 88 >> 3] > 0.0) | HEAP32[$5 + 76 >> 2] != 10 | HEAP32[$5 + 72 >> 2] >= 0)) {
     block5 : {
      if (HEAPF64[$5 + 88 >> 3] >= 1.0e21) {
       while (1) {
        if (HEAPF64[$5 + 88 >> 3] > 1.0e5) {
         HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] / 1.0e5;
         HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] + 5;
         continue;
        }
        break;
       };
       while (1) {
        if (HEAPF64[$5 + 88 >> 3] > 10.0) {
         HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] / 10.0;
         HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] + 1;
         continue;
        }
        break;
       };
       break block5;
      }
      if (HEAPF64[$5 + 88 >> 3] < 1.0e-06) {
       while (1) {
        if (HEAPF64[$5 + 88 >> 3] < 1.0e-05) {
         HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * 1.0e5;
         HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] - 5;
         continue;
        }
        break;
       };
       while (1) {
        if (HEAPF64[$5 + 88 >> 3] < 1.0) {
         HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * 10.0;
         HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] - 1;
         continue;
        }
        break;
       };
      }
     }
    }
    $0 = HEAPF64[$5 + 88 >> 3] + 1.0e-07;
    if (Math_abs($0) < 2147483647.0) {
     $1 = ~~$0
    } else {
     $1 = -2147483648
    }
    $0 = HEAPF64[$5 + 88 >> 3];
    if (Math_abs($0) < 2147483647.0) {
     $2 = ~~$0
    } else {
     $2 = -2147483648
    }
    if (($1 | 0) == ($2 + 1 | 0)) {
     $0 = HEAPF64[$5 + 88 >> 3];
     if (Math_abs($0) < 2147483647.0) {
      $1 = ~~$0
     } else {
      $1 = -2147483648
     }
     HEAPF64[$5 + 88 >> 3] = $1 + 1 | 0;
    }
    HEAPF64[$5 + 48 >> 3] = 1;
    while (1) {
     if (HEAPF64[$5 + 88 >> 3] >= HEAPF64[$5 + 48 >> 3] * +HEAP32[$5 + 76 >> 2]) {
      HEAPF64[$5 + 48 >> 3] = HEAPF64[$5 + 48 >> 3] * +HEAP32[$5 + 76 >> 2];
      continue;
     }
     break;
    };
    while (1) {
     if (HEAPF64[$5 + 48 >> 3] >= 1.0) {
      $0 = HEAPF64[$5 + 88 >> 3] / HEAPF64[$5 + 48 >> 3];
      if (Math_abs($0) < 2147483647.0) {
       $1 = ~~$0
      } else {
       $1 = -2147483648
      }
      HEAP32[$5 + 44 >> 2] = $1;
      HEAPF64[$5 + 88 >> 3] = -+HEAP32[$5 + 44 >> 2] * HEAPF64[$5 + 48 >> 3] + HEAPF64[$5 + 88 >> 3];
      $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
      HEAP32[$5 + 80 >> 2] = $1;
      if ($1) {
       $2 = itoch(HEAP32[$5 + 44 >> 2]);
       $1 = HEAP32[$5 + 84 >> 2];
       HEAP32[$5 + 84 >> 2] = $1 + 1;
       HEAP8[$1 | 0] = $2;
       HEAPF64[$5 + 48 >> 3] = HEAPF64[$5 + 48 >> 3] / +HEAP32[$5 + 76 >> 2];
       continue;
      } else {
       HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
       break block1;
      }
     }
     break;
    };
    if (!(!(HEAP32[$5 + 72 >> 2] < 0 & HEAPF64[$5 + 88 >> 3] > 0.0) & HEAP32[$5 + 72 >> 2] <= 0)) {
     HEAP8[$5 + 43 | 0] = 0;
     HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * +HEAP32[$5 + 76 >> 2];
     while (1) {
      block9 : {
       if (!(HEAP32[$5 + 72 >> 2] <= -12 | HEAP32[$5 + 72 >> 2] >= 0)) {
        $1 = 1;
        if (HEAPF64[$5 + 88 >> 3] > 1.0e-07) {
         break block9
        }
       }
       $1 = HEAP32[$5 + 72 >> 2] > 0;
      }
      if ($1) {
       $0 = HEAPF64[$5 + 88 >> 3] + (HEAP32[$5 + 72 >> 2] == 1 ? .5 : 1.0e-08);
       if (Math_abs($0) < 2147483647.0) {
        $1 = ~~$0
       } else {
        $1 = -2147483648
       }
       HEAP32[$5 + 36 >> 2] = $1;
       HEAPF64[$5 + 88 >> 3] = (HEAPF64[$5 + 88 >> 3] - +HEAP32[$5 + 36 >> 2]) * +HEAP32[$5 + 76 >> 2];
       if (HEAP32[$5 + 36 >> 2] == HEAP32[$5 + 76 >> 2]) {
        HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 76 >> 2] - 1
       }
       if (!(HEAP8[$5 + 43 | 0] & 1)) {
        HEAP8[$5 + 43 | 0] = 1;
        $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
        HEAP32[$5 + 80 >> 2] = $1;
        if (!$1) {
         HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
         break block1;
        }
        $1 = HEAP32[$5 + 84 >> 2];
        HEAP32[$5 + 84 >> 2] = $1 + 1;
        HEAP8[$1 | 0] = 46;
       }
       $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
       HEAP32[$5 + 80 >> 2] = $1;
       if (!$1) {
        HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
        break block1;
       }
       $2 = itoch(HEAP32[$5 + 36 >> 2]);
       $1 = HEAP32[$5 + 84 >> 2];
       HEAP32[$5 + 84 >> 2] = $1 + 1;
       HEAP8[$1 | 0] = $2;
       HEAP32[$5 + 72 >> 2] = HEAP32[$5 + 72 >> 2] - 1;
       continue;
      }
      break;
     };
    }
    if (!(!HEAP32[$5 + 60 >> 2] | HEAPU32[$5 + 80 >> 2] <= 5)) {
     $1 = HEAP32[$5 + 84 >> 2];
     HEAP32[$5 + 84 >> 2] = $1 + 1;
     HEAP8[$1 | 0] = 101;
     if (HEAP32[$5 + 60 >> 2] > 0) {
      $1 = HEAP32[$5 + 84 >> 2];
      HEAP32[$5 + 84 >> 2] = $1 + 1;
      HEAP8[$1 | 0] = 43;
     }
     itostr_471(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 84 >> 2], 10);
     break block1;
    }
    $1 = HEAP32[$5 + 84 >> 2];
    HEAP32[$5 + 84 >> 2] = $1 + 1;
    HEAP8[$1 | 0] = 0;
   }
  }
  __stack_pointer = $5 + 96 | 0;
 }
 
 function __DOUBLE_BITS_483($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function wrapAround($0, $1) {
  $0 = +$0;
  $1 = +$1;
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAPF64[$2 + 16 >> 3] = $0;
  HEAPF64[$2 + 8 >> 3] = $1;
  block : {
   if (HEAPF64[$2 + 8 >> 3] < 0.0) {
    HEAPF64[$2 + 24 >> 3] = 0;
    break block;
   }
   HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 16 >> 3] / HEAPF64[$2 + 8 >> 3];
   $0 = HEAPF64[$2 + 16 >> 3];
   $1 = HEAPF64[$2 + 16 >> 3];
   if (Math_abs($1) < 2147483647.0) {
    $3 = ~~$1
   } else {
    $3 = -2147483648
   }
   HEAPF64[$2 + 16 >> 3] = $0 - +($3 | 0);
   HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 16 >> 3] * HEAPF64[$2 + 8 >> 3];
  }
  return +HEAPF64[$2 + 24 >> 3];
 }
 
 function cbprintf($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  vcbprintf(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function espruino_snprintf_cb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  while (1) {
   if (HEAPU8[HEAP32[$2 + 12 >> 2]]) {
    if (HEAPU32[HEAP32[$2 + 4 >> 2] + 4 >> 2] < HEAPU32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
     HEAP8[HEAP32[HEAP32[$2 + 4 >> 2] >> 2] + HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] | 0] = HEAPU8[HEAP32[$2 + 12 >> 2]]
    }
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
 }
 
 function espruino_snprintf_va($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 8 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2];
  vcbprintf(8, $4 + 4 | 0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
  block : {
   if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 + 12 >> 2]) {
    HEAP8[HEAP32[$4 + 4 >> 2] + HEAP32[$4 + 8 >> 2] | 0] = 0;
    break block;
   }
   HEAP8[HEAP32[$4 + 4 >> 2] + (HEAP32[$4 + 12 >> 2] - 1 | 0) | 0] = 0;
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 8 >> 2];
 }
 
 function espruino_snprintf($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = espruino_snprintf_va(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 12 >> 2];
 }
 
 function jsuGetFreeStack() {
  return 1e6;
 }
 
 function rand() {
  HEAP32[61107] = Math_imul(HEAP32[61107] & 65535, 36969) + (HEAP32[61107] >>> 16 | 0);
  HEAP32[61106] = Math_imul(HEAP32[61106] & 65535, 18e3) + (HEAP32[61106] >>> 16 | 0);
  return HEAP32[61106] + (HEAP32[61107] << 16) & 2147483647;
 }
 
 function srand($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[61106] = HEAP32[$1 + 12 >> 2] & 65535 | HEAP32[$1 + 12 >> 2] << 16;
  HEAP32[61107] = HEAP32[$1 + 12 >> 2] & -65536 | HEAP32[$1 + 12 >> 2] >>> 16;
 }
 
 function int_sqrt32($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP16[$1 + 26 >> 1] = 0;
  HEAP16[$1 + 24 >> 1] = 32768;
  HEAP32[$1 + 20 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 20 >> 2] < 16) {
    HEAP16[$1 + 18 >> 1] = HEAPU16[$1 + 26 >> 1] | HEAPU16[$1 + 24 >> 1];
    HEAP32[$1 + 12 >> 2] = Math_imul(HEAPU16[$1 + 18 >> 1], HEAPU16[$1 + 18 >> 1]);
    if (HEAPU32[$1 + 28 >> 2] >= HEAPU32[$1 + 12 >> 2]) {
     HEAP16[$1 + 26 >> 1] = HEAPU16[$1 + 18 >> 1]
    }
    HEAP16[$1 + 24 >> 1] = HEAPU16[$1 + 24 >> 1] >>> 1;
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
    continue;
   }
   break;
  };
  return HEAPU16[$1 + 26 >> 1];
 }
 
 function reverseBytes($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2] >> 1;
  HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2] - 1;
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 20 >> 2]) {
    HEAP8[$2 + 11 | 0] = HEAPU8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 12 >> 2] | 0];
    HEAP8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 12 >> 2] | 0] = HEAPU8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 16 >> 2] | 0];
    HEAP8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 16 >> 2] | 0] = HEAPU8[$2 + 11 | 0];
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] - 1;
    continue;
   }
   break;
  };
 }
 
 function jsUTF8IsStartChar($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP8[$1 + 14 | 0] = HEAPU8[$1 + 15 | 0];
  $2 = HEAPU8[$1 + 14 | 0] >= 194 ? HEAPU8[$1 + 14 | 0] <= 244 : $2;
  return $2;
 }
 
 function jsUTF8LengthFromChar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 11 | 0] = $0;
  block1 : {
   if (!(HEAPU8[$1 + 11 | 0] <= 244 ? HEAP8[$1 + 11 | 0] << 24 >> 24 & 128 : 0)) {
    HEAP32[$1 + 12 >> 2] = 1;
    break block1;
   }
   if ((HEAP8[$1 + 11 | 0] << 24 >> 24 & 224) == 192) {
    HEAP32[$1 + 12 >> 2] = 2;
    break block1;
   }
   if ((HEAP8[$1 + 11 | 0] << 24 >> 24 & 240) == 224) {
    HEAP32[$1 + 12 >> 2] = 3;
    break block1;
   }
   if ((HEAP8[$1 + 11 | 0] << 24 >> 24 & 248) == 240) {
    HEAP32[$1 + 12 >> 2] = 4;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = 1;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsUTF8Bytes($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (HEAP32[$1 + 8 >> 2] <= 127) {
    HEAP32[$1 + 12 >> 2] = 1;
    break block;
   }
   if (HEAP32[$1 + 8 >> 2] <= 2047) {
    HEAP32[$1 + 12 >> 2] = 2;
    break block;
   }
   if (HEAP32[$1 + 8 >> 2] <= 65535) {
    HEAP32[$1 + 12 >> 2] = 3;
    break block;
   }
   if (HEAP32[$1 + 8 >> 2] <= 1114111) {
    HEAP32[$1 + 12 >> 2] = 4;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsUTF8Encode($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jsUTF8Bytes(HEAP32[$2 + 24 >> 2]);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 16 >> 2] - 1;
   while (1) {
    if (HEAP32[$2 + 12 >> 2]) {
     HEAP8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 12 >> 2] | 0] = HEAP32[$2 + 24 >> 2] & -193 | 128;
     HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] >> 6;
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - 1;
     continue;
    }
    break;
   };
   HEAP8[HEAP32[$2 + 20 >> 2]] = HEAP32[$2 + 24 >> 2] & (HEAPU8[(HEAP32[$2 + 16 >> 2] - 1 | 0) + 147230 | 0] ^ -1) | HEAPU8[(HEAP32[$2 + 16 >> 2] - 1 | 0) + 147230 | 0] << 1;
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsnCallFunction($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 28 >> 2] = $0;
  HEAP16[$5 + 26 >> 1] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  $0 = jswCallFunctionHack(HEAP32[$5 + 28 >> 2], HEAPU16[$5 + 26 >> 1], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2]);
  __stack_pointer = $5 + 32 | 0;
  return $0;
 }
 
 function jspDebuggerLoopIfCtrlC() {
  
 }
 
 function jspIsInterrupted() {
  return (HEAP32[103315] & 16) != 0;
 }
 
 function jspSetInterrupted($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  block : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    HEAP32[103315] = HEAP32[103315] | 16;
    break block;
   }
   HEAP32[103315] = HEAP32[103315] & -17;
  }
 }
 
 function jspSetError() {
  HEAP32[103315] = HEAP32[103315] & -2 | 64;
 }
 
 function jspHasError() {
  return (HEAP32[103315] & 112) != 0;
 }
 
 function jspeiClearScopes() {
  jsvUnLock(HEAP32[103309]);
  HEAP32[103309] = 0;
 }
 
 function jspeiAddScope($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  if (!HEAP32[103309]) {
   HEAP32[103309] = jsvNewEmptyArray()
  }
  block : {
   if (!HEAP32[103309]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   jsvArrayPush(HEAP32[103309], HEAP32[$1 + 8 >> 2]);
   HEAP8[$1 + 15 | 0] = 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jspeiRemoveScope() {
  block : {
   if (!HEAP32[103309]) {
    break block
   }
   if (!jsvGetArrayLength(HEAP32[103309])) {
    break block
   }
   jsvUnLock(jsvArrayPop(HEAP32[103309]));
   if (jsvGetFirstChild(HEAP32[103309]) & 65535) {
    break block
   }
   jsvUnLock(HEAP32[103309]);
   HEAP32[103309] = 0;
  }
 }
 
 function jspeiFindInScopes($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (HEAP32[103309]) {
    HEAP32[$1 + 20 >> 2] = jsvLockSafe(jsvGetLastChild(HEAP32[103309]) & 65535);
    while (1) {
     if (HEAP32[$1 + 20 >> 2]) {
      HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 20 >> 2]);
      HEAP16[$1 + 14 >> 1] = jsvGetPrevSibling(HEAP32[$1 + 20 >> 2]);
      HEAP32[$1 + 8 >> 2] = jsvFindChildFromString(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 24 >> 2]);
      jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
      if (HEAP32[$1 + 8 >> 2]) {
       HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
       break block;
      } else {
       HEAP32[$1 + 20 >> 2] = jsvLockSafe(HEAPU16[$1 + 14 >> 1]);
       continue;
      }
     }
     break;
    };
   }
   HEAP32[$1 + 28 >> 2] = jsvFindChildFromString(HEAP32[103307], HEAP32[$1 + 24 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jspFindPrototypeFor($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], HEAP32[$1 + 8 >> 2]);
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 4 >> 2], 17727);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jspeiFindChildFromStringInParents($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  block1 : {
   block3 : {
    if (jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 40 >> 2], 20670);
     if (!HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 32 >> 2] = jspFindPrototypeFor(5005)
     }
     block2 : {
      if (!(!HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 32 >> 2] == HEAP32[$2 + 40 >> 2])) {
       HEAP32[$2 + 28 >> 2] = jsvFindChildFromString(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2]);
       if (!HEAP32[$2 + 28 >> 2]) {
        HEAP32[$2 + 28 >> 2] = jspeiFindChildFromStringInParents(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2])
       }
       jsvUnLock(HEAP32[$2 + 32 >> 2]);
       if (HEAP32[$2 + 28 >> 2]) {
        HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 28 >> 2];
        break block1;
       }
       break block2;
      }
      jsvUnLock(HEAP32[$2 + 32 >> 2]);
     }
     break block3;
    }
    HEAP32[$2 + 24 >> 2] = jswGetBasicObjectName(HEAP32[$2 + 40 >> 2]);
    while (1) {
     if (HEAP32[$2 + 24 >> 2]) {
      HEAP32[$2 + 20 >> 2] = jsvFindChildFromString(HEAP32[103307], HEAP32[$2 + 24 >> 2]);
      if (!HEAP32[$2 + 20 >> 2]) {
       HEAP32[$2 + 20 >> 2] = jspNewPrototype(HEAP32[$2 + 24 >> 2], 1)
      }
      if (HEAP32[$2 + 20 >> 2]) {
       HEAP32[$2 + 16 >> 2] = 0;
       HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 20 >> 2]);
       if (jsvHasChildren(HEAP32[$2 + 12 >> 2]) & 1) {
        HEAP32[$2 + 8 >> 2] = jspGetNamedField(HEAP32[$2 + 12 >> 2], 17727, 0);
        if (HEAP32[$2 + 8 >> 2]) {
         HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 36 >> 2]);
         jsvUnLock(HEAP32[$2 + 8 >> 2]);
        }
       }
       jsvUnLock(HEAP32[$2 + 12 >> 2]);
       if (HEAP32[$2 + 16 >> 2]) {
        HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 16 >> 2];
        break block1;
       }
      }
      HEAP32[$2 + 24 >> 2] = jswGetBasicObjectPrototypeName(HEAP32[$2 + 24 >> 2]);
      continue;
     }
     break;
    };
   }
   HEAP32[$2 + 44 >> 2] = 0;
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jspNewPrototype($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP8[$2 + 23 | 0] = $1;
  HEAP32[$2 + 16 >> 2] = jsvFindOrAddChildFromString(HEAP32[103307], HEAP32[$2 + 24 >> 2]);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvSkipName(HEAP32[$2 + 16 >> 2]);
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 12 >> 2] = jspNewBuiltin(HEAP32[$2 + 24 >> 2]);
    if (!HEAP32[$2 + 12 >> 2]) {
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     HEAP32[$2 + 28 >> 2] = 0;
     break block;
    }
    jsvSetValueOfName(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]);
   }
   HEAP32[$2 + 8 >> 2] = jsvFindOrAddChildFromString(HEAP32[$2 + 12 >> 2], 17727);
   jspEnsureIsPrototype(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   if (HEAP8[$2 + 23 | 0] & 1) {
    $0 = HEAP32[$2 + 8 >> 2]
   } else {
    $0 = HEAP32[$2 + 12 >> 2]
   }
   jsvUnLock2($0, HEAP32[$2 + 16 >> 2]);
   if (HEAP8[$2 + 23 | 0] & 1) {
    $0 = HEAP32[$2 + 12 >> 2]
   } else {
    $0 = HEAP32[$2 + 8 >> 2]
   }
   HEAP32[$2 + 28 >> 2] = $0;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jspGetNamedField($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP8[$3 + 19 | 0] = $2;
  HEAP32[$3 + 12 >> 2] = 0;
  if (jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1) {
   HEAP32[$3 + 12 >> 2] = jsvFindChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2])
  }
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP8[$3 + 11 | 0] = !strcmp(HEAP32[$3 + 20 >> 2], 17727);
   if (!(HEAP8[$3 + 11 | 0] & 1)) {
    HEAP32[$3 + 12 >> 2] = jspGetNamedFieldInParents(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP8[$3 + 19 | 0] & 1)
   }
   block : {
    if (HEAP32[$3 + 12 >> 2]) {
     break block
    }
    if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1) | !(HEAP8[$3 + 11 | 0] & 1)) {
     break block
    }
    HEAP32[$3 + 4 >> 2] = jsvNewObject();
    HEAP32[$3 + 12 >> 2] = jsvAddNamedChild(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 4 >> 2], 17727);
    jsvUnLock(HEAP32[$3 + 4 >> 2]);
   }
  }
  block1 : {
   if (HEAP8[$3 + 19 | 0] & 1) {
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
    break block1;
   }
   HEAP32[$3 + 28 >> 2] = jsvSkipNameAndUnLock(HEAP32[$3 + 12 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jspNewBuiltin($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = jswFindBuiltInFunction(0, HEAP32[$1 + 8 >> 2]);
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jspEnsureIsPrototype($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  if (HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 20 >> 2] = jsvSkipName(HEAP32[$2 + 24 >> 2]);
   block : {
    if (jsvIsObject(HEAP32[$2 + 20 >> 2]) & 1) {
     break block
    }
    if (jsvIsFunction(HEAP32[$2 + 20 >> 2]) & 1) {
     break block
    }
    if (!(jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1)) {
     HEAP32[$2 >> 2] = HEAP32[$2 + 20 >> 2];
     jsExceptionHere(3, 5522, $2);
    }
    jsvUnLock(HEAP32[$2 + 20 >> 2]);
    HEAP32[$2 + 20 >> 2] = jsvNewObject();
    HEAP32[$2 + 16 >> 2] = jsvSkipToLastName(HEAP32[$2 + 24 >> 2]);
    jsvSetValueOfName(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
   }
   HEAP32[$2 + 12 >> 2] = jsvFindOrAddChildFromString(HEAP32[$2 + 20 >> 2], 7797);
   if (HEAP32[$2 + 12 >> 2]) {
    jsvSetValueOfName(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2])
   }
   jsvUnLock2(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jspGetNamedFieldInParents($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP8[$3 + 39 | 0] = $2;
  HEAP32[$3 + 32 >> 2] = jspeiFindChildFromStringInParents(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
  if (!HEAP32[$3 + 32 >> 2]) {
   HEAP32[$3 + 32 >> 2] = jswFindBuiltInFunction(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2])
  }
  if (!(!HEAP32[$3 + 32 >> 2] | !(HEAP8[$3 + 39 | 0] & 1))) {
   if (jsvIsName(HEAP32[$3 + 32 >> 2]) & 1) {
    HEAP32[$3 + 28 >> 2] = jsvGetValueOfName(HEAP32[$3 + 32 >> 2]);
    jsvUnLock(HEAP32[$3 + 32 >> 2]);
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 28 >> 2];
   }
   HEAP32[$3 + 24 >> 2] = jsvNewNameFromString(HEAP32[$3 + 40 >> 2]);
   HEAP32[$3 + 20 >> 2] = jsvCreateNewChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
   jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 20 >> 2];
   block1 : {
    if (!HEAP32[$3 + 32 >> 2]) {
     break block1
    }
    if (!(jsvIsArray(HEAP32[$3 + 44 >> 2]) & 1)) {
     break block1
    }
    if (strcmp(HEAP32[$3 + 40 >> 2], 16212)) {
     break block1
    }
    $0 = HEAP32[$3 + 32 >> 2];
    $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 64;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
  }
  if (!HEAP32[$3 + 32 >> 2]) {
   block3 : {
    block2 : {
     if (!(jsvIsFunction(HEAP32[$3 + 44 >> 2]) & 1)) {
      break block2
     }
     if (strcmp(HEAP32[$3 + 40 >> 2], 17727)) {
      break block2
     }
     HEAP32[$3 + 16 >> 2] = jsvNewObject();
     jsvObjectSetChild(HEAP32[$3 + 16 >> 2], 7797, HEAP32[$3 + 44 >> 2]);
     HEAP32[$3 + 32 >> 2] = jsvAddNamedChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 16 >> 2], 17727);
     jspEnsureIsPrototype(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2]);
     jsvUnLock(HEAP32[$3 + 16 >> 2]);
     break block3;
    }
    if (!strcmp(HEAP32[$3 + 40 >> 2], 20670)) {
     HEAP32[$3 + 12 >> 2] = jswGetBasicObjectName(HEAP32[$3 + 44 >> 2]);
     if (HEAP32[$3 + 12 >> 2]) {
      HEAP32[$3 + 8 >> 2] = jsvSkipNameAndUnLock(jspNewPrototype(HEAP32[$3 + 12 >> 2], 0));
      HEAP32[$3 + 4 >> 2] = jsvNewNameFromString(20670);
      if (HEAP32[$3 + 8 >> 2]) {
       HEAP32[$3 + 32 >> 2] = jsvCreateNewChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2])
      }
      jsvUnLock2(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
     }
    }
   }
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 32 >> 2];
 }
 
 function jspeiGetScopesAsVar() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (!HEAP32[103309]) {
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   if ((jsvGetArrayLength(HEAP32[103309]) | 0) == 1) {
    HEAP32[$0 + 8 >> 2] = jsvGetLastArrayItem(HEAP32[103309]);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
    break block;
   }
   HEAP32[$0 + 12 >> 2] = jsvCopy(HEAP32[103309], 1);
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeiLoadScopesFromVar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[103309]);
  HEAP32[103309] = 0;
  if (HEAP32[$1 + 12 >> 2]) {
   block : {
    if (jsvIsArray(HEAP32[$1 + 12 >> 2]) & 1) {
     HEAP32[103309] = jsvCopy(HEAP32[$1 + 12 >> 2], 1);
     break block;
    }
    HEAP32[103309] = jsvNewArray($1 + 12 | 0, 1);
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jspCheckStackPosition() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (jsuGetFreeStack() >>> 0 < 512) {
    jsExceptionHere(1, 3941, 0);
    jspSetInterrupted(1);
    HEAP8[$0 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$0 + 15 | 0] = 1;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function jspSetNoExecute() {
  HEAP32[103315] = HEAP32[103315] & -64;
 }
 
 function jspAppendStackTrace($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP32[$2 + 40 >> 2] = $1;
  jsvStringIteratorNew($2, HEAP32[$2 + 44 >> 2], 0);
  jsvStringIteratorGotoEnd($2);
  jslPrintStackTrace(2, $2, HEAP32[$2 + 40 >> 2]);
  jsvStringIteratorFree_520($2);
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jsvStringIteratorFree_520($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jspSetException($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvFindOrAddChildFromString(HEAP32[103308], 4498);
  if (HEAP32[$1 + 8 >> 2]) {
   jsvSetValueOfName(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
  HEAP32[103315] = HEAP32[103315] | 32;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jspGetException() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = jsvFindChildFromString(HEAP32[103308], 4498);
  block : {
   if (HEAP32[$0 + 8 >> 2]) {
    HEAP32[$0 + 4 >> 2] = jsvSkipName(HEAP32[$0 + 8 >> 2]);
    jsvRemoveChildAndUnLock(HEAP32[103308], HEAP32[$0 + 8 >> 2]);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
    break block;
   }
   HEAP32[$0 + 12 >> 2] = 0;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspGetStackTrace() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = jsvFindChildFromString(HEAP32[103308], 18338);
  block : {
   if (HEAP32[$0 + 8 >> 2]) {
    HEAP32[$0 + 4 >> 2] = jsvSkipName(HEAP32[$0 + 8 >> 2]);
    jsvRemoveChildAndUnLock(HEAP32[103308], HEAP32[$0 + 8 >> 2]);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
    break block;
   }
   HEAP32[$0 + 12 >> 2] = 0;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeFunctionArguments($0) {
  var $1 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 88 >> 2] = $0;
  block : {
   if (!(jslMatch(40) & 1)) {
    HEAP8[$1 + 95 | 0] = 0;
    break block;
   }
   while (1) {
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
     if (HEAP32[$1 + 88 >> 2]) {
      HEAP8[$1 + 16 | 0] = 255;
      strcpy($1 + 17 | 0, jslGetTokenValueAsString());
      HEAP32[$1 + 12 >> 2] = jsvAddNamedChild(HEAP32[$1 + 88 >> 2], 0, $1 + 16 | 0);
      if (!HEAP32[$1 + 12 >> 2]) {
       jspSetError();
       HEAP8[$1 + 95 | 0] = 0;
       break block;
      }
      HEAP32[$1 + 12 >> 2] = jsvMakeFunctionParameter(HEAP32[$1 + 12 >> 2]);
      jsvUnLock(HEAP32[$1 + 12 >> 2]);
     }
     if (!(jslMatch(128) & 1)) {
      HEAP8[$1 + 95 | 0] = 0;
      break block;
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
      if (!(jslMatch(44) & 1)) {
       HEAP8[$1 + 95 | 0] = 0;
       break block;
      }
     }
     continue;
    }
    break;
   };
   if (!(jslMatch(41) & 1)) {
    HEAP8[$1 + 95 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 95 | 0] = 1;
  }
  __stack_pointer = $1 + 96 | 0;
  return HEAP8[$1 + 95 | 0] & 1;
 }
 
 function jspeFunctionDefinitionInternal($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $0;
  HEAP8[$2 + 103 | 0] = $1;
  HEAP8[$2 + 55 | 0] = 0;
  block1 : {
   block : {
    if (HEAP8[$2 + 103 | 0] & 1) {
     if (HEAP32[$2 + 104 >> 2]) {
      $0 = HEAP32[$2 + 104 >> 2];
      $1 = HEAP32[$2 + 104 >> 2];
      $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 9;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
     }
     break block;
    }
    HEAP32[$2 + 48 >> 2] = HEAP32[103315];
    HEAP32[103315] = 1;
    if (!(jslMatch(123) & 1)) {
     HEAP8[$2 + 111 | 0] = 0;
     break block1;
    }
    HEAP32[103315] = HEAP32[$2 + 48 >> 2];
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 131) {
     HEAP32[$2 + 44 >> 2] = jslGetTokenValueAsVar();
     block2 : {
      if (jsvIsStringEqual(HEAP32[$2 + 44 >> 2], 19171) & 1) {
       jsWarn(15630, 0);
       break block2;
      }
      if (jsvIsStringEqual(HEAP32[$2 + 44 >> 2], 15717) & 1) {
       jslGetNextToken();
       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 59) {
        jslGetNextToken()
       }
       HEAP8[$2 + 55 | 0] = 1;
      }
     }
     jsvUnLock(HEAP32[$2 + 44 >> 2]);
    }
    if (!(!HEAP32[$2 + 104 >> 2] | HEAPU16[HEAP32[61300] + 2 >> 1] != 171)) {
     $0 = HEAP32[$2 + 104 >> 2];
     $1 = HEAP32[$2 + 104 >> 2];
     $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 9;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     jslGetNextToken();
    }
   }
   jslSkipWhiteSpace();
   jslCharPosNew($2 + 56 | 0, HEAP32[HEAP32[61300] + 84 >> 2], HEAP32[HEAP32[61300] + 4 >> 2]);
   HEAP32[$2 + 40 >> 2] = -1;
   HEAP8[HEAP32[61300] + 81 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 175;
   block4 : {
    if (!(HEAP8[$2 + 103 | 0] & 1)) {
     HEAP32[$2 + 36 >> 2] = 0;
     HEAP32[$2 + 32 >> 2] = HEAP32[103315];
     HEAP32[103315] = 0;
     while (1) {
      $0 = 0;
      if (HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16) {
       $0 = 1;
       $0 = HEAP32[$2 + 36 >> 2] ? $0 : HEAPU16[HEAP32[61300] + 2 >> 1] != 125;
      }
      if ($0 & 1) {
       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 123) {
        HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] + 1
       }
       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 125) {
        HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] - 1
       }
       HEAP32[$2 + 40 >> 2] = jsvStringIteratorGetIndex_526(HEAP32[61300] + 88 | 0) - 1;
       jslGetNextToken();
       continue;
      }
      break;
     };
     HEAP32[103315] = HEAP32[$2 + 32 >> 2];
     break block4;
    }
    HEAP32[$2 + 28 >> 2] = HEAP32[103315];
    HEAP32[103315] = 0;
    jsvUnLock(jspeAssignmentExpression());
    HEAP32[103315] = HEAP32[$2 + 28 >> 2];
    HEAP32[$2 + 40 >> 2] = HEAP32[HEAP32[61300] + 4 >> 2];
   }
   HEAP8[$2 + 27 | 0] = HEAP8[HEAP32[61300] + 81 | 0] & 1;
   if (!(!HEAP32[$2 + 104 >> 2] | HEAP32[$2 + 40 >> 2] <= 0)) {
    block7 : {
     block6 : {
      if (HEAP8[$2 + 55 | 0] & 1) {
       break block6
      }
      if (!(jsvIsNativeString(HEAP32[HEAP32[61300] + 84 >> 2]) & 1)) {
       break block6
      }
      HEAP32[$2 + 16 >> 2] = jsvStringIteratorGetIndex_526($2 + 56 | 0) - 1;
      $0 = HEAP32[HEAP32[61300] + 84 >> 2];
      HEAP32[$2 + 20 >> 2] = jsvNewNativeString(HEAP32[$2 + 16 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[$2 + 40 >> 2] - HEAP32[$2 + 16 >> 2] | 0);
      break block7;
     }
     block9 : {
      block8 : {
       if (HEAP8[$2 + 55 | 0] & 1) {
        break block8
       }
       if (!(jsvIsFlashString(HEAP32[HEAP32[61300] + 84 >> 2]) & 1)) {
        break block8
       }
       HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetIndex_526($2 + 56 | 0) - 1;
       $0 = HEAP32[HEAP32[61300] + 84 >> 2];
       HEAP32[$2 + 20 >> 2] = jsvNewFlashString(HEAP32[$2 + 12 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[$2 + 40 >> 2] - HEAP32[$2 + 12 >> 2] | 0);
       break block9;
      }
      block11 : {
       if (jsfGetFlag(8) & 1 | HEAP8[$2 + 55 | 0] & 1) {
        HEAP32[$2 + 20 >> 2] = jslNewTokenisedStringFromLexer($2 + 56 | 0, HEAP32[$2 + 40 >> 2]);
        break block11;
       }
       HEAP32[$2 + 20 >> 2] = jslNewStringFromLexer($2 + 56 | 0, HEAP32[$2 + 40 >> 2]);
      }
     }
    }
    jsvAddNamedChildAndUnLock(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 20 >> 2], 18659);
    HEAP32[$2 + 8 >> 2] = jspeiGetScopesAsVar();
    if (HEAP32[$2 + 8 >> 2]) {
     jsvAddNamedChildAndUnLock(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 8 >> 2], 15114)
    }
   }
   jslCharPosFree($2 + 56 | 0);
   if (!(HEAP8[$2 + 103 | 0] & 1)) {
    if (!(jslMatch(125) & 1)) {
     HEAP8[$2 + 111 | 0] = 0;
     break block1;
    }
   }
   HEAP8[$2 + 111 | 0] = HEAP8[$2 + 27 | 0] & 1;
  }
  __stack_pointer = $2 + 112 | 0;
  return HEAP8[$2 + 111 | 0] & 1;
 }
 
 function jsvStringIteratorGetIndex_526($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
 }
 
 function jspeAssignmentExpression() {
  return __jspeAssignmentExpression(jspeConditionalExpression());
 }
 
 function jspeFunctionDefinition($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 27 | 0] = $0;
  HEAP32[$1 + 20 >> 2] = 0;
  HEAP8[$1 + 19 | 0] = (HEAP32[103315] & 63) == 1;
  if (HEAP8[$1 + 19 | 0] & 1) {
   HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(7)
  }
  HEAP32[$1 + 12 >> 2] = 0;
  if (!(!(HEAP8[$1 + 27 | 0] & 1) | HEAPU16[HEAP32[61300] + 2 >> 1] != 128)) {
   if (HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 12 >> 2] = jslGetTokenValueAsVar()
   }
   jslGetNextToken();
  }
  block1 : {
   if (!(jspeFunctionArguments(HEAP32[$1 + 20 >> 2]) & 1)) {
    jsvUnLock2(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 28 >> 2] = 0;
    break block1;
   }
   jspeFunctionDefinitionInternal(HEAP32[$1 + 20 >> 2], 0);
   if (!(!HEAP32[$1 + 20 >> 2] | !HEAP32[$1 + 12 >> 2])) {
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 15721, HEAP32[$1 + 12 >> 2])
   }
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jspeParseFunctionCallBrackets() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (!(jslMatch(40) & 1)) {
    break block
   }
   while (1) {
    $1 = 0;
    $1 = HEAP32[103315] & 80 ? $1 : HEAPU16[HEAP32[61300] + 2 >> 1] != 41;
    if ($1) {
     jsvUnLock(jspeAssignmentExpression());
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 162) {
      jsvUnLock(jspeArrowFunction(0, 0))
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
      if (!(jslMatch(44) & 1)) {
       break block
      }
     }
     continue;
    }
    break;
   };
   if (!(HEAP32[103315] & 80)) {
    jslMatch(41)
   }
  }
  HEAP8[$0 + 15 | 0] = 0;
  __stack_pointer = $0 + 16 | 0;
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function jspeArrowFunction($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jslGetNextToken();
  if ((HEAP32[103315] & 63) == 1) {
   HEAP32[$2 + 12 >> 2] = jspeAddNamedFunctionParameter(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2])
  }
  HEAP8[$2 + 7 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] != 123;
  HEAP8[$2 + 6 | 0] = jspeFunctionDefinitionInternal(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 7 | 0] & 1) & 1;
  if (HEAP8[$2 + 6 | 0] & 1) {
   jsvObjectSetChild(HEAP32[$2 + 12 >> 2], 7212, HEAP32[103313])
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jspeAddNamedFunctionParameter($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 92 >> 2] = $0;
  HEAP32[$2 + 88 >> 2] = $1;
  if (!HEAP32[$2 + 92 >> 2]) {
   HEAP32[$2 + 92 >> 2] = jsvNewWithFlags(7)
  }
  if (HEAP32[$2 + 88 >> 2]) {
   HEAP8[$2 + 16 | 0] = 255;
   jsvGetString(HEAP32[$2 + 88 >> 2], $2 + 17 | 0, 64);
   HEAP32[$2 + 12 >> 2] = jsvAddNamedChild(HEAP32[$2 + 92 >> 2], 0, $2 + 16 | 0);
   HEAP32[$2 + 12 >> 2] = jsvMakeFunctionParameter(HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function jspeFunctionCall($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0, $7 = 0;
  $7 = __stack_pointer - 384 | 0;
  $6 = $7;
  __stack_pointer = $6;
  HEAP32[$6 + 376 >> 2] = $0;
  HEAP32[$6 + 372 >> 2] = $1;
  HEAP32[$6 + 368 >> 2] = $2;
  HEAP8[$6 + 367 | 0] = $3;
  HEAP32[$6 + 360 >> 2] = $4;
  HEAP32[$6 + 356 >> 2] = $5;
  block2 : {
   if (!(HEAP32[$6 + 376 >> 2] | (HEAP32[103315] & 63) != 1)) {
    block1 : {
     if (HEAP32[$6 + 372 >> 2]) {
      HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 372 >> 2];
      jsExceptionHere(1, 27332, $6 + 32 | 0);
      break block1;
     }
     HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 372 >> 2];
     jsExceptionHere(1, 27355, $6 + 48 | 0);
    }
    HEAP32[$6 + 380 >> 2] = 0;
    break block2;
   }
   if ((HEAP32[103315] & 63) == 1) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$6 + 380 >> 2] = 0;
     break block2;
    }
   }
   if (!(!HEAP32[$6 + 376 >> 2] | (HEAP32[103315] & 63) != 1)) {
    HEAP32[$6 + 352 >> 2] = 0;
    if (!(jsvIsFunction(HEAP32[$6 + 376 >> 2]) & 1)) {
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 376 >> 2];
     jsExceptionHere(1, 5867, $6 + 16 | 0);
     HEAP32[$6 + 380 >> 2] = 0;
     break block2;
    }
    HEAP32[$6 + 348 >> 2] = jsvLockAgainSafe(HEAP32[$6 + 368 >> 2]);
    if (HEAP8[$6 + 367 | 0] & 1) {
     if (!(jslMatch(40) & 1)) {
      HEAP32[$6 + 380 >> 2] = 0;
      break block2;
     }
    }
    block11 : {
     if (jsvIsNativeFunction(HEAP32[$6 + 376 >> 2]) & 1) {
      HEAP32[$6 + 344 >> 2] = 0;
      HEAP32[$6 + 340 >> 2] = 0;
      jsvObjectIteratorNew($6 + 336 | 0, HEAP32[$6 + 376 >> 2]);
      HEAP32[$6 + 332 >> 2] = jsvObjectIteratorGetKey_533($6 + 336 | 0);
      while (1) {
       if (jsvIsFunctionParameter(HEAP32[$6 + 332 >> 2]) & 1) {
        if (HEAPU32[$6 + 360 >> 2] >= HEAPU32[$6 + 344 >> 2]) {
         if (HEAP32[$6 + 344 >> 2]) {
          $0 = HEAP32[$6 + 344 >> 2]
         } else {
          $0 = HEAP32[$6 + 360 >> 2]
         }
         HEAP32[$6 + 328 >> 2] = $0 << 2;
         HEAP32[$6 + 324 >> 2] = HEAP32[$6 + 328 >> 2] << 2;
         if (jsuGetFreeStack() >>> 0 < HEAP32[$6 + 324 >> 2] + 256 >>> 0) {
          jsExceptionHere(1, 6746, 0);
          jsvUnLock(HEAP32[$6 + 348 >> 2]);
          HEAP32[$6 + 380 >> 2] = 0;
          break block2;
         }
         $7 = $7 - (HEAP32[$6 + 324 >> 2] + 15 & -16) | 0;
         __stack_pointer = $7;
         HEAP32[$6 + 320 >> 2] = $7;
         $1 = HEAP32[$6 + 320 >> 2];
         $2 = HEAP32[$6 + 356 >> 2];
         $0 = HEAP32[$6 + 360 >> 2] << 2;
         if ($0) {
          wasm2js_memory_copy($1, $2, $0)
         }
         HEAP32[$6 + 356 >> 2] = HEAP32[$6 + 320 >> 2];
         HEAP32[$6 + 344 >> 2] = HEAP32[$6 + 328 >> 2];
        }
        HEAP32[$6 + 316 >> 2] = HEAP32[$6 + 360 >> 2] - 1;
        while (1) {
         if (HEAP32[$6 + 316 >> 2] >= HEAP32[$6 + 340 >> 2]) {
          HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 316 >> 2] + 1 << 2) >> 2] = HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 316 >> 2] << 2) >> 2];
          HEAP32[$6 + 316 >> 2] = HEAP32[$6 + 316 >> 2] - 1;
          continue;
         }
         break;
        };
        $0 = jsvSkipName(HEAP32[$6 + 332 >> 2]);
        HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 340 >> 2] << 2) >> 2] = $0;
        HEAP32[$6 + 360 >> 2] = HEAP32[$6 + 360 >> 2] + 1;
        HEAP32[$6 + 340 >> 2] = HEAP32[$6 + 340 >> 2] + 1;
        jsvUnLock(HEAP32[$6 + 332 >> 2]);
        jsvObjectIteratorNext($6 + 336 | 0);
        HEAP32[$6 + 332 >> 2] = jsvObjectIteratorGetKey_533($6 + 336 | 0);
        continue;
       }
       break;
      };
      while (1) {
       if (HEAP32[$6 + 332 >> 2]) {
        if (jsvIsStringEqual(HEAP32[$6 + 332 >> 2], 7212) & 1) {
         jsvUnLock(HEAP32[$6 + 348 >> 2]);
         HEAP32[$6 + 348 >> 2] = jsvSkipName(HEAP32[$6 + 332 >> 2]);
        } else {
         jsvUnLock(HEAP32[$6 + 332 >> 2]);
         jsvObjectIteratorNext($6 + 336 | 0);
         HEAP32[$6 + 332 >> 2] = jsvObjectIteratorGetKey_533($6 + 336 | 0);
         continue;
        }
       }
       break;
      };
      jsvUnLock(HEAP32[$6 + 332 >> 2]);
      jsvObjectIteratorFree_534($6 + 336 | 0);
      HEAP32[$6 + 312 >> 2] = HEAP32[$6 + 340 >> 2];
      if (HEAP8[$6 + 367 | 0] & 1) {
       while (1) {
        $0 = 0;
        block5 : {
         if (HEAP32[103315] & 112) {
          break block5
         }
         $0 = 0;
         if (HEAPU16[HEAP32[61300] + 2 >> 1] == 41) {
          break block5
         }
         $0 = HEAPU16[HEAP32[61300] + 2 >> 1];
        }
        if ($0) {
         if (HEAPU32[$6 + 360 >> 2] >= HEAPU32[$6 + 344 >> 2]) {
          if (HEAP32[$6 + 344 >> 2]) {
           $0 = HEAP32[$6 + 344 >> 2] << 2
          } else {
           $0 = 16
          }
          HEAP32[$6 + 308 >> 2] = $0;
          $7 = $7 - ((HEAP32[$6 + 308 >> 2] << 2) + 15 & -16) | 0;
          __stack_pointer = $7;
          HEAP32[$6 + 304 >> 2] = $7;
          $1 = HEAP32[$6 + 304 >> 2];
          $2 = HEAP32[$6 + 356 >> 2];
          $0 = HEAP32[$6 + 360 >> 2] << 2;
          if ($0) {
           wasm2js_memory_copy($1, $2, $0)
          }
          HEAP32[$6 + 356 >> 2] = HEAP32[$6 + 304 >> 2];
          HEAP32[$6 + 344 >> 2] = HEAP32[$6 + 308 >> 2];
         }
         $1 = jsvSkipNameAndUnLock(jspeAssignmentExpression());
         $2 = HEAP32[$6 + 356 >> 2];
         $0 = HEAP32[$6 + 360 >> 2];
         HEAP32[$6 + 360 >> 2] = $0 + 1;
         HEAP32[($0 << 2) + $2 >> 2] = $1;
         if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
          if (!(jslMatch(44) & 1)) {
           jsvUnLockMany(HEAP32[$6 + 360 >> 2], HEAP32[$6 + 356 >> 2]);
           jsvUnLock(HEAP32[$6 + 348 >> 2]);
           HEAP32[$6 + 380 >> 2] = 0;
           break block2;
          }
         }
         continue;
        }
        break;
       };
       if (!(jslMatch(41) & 1)) {
        jsvUnLockMany(HEAP32[$6 + 360 >> 2], HEAP32[$6 + 356 >> 2]);
        jsvUnLock(HEAP32[$6 + 348 >> 2]);
        HEAP32[$6 + 380 >> 2] = 0;
        break block2;
       }
       HEAP32[$6 + 312 >> 2] = HEAP32[$6 + 360 >> 2];
      }
      HEAP32[$6 + 300 >> 2] = jsvGetNativeFunctionPtr(HEAP32[$6 + 376 >> 2]);
      HEAP32[$6 + 296 >> 2] = HEAP32[103313];
      block7 : {
       if (HEAP32[$6 + 348 >> 2]) {
        HEAP32[103313] = jsvRef(HEAP32[$6 + 348 >> 2]);
        break block7;
       }
       block8 : {
        if (HEAP32[$6 + 300 >> 2] == 9) {
         if (HEAP32[103313]) {
          HEAP32[103313] = jsvRef(HEAP32[103313])
         }
         break block8;
        }
        HEAP32[103313] = jsvRef(HEAP32[103307]);
       }
      }
      block10 : {
       if (!(!HEAP32[$6 + 300 >> 2] | HEAP32[103315] & 112)) {
        $0 = HEAP32[$6 + 376 >> 2];
        HEAP32[$6 + 352 >> 2] = jsnCallFunction(HEAP32[$6 + 300 >> 2], HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8, HEAP32[$6 + 348 >> 2], HEAP32[$6 + 356 >> 2], HEAP32[$6 + 360 >> 2]);
        break block10;
       }
       HEAP32[$6 + 352 >> 2] = 0;
      }
      jsvUnLockMany(HEAP32[$6 + 312 >> 2], HEAP32[$6 + 356 >> 2]);
      if (HEAP32[103313]) {
       jsvUnRef(HEAP32[103313])
      }
      HEAP32[103313] = HEAP32[$6 + 296 >> 2];
      break block11;
     }
     HEAP32[$6 + 292 >> 2] = jsvNewWithFlags(7);
     if (!HEAP32[$6 + 292 >> 2]) {
      jspSetError();
      jsvUnLock(HEAP32[$6 + 348 >> 2]);
      HEAP32[$6 + 380 >> 2] = 0;
      break block2;
     }
     HEAP32[$6 + 288 >> 2] = 0;
     HEAP32[$6 + 284 >> 2] = 0;
     HEAP32[$6 + 280 >> 2] = 0;
     jsvObjectIteratorNew($6 + 276 | 0, HEAP32[$6 + 376 >> 2]);
     HEAP32[$6 + 272 >> 2] = jsvObjectIteratorGetKey_533($6 + 276 | 0);
     HEAP32[$6 + 268 >> 2] = jsvObjectIteratorGetValue_535($6 + 276 | 0);
     while (1) {
      $0 = 0;
      if (jsvIsFunctionParameter(HEAP32[$6 + 272 >> 2]) & 1) {
       $0 = HEAP32[$6 + 268 >> 2] != 0
      }
      if ($0) {
       jsvAddFunctionParameter(HEAP32[$6 + 292 >> 2], jsvNewFromStringVar(HEAP32[$6 + 272 >> 2], 1, 2147483647), HEAP32[$6 + 268 >> 2]);
       jsvUnLock2(HEAP32[$6 + 268 >> 2], HEAP32[$6 + 272 >> 2]);
       jsvObjectIteratorNext($6 + 276 | 0);
       HEAP32[$6 + 272 >> 2] = jsvObjectIteratorGetKey_533($6 + 276 | 0);
       HEAP32[$6 + 268 >> 2] = jsvObjectIteratorGetValue_535($6 + 276 | 0);
       continue;
      }
      break;
     };
     jsvUnLock2(HEAP32[$6 + 268 >> 2], HEAP32[$6 + 272 >> 2]);
     block14 : {
      if (HEAP8[$6 + 367 | 0] & 1) {
       HEAP32[$6 + 264 >> 2] = 0;
       while (1) {
        $0 = 0;
        $0 = HEAP32[103315] & 80 ? $0 : HEAPU16[HEAP32[61300] + 2 >> 1] != 41;
        if ($0) {
         HEAP32[$6 + 260 >> 2] = jsvObjectIteratorGetKey_533($6 + 276 | 0);
         HEAP8[$6 + 259 | 0] = jsvIsFunctionParameter(HEAP32[$6 + 260 >> 2]) & 1;
         if (!(!(HEAP8[$6 + 259 | 0] & 1) & HEAPU16[HEAP32[61300] + 2 >> 1] == 41)) {
          HEAP32[$6 + 264 >> 2] = HEAP32[$6 + 264 >> 2] + 1;
          HEAP32[$6 + 252 >> 2] = 0;
          if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
           HEAP32[$6 + 252 >> 2] = jspeAssignmentExpression()
          }
          HEAP32[$6 + 252 >> 2] = jsvSkipNameAndUnLock(HEAP32[$6 + 252 >> 2]);
          $1 = HEAP32[$6 + 292 >> 2];
          block13 : {
           if (HEAP8[$6 + 259 | 0] & 1) {
            $0 = jsvNewFromStringVar(HEAP32[$6 + 260 >> 2], 1, 2147483647);
            break block13;
           }
           $0 = 0;
          }
          jsvAddFunctionParameter($1, $0, HEAP32[$6 + 252 >> 2]);
          jsvUnLock(HEAP32[$6 + 252 >> 2]);
          if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
           if (!(jslMatch(44) & 1)) {
            HEAP32[$6 + 380 >> 2] = 0;
            break block2;
           }
          }
         }
         jsvUnLock(HEAP32[$6 + 260 >> 2]);
         if (HEAP8[$6 + 259 | 0] & 1) {
          jsvObjectIteratorNext($6 + 276 | 0)
         }
         continue;
        }
        break;
       };
       if (!(jslMatch(41) & 1)) {
        HEAP32[$6 + 380 >> 2] = 0;
        break block2;
       }
       break block14;
      }
      HEAP32[$6 + 248 >> 2] = 0;
      while (1) {
       if (HEAP32[$6 + 248 >> 2] < HEAP32[$6 + 360 >> 2]) {
        HEAP32[$6 + 244 >> 2] = jsvObjectIteratorGetKey_533($6 + 276 | 0);
        HEAP8[$6 + 243 | 0] = jsvIsFunctionParameter(HEAP32[$6 + 244 >> 2]) & 1;
        $1 = HEAP32[$6 + 292 >> 2];
        block15 : {
         if (HEAP8[$6 + 243 | 0] & 1) {
          $0 = jsvNewFromStringVar(HEAP32[$6 + 244 >> 2], 1, 2147483647);
          break block15;
         }
         $0 = 0;
        }
        jsvAddFunctionParameter($1, $0, HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 248 >> 2] << 2) >> 2]);
        HEAP32[$6 + 248 >> 2] = HEAP32[$6 + 248 >> 2] + 1;
        jsvUnLock(HEAP32[$6 + 244 >> 2]);
        if (HEAP8[$6 + 243 | 0] & 1) {
         jsvObjectIteratorNext($6 + 276 | 0)
        }
        continue;
       }
       break;
      };
     }
     while (1) {
      if (jsvObjectIteratorHasValue_536($6 + 276 | 0) & 1) {
       HEAP32[$6 + 236 >> 2] = jsvObjectIteratorGetKey_533($6 + 276 | 0);
       if (jsvIsString(HEAP32[$6 + 236 >> 2]) & 1) {
        block16 : {
         if (jsvIsStringEqual(HEAP32[$6 + 236 >> 2], 15114) & 1) {
          HEAP32[$6 + 288 >> 2] = jsvSkipName(HEAP32[$6 + 236 >> 2]);
          break block16;
         }
         block17 : {
          if (jsvIsStringEqual(HEAP32[$6 + 236 >> 2], 18659) & 1) {
           HEAP32[$6 + 284 >> 2] = jsvSkipName(HEAP32[$6 + 236 >> 2]);
           break block17;
          }
          block18 : {
           if (jsvIsStringEqual(HEAP32[$6 + 236 >> 2], 15721) & 1) {
            HEAP32[$6 + 280 >> 2] = jsvSkipName(HEAP32[$6 + 236 >> 2]);
            break block18;
           }
           block19 : {
            if (jsvIsStringEqual(HEAP32[$6 + 236 >> 2], 7212) & 1) {
             jsvUnLock(HEAP32[$6 + 348 >> 2]);
             HEAP32[$6 + 348 >> 2] = jsvSkipName(HEAP32[$6 + 236 >> 2]);
             break block19;
            }
            if (jsvIsFunctionParameter(HEAP32[$6 + 236 >> 2]) & 1) {
             HEAP32[$6 + 232 >> 2] = jsvSkipName(HEAP32[$6 + 236 >> 2]);
             jsvAddFunctionParameter(HEAP32[$6 + 292 >> 2], jsvNewFromStringVar(HEAP32[$6 + 236 >> 2], 1, 2147483647), HEAP32[$6 + 232 >> 2]);
             jsvUnLock(HEAP32[$6 + 232 >> 2]);
            }
           }
          }
         }
        }
       }
       jsvUnLock(HEAP32[$6 + 236 >> 2]);
       jsvObjectIteratorNext($6 + 276 | 0);
       continue;
      }
      break;
     };
     jsvObjectIteratorFree_534($6 + 276 | 0);
     if (HEAP32[$6 + 280 >> 2]) {
      HEAP32[$6 + 228 >> 2] = jsvMakeIntoVariableName(jsvNewFromStringVarComplete(HEAP32[$6 + 280 >> 2]), HEAP32[$6 + 376 >> 2]);
      jsvAddName(HEAP32[$6 + 292 >> 2], HEAP32[$6 + 228 >> 2]);
      jsvUnLock2(HEAP32[$6 + 228 >> 2], HEAP32[$6 + 280 >> 2]);
     }
     if (!(HEAP32[103315] & 112)) {
      HEAP32[$6 + 224 >> 2] = HEAP32[103309];
      HEAP32[103309] = 0;
      if (HEAP32[$6 + 288 >> 2]) {
       jspeiLoadScopesFromVar(HEAP32[$6 + 288 >> 2]);
       jsvUnLock(HEAP32[$6 + 288 >> 2]);
      }
      if (jspeiAddScope(HEAP32[$6 + 292 >> 2]) & 1) {
       HEAP32[$6 + 220 >> 2] = HEAP32[103310];
       HEAP8[$6 + 219 | 0] = HEAPU8[413248];
       HEAP32[103310] = HEAP32[$6 + 292 >> 2];
       HEAP8[413248] = 0;
       HEAP32[$6 + 212 >> 2] = HEAP32[103313];
       block20 : {
        if (HEAP32[$6 + 348 >> 2]) {
         HEAP32[103313] = jsvRef(HEAP32[$6 + 348 >> 2]);
         break block20;
        }
        HEAP32[103313] = jsvRef(HEAP32[103307]);
       }
       block22 : {
        if (jsvIsString(HEAP32[$6 + 284 >> 2]) & 1) {
         HEAP32[$6 + 72 >> 2] = jslSetLex($6 + 76 | 0);
         jslInit(HEAP32[$6 + 284 >> 2]);
         HEAP32[$6 + 204 >> 2] = HEAP32[$6 + 372 >> 2];
         HEAP32[$6 + 208 >> 2] = HEAP32[$6 + 72 >> 2];
         jsvUnLock(HEAP32[$6 + 284 >> 2]);
         HEAP32[$6 + 284 >> 2] = 0;
         HEAP32[$6 + 68 >> 2] = HEAP32[103315];
         HEAP32[103315] = HEAP32[103315] & 6256 | 1;
         block21 : {
          if (jsvIsFunctionReturn(HEAP32[$6 + 376 >> 2]) & 1) {
           if (HEAPU16[HEAP32[61300] + 2 >> 1] == 59 | HEAPU16[HEAP32[61300] + 2 >> 1] == 125) {
            break block21
           }
           HEAP32[$6 + 352 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
           break block21;
          }
          HEAP32[$6 + 64 >> 2] = jsvAddNamedChild(HEAP32[$6 + 292 >> 2], 0, 15143);
          HEAP8[413248] = HEAPU8[413248] - 1;
          jspeBlockNoBrackets();
          HEAP8[413248] = HEAPU8[413248] + 1;
          HEAP32[$6 + 352 >> 2] = jsvSkipName(HEAP32[$6 + 64 >> 2]);
          if (HEAP32[$6 + 64 >> 2]) {
           jsvRemoveChildAndUnLock(HEAP32[$6 + 292 >> 2], HEAP32[$6 + 64 >> 2])
          }
         }
         HEAP32[$6 + 60 >> 2] = HEAP32[103315] & 112;
         HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$6 + 68 >> 2] & 1663;
         jslKill();
         jslSetLex(HEAP32[$6 + 72 >> 2]);
         if (HEAP32[$6 + 60 >> 2]) {
          HEAP32[103315] = HEAP32[$6 + 60 >> 2] | HEAP32[103315]
         }
         break block22;
        }
        if (!(jsvIsUndefined(HEAP32[$6 + 284 >> 2]) & 1)) {
         HEAP32[$6 >> 2] = HEAP32[$6 + 284 >> 2];
         jsExceptionHere(1, 16657, $6);
        }
       }
       if (HEAP32[103313]) {
        jsvUnRef(HEAP32[103313])
       }
       HEAP32[103313] = HEAP32[$6 + 212 >> 2];
       jspeiRemoveScope();
       HEAP32[103310] = HEAP32[$6 + 220 >> 2];
       HEAP8[413248] = HEAPU8[$6 + 219 | 0];
      }
      jsvUnLock(HEAP32[103309]);
      HEAP32[103309] = HEAP32[$6 + 224 >> 2];
     }
     jsvUnLock2(HEAP32[$6 + 284 >> 2], HEAP32[$6 + 292 >> 2]);
    }
    block23 : {
     if (!HEAP32[61300]) {
      break block23
     }
     if (!(jsvIsNull(HEAP32[HEAP32[61300] + 100 >> 2]) & 1)) {
      break block23
     }
     HEAP16[HEAP32[61300] + 2 >> 1] = 0;
    }
    jsvUnLock(HEAP32[$6 + 348 >> 2]);
    if (HEAP32[61300]) {
     jsvStringIteratorUpdatePtr(HEAP32[61300] + 88 | 0)
    }
    HEAP32[$6 + 380 >> 2] = HEAP32[$6 + 352 >> 2];
    break block2;
   }
   if (HEAP8[$6 + 367 | 0] & 1) {
    if (jspCheckStackPosition() & 1) {
     jspeParseFunctionCallBrackets()
    }
    HEAP32[$6 + 380 >> 2] = 0;
    break block2;
   }
   HEAP32[$6 + 380 >> 2] = 0;
  }
  __stack_pointer = $6 + 384 | 0;
  return HEAP32[$6 + 380 >> 2];
 }
 
 function jsvObjectIteratorGetKey_533($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_534($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvObjectIteratorGetValue_535($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorHasValue_536($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jspeExpression() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   while (1) {
    if (((HEAP32[103315] & 80) != 0 ^ -1) & 1) {
     HEAP32[$0 + 8 >> 2] = jspeAssignmentExpression();
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 44) {
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
      break block;
     } else {
      jsvCheckReferenceError(HEAP32[$0 + 8 >> 2]);
      jsvUnLock(HEAP32[$0 + 8 >> 2]);
      jslGetNextToken();
      continue;
     }
    }
    break;
   };
   HEAP32[$0 + 12 >> 2] = 0;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeBlockNoBrackets() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jspeBlockStart();
  block1 : {
   if ((HEAP32[103315] & 63) == 1) {
    while (1) {
     $1 = 0;
     block : {
      $1 = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 ? HEAPU16[HEAP32[61300] + 2 >> 1] != 125 : $1;
      if (!$1) {
       break block
      }
      HEAP32[$0 + 8 >> 2] = jspeStatement();
      jsvCheckReferenceError(HEAP32[$0 + 8 >> 2]);
      jsvUnLock(HEAP32[$0 + 8 >> 2]);
      if (HEAP32[103315] & 80) {
       break block
      }
      if ((HEAP32[103315] & 63) != 1) {
       jspeSkipBlock();
       break block;
      }
      continue;
     }
     break;
    };
    break block1;
   }
   jspeSkipBlock();
  }
  jspeBlockEnd(HEAP32[$0 + 12 >> 2]);
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jspGetNamedVariable($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if ((HEAP32[103315] & 63) == 1) {
    $0 = jspeiFindInScopes(HEAP32[$1 + 12 >> 2]);
    break block;
   }
   $0 = 0;
  }
  HEAP32[$1 + 8 >> 2] = $0;
  if (!(HEAP32[$1 + 8 >> 2] | (HEAP32[103315] & 63) != 1)) {
   HEAP32[$1 + 8 >> 2] = jswFindBuiltInFunction(0, HEAP32[$1 + 12 >> 2]);
   block2 : {
    if (HEAP32[$1 + 8 >> 2]) {
     if (jswIsBuiltInObject(HEAP32[$1 + 12 >> 2]) & 1) {
      HEAP32[$1 + 4 >> 2] = jsvAddNamedChild(HEAP32[103307], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 4 >> 2];
     }
     break block2;
    }
    HEAP32[$1 + 8 >> 2] = jsvNewNameFromString(HEAP32[$1 + 12 >> 2]);
   }
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jspGetVarNamedField($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 112 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 104 >> 2] = $0;
  HEAP32[$3 + 100 >> 2] = $1;
  HEAP8[$3 + 99 | 0] = $2;
  HEAP32[$3 + 92 >> 2] = 0;
  if (jsvHasChildren(HEAP32[$3 + 104 >> 2]) & 1) {
   HEAP32[$3 + 92 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 0)
  }
  block4 : {
   if (!HEAP32[$3 + 92 >> 2]) {
    block1 : {
     block : {
      if (!(jsvIsArrayBuffer(HEAP32[$3 + 104 >> 2]) & 1)) {
       break block
      }
      if (!(jsvIsInt(HEAP32[$3 + 100 >> 2]) & 1)) {
       break block
      }
      HEAP32[$3 + 92 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(jsvGetInteger(HEAP32[$3 + 100 >> 2])), HEAP32[$3 + 104 >> 2]);
      if (HEAP32[$3 + 92 >> 2]) {
       $0 = HEAP32[$3 + 92 >> 2];
       $1 = HEAP32[$3 + 92 >> 2];
       $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 14;
       HEAP8[$0 + 12 | 0] = $1;
       HEAP8[$0 + 13 | 0] = $1 >>> 8;
      }
      break block1;
     }
     block5 : {
      block2 : {
       if (!(jsvIsString(HEAP32[$3 + 104 >> 2]) & 1)) {
        break block2
       }
       if (!(jsvIsInt(HEAP32[$3 + 100 >> 2]) & 1)) {
        break block2
       }
       HEAP32[$3 + 88 >> 2] = jsvGetInteger(HEAP32[$3 + 100 >> 2]);
       block3 : {
        if (HEAP32[$3 + 88 >> 2] < 0) {
         break block3
        }
        if (HEAP32[$3 + 88 >> 2] >= (jsvGetStringLength(HEAP32[$3 + 104 >> 2]) | 0)) {
         break block3
        }
        HEAP32[$3 + 108 >> 2] = jswrap_string_charAt_undefined(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 88 >> 2]);
        break block4;
       }
       if (HEAP8[$3 + 99 | 0] & 1) {
        HEAP32[$3 + 92 >> 2] = jsvCreateNewChild(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 0)
       }
       break block5;
      }
      jsvGetString(HEAP32[$3 + 100 >> 2], $3 + 16 | 0, 64);
      HEAP32[$3 + 92 >> 2] = jspGetNamedFieldInParents(HEAP32[$3 + 104 >> 2], $3 + 16 | 0, HEAP8[$3 + 99 | 0] & 1);
      block6 : {
       if (HEAP32[$3 + 92 >> 2]) {
        break block6
       }
       if (!(jsvIsFunction(HEAP32[$3 + 104 >> 2]) & 1)) {
        break block6
       }
       if (!(jsvIsStringEqual(HEAP32[$3 + 100 >> 2], 17727) & 1)) {
        break block6
       }
       HEAP32[$3 + 12 >> 2] = jsvNewObject();
       HEAP32[$3 + 92 >> 2] = jsvAddNamedChild(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 12 >> 2], 17727);
       jsvUnLock(HEAP32[$3 + 12 >> 2]);
      }
     }
    }
   }
   if (HEAP8[$3 + 99 | 0] & 1) {
    HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 92 >> 2];
    break block4;
   }
   HEAP32[$3 + 108 >> 2] = jsvSkipNameAndUnLock(HEAP32[$3 + 92 >> 2]);
  }
  __stack_pointer = $3 + 112 | 0;
  return HEAP32[$3 + 108 >> 2];
 }
 
 function jspeFactorMember($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP32[$2 + 68 >> 2] = $1;
  HEAP32[$2 + 64 >> 2] = 0;
  block2 : {
   while (1) {
    $0 = 1;
    $0 = HEAPU16[HEAP32[61300] + 2 >> 1] != 46 ? HEAPU16[HEAP32[61300] + 2 >> 1] == 91 : $0;
    if ($0) {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 46) {
      jslGetNextToken();
      block1 : {
       if (jslIsIDOrReservedWord() & 1) {
        if ((HEAP32[103315] & 63) == 1) {
         HEAP32[$2 + 60 >> 2] = jslGetTokenValueAsString();
         HEAP32[$2 + 56 >> 2] = jsvSkipNameWithParent(HEAP32[$2 + 72 >> 2], 1, HEAP32[$2 + 64 >> 2]);
         HEAP32[$2 + 52 >> 2] = 0;
         if (HEAP32[$2 + 56 >> 2]) {
          HEAP32[$2 + 52 >> 2] = jspGetNamedField(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 60 >> 2], 1)
         }
         if (!HEAP32[$2 + 52 >> 2]) {
          block : {
           if (!(jsvIsNullish(HEAP32[$2 + 56 >> 2]) & 1)) {
            HEAP32[$2 + 48 >> 2] = jsvNewNameFromString(jslGetTokenValueAsString());
            HEAP32[$2 + 52 >> 2] = jsvCreateNewChild(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 48 >> 2], 0);
            jsvUnLock(HEAP32[$2 + 48 >> 2]);
            break block;
           }
           $0 = HEAP32[$2 + 60 >> 2];
           HEAP32[$2 + 4 >> 2] = jsvIsUndefined(HEAP32[$2 + 56 >> 2]) & 1 ? 19123 : 15755;
           HEAP32[$2 >> 2] = $0;
           jsExceptionHere(1, 7613, $2);
          }
         }
         jsvUnLock(HEAP32[$2 + 64 >> 2]);
         HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 56 >> 2];
         jsvUnLock(HEAP32[$2 + 72 >> 2]);
         HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 52 >> 2];
        }
        jslGetNextToken();
        break block1;
       }
       if (!(jslMatch(128) & 1)) {
        HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
        break block2;
       }
      }
      continue;
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 91) {
      jslGetNextToken();
      if (!(jspCheckStackPosition() & 1)) {
       HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 64 >> 2];
       break block2;
      }
      HEAP32[$2 + 44 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
      if (!(jslMatch(93) & 1)) {
       jsvUnLock2(HEAP32[$2 + 64 >> 2], HEAP32[$2 + 44 >> 2]);
       HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
       break block2;
      }
      if ((HEAP32[103315] & 63) == 1) {
       HEAP32[$2 + 44 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$2 + 44 >> 2]);
       HEAP32[$2 + 40 >> 2] = jsvSkipNameWithParent(HEAP32[$2 + 72 >> 2], 1, HEAP32[$2 + 64 >> 2]);
       HEAP32[$2 + 36 >> 2] = 0;
       if (HEAP32[$2 + 40 >> 2]) {
        HEAP32[$2 + 36 >> 2] = jspGetVarNamedField(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], 1)
       }
       if (!HEAP32[$2 + 36 >> 2]) {
        block3 : {
         if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
          HEAP32[$2 + 36 >> 2] = jsvCreateNewChild(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], 0);
          break block3;
         }
         $0 = HEAP32[$2 + 44 >> 2];
         HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 40 >> 2];
         HEAP32[$2 + 16 >> 2] = $0;
         jsExceptionHere(1, 6296, $2 + 16 | 0);
        }
       }
       jsvUnLock(HEAP32[$2 + 64 >> 2]);
       HEAP32[$2 + 64 >> 2] = jsvLockAgainSafe(HEAP32[$2 + 40 >> 2]);
       jsvUnLock(HEAP32[$2 + 72 >> 2]);
       HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 36 >> 2];
       jsvUnLock(HEAP32[$2 + 40 >> 2]);
      }
      jsvUnLock(HEAP32[$2 + 44 >> 2]);
     }
     continue;
    }
    break;
   };
   block4 : {
    if (HEAP32[$2 + 68 >> 2]) {
     HEAP32[HEAP32[$2 + 68 >> 2] >> 2] = HEAP32[$2 + 64 >> 2];
     break block4;
    }
    jsvUnLock(HEAP32[$2 + 64 >> 2]);
   }
   HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAP32[$2 + 76 >> 2];
 }
 
 function jspeConstruct($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP8[$3 + 19 | 0] = $2;
  block : {
   if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1)) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
    jsExceptionHere(1, 6252, $3);
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 12 >> 2] = jsvNewObject();
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 8 >> 2] = jsvFindOrAddChildFromString(HEAP32[$3 + 24 >> 2], 17727);
   jspEnsureIsPrototype(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvAddNamedChildAndUnLock(HEAP32[$3 + 12 >> 2], jsvSkipNameAndUnLock(HEAP32[$3 + 8 >> 2]), 20670);
   HEAP32[$3 + 4 >> 2] = jspeFunctionCall(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2], HEAP8[$3 + 19 | 0] & 1, 0, 0);
   block1 : {
    if (HEAP32[$3 + 4 >> 2]) {
     jsvUnLock(HEAP32[$3 + 12 >> 2]);
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 4 >> 2];
     break block1;
    }
    jsvUnLock(HEAP32[$3 + 4 >> 2]);
   }
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jspeFactorFunctionCall() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 80 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 75 | 0] = 0;
  block : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 184) {
    jslGetNextToken();
    HEAP8[$0 + 75 | 0] = 1;
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 184) {
     jsExceptionHere(1, 18707, 0);
     jspSetError();
     HEAP32[$0 + 76 >> 2] = 0;
     break block;
    }
   }
   HEAP32[$0 + 68 >> 2] = 0;
   HEAP32[$0 + 64 >> 2] = 0;
   HEAP8[$0 + 63 | 0] = 0;
   block9 : {
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 196) {
     jslGetNextToken();
     block5 : {
      if (jsvIsObject(HEAP32[103313]) & 1) {
       block2 : {
        if (!(!HEAP32[103314] | HEAPU16[HEAP32[61300] + 2 >> 1] != 40)) {
         HEAP32[$0 + 56 >> 2] = jsvObjectGetChildIfExists(HEAP32[103314], 17727);
         break block2;
        }
        HEAP32[$0 + 56 >> 2] = jsvObjectGetChildIfExists(HEAP32[103313], 20670);
       }
       block3 : {
        if (jsvIsObject(HEAP32[$0 + 56 >> 2]) & 1) {
         $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 56 >> 2], 20670);
         break block3;
        }
        $1 = 0;
       }
       HEAP32[$0 + 52 >> 2] = $1;
       jsvUnLock(HEAP32[$0 + 56 >> 2]);
       if (!HEAP32[$0 + 52 >> 2]) {
        jsExceptionHere(2, 6945, 0);
        HEAP32[$0 + 76 >> 2] = 0;
        break block;
       }
       block4 : {
        if (HEAPU16[HEAP32[61300] + 2 >> 1] == 40) {
         HEAP32[$0 + 48 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 52 >> 2], 7797);
         jsvUnLock(HEAP32[$0 + 52 >> 2]);
         HEAP32[103314] = HEAP32[$0 + 48 >> 2];
         HEAP8[$0 + 63 | 0] = 1;
         HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 48 >> 2];
         break block4;
        }
        HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 52 >> 2];
       }
       break block5;
      }
      block7 : {
       if (jsvIsFunction(HEAP32[103313]) & 1) {
        HEAP32[$0 + 44 >> 2] = jsvObjectGetChildIfExists(HEAP32[103313], 17727);
        block6 : {
         if (jsvIsObject(HEAP32[$0 + 44 >> 2]) & 1) {
          $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 44 >> 2], 20670);
          break block6;
         }
         $1 = 0;
        }
        HEAP32[$0 + 40 >> 2] = $1;
        jsvUnLock(HEAP32[$0 + 44 >> 2]);
        if (!HEAP32[$0 + 40 >> 2]) {
         jsExceptionHere(2, 6945, 0);
         HEAP32[$0 + 76 >> 2] = 0;
         break block;
        }
        HEAP32[$0 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 40 >> 2], 7797);
        jsvUnLock(HEAP32[$0 + 40 >> 2]);
        HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 36 >> 2];
        break block7;
       }
       jsExceptionHere(2, 6945, 0);
       HEAP32[$0 + 76 >> 2] = 0;
       break block;
      }
     }
     HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 64 >> 2];
     HEAP32[$0 + 64 >> 2] = jspeFactorMember(HEAP32[$0 + 64 >> 2], $0 + 68 | 0);
     if (!(HEAP32[$0 + 68 >> 2] != HEAP32[$0 + 32 >> 2] ? HEAP32[$0 + 68 >> 2] : 0)) {
      jsvUnLock(HEAP32[$0 + 68 >> 2]);
      HEAP32[$0 + 68 >> 2] = jsvLockAgain(HEAP32[103313]);
     }
     break block9;
    }
    HEAP32[$0 + 64 >> 2] = jspeFactorMember(jspeFactor(), $0 + 68 | 0);
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 133) {
    jsExceptionHere(2, 18845, 0);
    jsvUnLock2(HEAP32[$0 + 64 >> 2], HEAP32[$0 + 68 >> 2]);
    HEAP32[$0 + 76 >> 2] = 0;
    break block;
   }
   while (1) {
    block10 : {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 40) {
      $1 = 0;
      if (!(HEAP8[$0 + 75 | 0] & 1)) {
       break block10
      }
      $1 = 0;
      if ((HEAP32[103315] & 63) != 1) {
       break block10
      }
     }
     $1 = jspIsInterrupted() ^ -1;
    }
    if ($1 & 1) {
     HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 64 >> 2];
     HEAP32[$0 + 24 >> 2] = jsvSkipName(HEAP32[$0 + 28 >> 2]);
     block12 : {
      if (!(!(HEAP8[$0 + 75 | 0] & 1) | (HEAP32[103315] & 63) != 1)) {
       HEAP8[$0 + 23 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 40;
       HEAP32[$0 + 64 >> 2] = jspeConstruct(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2], HEAP8[$0 + 23 | 0] & 1);
       HEAP8[$0 + 75 | 0] = 0;
       break block12;
      }
      HEAP32[$0 + 64 >> 2] = jspeFunctionCall(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2], HEAP32[$0 + 68 >> 2], 1, 0, 0);
     }
     jsvUnLock3(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2], HEAP32[$0 + 68 >> 2]);
     HEAP32[$0 + 68 >> 2] = 0;
     HEAP32[$0 + 64 >> 2] = jspeFactorMember(HEAP32[$0 + 64 >> 2], $0 + 68 | 0);
     continue;
    }
    break;
   };
   if (HEAP8[$0 + 63 | 0] & 1) {
    HEAP32[103314] = 0
   }
   block13 : {
    if (!HEAP32[$0 + 68 >> 2]) {
     break block13
    }
    if (!(jsvIsBasicName(HEAP32[$0 + 64 >> 2]) & 1)) {
     break block13
    }
    if (jsvIsNewChild(HEAP32[$0 + 64 >> 2]) & 1) {
     break block13
    }
    HEAP32[$0 + 16 >> 2] = jsvLockSafe(jsvGetFirstChild(HEAP32[$0 + 64 >> 2]) & 65535);
    if (jsvIsGetterOrSetter(HEAP32[$0 + 16 >> 2]) & 1) {
     HEAP32[$0 + 12 >> 2] = jsvCopyNameOnly(HEAP32[$0 + 64 >> 2], 0, 1);
     HEAP32[$0 + 8 >> 2] = jsvCreateNewChild(HEAP32[$0 + 68 >> 2], HEAP32[$0 + 12 >> 2], HEAP32[$0 + 16 >> 2]);
     jsvUnLock2(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 64 >> 2]);
     HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 8 >> 2];
    }
    jsvUnLock(HEAP32[$0 + 16 >> 2]);
   }
   jsvUnLock(HEAP32[$0 + 68 >> 2]);
   HEAP32[$0 + 76 >> 2] = HEAP32[$0 + 64 >> 2];
  }
  __stack_pointer = $0 + 80 | 0;
  return HEAP32[$0 + 76 >> 2];
 }
 
 function jspeFactor() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 96 | 0;
  __stack_pointer = $0;
  block2 : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 128) {
    HEAP32[$0 + 88 >> 2] = jspGetNamedVariable(jslGetTokenValueAsString());
    jslGetNextToken();
    block : {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 133) {
      jsExceptionHere(2, 18777, 0);
      break block;
     }
     block1 : {
      if (HEAPU16[HEAP32[61300] + 2 >> 1] != 162) {
       break block1
      }
      if (!(jsvIsName(HEAP32[$0 + 88 >> 2]) & 1)) {
       if (HEAP32[$0 + 88 >> 2] | (HEAP32[103315] & 63) == 1) {
        break block1
       }
      }
      HEAP32[$0 + 84 >> 2] = jspeArrowFunction(0, HEAP32[$0 + 88 >> 2]);
      jsvUnLock(HEAP32[$0 + 88 >> 2]);
      HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 84 >> 2];
     }
    }
    HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 88 >> 2];
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 129) {
    HEAP32[$0 + 80 >> 2] = 0;
    if ((HEAP32[103315] & 63) == 1) {
     HEAP32[$0 + 80 >> 2] = jslGetTokenValueAsVar()
    }
    jslGetNextToken();
    HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 80 >> 2];
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 130) {
    HEAP32[$0 + 76 >> 2] = 0;
    if ((HEAP32[103315] & 63) == 1) {
     HEAP32[$0 + 76 >> 2] = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString()))
    }
    jslGetNextToken();
    HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 76 >> 2];
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 40) {
    jslGetNextToken();
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    HEAP32[$0 + 92 >> 2] = jspeExpressionOrArrowFunction();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 180) {
    jslGetNextToken();
    block3 : {
     if ((HEAP32[103315] & 63) == 1) {
      $1 = jsvNewFromBool(1);
      break block3;
     }
     $1 = 0;
    }
    HEAP32[$0 + 92 >> 2] = $1;
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 181) {
    jslGetNextToken();
    block4 : {
     if ((HEAP32[103315] & 63) == 1) {
      $1 = jsvNewFromBool(0);
      break block4;
     }
     $1 = 0;
    }
    HEAP32[$0 + 92 >> 2] = $1;
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 182) {
    jslGetNextToken();
    block5 : {
     if ((HEAP32[103315] & 63) == 1) {
      $1 = jsvNewWithFlags(2);
      break block5;
     }
     $1 = 0;
    }
    HEAP32[$0 + 92 >> 2] = $1;
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 183) {
    jslGetNextToken();
    HEAP32[$0 + 92 >> 2] = 0;
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 131) {
    HEAP32[$0 + 72 >> 2] = 0;
    if ((HEAP32[103315] & 63) == 1) {
     HEAP32[$0 + 72 >> 2] = jslGetTokenValueAsVar();
     if (HEAP8[HEAP32[61300] + 82 | 0] & 1) {
      HEAP32[$0 + 72 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$0 + 72 >> 2])
     }
    }
    jslGetNextToken();
    HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 72 >> 2];
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 133) {
    HEAP32[$0 + 92 >> 2] = jspeTemplateLiteral();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 135) {
    HEAP32[$0 + 68 >> 2] = 0;
    if ((HEAP32[103315] & 63) == 1) {
     HEAP32[$0 + 64 >> 2] = jslGetTokenValueAsVar();
     HEAP32[$0 + 60 >> 2] = 0;
     HEAP32[$0 + 56 >> 2] = 0;
     jsvStringIteratorNew($0 + 16 | 0, HEAP32[$0 + 64 >> 2], 0);
     while (1) {
      if (jsvStringIteratorHasChar_553($0 + 16 | 0) & 1) {
       HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 56 >> 2] + 1;
       if ((jsvStringIteratorGetCharAndNext($0 + 16 | 0) & 255) == 47) {
        HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 56 >> 2]
       }
       continue;
      }
      break;
     };
     jsvStringIteratorFree_520($0 + 16 | 0);
     HEAP32[$0 + 12 >> 2] = 0;
     if (HEAPU32[$0 + 60 >> 2] < HEAPU32[$0 + 56 >> 2]) {
      HEAP32[$0 + 12 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 64 >> 2], HEAP32[$0 + 60 >> 2], 2147483647)
     }
     HEAP32[$0 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 64 >> 2], 1, HEAP32[$0 + 60 >> 2] - 2 | 0);
     HEAP32[$0 + 68 >> 2] = jswrap_regexp_constructor(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 12 >> 2]);
     jsvUnLock3(HEAP32[$0 + 64 >> 2], HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2]);
    }
    jslGetNextToken();
    HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 68 >> 2];
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 123) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    HEAP32[$0 + 92 >> 2] = jspeFactorObject();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 91) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    HEAP32[$0 + 92 >> 2] = jspeFactorArray();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 170) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    jslGetNextToken();
    HEAP32[$0 + 92 >> 2] = jspeFunctionDefinition(1);
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 194) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    jslGetNextToken();
    HEAP32[$0 + 92 >> 2] = jspeClassDefinition(1);
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 175) {
    jslGetNextToken();
    if (HEAP32[103313]) {
     $1 = HEAP32[103313]
    } else {
     $1 = HEAP32[103307]
    }
    HEAP32[$0 + 92 >> 2] = jsvLockAgain($1);
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 190) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    HEAP32[$0 + 92 >> 2] = jspeFactorDelete();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 191) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    HEAP32[$0 + 92 >> 2] = jspeFactorTypeOf();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 192) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 92 >> 2] = 0;
     break block2;
    }
    jslGetNextToken();
    jsvUnLock(jspeUnaryExpression());
    HEAP32[$0 + 92 >> 2] = 0;
    break block2;
   }
   if (!(jslMatch(0) & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break block2;
   }
   jsExceptionHere(2, 4292, 0);
   HEAP32[$0 + 92 >> 2] = 0;
  }
  __stack_pointer = $0 + 96 | 0;
  return HEAP32[$0 + 92 >> 2];
 }
 
 function jspeFactorObject() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 112 | 0;
  __stack_pointer = $0;
  block : {
   if ((HEAP32[103315] & 63) == 1) {
    HEAP32[$0 + 104 >> 2] = jsvNewObject();
    if (!HEAP32[$0 + 104 >> 2]) {
     jspSetError();
     HEAP32[$0 + 108 >> 2] = 0;
     break block;
    }
    if (!(jslMatch(123) & 1)) {
     HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
     break block;
    }
    while (1) {
     $1 = 0;
     $1 = HEAP32[103315] & 80 ? $1 : HEAPU16[HEAP32[61300] + 2 >> 1] != 125;
     if ($1) {
      HEAP32[$0 + 100 >> 2] = 0;
      HEAP8[$0 + 99 | 0] = 0;
      block1 : {
       if (jslIsIDOrReservedWord() & 1) {
        HEAP8[$0 + 99 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 128;
        if ((HEAP32[103315] & 63) == 1) {
         HEAP32[$0 + 100 >> 2] = jslGetTokenValueAsVar()
        }
        jslGetNextToken();
        break block1;
       }
       block4 : {
        if (!(!(HEAPU16[HEAP32[61300] + 2 >> 1] == 131 | HEAPU16[HEAP32[61300] + 2 >> 1] == 130) & HEAPU16[HEAP32[61300] + 2 >> 1] != 129)) {
         HEAP32[$0 + 100 >> 2] = jspeFactor();
         break block4;
        }
        if (!(jslMatch(128) & 1)) {
         HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
         break block;
        }
       }
      }
      block7 : {
       block5 : {
        if (HEAPU16[HEAP32[61300] + 2 >> 1] != 128) {
         break block5
        }
        if (!(jsvIsString(HEAP32[$0 + 100 >> 2]) & 1)) {
         break block5
        }
        HEAP8[$0 + 98 | 0] = jsvIsStringEqual(HEAP32[$0 + 100 >> 2], 4994) & 1;
        HEAP8[$0 + 97 | 0] = jsvIsStringEqual(HEAP32[$0 + 100 >> 2], 4980) & 1;
        if (HEAP8[$0 + 98 | 0] & 1 | HEAP8[$0 + 97 | 0] & 1) {
         jsvUnLock(HEAP32[$0 + 100 >> 2]);
         HEAP32[$0 + 100 >> 2] = jslGetTokenValueAsVar();
         jslGetNextToken();
         HEAP32[$0 + 92 >> 2] = jspeFunctionDefinition(0);
         jsvAddGetterOrSetter(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], HEAP8[$0 + 98 | 0] & 1, HEAP32[$0 + 92 >> 2]);
         jsvUnLock(HEAP32[$0 + 92 >> 2]);
        }
        break block7;
       }
       block8 : {
        if (HEAPU16[HEAP32[61300] + 2 >> 1] == 40) {
         HEAP32[$0 + 88 >> 2] = jsvFindChildFromVar(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], 1);
         if (HEAP32[$0 + 88 >> 2]) {
          HEAP32[$0 + 84 >> 2] = jspeFunctionDefinition(0);
          jsvUnLock2(jsvSetValueOfName(HEAP32[$0 + 88 >> 2], HEAP32[$0 + 84 >> 2]), HEAP32[$0 + 84 >> 2]);
         }
         break block8;
        }
        block10 : {
         block9 : {
          if (!(HEAP8[$0 + 99 | 0] & 1) | HEAPU16[HEAP32[61300] + 2 >> 1] != 44 & HEAPU16[HEAP32[61300] + 2 >> 1] != 125) {
           break block9
          }
          if (!(jsvIsString(HEAP32[$0 + 100 >> 2]) & 1)) {
           break block9
          }
          if ((HEAP32[103315] & 63) == 1) {
           HEAP32[$0 + 100 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$0 + 100 >> 2]);
           HEAP32[$0 + 80 >> 2] = jsvFindChildFromVar(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], 1);
           if (HEAP32[$0 + 80 >> 2]) {
            jsvGetString(HEAP32[$0 + 100 >> 2], $0 + 16 | 0, 64);
            HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspGetNamedVariable($0 + 16 | 0));
            jsvUnLock2(jsvSetValueOfName(HEAP32[$0 + 80 >> 2], HEAP32[$0 + 12 >> 2]), HEAP32[$0 + 12 >> 2]);
           }
          }
          break block10;
         }
         if (!(jslMatch(58) & 1)) {
          jsvUnLock(HEAP32[$0 + 100 >> 2]);
          HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
          break block;
         }
         if ((HEAP32[103315] & 63) == 1) {
          HEAP32[$0 + 100 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$0 + 100 >> 2]);
          HEAP32[$0 + 8 >> 2] = jsvFindChildFromVar(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], 1);
          if (HEAP32[$0 + 8 >> 2]) {
           HEAP32[$0 + 4 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
           jsvUnLock2(jsvSetValueOfName(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]), HEAP32[$0 + 4 >> 2]);
          }
         }
        }
       }
      }
      jsvUnLock(HEAP32[$0 + 100 >> 2]);
      if (HEAPU16[HEAP32[61300] + 2 >> 1] != 125) {
       if (!(jslMatch(44) & 1)) {
        HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
        break block;
       }
      }
      continue;
     }
     break;
    };
    if (!(jslMatch(125) & 1)) {
     HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
     break block;
    }
    HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
    break block;
   }
   jspeBlock();
   HEAP32[$0 + 108 >> 2] = 0;
  }
  __stack_pointer = $0 + 112 | 0;
  return HEAP32[$0 + 108 >> 2];
 }
 
 function jspeBlock() {
  if (jslMatch(123) & 1) {
   jspeBlockNoBrackets();
   if (!(HEAP32[103315] & 80)) {
    block : {
     if (jslMatch(125) & 1) {
      break block
     }
    }
   }
  }
 }
 
 function jspeFactorArray() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  block : {
   if ((HEAP32[103315] & 63) == 1) {
    HEAP32[$0 + 20 >> 2] = jsvNewEmptyArray();
    if (!HEAP32[$0 + 20 >> 2]) {
     jspSetError();
     HEAP32[$0 + 28 >> 2] = 0;
     break block;
    }
   }
   if (!(jslMatch(91) & 1)) {
    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
    break block;
   }
   while (1) {
    $1 = 0;
    $1 = HEAP32[103315] & 80 ? $1 : HEAPU16[HEAP32[61300] + 2 >> 1] != 93;
    if ($1) {
     block1 : {
      if ((HEAP32[103315] & 63) == 1) {
       if (HEAPU16[HEAP32[61300] + 2 >> 1] != 44) {
        $1 = jsvSkipNameAndUnLock(jspeAssignmentExpression());
        HEAP32[$0 + 16 >> 2] = $1;
        HEAP32[$0 + 16 >> 2] = $1;
        HEAP32[$0 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$0 + 24 >> 2]), HEAP32[$0 + 16 >> 2]);
        if (HEAP32[$0 + 12 >> 2]) {
         jsvAddName(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2]);
         jsvUnLock(HEAP32[$0 + 12 >> 2]);
        }
        jsvUnLock(HEAP32[$0 + 16 >> 2]);
       }
       break block1;
      }
      jsvUnLock(jspeAssignmentExpression());
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 93) {
      if (!(jslMatch(44) & 1)) {
       HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
       break block;
      }
     }
     HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$0 + 20 >> 2]) {
    jsvSetArrayLength(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 24 >> 2], 0)
   }
   if (!(jslMatch(93) & 1)) {
    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
    break block;
   }
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
  }
  __stack_pointer = $0 + 32 | 0;
  return HEAP32[$0 + 28 >> 2];
 }
 
 function jspeFactorTypeOf() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  jslGetNextToken();
  HEAP32[$0 + 12 >> 2] = jspeUnaryExpression();
  HEAP32[$0 + 8 >> 2] = 0;
  if ((HEAP32[103315] & 63) == 1) {
   block : {
    if (!(jsvIsVariableDefined(HEAP32[$0 + 12 >> 2]) & 1)) {
     HEAP32[$0 + 8 >> 2] = jsvNewFromString(19123);
     break block;
    }
    HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(HEAP32[$0 + 12 >> 2]);
    HEAP32[$0 + 8 >> 2] = jsvNewFromString(jsvGetTypeOf(HEAP32[$0 + 12 >> 2]));
   }
  }
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 8 >> 2];
 }
 
 function jspeUnaryExpression() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block2 : {
   block1 : {
    if (!(HEAPU16[HEAP32[61300] + 2 >> 1] == 33 | HEAPU16[HEAP32[61300] + 2 >> 1] == 126 | HEAPU16[HEAP32[61300] + 2 >> 1] == 45)) {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 43) {
      break block1
     }
    }
    HEAP16[$0 + 10 >> 1] = HEAPU16[HEAP32[61300] + 2 >> 1];
    jslGetNextToken();
    if ((HEAP32[103315] & 63) != 1) {
     HEAP32[$0 + 12 >> 2] = jspeUnaryExpression();
     break block2;
    }
    HEAP32[$0 + 4 >> 2] = jsvSkipNameAndUnLock(jspeUnaryExpression());
    if (HEAPU16[$0 + 10 >> 1] == 33) {
     HEAP32[$0 + 12 >> 2] = jsvNewFromBool((jsvGetBoolAndUnLock(HEAP32[$0 + 4 >> 2]) ^ -1) & 1);
     break block2;
    }
    HEAP32[$0 + 4 >> 2] = jsvGetValueOfAndUnLock(HEAP32[$0 + 4 >> 2]);
    if (HEAPU16[$0 + 10 >> 1] == 126) {
     HEAP32[$0 + 12 >> 2] = jsvNewFromInteger(jsvGetIntegerAndUnLock(HEAP32[$0 + 4 >> 2]) ^ -1);
     break block2;
    }
    if (HEAPU16[$0 + 10 >> 1] == 45) {
     HEAP32[$0 + 12 >> 2] = jsvNegateAndUnLock(HEAP32[$0 + 4 >> 2]);
     break block2;
    }
    if (HEAPU16[$0 + 10 >> 1] == 43) {
     HEAP32[$0 + 12 >> 2] = jsvAsNumberAndUnLock(HEAP32[$0 + 4 >> 2]);
     break block2;
    }
    HEAP32[$0 + 12 >> 2] = 0;
    break block2;
   }
   HEAP32[$0 + 12 >> 2] = jspePostfixExpression();
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeFactorDelete() {
  var $0 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  jslGetNextToken();
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = jspeFactorMember(jspeFactor(), $0 + 28 | 0);
  HEAP32[$0 + 20 >> 2] = 0;
  if ((HEAP32[103315] & 63) == 1) {
   HEAP8[$0 + 19 | 0] = 0;
   block : {
    if (!(jsvIsName(HEAP32[$0 + 24 >> 2]) & 1)) {
     break block
    }
    if (jsvIsNewChild(HEAP32[$0 + 24 >> 2]) & 1) {
     break block
    }
    block1 : {
     if (HEAP32[$0 + 28 >> 2]) {
      break block1
     }
     if (!(jsvIsChild(HEAP32[103307], HEAP32[$0 + 24 >> 2]) & 1)) {
      break block1
     }
     HEAP32[$0 + 28 >> 2] = jsvLockAgain(HEAP32[103307]);
    }
    block2 : {
     if (!(jsvHasChildren(HEAP32[$0 + 28 >> 2]) & 1)) {
      break block2
     }
     if (!(jsvIsChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]) & 1)) {
      break block2
     }
     block3 : {
      if (jsvIsArray(HEAP32[$0 + 28 >> 2]) & 1) {
       HEAP32[$0 + 12 >> 2] = jsvGetArrayLength(HEAP32[$0 + 28 >> 2]);
       jsvRemoveChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]);
       jsvSetArrayLength(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 12 >> 2], 0);
       break block3;
      }
      jsvRemoveChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]);
     }
     HEAP8[$0 + 19 | 0] = 1;
    }
   }
   HEAP32[$0 + 20 >> 2] = jsvNewFromBool(HEAP8[$0 + 19 | 0] & 1);
  }
  jsvUnLock2(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2]);
  __stack_pointer = $0 + 32 | 0;
  return HEAP32[$0 + 20 >> 2];
 }
 
 function jspeTemplateLiteral() {
  var $0 = 0;
  $0 = __stack_pointer - 144 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 140 >> 2] = 0;
  if ((HEAP32[103315] & 63) == 1) {
   HEAP32[$0 + 136 >> 2] = jslGetTokenValueAsVar();
   HEAP32[$0 + 140 >> 2] = jsvNewFromEmptyString_552();
   if (!(!HEAP32[$0 + 140 >> 2] | !HEAP32[$0 + 136 >> 2])) {
    jsvStringIteratorNew($0 + 96 | 0, HEAP32[$0 + 136 >> 2], 0);
    jsvStringIteratorNew($0 + 56 | 0, HEAP32[$0 + 140 >> 2], 0);
    while (1) {
     block1 : {
      if (!(jsvStringIteratorHasChar_553($0 + 96 | 0) & 1)) {
       break block1
      }
      HEAP8[$0 + 55 | 0] = jsvStringIteratorGetCharAndNext($0 + 96 | 0);
      block4 : {
       if (HEAPU8[$0 + 55 | 0] == 36) {
        HEAP8[$0 + 55 | 0] = jsvStringIteratorGetChar_554($0 + 96 | 0);
        block3 : {
         if (HEAPU8[$0 + 55 | 0] == 123) {
          jsvStringIteratorNext($0 + 96 | 0);
          HEAP32[$0 + 48 >> 2] = 1;
          HEAP32[$0 + 44 >> 2] = jsvNewFromEmptyString_552();
          if (!HEAP32[$0 + 44 >> 2]) {
           break block1
          }
          jsvStringIteratorNew($0 + 4 | 0, HEAP32[$0 + 44 >> 2], 0);
          while (1) {
           block2 : {
            if (!(jsvStringIteratorHasChar_553($0 + 96 | 0) & 1)) {
             break block2
            }
            HEAP8[$0 + 55 | 0] = jsvStringIteratorGetCharAndNext($0 + 96 | 0);
            if (HEAPU8[$0 + 55 | 0] == 123) {
             HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + 1
            }
            if (HEAPU8[$0 + 55 | 0] == 125) {
             HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] - 1;
             if (!HEAP32[$0 + 48 >> 2]) {
              break block2
             }
            }
            jsvStringIteratorAppend($0 + 4 | 0, HEAP8[$0 + 55 | 0] << 24 >> 24);
            continue;
           }
           break;
          };
          jsvStringIteratorFree_520($0 + 4 | 0);
          HEAP32[$0 >> 2] = jspEvaluateExpressionVar(HEAP32[$0 + 44 >> 2]);
          jsvUnLock(HEAP32[$0 + 44 >> 2]);
          HEAP32[$0 >> 2] = jsvAsStringAndUnLock(HEAP32[$0 >> 2]);
          jsvStringIteratorAppendString($0 + 56 | 0, HEAP32[$0 >> 2], 0, 2147483647);
          jsvUnLock(HEAP32[$0 >> 2]);
          break block3;
         }
         jsvStringIteratorAppend($0 + 56 | 0, 36);
        }
        break block4;
       }
       jsvStringIteratorAppend($0 + 56 | 0, HEAP8[$0 + 55 | 0] << 24 >> 24);
      }
      continue;
     }
     break;
    };
    jsvStringIteratorFree_520($0 + 96 | 0);
    jsvStringIteratorFree_520($0 + 56 | 0);
   }
   jsvUnLock(HEAP32[$0 + 136 >> 2]);
  }
  jslGetNextToken();
  __stack_pointer = $0 + 144 | 0;
  return HEAP32[$0 + 140 >> 2];
 }
 
 function jsvNewFromEmptyString_552() {
  return jsvNewWithFlags(29);
 }
 
 function jsvStringIteratorHasChar_553($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorGetChar_554($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function jspEvaluateExpressionVar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 160 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 156 >> 2] = $0;
  HEAP32[$1 + 16 >> 2] = jslSetLex($1 + 20 | 0);
  jslInit(HEAP32[$1 + 156 >> 2]);
  HEAP32[$1 + 12 >> 2] = jspeExpression();
  jslKill();
  jslSetLex(HEAP32[$1 + 16 >> 2]);
  $0 = jsvSkipNameAndUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 160 | 0;
  return $0;
 }
 
 function jspeExpressionOrArrowFunction() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP8[$0 + 3 | 0] = 1;
  block2 : {
   while (1) {
    $1 = 0;
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
     $1 = (HEAP32[103315] & 80) != 0 ^ -1
    }
    if ($1 & 1) {
     if (!(!(HEAP8[$0 + 3 | 0] & 1) | !HEAP32[$0 + 8 >> 2])) {
      HEAP32[$0 + 4 >> 2] = jspeAddNamedFunctionParameter(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2])
     }
     jsvUnLock(HEAP32[$0 + 8 >> 2]);
     HEAP32[$0 + 8 >> 2] = jspeAssignmentExpression();
     block1 : {
      if ((HEAP32[103315] & 63) != 1) {
       break block1
      }
      if (jsvIsName(HEAP32[$0 + 8 >> 2]) & 1) {
       if (jsvIsString(HEAP32[$0 + 8 >> 2]) & 1) {
        break block1
       }
      }
      HEAP8[$0 + 3 | 0] = 0;
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
      if (!(jslMatch(44) & 1)) {
       jsvUnLock2(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
       HEAP32[$0 + 12 >> 2] = 0;
       break block2;
      }
     }
     continue;
    }
    break;
   };
   if (!(jslMatch(41) & 1)) {
    jsvUnLock2(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
    HEAP32[$0 + 12 >> 2] = 0;
    break block2;
   }
   if (!(!(HEAP8[$0 + 3 | 0] & 1) | HEAPU16[HEAP32[61300] + 2 >> 1] != 162)) {
    HEAP32[$0 + 4 >> 2] = jspeArrowFunction(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
    break block2;
   }
   jsvUnLock(HEAP32[$0 + 4 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeClassDefinition($0) {
  var $1 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 91 | 0] = $0;
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  HEAP32[$1 + 76 >> 2] = 0;
  HEAP8[$1 + 75 | 0] = (HEAP32[103315] & 63) == 1;
  if (HEAP8[$1 + 75 | 0] & 1) {
   HEAP32[$1 + 84 >> 2] = jsvNewWithFlags(7);
   HEAP32[$1 + 76 >> 2] = jsvNewObject();
   HEAP32[$1 + 68 >> 2] = jspeiGetScopesAsVar();
   if (HEAP32[$1 + 68 >> 2]) {
    jsvAddNamedChildAndUnLock(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 68 >> 2], 15114)
   }
  }
  if (!(!(HEAP8[$1 + 91 | 0] & 1) | HEAPU16[HEAP32[61300] + 2 >> 1] != 128)) {
   if (HEAP32[$1 + 76 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 15721, jslGetTokenValueAsVar())
   }
   jslGetNextToken();
  }
  if (HEAP32[$1 + 84 >> 2]) {
   HEAP32[$1 + 64 >> 2] = jsvFindOrAddChildFromString(HEAP32[$1 + 84 >> 2], 17727);
   jspEnsureIsPrototype(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 64 >> 2]);
   HEAP32[$1 + 80 >> 2] = jsvSkipName(HEAP32[$1 + 64 >> 2]);
   jsvUnLock(HEAP32[$1 + 64 >> 2]);
  }
  block1 : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 195) {
    jslGetNextToken();
    HEAP32[$1 + 60 >> 2] = 0;
    HEAP32[$1 + 56 >> 2] = 0;
    if (HEAP8[$1 + 75 | 0] & 1) {
     HEAP32[$1 + 60 >> 2] = jspGetNamedVariable(jslGetTokenValueAsString());
     HEAP32[$1 + 56 >> 2] = jsvSkipName(HEAP32[$1 + 60 >> 2]);
    }
    if (!(jslMatch(128) & 1)) {
     jsvUnLock4(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
     HEAP32[$1 + 92 >> 2] = 0;
     break block1;
    }
    if (HEAP32[$1 + 80 >> 2]) {
     block2 : {
      if (jsvIsFunction(HEAP32[$1 + 56 >> 2]) & 1) {
       HEAP32[$1 + 52 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 56 >> 2], 17727);
       if (HEAP32[$1 + 52 >> 2]) {
        jsvObjectSetChild(HEAP32[$1 + 80 >> 2], 20670, HEAP32[$1 + 52 >> 2]);
        $0 = HEAP32[$1 + 84 >> 2];
        HEAP32[$1 >> 2] = HEAP32[$1 + 60 >> 2];
        jsvObjectSetChildAndUnLock($0, 18659, jsvVarPrintf(24563, $1));
        jsvUnLock(HEAP32[$1 + 52 >> 2]);
       }
       break block2;
      }
      $0 = HEAP32[$1 + 60 >> 2];
      HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 56 >> 2];
      HEAP32[$1 + 16 >> 2] = $0;
      jsExceptionHere(2, 5929, $1 + 16 | 0);
     }
    }
    jsvUnLock2(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 60 >> 2]);
   }
   if (!(jslMatch(123) & 1)) {
    jsvUnLock3(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
    HEAP32[$1 + 92 >> 2] = 0;
    break block1;
   }
   while (1) {
    block3 : {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 128) {
      $0 = 0;
      if (HEAPU16[HEAP32[61300] + 2 >> 1] != 197) {
       break block3
      }
     }
     $0 = jspIsInterrupted() ^ -1;
    }
    if ($0 & 1) {
     HEAP8[$1 + 51 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 197;
     if (HEAP8[$1 + 51 | 0] & 1) {
      jslGetNextToken()
     }
     HEAP32[$1 + 44 >> 2] = jslGetTokenValueAsVar();
     HEAP8[$1 + 43 | 0] = jsvIsStringEqual(HEAP32[$1 + 44 >> 2], 7797) & 1;
     if (!(jslMatch(128) & 1)) {
      jsvUnLock4(HEAP32[$1 + 44 >> 2], HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
      HEAP32[$1 + 92 >> 2] = 0;
      break block1;
     }
     HEAP8[$1 + 42 | 0] = 0;
     HEAP8[$1 + 41 | 0] = 0;
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 128) {
      HEAP8[$1 + 42 | 0] = jsvIsStringEqual(HEAP32[$1 + 44 >> 2], 4994) & 1;
      HEAP8[$1 + 41 | 0] = jsvIsStringEqual(HEAP32[$1 + 44 >> 2], 4980) & 1;
      if (HEAP8[$1 + 42 | 0] & 1 | HEAP8[$1 + 41 | 0] & 1) {
       jsvUnLock(HEAP32[$1 + 44 >> 2]);
       HEAP32[$1 + 44 >> 2] = jslGetTokenValueAsVar();
       jslGetNextToken();
      }
     }
     if (HEAP8[$1 + 51 | 0] & 1) {
      $0 = HEAP32[$1 + 76 >> 2]
     } else {
      $0 = HEAP32[$1 + 80 >> 2]
     }
     HEAP32[$1 + 36 >> 2] = $0;
     if (HEAP32[$1 + 36 >> 2]) {
      block11 : {
       block7 : {
        if (!(HEAP8[$1 + 43 | 0] & 1 | (HEAP8[$1 + 42 | 0] & 1 | HEAP8[$1 + 41 | 0] & 1))) {
         if (HEAPU16[HEAP32[61300] + 2 >> 1] != 40) {
          break block7
         }
        }
        HEAP32[$1 + 32 >> 2] = jspeFunctionDefinition(0);
        block8 : {
         if (HEAP8[$1 + 43 | 0] & 1) {
          jswrap_function_replaceWith(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 32 >> 2]);
          break block8;
         }
         block10 : {
          if (HEAP8[$1 + 42 | 0] & 1 | HEAP8[$1 + 41 | 0] & 1) {
           jsvAddGetterOrSetter(HEAP32[$1 + 36 >> 2], HEAP32[$1 + 44 >> 2], HEAP8[$1 + 42 | 0] & 1, HEAP32[$1 + 32 >> 2]);
           break block10;
          }
          jsvObjectSetChildVar(HEAP32[$1 + 36 >> 2], HEAP32[$1 + 44 >> 2], HEAP32[$1 + 32 >> 2]);
         }
        }
        jsvUnLock(HEAP32[$1 + 32 >> 2]);
        break block11;
       }
       if (!(jslMatch(61) & 1)) {
        jsvUnLock4(HEAP32[$1 + 44 >> 2], HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
        HEAP32[$1 + 92 >> 2] = 0;
        break block1;
       }
       HEAP32[$1 + 28 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
       jsvObjectSetChildVar(HEAP32[$1 + 36 >> 2], HEAP32[$1 + 44 >> 2], HEAP32[$1 + 28 >> 2]);
       jsvUnLock(HEAP32[$1 + 28 >> 2]);
      }
     }
     while (1) {
      if (HEAPU16[HEAP32[61300] + 2 >> 1] == 59) {
       jslGetNextToken();
       continue;
      }
      break;
     };
     jsvUnLock(HEAP32[$1 + 44 >> 2]);
     continue;
    }
    break;
   };
   jsvUnLock(HEAP32[$1 + 80 >> 2]);
   jsvObjectAppendAll(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2]);
   jsvUnLock(HEAP32[$1 + 76 >> 2]);
   if (!(jslMatch(125) & 1)) {
    jsvUnLock(HEAP32[$1 + 84 >> 2]);
    HEAP32[$1 + 92 >> 2] = 0;
    break block1;
   }
   HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 84 >> 2];
  }
  __stack_pointer = $1 + 96 | 0;
  return HEAP32[$1 + 92 >> 2];
 }
 
 function __jspePostfixExpression($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  while (1) {
   $0 = 1;
   $0 = HEAPU16[HEAP32[61300] + 2 >> 1] != 152 ? HEAPU16[HEAP32[61300] + 2 >> 1] == 153 : $0;
   if ($0) {
    HEAP32[$1 + 24 >> 2] = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16;
    jslGetNextToken();
    if ((HEAP32[103315] & 63) == 1) {
     HEAP32[$1 + 20 >> 2] = jsvNewFromInteger(1);
     HEAP32[$1 + 16 >> 2] = jsvAsNumberAndUnLock(jsvSkipName(HEAP32[$1 + 28 >> 2]));
     HEAP32[$1 + 12 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 24 >> 2] == 152 ? 43 : 45);
     jsvUnLock(HEAP32[$1 + 20 >> 2]);
     jsvReplaceWith(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 12 >> 2]);
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
     jsvUnLock(HEAP32[$1 + 28 >> 2]);
     HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
    }
    continue;
   }
   break;
  };
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jspePostfixExpression() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block1 : {
   if (!(HEAPU16[HEAP32[61300] + 2 >> 1] != 152 & HEAPU16[HEAP32[61300] + 2 >> 1] != 153)) {
    HEAP32[$0 + 8 >> 2] = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16;
    jslGetNextToken();
    HEAP32[$0 + 12 >> 2] = jspePostfixExpression();
    if ((HEAP32[103315] & 63) == 1) {
     HEAP32[$0 + 4 >> 2] = jsvNewFromInteger(1);
     HEAP32[$0 >> 2] = jsvMathsOpSkipNames(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2] == 152 ? 43 : 45);
     jsvUnLock(HEAP32[$0 + 4 >> 2]);
     jsvReplaceWith(HEAP32[$0 + 12 >> 2], HEAP32[$0 >> 2]);
     jsvUnLock(HEAP32[$0 >> 2]);
    }
    break block1;
   }
   HEAP32[$0 + 12 >> 2] = jspeFactorFunctionCall();
  }
  $1 = __jspePostfixExpression(HEAP32[$0 + 12 >> 2]);
  __stack_pointer = $0 + 16 | 0;
  return $1;
 }
 
 function jspeGetBinaryExpressionPrecedence($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block12 : {
   block2 : {
    switch (HEAP32[$1 + 8 >> 2] - 37 | 0) {
    case 123:
    case 171:
     HEAP32[$1 + 12 >> 2] = 1;
     break block12;
    case 121:
     HEAP32[$1 + 12 >> 2] = 2;
     break block12;
    case 87:
     HEAP32[$1 + 12 >> 2] = 3;
     break block12;
    case 57:
     HEAP32[$1 + 12 >> 2] = 4;
     break block12;
    case 1:
     HEAP32[$1 + 12 >> 2] = 5;
     break block12;
    case 101:
    case 102:
    case 103:
    case 104:
     HEAP32[$1 + 12 >> 2] = 6;
     break block12;
    case 23:
    case 25:
    case 105:
    case 108:
    case 149:
     HEAP32[$1 + 12 >> 2] = 7;
     break block12;
    case 148:
     HEAP32[$1 + 12 >> 2] = HEAP32[103315] & 256 ? 0 : 7;
     break block12;
    case 106:
    case 109:
    case 110:
     HEAP32[$1 + 12 >> 2] = 8;
     break block12;
    case 6:
    case 8:
     HEAP32[$1 + 12 >> 2] = 9;
     break block12;
    case 0:
    case 5:
    case 10:
     HEAP32[$1 + 12 >> 2] = 10;
     break block12;
    default:
     break block2;
    };
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function __jspeBinaryExpression($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 208 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 204 >> 2] = $0;
  HEAP32[$2 + 200 >> 2] = $1;
  HEAP32[$2 + 196 >> 2] = jspeGetBinaryExpressionPrecedence(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16);
  while (1) {
   $0 = 0;
   $0 = HEAP32[$2 + 196 >> 2] ? HEAPU32[$2 + 196 >> 2] > HEAPU32[$2 + 200 >> 2] : $0;
   if ($0) {
    HEAP32[$2 + 192 >> 2] = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16;
    jslGetNextToken();
    if ((HEAP32[103315] & 63) == 1) {
     HEAP32[$2 + 204 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 204 >> 2])
    }
    block4 : {
     if (!(HEAP32[$2 + 192 >> 2] != 158 & HEAP32[$2 + 192 >> 2] != 160)) {
      HEAP8[$2 + 191 | 0] = jsvGetBool(HEAP32[$2 + 204 >> 2]) & 1;
      block3 : {
       block2 : {
        if (!(!(HEAP8[$2 + 191 | 0] & 1) & HEAP32[$2 + 192 >> 2] == 158)) {
         if (!(HEAP8[$2 + 191 | 0] & 1) | HEAP32[$2 + 192 >> 2] != 160) {
          break block2
         }
        }
        HEAP32[$2 + 184 >> 2] = HEAP32[103315];
        jspSetNoExecute();
        jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]));
        HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$2 + 184 >> 2] & 1663;
        break block3;
       }
       jsvUnLock(HEAP32[$2 + 204 >> 2]);
       HEAP32[$2 + 204 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]);
      }
      break block4;
     }
     block5 : {
      if (HEAP32[$2 + 192 >> 2] == 208) {
       if (jsvIsNullish(HEAP32[$2 + 204 >> 2]) & 1) {
        jsvUnLock(HEAP32[$2 + 204 >> 2]);
        HEAP32[$2 + 204 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]);
        break block5;
       }
       HEAP32[$2 + 180 >> 2] = HEAP32[103315];
       jspSetNoExecute();
       jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]));
       HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$2 + 180 >> 2] & 1663;
       break block5;
      }
      HEAP32[$2 + 176 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]);
      if ((HEAP32[103315] & 63) == 1) {
       block10 : {
        if (HEAP32[$2 + 192 >> 2] == 185) {
         HEAP32[$2 + 172 >> 2] = jsvSkipName(HEAP32[$2 + 176 >> 2]);
         block6 : {
          if (jsvHasChildren(HEAP32[$2 + 172 >> 2]) & 1) {
           HEAP32[$2 + 168 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$2 + 204 >> 2]);
           HEAP32[$2 + 164 >> 2] = jspGetVarNamedField(HEAP32[$2 + 172 >> 2], HEAP32[$2 + 168 >> 2], 1);
           HEAP32[$2 + 204 >> 2] = jsvNewFromBool(HEAP32[$2 + 164 >> 2] != 0);
           jsvUnLock2(HEAP32[$2 + 168 >> 2], HEAP32[$2 + 164 >> 2]);
           break block6;
          }
          HEAP32[$2 + 160 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$2 + 172 >> 2]);
          block9 : {
           if (HEAP32[$2 + 160 >> 2]) {
            HEAP32[$2 + 156 >> 2] = 0;
            if (jsvGetString(HEAP32[$2 + 204 >> 2], $2 + 80 | 0, 64) >>> 0 < 64) {
             HEAP32[$2 + 156 >> 2] = jswBinarySearch(HEAP32[$2 + 160 >> 2], HEAP32[$2 + 172 >> 2], $2 + 80 | 0)
            }
            HEAP8[$2 + 79 | 0] = HEAP32[$2 + 156 >> 2] != 0;
            jsvUnLock(HEAP32[$2 + 156 >> 2]);
            block7 : {
             if (HEAP8[$2 + 79 | 0] & 1) {
              break block7
             }
             if (!(jsvIsArrayBuffer(HEAP32[$2 + 172 >> 2]) & 1)) {
              break block7
             }
             HEAPF64[$2 + 64 >> 3] = jsvGetFloat(HEAP32[$2 + 204 >> 2]);
             block8 : {
              if (!(HEAPF64[$2 + 64 >> 3] >= 0.0) | HEAPF64[$2 + 64 >> 3] != Math_floor(HEAPF64[$2 + 64 >> 3])) {
               break block8
              }
              if (!(HEAPF64[$2 + 64 >> 3] < +(jsvGetArrayBufferLength(HEAP32[$2 + 172 >> 2]) >>> 0))) {
               break block8
              }
              HEAP8[$2 + 79 | 0] = 1;
             }
            }
            jsvUnLock(HEAP32[$2 + 204 >> 2]);
            HEAP32[$2 + 204 >> 2] = jsvNewFromBool(HEAP8[$2 + 79 | 0] & 1);
            break block9;
           }
           HEAP32[$2 >> 2] = HEAP32[$2 + 172 >> 2];
           jsExceptionHere(1, 6591, $2);
           jsvUnLock(HEAP32[$2 + 204 >> 2]);
           HEAP32[$2 + 204 >> 2] = 0;
          }
         }
         jsvUnLock(HEAP32[$2 + 172 >> 2]);
         break block10;
        }
        block14 : {
         if (HEAP32[$2 + 192 >> 2] == 186) {
          HEAP8[$2 + 63 | 0] = 0;
          HEAP32[$2 + 56 >> 2] = jsvSkipName(HEAP32[$2 + 176 >> 2]);
          block11 : {
           if (!(jsvIsFunction(HEAP32[$2 + 56 >> 2]) & 1)) {
            HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 56 >> 2];
            jsExceptionHere(1, 6218, $2 + 16 | 0);
            break block11;
           }
           block12 : {
            if (!(jsvIsObject(HEAP32[$2 + 204 >> 2]) & 1)) {
             if (!(jsvIsFunction(HEAP32[$2 + 204 >> 2]) & 1)) {
              break block12
             }
            }
            HEAP32[$2 + 52 >> 2] = jspGetNamedField(HEAP32[$2 + 56 >> 2], 17727, 0);
            HEAP32[$2 + 48 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 204 >> 2], 20670);
            while (1) {
             if (jsvHasChildren(HEAP32[$2 + 48 >> 2]) & 1) {
              if (HEAP32[$2 + 48 >> 2] == HEAP32[$2 + 52 >> 2]) {
               HEAP8[$2 + 63 | 0] = 1
              }
              HEAP32[$2 + 44 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 48 >> 2], 20670);
              jsvUnLock(HEAP32[$2 + 48 >> 2]);
              HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 44 >> 2];
              continue;
             }
             break;
            };
            if (jspIsConstructor(HEAP32[$2 + 56 >> 2], 5005) & 1) {
             HEAP8[$2 + 63 | 0] = 1
            }
            jsvUnLock2(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 48 >> 2]);
           }
           if (!(HEAP8[$2 + 63 | 0] & 1)) {
            HEAP32[$2 + 40 >> 2] = jswGetBasicObjectName(HEAP32[$2 + 204 >> 2]);
            if (HEAP32[$2 + 40 >> 2]) {
             HEAP8[$2 + 63 | 0] = jspIsConstructor(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 40 >> 2]) & 1
            }
            block13 : {
             if (HEAP8[$2 + 63 | 0] & 1) {
              break block13
             }
             if (!(jsvIsArray(HEAP32[$2 + 204 >> 2]) & 1)) {
              if (!(jsvIsArrayBuffer(HEAP32[$2 + 204 >> 2]) & 1)) {
               break block13
              }
             }
             if (!(jspIsConstructor(HEAP32[$2 + 56 >> 2], 5005) & 1)) {
              break block13
             }
             HEAP8[$2 + 63 | 0] = 1;
            }
           }
          }
          jsvUnLock2(HEAP32[$2 + 204 >> 2], HEAP32[$2 + 56 >> 2]);
          HEAP32[$2 + 204 >> 2] = jsvNewFromBool(HEAP8[$2 + 63 | 0] & 1);
          break block14;
         }
         HEAP32[$2 + 36 >> 2] = jsvSkipName(HEAP32[$2 + 176 >> 2]);
         HEAP32[$2 + 32 >> 2] = jsvGetValueOfAndUnLock(HEAP32[$2 + 204 >> 2]);
         HEAP32[$2 + 28 >> 2] = jsvGetValueOfAndUnLock(HEAP32[$2 + 36 >> 2]);
         HEAP32[$2 + 24 >> 2] = jsvMathsOp(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 192 >> 2]);
         jsvUnLock2(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2]);
         HEAP32[$2 + 204 >> 2] = HEAP32[$2 + 24 >> 2];
        }
       }
      }
      jsvUnLock(HEAP32[$2 + 176 >> 2]);
     }
    }
    HEAP32[$2 + 196 >> 2] = jspeGetBinaryExpressionPrecedence(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16);
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 208 | 0;
  return HEAP32[$2 + 204 >> 2];
 }
 
 function jspIsConstructor($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], HEAP32[$2 + 20 >> 2]);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP8[$2 + 31 | 0] = 0;
    break block;
   }
   HEAP8[$2 + 15 | 0] = HEAP32[$2 + 16 >> 2] == HEAP32[$2 + 24 >> 2];
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP8[$2 + 31 | 0] = HEAP8[$2 + 15 | 0] & 1;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP8[$2 + 31 | 0] & 1;
 }
 
 function jspeBinaryExpression() {
  return __jspeBinaryExpression(jspeUnaryExpression(), 0);
 }
 
 function __jspeConditionalExpression($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 63) {
    jslGetNextToken();
    block1 : {
     if ((HEAP32[103315] & 63) != 1) {
      jsvUnLock(jspeAssignmentExpression());
      if (!(jslMatch(58) & 1)) {
       HEAP32[$1 + 28 >> 2] = 0;
       break block;
      }
      jsvUnLock(jspeAssignmentExpression());
      break block1;
     }
     HEAP8[$1 + 23 | 0] = jsvGetBoolAndUnLock(jsvGetValueOfAndUnLock(jsvSkipName(HEAP32[$1 + 24 >> 2]))) & 1;
     jsvUnLock(HEAP32[$1 + 24 >> 2]);
     block2 : {
      if (HEAP8[$1 + 23 | 0] & 1) {
       HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
       if (!(jslMatch(58) & 1)) {
        HEAP32[$1 + 28 >> 2] = 0;
        break block;
       }
       HEAP32[$1 + 16 >> 2] = HEAP32[103315];
       jspSetNoExecute();
       jsvUnLock(jspeAssignmentExpression());
       HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$1 + 16 >> 2] & 1663;
       break block2;
      }
      HEAP32[$1 + 12 >> 2] = HEAP32[103315];
      jspSetNoExecute();
      jsvUnLock(jspeAssignmentExpression());
      HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$1 + 12 >> 2] & 1663;
      if (!(jslMatch(58) & 1)) {
       HEAP32[$1 + 28 >> 2] = 0;
       break block;
      }
      HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
     }
    }
   }
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 24 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jspeConditionalExpression() {
  return __jspeConditionalExpression(jspeBinaryExpression());
 }
 
 function __jspeAssignmentExpression($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  block1 : {
   block : {
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 61 | HEAPU16[HEAP32[61300] + 2 >> 1] == 150 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 151 | HEAPU16[HEAP32[61300] + 2 >> 1] == 154)) {
     break block
    }
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 155 | HEAPU16[HEAP32[61300] + 2 >> 1] == 156 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 157 | HEAPU16[HEAP32[61300] + 2 >> 1] == 159)) {
     break block
    }
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 161 | HEAPU16[HEAP32[61300] + 2 >> 1] == 148 | HEAPU16[HEAP32[61300] + 2 >> 1] == 144) {
     break block
    }
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 149) {
     break block1
    }
   }
   HEAP32[$1 + 20 >> 2] = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16;
   jslGetNextToken();
   HEAP32[$1 + 24 >> 2] = jspeAssignmentExpression();
   HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 24 >> 2]);
   if (!(!HEAP32[$1 + 28 >> 2] | (HEAP32[103315] & 63) != 1)) {
    block3 : {
     if (HEAP32[$1 + 20 >> 2] == 61) {
      jsvReplaceWithOrAddToRoot(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2]);
      break block3;
     }
     block4 : {
      if (HEAP32[$1 + 20 >> 2] == 150) {
       HEAP32[$1 + 20 >> 2] = 43;
       break block4;
      }
      block5 : {
       if (HEAP32[$1 + 20 >> 2] == 151) {
        HEAP32[$1 + 20 >> 2] = 45;
        break block5;
       }
       block6 : {
        if (HEAP32[$1 + 20 >> 2] == 154) {
         HEAP32[$1 + 20 >> 2] = 42;
         break block6;
        }
        block7 : {
         if (HEAP32[$1 + 20 >> 2] == 155) {
          HEAP32[$1 + 20 >> 2] = 47;
          break block7;
         }
         block8 : {
          if (HEAP32[$1 + 20 >> 2] == 156) {
           HEAP32[$1 + 20 >> 2] = 37;
           break block8;
          }
          block9 : {
           if (HEAP32[$1 + 20 >> 2] == 157) {
            HEAP32[$1 + 20 >> 2] = 38;
            break block9;
           }
           block10 : {
            if (HEAP32[$1 + 20 >> 2] == 159) {
             HEAP32[$1 + 20 >> 2] = 124;
             break block10;
            }
            block11 : {
             if (HEAP32[$1 + 20 >> 2] == 161) {
              HEAP32[$1 + 20 >> 2] = 94;
              break block11;
             }
             block12 : {
              if (HEAP32[$1 + 20 >> 2] == 148) {
               HEAP32[$1 + 20 >> 2] = 146;
               break block12;
              }
              block13 : {
               if (HEAP32[$1 + 20 >> 2] == 144) {
                HEAP32[$1 + 20 >> 2] = 143;
                break block13;
               }
               if (HEAP32[$1 + 20 >> 2] == 149) {
                HEAP32[$1 + 20 >> 2] = 147
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
     block14 : {
      if (HEAP32[$1 + 20 >> 2] != 43) {
       break block14
      }
      if (!(jsvIsName(HEAP32[$1 + 28 >> 2]) & 1)) {
       break block14
      }
      HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 28 >> 2]);
      block15 : {
       if (!(jsvIsBasicString(HEAP32[$1 + 16 >> 2]) & 1)) {
        break block15
       }
       if ((jsvGetRefs(HEAP32[$1 + 16 >> 2]) & 65535) != 1 | HEAP32[$1 + 24 >> 2] == HEAP32[$1 + 16 >> 2]) {
        break block15
       }
       HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
       jsvAppendStringVarComplete(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
       jsvUnLock(HEAP32[$1 + 12 >> 2]);
       HEAP32[$1 + 20 >> 2] = 0;
      }
      jsvUnLock(HEAP32[$1 + 16 >> 2]);
     }
     if (HEAP32[$1 + 20 >> 2]) {
      HEAP32[$1 + 8 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2]);
      jsvReplaceWith(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 8 >> 2]);
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
     }
    }
   }
   jsvUnLock(HEAP32[$1 + 24 >> 2]);
   HEAP32[$1 + 28 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 28 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jspeSkipBlock() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 1;
  HEAP32[$0 + 8 >> 2] = HEAP32[103315];
  HEAP32[103315] = HEAP32[103315] & -64;
  while (1) {
   $1 = 0;
   block : {
    $1 = HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16 ? HEAP32[$0 + 12 >> 2] != 0 : $1;
    if (!$1) {
     break block
    }
    block1 : {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 123) {
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
      break block1;
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 125) {
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] - 1;
      if (!HEAP32[$0 + 12 >> 2]) {
       break block
      }
     }
    }
    jslGetNextToken();
    continue;
   }
   break;
  };
  HEAP32[103315] = HEAP32[$0 + 8 >> 2];
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jspeBlockStart() {
  var $0 = 0;
  HEAP8[413248] = HEAPU8[413248] + 1;
  $0 = __stack_pointer - 16 | 0;
  HEAP32[$0 + 12 >> 2] = HEAP32[103311];
  HEAP32[103311] = 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeBlockEnd($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[103311]) {
   jspeiRemoveScope();
   jsvUnLock(HEAP32[103311]);
   HEAP32[103311] = 0;
  }
  HEAP32[103311] = HEAP32[$1 + 12 >> 2];
  HEAP8[413248] = HEAPU8[413248] - 1;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jspeStatement() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  if (HEAP32[103315] & 128) {
   jstRunInterruptingJS()
  }
  block2 : {
   block1 : {
    block : {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 128 | HEAPU16[HEAP32[61300] + 2 >> 1] == 129 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 130 | HEAPU16[HEAP32[61300] + 2 >> 1] == 131)) {
      break block
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 133 | HEAPU16[HEAP32[61300] + 2 >> 1] == 135 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 184 | HEAPU16[HEAP32[61300] + 2 >> 1] == 182)) {
      break block
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 183 | HEAPU16[HEAP32[61300] + 2 >> 1] == 180 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 181 | HEAPU16[HEAP32[61300] + 2 >> 1] == 175)) {
      break block
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 190 | HEAPU16[HEAP32[61300] + 2 >> 1] == 191 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 192 | HEAPU16[HEAP32[61300] + 2 >> 1] == 196)) {
      break block
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 152 | HEAPU16[HEAP32[61300] + 2 >> 1] == 153 | (HEAPU16[HEAP32[61300] + 2 >> 1] == 33 | HEAPU16[HEAP32[61300] + 2 >> 1] == 45)) {
      break block
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 43 | HEAPU16[HEAP32[61300] + 2 >> 1] == 126 | HEAPU16[HEAP32[61300] + 2 >> 1] == 91) {
      break block
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 40) {
      break block1
     }
    }
    HEAP32[$0 + 12 >> 2] = jspeExpression();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 123) {
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$0 + 12 >> 2] = 0;
     break block2;
    }
    jspeBlock();
    HEAP32[$0 + 12 >> 2] = 0;
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 59) {
    jslGetNextToken();
    HEAP32[$0 + 12 >> 2] = 0;
    break block2;
   }
   if (!(!(HEAPU16[HEAP32[61300] + 2 >> 1] == 172 | HEAPU16[HEAP32[61300] + 2 >> 1] == 173) & HEAPU16[HEAP32[61300] + 2 >> 1] != 174)) {
    HEAP32[$0 + 12 >> 2] = jspeStatementVar();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 163) {
    HEAP32[$0 + 12 >> 2] = jspeStatementIf();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 165) {
    HEAP32[$0 + 12 >> 2] = jspeStatementDoOrWhile(0);
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 166) {
    HEAP32[$0 + 12 >> 2] = jspeStatementDoOrWhile(1);
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 167) {
    HEAP32[$0 + 12 >> 2] = jspeStatementFor();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 177) {
    HEAP32[$0 + 12 >> 2] = jspeStatementTry();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 171) {
    HEAP32[$0 + 12 >> 2] = jspeStatementReturn();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 176) {
    HEAP32[$0 + 12 >> 2] = jspeStatementThrow();
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 170) {
    HEAP32[$0 + 12 >> 2] = jspeStatementFunctionDecl(0);
    break block2;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 194) {
    HEAP32[$0 + 12 >> 2] = jspeStatementFunctionDecl(1);
    break block2;
   }
   block6 : {
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 169) {
     jslGetNextToken();
     if ((HEAP32[103315] & 63) == 1) {
      block5 : {
       if (!(HEAP32[103315] & 512)) {
        jsExceptionHere(2, 14908, 0);
        break block5;
       }
       HEAP32[103315] = HEAP32[103315] & -64 | 4;
      }
     }
     break block6;
    }
    block8 : {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 168) {
      jslGetNextToken();
      if ((HEAP32[103315] & 63) == 1) {
       block7 : {
        if (!(HEAP32[103315] & 1536)) {
         jsExceptionHere(2, 14956, 0);
         break block7;
        }
        HEAP32[103315] = HEAP32[103315] & -64 | 2;
       }
      }
      break block8;
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 187) {
      HEAP32[$0 + 12 >> 2] = jspeStatementSwitch();
      break block2;
     }
     block9 : {
      if (HEAPU16[HEAP32[61300] + 2 >> 1] == 193) {
       jslGetNextToken();
       break block9;
      }
      if (!(jslMatch(0) & 1)) {
       HEAP32[$0 + 12 >> 2] = 0;
       break block2;
      }
     }
    }
   }
   HEAP32[$0 + 12 >> 2] = 0;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeBlockOrStatement() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 123) {
    jspeBlock();
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 8 >> 2] = jspeStatement();
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspParse() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   $1 = 0;
   $1 = HEAP32[103315] & 80 ? $1 : HEAPU16[HEAP32[61300] + 2 >> 1] != 0;
   if ($1) {
    jsvUnLock(HEAP32[$0 + 12 >> 2]);
    HEAP32[$0 + 12 >> 2] = jspeBlockOrStatement();
    while (1) {
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 59) {
      jslGetNextToken();
      continue;
     }
     break;
    };
    jsvCheckReferenceError(HEAP32[$0 + 12 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jspeStatementVar() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 24 >> 2] = 0;
  block : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] != 173) {
    $1 = 0;
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 174) {
     break block
    }
   }
   $1 = HEAPU8[413248] != 0;
  }
  HEAP8[$0 + 23 | 0] = $1;
  HEAP8[$0 + 22 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 174;
  jslGetNextToken();
  HEAP8[$0 + 21 | 0] = 1;
  while (1) {
   $1 = 0;
   block1 : {
    if (!(HEAP8[$0 + 21 | 0] & 1)) {
     break block1
    }
    $1 = 0;
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 128) {
     break block1
    }
    $1 = jspIsInterrupted() ^ -1;
   }
   if ($1 & 1) {
    block3 : {
     HEAP32[$0 + 16 >> 2] = 0;
     if ((HEAP32[103315] & 63) == 1) {
      HEAP32[$0 + 12 >> 2] = jslGetTokenValueAsString();
      block2 : {
       if (HEAP8[$0 + 23 | 0] & 1) {
        if (!HEAP32[103311]) {
         HEAP32[103311] = jsvNewObject();
         jspeiAddScope(HEAP32[103311]);
        }
        HEAP32[$0 + 16 >> 2] = jsvFindOrAddChildFromString(HEAP32[103311], HEAP32[$0 + 12 >> 2]);
        break block2;
       }
       HEAP32[$0 + 16 >> 2] = jsvFindOrAddChildFromString(HEAP32[103310], HEAP32[$0 + 12 >> 2]);
      }
      if (!HEAP32[$0 + 16 >> 2]) {
       jspSetError();
       break block3;
      }
     }
     if (!(jslMatch(128) & 1)) {
      jsvUnLock(HEAP32[$0 + 16 >> 2]);
      break block3;
     }
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 61) {
      if (!(jslMatch(61) & 1)) {
       jsvUnLock(HEAP32[$0 + 16 >> 2]);
       break block3;
      }
      HEAP32[$0 + 8 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
      if ((HEAP32[103315] & 63) == 1) {
       jsvReplaceWith(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 8 >> 2])
      }
      jsvUnLock(HEAP32[$0 + 8 >> 2]);
     }
     if (HEAP8[$0 + 22 | 0] & 1 & (HEAP32[103315] & 63) == 1) {
      $2 = HEAP32[$0 + 16 >> 2];
      $1 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | 64;
      HEAP8[$2 + 12 | 0] = $1;
      HEAP8[$2 + 13 | 0] = $1 >>> 8;
     }
     jsvUnLock(HEAP32[$0 + 24 >> 2]);
     HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
     HEAP8[$0 + 21 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 44;
     if (HEAP8[$0 + 21 | 0] & 1) {
      if (!(jslMatch(44) & 1)) {
       break block3
      }
     }
     continue;
    }
   }
   break;
  };
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
  __stack_pointer = $0 + 32 | 0;
  return HEAP32[$0 + 28 >> 2];
 }
 
 function jspeStatementIf() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 48 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 32 >> 2] = 0;
  jslGetNextToken();
  block : {
   if (!(jslMatch(40) & 1)) {
    HEAP32[$0 + 44 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 36 >> 2] = jspeExpression();
   if (HEAP32[103315] & 80) {
    HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 36 >> 2];
    break block;
   }
   if (!(jslMatch(41) & 1)) {
    HEAP32[$0 + 44 >> 2] = 0;
    break block;
   }
   if ((HEAP32[103315] & 63) == 1) {
    $1 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 36 >> 2]))
   }
   HEAP8[$0 + 43 | 0] = $1 & 1;
   jsvUnLock(HEAP32[$0 + 36 >> 2]);
   HEAP32[$0 + 28 >> 2] = HEAP32[103315];
   if (!(HEAP8[$0 + 43 | 0] & 1)) {
    jspSetNoExecute()
   }
   HEAP32[$0 + 24 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   if (HEAPU16[HEAP32[61300] + 2 >> 1] != 59) {
    HEAP32[$0 + 20 >> 2] = jspeBlockOrStatement()
   }
   HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | HEAP32[103315] & 112;
   block1 : {
    if (!(HEAP8[$0 + 43 | 0] & 1)) {
     jsvUnLock(HEAP32[$0 + 20 >> 2]);
     HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 28 >> 2] & 1663;
     HEAP32[103315] = HEAP32[$0 + 24 >> 2] | HEAP32[103315];
     break block1;
    }
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 20 >> 2];
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 59) {
    jslGetNextToken()
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 164) {
    jslGetNextToken();
    HEAP32[$0 + 16 >> 2] = HEAP32[103315];
    if (HEAP8[$0 + 43 | 0] & 1) {
     jspSetNoExecute()
    }
    HEAP32[$0 + 12 >> 2] = 0;
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 59) {
     HEAP32[$0 + 12 >> 2] = jspeBlockOrStatement()
    }
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | HEAP32[103315] & 112;
    block2 : {
     if (HEAP8[$0 + 43 | 0] & 1) {
      jsvUnLock(HEAP32[$0 + 12 >> 2]);
      HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 16 >> 2] & 1663;
      HEAP32[103315] = HEAP32[$0 + 24 >> 2] | HEAP32[103315];
      break block2;
     }
     HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 12 >> 2];
    }
   }
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 32 >> 2];
  }
  __stack_pointer = $0 + 48 | 0;
  return HEAP32[$0 + 44 >> 2];
 }
 
 function jspeStatementSwitch() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 48 | 0;
  __stack_pointer = $0;
  jslGetNextToken();
  block : {
   if (!(jslMatch(40) & 1)) {
    break block
   }
   HEAP32[$0 + 40 >> 2] = jspeExpression();
   HEAP32[$0 + 36 >> 2] = HEAP32[103315] & 512;
   HEAP32[$0 + 32 >> 2] = HEAP32[103315];
   HEAP8[$0 + 31 | 0] = (HEAP32[103315] & 63) == 1;
   if (!(jslMatch(41) & 1)) {
    jsvUnLock(HEAP32[$0 + 40 >> 2]);
    break block;
   }
   if (!(HEAP8[$0 + 31 | 0] & 1)) {
    jsvUnLock(HEAP32[$0 + 40 >> 2]);
    jspeBlock();
    break block;
   }
   if (!(jslMatch(123) & 1)) {
    jsvUnLock(HEAP32[$0 + 40 >> 2]);
    break block;
   }
   HEAP8[$0 + 30 | 0] = 1;
   if (HEAP8[$0 + 31 | 0] & 1) {
    HEAP32[103315] = HEAP32[$0 + 36 >> 2] | 1024
   }
   while (1) {
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 188) {
     HEAP32[$0 + 24 >> 2] = HEAP32[103315];
     if (HEAP8[$0 + 31 | 0] & 1) {
      HEAP32[103315] = HEAP32[$0 + 36 >> 2] | 1025
     }
     if (!(jslMatch(188) & 1)) {
      jsvUnLock(HEAP32[$0 + 40 >> 2]);
      break block;
     }
     HEAP32[$0 + 20 >> 2] = jspeAssignmentExpression();
     HEAP32[103315] = HEAP32[$0 + 24 >> 2] | 1024;
     if (!(jslMatch(58) & 1)) {
      jsvUnLock2(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 20 >> 2]);
      break block;
     }
     HEAP8[$0 + 19 | 0] = 0;
     if (HEAP8[$0 + 31 | 0] & 1) {
      HEAP8[$0 + 19 | 0] = jsvGetBoolAndUnLock(jsvMathsOpSkipNames(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 20 >> 2], 139)) & 1
     }
     if (HEAP8[$0 + 19 | 0] & 1) {
      HEAP8[$0 + 30 | 0] = 0
     }
     jsvUnLock(HEAP32[$0 + 20 >> 2]);
     if (!(!(HEAP8[$0 + 19 | 0] & 1) | HEAP32[103315] & 63)) {
      HEAP32[103315] = HEAP32[$0 + 36 >> 2] | 1025
     }
     while (1) {
      $1 = 0;
      block2 : {
       if (HEAP32[103315] & 80) {
        break block2
       }
       $1 = 0;
       if (!HEAPU16[HEAP32[61300] + 2 >> 1]) {
        break block2
       }
       $1 = 0;
       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 188) {
        break block2
       }
       $1 = 0;
       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 189) {
        break block2
       }
       $1 = HEAPU16[HEAP32[61300] + 2 >> 1] != 125;
      }
      if ($1) {
       jsvUnLock(jspeBlockOrStatement());
       continue;
      }
      break;
     };
     HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] | HEAP32[103315] & 124;
     continue;
    }
    break;
   };
   jsvUnLock(HEAP32[$0 + 40 >> 2]);
   block4 : {
    if (!(!(HEAP8[$0 + 31 | 0] & 1) | (HEAP32[103315] & 63) != 2)) {
     HEAP32[103315] = HEAP32[$0 + 36 >> 2] | 1025;
     break block4;
    }
    HEAP8[$0 + 30 | 0] = 1;
   }
   HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 32 >> 2] & 1663;
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 189) {
    jslGetNextToken();
    if (!(jslMatch(58) & 1)) {
     break block
    }
    HEAP32[$0 + 12 >> 2] = HEAP32[103315];
    block5 : {
     if (!(HEAP8[$0 + 30 | 0] & 1)) {
      jspSetNoExecute();
      break block5;
     }
     HEAP32[103315] = HEAP32[103315] | 1024;
    }
    while (1) {
     $1 = 0;
     block6 : {
      if (HEAP32[103315] & 80) {
       break block6
      }
      $1 = 0;
      if (!HEAPU16[HEAP32[61300] + 2 >> 1]) {
       break block6
      }
      $1 = 0;
      if (HEAPU16[HEAP32[61300] + 2 >> 1] == 125) {
       break block6
      }
      $1 = HEAPU16[HEAP32[61300] + 2 >> 1] != 188;
     }
     if ($1) {
      jsvUnLock(jspeBlockOrStatement());
      continue;
     }
     break;
    };
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] | HEAP32[103315] & 124;
    HEAP32[103315] = HEAP32[103315] & -3;
    HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 12 >> 2] & 1663;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 188) {
    jsExceptionHere(2, 18746, 0);
    break block;
   }
   jslMatch(125);
  }
  HEAP32[$0 + 44 >> 2] = 0;
  __stack_pointer = $0 + 48 | 0;
  return HEAP32[$0 + 44 >> 2];
 }
 
 function jspeStatementDoOrWhile($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  $1 = __stack_pointer - 176 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 171 | 0] = $0;
  HEAP8[$1 + 163 | 0] = 1;
  HEAP8[$1 + 162 | 0] = 0;
  HEAP8[$1 + 115 | 0] = (HEAP32[103315] & 512) != 0;
  block : {
   block1 : {
    if (HEAP8[$1 + 171 | 0] & 1) {
     jslGetNextToken();
     jslCharPosFromLex($1 + 116 | 0);
     if (!(jslMatch(40) & 1)) {
      jslCharPosFree($1 + 116 | 0);
      break block;
     }
     HEAP32[$1 + 164 >> 2] = jspeExpression();
     if ((HEAP32[103315] & 63) == 1) {
      $3 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 164 >> 2]))
     }
     HEAP8[$1 + 163 | 0] = $3 & 1;
     jsvUnLock(HEAP32[$1 + 164 >> 2]);
     jslCharPosFromLex($1 + 68 | 0);
     if (!(jslMatch(41) & 1)) {
      jslCharPosFree($1 + 68 | 0);
      jslCharPosFree($1 + 116 | 0);
      break block;
     }
     break block1;
    }
    jslCharPosFromLex($1 + 68 | 0);
    if (!(jslMatch(165) & 1)) {
     jslCharPosFree($1 + 68 | 0);
     break block;
    }
    jslCharPosClear($1 + 116 | 0);
   }
   HEAP32[$1 + 64 >> 2] = HEAP32[103315];
   if (!(HEAP8[$1 + 163 | 0] & 1)) {
    jspSetNoExecute()
   }
   HEAP32[103315] = HEAP32[103315] | 512;
   $2 = HEAP8[$1 + 171 | 0] & 1 ? $2 : HEAPU16[HEAP32[61300] + 2 >> 1] != 123;
   HEAP8[$1 + 63 | 0] = $2;
   jsvUnLock(jspeBlockOrStatement());
   if (HEAP8[$1 + 63 | 0] & 1) {
    if (!(jslMatch(59) & 1)) {
     jslCharPosFree($1 + 68 | 0);
     jslCharPosFree($1 + 116 | 0);
     break block;
    }
   }
   if (!(HEAP8[$1 + 115 | 0] & 1)) {
    HEAP32[103315] = HEAP32[103315] & -513
   }
   HEAP8[$1 + 162 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$1 + 162 | 0] & 1;
   if (!(HEAP8[$1 + 163 | 0] & 1)) {
    HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$1 + 64 >> 2] & 1663
   }
   if (!(HEAP8[$1 + 171 | 0] & 1)) {
    if (!(jslMatch(166) & 1)) {
     jslCharPosFree($1 + 68 | 0);
     break block;
    }
    jslCharPosFromLex($1 + 116 | 0);
    if (!(jslMatch(40) & 1)) {
     jslCharPosFree($1 + 68 | 0);
     jslCharPosFree($1 + 116 | 0);
     break block;
    }
    HEAP32[$1 + 164 >> 2] = jspeExpression();
    if ((HEAP32[103315] & 63) == 1) {
     $4 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 164 >> 2]))
    }
    HEAP8[$1 + 163 | 0] = $4 & 1;
    jsvUnLock(HEAP32[$1 + 164 >> 2]);
    if (!(jslMatch(41) & 1)) {
     jslCharPosFree($1 + 68 | 0);
     jslCharPosFree($1 + 116 | 0);
     break block;
    }
   }
   jslCharPosNew($1 + 16 | 0, HEAP32[HEAP32[61300] + 84 >> 2], HEAP32[HEAP32[61300] + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = 0;
   while (1) {
    $0 = 0;
    $0 = HEAP8[$1 + 162 | 0] & 1 ? $0 : HEAPU8[$1 + 163 | 0];
    if ($0 & 1) {
     if (HEAP8[$1 + 171 | 0] & 1 | HEAP32[$1 + 12 >> 2]) {
      jslSeekToP($1 + 116 | 0);
      HEAP32[$1 + 164 >> 2] = jspeExpression();
      $0 = 0;
      if ((HEAP32[103315] & 63) == 1) {
       $0 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 164 >> 2]))
      }
      HEAP8[$1 + 163 | 0] = $0 & 1;
      jsvUnLock(HEAP32[$1 + 164 >> 2]);
     }
     if (HEAP8[$1 + 163 | 0] & 1) {
      jslSeekToP($1 + 68 | 0);
      HEAP32[103315] = HEAP32[103315] | 512;
      jspDebuggerLoopIfCtrlC();
      jsvUnLock(jspeBlockOrStatement());
      if (!(HEAP8[$1 + 115 | 0] & 1)) {
       HEAP32[103315] = HEAP32[103315] & -513
      }
      HEAP8[$1 + 162 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$1 + 162 | 0] & 1;
     }
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   jslSeekToP($1 + 16 | 0);
   jslCharPosFree($1 + 116 | 0);
   jslCharPosFree($1 + 68 | 0);
   jslCharPosFree($1 + 16 | 0);
  }
  HEAP32[$1 + 172 >> 2] = 0;
  __stack_pointer = $1 + 176 | 0;
  return HEAP32[$1 + 172 >> 2];
 }
 
 function jspeCheckBreakContinue() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  block1 : {
   block : {
    if (HEAP32[103315] & 4) {
     HEAP32[103315] = HEAP32[103315] & -64 | 1;
     break block;
    }
    if (HEAP32[103315] & 2) {
     HEAP32[103315] = HEAP32[103315] & -64 | 1;
     HEAP8[$0 + 15 | 0] = 1;
     break block1;
    }
   }
   HEAP8[$0 + 15 | 0] = 0;
  }
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function jspGetBuiltinPrototype($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 4 >> 2] = jspFindPrototypeFor(3797);
    if (HEAP32[$1 + 4 >> 2]) {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
     break block;
    }
   }
   block1 : {
    if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
     if (!(jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1)) {
      break block1
     }
    }
    HEAP32[$1 >> 2] = jspFindPrototypeFor(5005);
    if (HEAP32[$1 >> 2] == HEAP32[$1 + 8 >> 2]) {
     jsvUnLock(HEAP32[$1 >> 2]);
     HEAP32[$1 >> 2] = 0;
    }
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jspeStatementFor() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 432 | 0;
  __stack_pointer = $0;
  jslGetNextToken();
  block : {
   if (!(jslMatch(40) & 1)) {
    break block
   }
   HEAP8[$0 + 427 | 0] = (HEAP32[103315] & 512) != 0;
   HEAP32[103315] = HEAP32[103315] | 256;
   HEAP32[$0 + 420 >> 2] = jspeBlockStart();
   HEAP32[$0 + 416 >> 2] = 0;
   HEAP8[$0 + 415 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 174;
   if (HEAPU16[HEAP32[61300] + 2 >> 1] != 59) {
    HEAP32[$0 + 416 >> 2] = jspeStatement()
   }
   if (jspIsInterrupted() & 1) {
    jsvUnLock(HEAP32[$0 + 416 >> 2]);
    jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
    break block;
   }
   HEAP32[103315] = HEAP32[103315] & -257;
   block10 : {
    if (!(HEAPU16[HEAP32[61300] + 2 >> 1] != 185 & HEAPU16[HEAP32[61300] + 2 >> 1] != 198)) {
     HEAP8[$0 + 414 | 0] = HEAPU16[HEAP32[61300] + 2 >> 1] == 198;
     block2 : {
      if ((HEAP32[103315] & 63) != 1) {
       break block2
      }
      if (jsvIsName(HEAP32[$0 + 416 >> 2]) & 1) {
       break block2
      }
      jsvUnLock(HEAP32[$0 + 416 >> 2]);
      $1 = HEAP8[$0 + 414 | 0] & 1;
      HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 416 >> 2];
      HEAP32[$0 + 16 >> 2] = $1 ? 17091 : 15533;
      jsExceptionHere(1, 5215, $0 + 16 | 0);
      jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
      break block;
     }
     jslGetNextToken();
     HEAP32[$0 + 408 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
     jslCharPosFromLex($0 + 364 | 0);
     if (!(jslMatch(41) & 1)) {
      jsvUnLock2(HEAP32[$0 + 416 >> 2], HEAP32[$0 + 408 >> 2]);
      jslCharPosFree($0 + 364 | 0);
      jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
      break block;
     }
     HEAP32[$0 + 360 >> 2] = HEAP32[103315];
     jspSetNoExecute();
     HEAP32[103315] = HEAP32[103315] | 512;
     jsvUnLock(jspeBlockOrStatement());
     jslCharPosNew($0 + 316 | 0, HEAP32[HEAP32[61300] + 84 >> 2], HEAP32[HEAP32[61300] + 4 >> 2]);
     if (!(HEAP8[$0 + 427 | 0] & 1)) {
      HEAP32[103315] = HEAP32[103315] & -513
     }
     HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 360 >> 2] & 1663;
     if ((HEAP32[103315] & 63) == 1) {
      block9 : {
       if (jsvIsIterable(HEAP32[$0 + 408 >> 2]) & 1) {
        HEAP32[$0 + 312 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$0 + 408 >> 2]);
        HEAP32[$0 + 308 >> 2] = 0;
        if (!(HEAP8[$0 + 414 | 0] & 1)) {
         HEAP32[$0 + 308 >> 2] = jspGetBuiltinPrototype(HEAP32[$0 + 408 >> 2])
        }
        jsvIteratorNew($0 + 244 | 0, HEAP32[$0 + 408 >> 2], HEAP8[$0 + 414 | 0] & 1);
        HEAP8[$0 + 243 | 0] = 0;
        while (1) {
         $1 = 0;
         block3 : {
          if ((HEAP32[103315] & 63) != 1) {
           break block3
          }
          $1 = 0;
          if (!(jsvIteratorHasElement($0 + 244 | 0) & 1)) {
           break block3
          }
          $1 = HEAPU8[$0 + 243 | 0] ^ -1;
         }
         if ($1 & 1) {
          HEAP32[$0 + 236 >> 2] = jsvIteratorGetKey($0 + 244 | 0);
          HEAP8[$0 + 235 | 0] = 0;
          block4 : {
           if (!HEAP32[$0 + 312 >> 2]) {
            break block4
           }
           if (!(FUNCTION_TABLE[HEAP32[$0 + 312 >> 2]](HEAP32[$0 + 236 >> 2]) & 1)) {
            break block4
           }
           HEAP8[$0 + 235 | 0] = 1;
           block5 : {
            if (HEAP8[$0 + 414 | 0] & 1) {
             break block5
            }
            if (!(jsvIsString(HEAP32[$0 + 236 >> 2]) & 1)) {
             break block5
            }
            if (!(jsvIsStringEqual(HEAP32[$0 + 236 >> 2], 20670) & 1)) {
             break block5
            }
            HEAP32[$0 + 308 >> 2] = jsvSkipName(HEAP32[$0 + 236 >> 2]);
           }
          }
          if (!(HEAP8[$0 + 235 | 0] & 1)) {
           block6 : {
            if (HEAP8[$0 + 414 | 0] & 1) {
             HEAP32[$0 + 228 >> 2] = jsvIteratorGetValue($0 + 244 | 0);
             break block6;
            }
            HEAP32[$0 + 228 >> 2] = jsvAsString(HEAP32[$0 + 236 >> 2]);
           }
           if (HEAP8[$0 + 414 | 0] & 1 | HEAP32[$0 + 228 >> 2]) {
            if (HEAP8[$0 + 415 | 0] & 1) {
             $1 = HEAP32[$0 + 416 >> 2];
             $2 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -65;
             HEAP8[$1 + 12 | 0] = $2;
             HEAP8[$1 + 13 | 0] = $2 >>> 8;
            }
            jsvReplaceWithOrAddToRoot(HEAP32[$0 + 416 >> 2], HEAP32[$0 + 228 >> 2]);
            if (HEAP8[$0 + 415 | 0] & 1) {
             $1 = HEAP32[$0 + 416 >> 2];
             $2 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | 64;
             HEAP8[$1 + 12 | 0] = $2;
             HEAP8[$1 + 13 | 0] = $2 >>> 8;
            }
            jsvUnLock(HEAP32[$0 + 228 >> 2]);
            jslSeekToP($0 + 364 | 0);
            HEAP32[103315] = HEAP32[103315] | 512;
            jspDebuggerLoopIfCtrlC();
            jsvUnLock(jspeBlockOrStatement());
            if (!(HEAP8[$0 + 427 | 0] & 1)) {
             HEAP32[103315] = HEAP32[103315] & -513
            }
            HEAP8[$0 + 243 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$0 + 243 | 0] & 1;
           }
          }
          jsvIteratorNext($0 + 244 | 0);
          jsvUnLock(HEAP32[$0 + 236 >> 2]);
          if (!(jsvIteratorHasElement($0 + 244 | 0) & 1 | HEAP8[$0 + 414 | 0] & 1 | !HEAP32[$0 + 308 >> 2])) {
           jsvIteratorFree($0 + 244 | 0);
           HEAP32[$0 + 224 >> 2] = HEAP32[$0 + 308 >> 2];
           jsvIteratorNew($0 + 244 | 0, HEAP32[$0 + 224 >> 2], 0);
           HEAP32[$0 + 312 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$0 + 224 >> 2]);
           HEAP32[$0 + 308 >> 2] = jspGetBuiltinPrototype(HEAP32[$0 + 224 >> 2]);
           jsvUnLock(HEAP32[$0 + 224 >> 2]);
          }
          continue;
         }
         break;
        };
        jsvUnLock(HEAP32[$0 + 308 >> 2]);
        jsvIteratorFree($0 + 244 | 0);
        break block9;
       }
       if (!(jsvIsUndefined(HEAP32[$0 + 408 >> 2]) & 1)) {
        HEAP32[$0 >> 2] = HEAP32[$0 + 408 >> 2];
        jsExceptionHere(1, 5149, $0);
       }
      }
     }
     jslSeekToP($0 + 316 | 0);
     jslCharPosFree($0 + 364 | 0);
     jslCharPosFree($0 + 316 | 0);
     jsvUnLock2(HEAP32[$0 + 416 >> 2], HEAP32[$0 + 408 >> 2]);
     break block10;
    }
    HEAP8[$0 + 223 | 0] = 1;
    HEAP8[$0 + 222 | 0] = 0;
    jsvUnLock(HEAP32[$0 + 416 >> 2]);
    jslCharPosFromLex($0 + 176 | 0);
    if (!(jslMatch(59) & 1)) {
     jslCharPosFree($0 + 176 | 0);
     jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
     jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
     break block;
    }
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 59) {
     HEAP32[$0 + 172 >> 2] = jspeExpression();
     if ((HEAP32[103315] & 63) == 1) {
      $1 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 172 >> 2]))
     }
     HEAP8[$0 + 223 | 0] = $1 & 1;
     jsvUnLock(HEAP32[$0 + 172 >> 2]);
    }
    jslCharPosFromLex($0 + 128 | 0);
    if (!(jslMatch(59) & 1)) {
     jslCharPosFree($0 + 176 | 0);
     jslCharPosFree($0 + 128 | 0);
     jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
     break block;
    }
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
     HEAP32[$0 + 124 >> 2] = HEAP32[103315];
     jspSetNoExecute();
     jsvUnLock(jspeExpression());
     HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 124 >> 2] & 1663;
    }
    jslSkipWhiteSpace();
    jslCharPosFromLex($0 + 80 | 0);
    if (!(jslMatch(41) & 1)) {
     jslCharPosFree($0 + 176 | 0);
     jslCharPosFree($0 + 128 | 0);
     jslCharPosFree($0 + 80 | 0);
     jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
     break block;
    }
    HEAP32[$0 + 76 >> 2] = HEAP32[103315];
    if (!(HEAP8[$0 + 223 | 0] & 1)) {
     jspSetNoExecute()
    }
    HEAP32[103315] = HEAP32[103315] | 512;
    jsvUnLock(jspeBlockOrStatement());
    jslSkipWhiteSpace();
    jslCharPosNew($0 + 32 | 0, HEAP32[HEAP32[61300] + 84 >> 2], HEAP32[HEAP32[61300] + 4 >> 2]);
    if (!(HEAP8[$0 + 427 | 0] & 1)) {
     HEAP32[103315] = HEAP32[103315] & -513
    }
    if (!(!(HEAP8[$0 + 223 | 0] & 1) & (HEAP32[103315] & 63) == 1)) {
     HEAP8[$0 + 222 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$0 + 222 | 0] & 1;
     if (HEAP8[$0 + 222 | 0] & 1) {
      HEAP8[$0 + 223 | 0] = 0
     }
    }
    if (!(HEAP8[$0 + 223 | 0] & 1)) {
     HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 76 >> 2] & 1663
    }
    if (HEAP8[$0 + 223 | 0] & 1) {
     jslSeekToP($0 + 128 | 0);
     if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
      jsvUnLock(jspeExpression())
     }
    }
    while (1) {
     $1 = 0;
     block12 : {
      if (HEAP8[$0 + 222 | 0] & 1) {
       break block12
      }
      $1 = 0;
      if ((HEAP32[103315] & 63) != 1) {
       break block12
      }
      $1 = HEAPU8[$0 + 223 | 0];
     }
     if ($1 & 1) {
      jslSeekToP($0 + 176 | 0);
      block13 : {
       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 59) {
        HEAP8[$0 + 223 | 0] = 1;
        break block13;
       }
       HEAP32[$0 + 28 >> 2] = jspeExpression();
       HEAP8[$0 + 223 | 0] = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 28 >> 2])) & 1;
       jsvUnLock(HEAP32[$0 + 28 >> 2]);
      }
      if (!(!(HEAP8[$0 + 223 | 0] & 1) | (HEAP32[103315] & 63) != 1)) {
       jslSeekToP($0 + 80 | 0);
       HEAP32[103315] = HEAP32[103315] | 512;
       jspDebuggerLoopIfCtrlC();
       jsvUnLock(jspeBlockOrStatement());
       if (!(HEAP8[$0 + 427 | 0] & 1)) {
        HEAP32[103315] = HEAP32[103315] & -513
       }
       HEAP8[$0 + 222 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$0 + 222 | 0] & 1;
      }
      if (!(HEAP8[$0 + 222 | 0] & 1 | (!(HEAP8[$0 + 223 | 0] & 1) | (HEAP32[103315] & 63) != 1))) {
       jslSeekToP($0 + 128 | 0);
       if (HEAPU16[HEAP32[61300] + 2 >> 1] != 41) {
        jsvUnLock(jspeExpression())
       }
      }
      continue;
     }
     break;
    };
    jslSeekToP($0 + 32 | 0);
    jslCharPosFree($0 + 176 | 0);
    jslCharPosFree($0 + 128 | 0);
    jslCharPosFree($0 + 80 | 0);
    jslCharPosFree($0 + 32 | 0);
   }
   jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
  }
  HEAP32[$0 + 428 >> 2] = 0;
  __stack_pointer = $0 + 432 | 0;
  return HEAP32[$0 + 428 >> 2];
 }
 
 function jspeStatementTry() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  jslGetNextToken();
  HEAP8[$0 + 27 | 0] = (HEAP32[103315] & 63) == 1;
  jspeBlock();
  $1 = HEAP8[$0 + 27 | 0] & 1 ? (HEAP32[103315] & 32) != 0 : $1;
  HEAP8[$0 + 26 | 0] = $1;
  HEAP8[$0 + 25 | 0] = 0;
  block1 : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 178) {
    jslGetNextToken();
    HEAP8[$0 + 25 | 0] = 1;
    HEAP32[$0 + 20 >> 2] = 0;
    HEAP32[$0 + 16 >> 2] = 0;
    block : {
     if (HEAP8[$0 + 27 | 0] & 1) {
      $1 = jspGetException();
      break block;
     }
     $1 = 0;
    }
    HEAP32[$0 + 12 >> 2] = $1;
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 40) {
     if (!(jslMatch(40) & 1)) {
      break block1
     }
     if (HEAP8[$0 + 26 | 0] & 1) {
      HEAP32[$0 + 16 >> 2] = jsvNewObject();
      if (HEAP32[$0 + 16 >> 2]) {
       HEAP32[$0 + 20 >> 2] = jsvFindOrAddChildFromString(HEAP32[$0 + 16 >> 2], jslGetTokenValueAsString())
      }
     }
     if (!(jslMatch(128) & 1)) {
      jsvUnLock2(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]);
      break block1;
     }
     if (!(jslMatch(41) & 1)) {
      jsvUnLock2(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]);
      break block1;
     }
     if (HEAP32[$0 + 20 >> 2]) {
      if (HEAP32[$0 + 12 >> 2]) {
       jsvSetValueOfName(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2])
      }
      jsvUnLock(HEAP32[$0 + 20 >> 2]);
     }
    }
    if (HEAP8[$0 + 27 | 0] & 1) {
     HEAP32[103315] = HEAP32[103315] & -33;
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
    }
    block3 : {
     if (!(!(HEAP8[$0 + 27 | 0] & 1) | HEAP8[$0 + 26 | 0] & 1)) {
      HEAP32[$0 + 8 >> 2] = HEAP32[103315];
      jspSetNoExecute();
      jspeBlock();
      HEAP32[103315] = HEAP32[103315] & -1664 | HEAP32[$0 + 8 >> 2] & 1663;
      break block3;
     }
     block4 : {
      if (HEAP32[$0 + 16 >> 2]) {
       if (!(jspeiAddScope(HEAP32[$0 + 16 >> 2]) & 1)) {
        break block4
       }
      }
      jspeBlock();
      if (HEAP32[$0 + 16 >> 2]) {
       jspeiRemoveScope()
      }
     }
    }
    jsvUnLock(HEAP32[$0 + 16 >> 2]);
   }
   block5 : {
    if (HEAPU16[HEAP32[61300] + 2 >> 1] != 179) {
     if (HEAP8[$0 + 25 | 0] & 1 | HEAP32[103315] & 80) {
      break block5
     }
    }
    if (!(jslMatch(179) & 1)) {
     break block1
    }
    HEAP32[$0 + 4 >> 2] = HEAP32[103315];
    if (HEAP8[$0 + 27 | 0] & 1) {
     HEAP32[103315] = HEAP32[103315] & -47 | 1
    }
    jspeBlock();
    HEAP32[103315] = HEAP32[$0 + 4 >> 2];
    if (!(!(HEAP8[$0 + 26 | 0] & 1) | HEAP8[$0 + 25 | 0] & 1)) {
     HEAP32[103315] = HEAP32[103315] | 32
    }
   }
  }
  HEAP32[$0 + 28 >> 2] = 0;
  __stack_pointer = $0 + 32 | 0;
  return HEAP32[$0 + 28 >> 2];
 }
 
 function jspeStatementReturn() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 0;
  jslGetNextToken();
  if (!(HEAPU16[HEAP32[61300] + 2 >> 1] == 59 | HEAPU16[HEAP32[61300] + 2 >> 1] == 125)) {
   HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspeExpression())
  }
  if ((HEAP32[103315] & 63) == 1) {
   HEAP32[$0 + 8 >> 2] = jspeiFindInScopes(15143);
   block1 : {
    if (HEAP32[$0 + 8 >> 2]) {
     jsvReplaceWith(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 12 >> 2]);
     jsvUnLock(HEAP32[$0 + 8 >> 2]);
     HEAP32[103315] = HEAP32[103315] | 8;
     break block1;
    }
    jsExceptionHere(2, 22707, 0);
   }
  }
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
  __stack_pointer = $0 + 16 | 0;
  return 0;
 }
 
 function jspeStatementThrow() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 0;
  jslGetNextToken();
  HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
  if ((HEAP32[103315] & 63) == 1) {
   jspSetException(HEAP32[$0 + 12 >> 2])
  }
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
  __stack_pointer = $0 + 16 | 0;
  return 0;
 }
 
 function jspeStatementFunctionDecl($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 27 | 0] = $0;
  HEAP32[$1 + 20 >> 2] = 0;
  jslGetNextToken();
  HEAP8[$1 + 15 | 0] = (HEAP32[103315] & 63) == 1;
  block : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    HEAP32[$1 + 20 >> 2] = jsvNewNameFromString(jslGetTokenValueAsString());
    if (!HEAP32[$1 + 20 >> 2]) {
     HEAP32[$1 + 28 >> 2] = 0;
     break block;
    }
   }
   if (!(jslMatch(128) & 1)) {
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   block1 : {
    if (HEAP8[$1 + 27 | 0] & 1) {
     $0 = jspeClassDefinition(0);
     break block1;
    }
    $0 = jspeFunctionDefinition(0);
   }
   HEAP32[$1 + 16 >> 2] = $0;
   if (HEAP8[$1 + 15 | 0] & 1) {
    HEAP32[$1 + 8 >> 2] = jsvFindChildFromVar(HEAP32[103310], HEAP32[$1 + 20 >> 2], 1);
    HEAP32[$1 + 4 >> 2] = jsvSkipName(HEAP32[$1 + 8 >> 2]);
    block2 : {
     if (jsvIsFunction(HEAP32[$1 + 4 >> 2]) & 1) {
      HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 16 >> 2]);
      jswrap_function_replaceWith(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 16 >> 2]);
      break block2;
     }
     jsvReplaceWith(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 16 >> 2]);
    }
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 8 >> 2];
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 16 >> 2]);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jspNewObject($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jspNewPrototype(HEAP32[$2 + 20 >> 2], 0);
  HEAP32[$2 + 12 >> 2] = jsvNewObject();
  block : {
   if (!HEAP32[$2 + 12 >> 2]) {
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   if (HEAP32[$2 + 24 >> 2]) {
    HEAP8[$2 + 11 | 0] = jshFromDeviceString(HEAP32[$2 + 24 >> 2]);
    if (HEAPU8[$2 + 11 | 0]) {
     HEAP8[HEAP32[$2 + 12 >> 2]] = 68;
     HEAP8[HEAP32[$2 + 12 >> 2] + 1 | 0] = 69;
     HEAP8[HEAP32[$2 + 12 >> 2] + 2 | 0] = 86;
     HEAP8[HEAP32[$2 + 12 >> 2] + 3 | 0] = HEAPU8[$2 + 11 | 0];
    }
   }
   jsvAddNamedChildAndUnLock(HEAP32[$2 + 12 >> 2], jsvSkipNameAndUnLock(HEAP32[$2 + 16 >> 2]), 20670);
   if (HEAP32[$2 + 24 >> 2]) {
    HEAP32[$2 + 4 >> 2] = jsvFindOrAddChildFromString(HEAP32[103307], HEAP32[$2 + 24 >> 2]);
    if (HEAP32[$2 + 4 >> 2]) {
     jsvSetValueOfName(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 12 >> 2])
    }
    jsvUnLock(HEAP32[$2 + 12 >> 2]);
    if (!HEAP32[$2 + 4 >> 2]) {
     HEAP32[$2 + 28 >> 2] = 0;
     break block;
    }
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
    break block;
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jspGetPrototype($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 8 >> 2], 20670);
   if (jsvIsObject(HEAP32[$1 + 4 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
    break block;
   }
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jspGetConstructor($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = jspGetPrototype(HEAP32[$1 + 8 >> 2]);
  block : {
   if (HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 4 >> 2], 7797);
    if (jsvIsFunction(HEAP32[$1 >> 2]) & 1) {
     jsvUnLock(HEAP32[$1 + 4 >> 2]);
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
     break block;
    }
    jsvUnLock2(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jspSoftInit() {
  HEAP32[103307] = jsvFindOrCreateRoot();
  HEAP32[103308] = jsvObjectGetChild(HEAP32[103307], 1024, 5);
  HEAP32[103315] = 1;
  HEAP32[103309] = 0;
  HEAP32[103310] = HEAP32[103307];
  HEAP32[103311] = 0;
  HEAP8[413248] = 0;
 }
 
 function jspSoftKill() {
  jsvUnLock(HEAP32[103309]);
  HEAP32[103309] = 0;
  jsvUnLock(HEAP32[103308]);
  HEAP32[103308] = 0;
  jsvUnLock(HEAP32[103307]);
  HEAP32[103307] = 0;
 }
 
 function jspInit() {
  jspSoftInit();
 }
 
 function jspKill() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  jspSoftKill();
  HEAP32[$0 + 12 >> 2] = jsvFindOrCreateRoot();
  jsvUnRef(HEAP32[$0 + 12 >> 2]);
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jspEvaluateVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 208 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 204 >> 2] = $0;
  HEAP32[$3 + 200 >> 2] = $1;
  HEAP32[$3 + 196 >> 2] = $2;
  HEAP32[$3 + 56 >> 2] = jslSetLex($3 + 60 | 0);
  jslInit(HEAP32[$3 + 204 >> 2]);
  HEAP32[$3 + 192 >> 2] = HEAP32[$3 + 56 >> 2];
  block : {
   if (HEAP32[$3 + 196 >> 2]) {
    $0 = jsvNewFromString(HEAP32[$3 + 196 >> 2]);
    break block;
   }
   $0 = 0;
  }
  HEAP32[$3 + 188 >> 2] = $0;
  HEAP32[$3 + 48 >> 2] = HEAP32[103315];
  $0 = HEAP32[103314];
  $1 = HEAP32[103313];
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 44 >> 2] = $0;
  $1 = HEAP32[103312];
  $0 = HEAP32[103311];
  HEAP32[$3 + 32 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  $0 = HEAP32[103310];
  $1 = HEAP32[103309];
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 28 >> 2] = $0;
  $1 = HEAP32[103308];
  $0 = HEAP32[103307];
  HEAP32[$3 + 16 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[103315] = 1;
  if (HEAP32[$3 + 200 >> 2]) {
   HEAP32[103309] = 0;
   if (HEAP32[$3 + 200 >> 2] != HEAP32[103307]) {
    jspeiAddScope(HEAP32[$3 + 200 >> 2]);
    HEAP32[103310] = HEAP32[$3 + 200 >> 2];
   }
  }
  HEAP32[$3 + 12 >> 2] = jspParse();
  if (HEAP32[$3 + 200 >> 2]) {
   jspeiClearScopes()
  }
  jslKill();
  jsvUnLock(HEAP32[$3 + 188 >> 2]);
  jslSetLex(HEAP32[$3 + 56 >> 2]);
  HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] | HEAP32[103315] & 6384;
  $0 = HEAP32[$3 + 20 >> 2];
  $1 = HEAP32[$3 + 16 >> 2];
  HEAP32[103307] = $1;
  HEAP32[103308] = $0;
  HEAP32[103315] = HEAP32[$3 + 48 >> 2];
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$3 + 40 >> 2];
  HEAP32[103313] = $0;
  HEAP32[103314] = $1;
  $0 = HEAP32[$3 + 36 >> 2];
  $1 = HEAP32[$3 + 32 >> 2];
  HEAP32[103311] = $1;
  HEAP32[103312] = $0;
  $1 = HEAP32[$3 + 28 >> 2];
  $0 = HEAP32[$3 + 24 >> 2];
  HEAP32[103309] = $0;
  HEAP32[103310] = $1;
  $0 = jsvSkipNameAndUnLock(HEAP32[$3 + 12 >> 2]);
  __stack_pointer = $3 + 208 | 0;
  return $0;
 }
 
 function jspEvaluate($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP8[$2 + 23 | 0] = $1;
  block : {
   if (HEAP8[$2 + 23 | 0] & 1) {
    HEAP32[$2 + 16 >> 2] = jsvNewNativeString(HEAP32[$2 + 24 >> 2], strlen(HEAP32[$2 + 24 >> 2]));
    break block;
   }
   HEAP32[$2 + 16 >> 2] = jsvNewFromString(HEAP32[$2 + 24 >> 2]);
  }
  block1 : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block1;
   }
   HEAP32[$2 + 12 >> 2] = 0;
   if (!(jsvIsMemoryFull() & 1)) {
    HEAP32[$2 + 12 >> 2] = jspEvaluateVar(HEAP32[$2 + 16 >> 2], 0, 20689)
   }
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jspExecuteJSFunctionCode($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer + -64 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 56 >> 2] = $0;
  HEAP32[$6 + 52 >> 2] = $1;
  HEAP32[$6 + 48 >> 2] = $2;
  HEAP32[$6 + 44 >> 2] = $3;
  HEAP32[$6 + 40 >> 2] = $4;
  HEAP32[$6 + 36 >> 2] = $5;
  if (!HEAP32[$6 + 48 >> 2]) {
   HEAP32[$6 + 48 >> 2] = strlen(HEAP32[$6 + 52 >> 2])
  }
  HEAP32[$6 + 32 >> 2] = jsvNewWithFlags(7);
  block : {
   if (!HEAP32[$6 + 32 >> 2]) {
    HEAP32[$6 + 60 >> 2] = 0;
    break block;
   }
   if (!(!HEAP32[$6 + 56 >> 2] | !HEAPU8[HEAP32[$6 + 56 >> 2]])) {
    HEAP8[$6 + 22 | 0] = 255;
    while (1) {
     if (HEAPU8[HEAP32[$6 + 56 >> 2]]) {
      HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 56 >> 2];
      HEAP32[$6 + 16 >> 2] = 1;
      while (1) {
       $0 = 0;
       $0 = HEAP8[HEAP32[$6 + 12 >> 2]] << 24 >> 24 ? HEAPU8[HEAP32[$6 + 12 >> 2]] != 44 : $0;
       if ($0) {
        $1 = HEAPU8[HEAP32[$6 + 12 >> 2]];
        $0 = HEAP32[$6 + 16 >> 2];
        HEAP32[$6 + 16 >> 2] = $0 + 1;
        HEAP8[($6 + 22 | 0) + $0 | 0] = $1;
        HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
        continue;
       }
       break;
      };
      HEAP8[HEAP32[$6 + 16 >> 2] + ($6 + 22 | 0) | 0] = 0;
      HEAP32[$6 + 8 >> 2] = jsvNewNameFromString($6 + 22 | 0);
      jsvAddFunctionParameter(HEAP32[$6 + 32 >> 2], HEAP32[$6 + 8 >> 2], 0);
      if (HEAP8[HEAP32[$6 + 12 >> 2]] << 24 >> 24) {
       $0 = HEAP32[$6 + 12 >> 2] + 1 | 0
      } else {
       $0 = HEAP32[$6 + 12 >> 2]
      }
      HEAP32[$6 + 56 >> 2] = $0;
      continue;
     }
     break;
    };
   }
   jsvObjectSetChildAndUnLock(HEAP32[$6 + 32 >> 2], 18659, jsvNewNativeString(HEAP32[$6 + 52 >> 2], HEAP32[$6 + 48 >> 2]));
   HEAP32[$6 + 4 >> 2] = jspExecuteFunction(HEAP32[$6 + 32 >> 2], HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2]);
   jsvUnLock(HEAP32[$6 + 32 >> 2]);
   HEAP32[$6 + 60 >> 2] = HEAP32[$6 + 4 >> 2];
  }
  __stack_pointer = $6 - -64 | 0;
  return HEAP32[$6 + 60 >> 2];
 }
 
 function jspExecuteFunction($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP32[$4 + 48 >> 2] = $3;
  HEAP32[$4 + 40 >> 2] = HEAP32[103315];
  $0 = HEAP32[103314];
  $1 = HEAP32[103313];
  HEAP32[$4 + 32 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $0;
  $1 = HEAP32[103312];
  $0 = HEAP32[103311];
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 28 >> 2] = $1;
  $0 = HEAP32[103310];
  $1 = HEAP32[103309];
  HEAP32[$4 + 16 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $0;
  $1 = HEAP32[103308];
  $0 = HEAP32[103307];
  HEAP32[$4 + 8 >> 2] = $0;
  HEAP32[$4 + 12 >> 2] = $1;
  HEAP32[103309] = 0;
  HEAP32[103315] = 1;
  HEAP32[103313] = 0;
  HEAP32[$4 + 4 >> 2] = jspeFunctionCall(HEAP32[$4 + 60 >> 2], 0, HEAP32[$4 + 56 >> 2], 0, HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2]);
  jspeiClearScopes();
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 40 >> 2] | HEAP32[103315] & 6384;
  jspeiClearScopes();
  $0 = HEAP32[$4 + 12 >> 2];
  $1 = HEAP32[$4 + 8 >> 2];
  HEAP32[103307] = $1;
  HEAP32[103308] = $0;
  HEAP32[103315] = HEAP32[$4 + 40 >> 2];
  $1 = HEAP32[$4 + 36 >> 2];
  $0 = HEAP32[$4 + 32 >> 2];
  HEAP32[103313] = $0;
  HEAP32[103314] = $1;
  $0 = HEAP32[$4 + 28 >> 2];
  $1 = HEAP32[$4 + 24 >> 2];
  HEAP32[103311] = $1;
  HEAP32[103312] = $0;
  $1 = HEAP32[$4 + 20 >> 2];
  $0 = HEAP32[$4 + 16 >> 2];
  HEAP32[103309] = $0;
  HEAP32[103310] = $1;
  __stack_pointer = $4 - -64 | 0;
  return HEAP32[$4 + 4 >> 2];
 }
 
 function jspEvaluateModule($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 56 >> 2] = $0;
  block : {
   block1 : {
    if (jsvIsFunction(HEAP32[$1 + 56 >> 2]) & 1) {
     HEAP32[$1 + 56 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 56 >> 2], 18659);
     if (!(jsvIsString(HEAP32[$1 + 56 >> 2]) & 1)) {
      jsvUnLock(HEAP32[$1 + 56 >> 2]);
      HEAP32[$1 + 60 >> 2] = 0;
      break block;
     }
     break block1;
    }
    jsvLockAgain(HEAP32[$1 + 56 >> 2]);
   }
   HEAP32[$1 + 52 >> 2] = jsvNewObject();
   HEAP32[$1 + 48 >> 2] = jsvNewObject();
   if (!(HEAP32[$1 + 48 >> 2] ? HEAP32[$1 + 52 >> 2] : 0)) {
    jsvUnLock3(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 48 >> 2], HEAP32[$1 + 56 >> 2]);
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 44 >> 2] = jsvAddNamedChild(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 48 >> 2], 6681);
   jsvUnLock2(HEAP32[$1 + 48 >> 2], jsvAddNamedChild(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 52 >> 2], 17835));
   HEAP32[$1 + 40 >> 2] = HEAP32[103315];
   $0 = HEAP32[103314];
   $2 = HEAP32[103313];
   HEAP32[$1 + 32 >> 2] = $2;
   HEAP32[$1 + 36 >> 2] = $0;
   $2 = HEAP32[103312];
   $0 = HEAP32[103311];
   HEAP32[$1 + 24 >> 2] = $0;
   HEAP32[$1 + 28 >> 2] = $2;
   $0 = HEAP32[103310];
   $2 = HEAP32[103309];
   HEAP32[$1 + 16 >> 2] = $2;
   HEAP32[$1 + 20 >> 2] = $0;
   $2 = HEAP32[103308];
   $0 = HEAP32[103307];
   HEAP32[$1 + 8 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = $2;
   HEAP32[103310] = HEAP32[$1 + 48 >> 2];
   HEAP32[103311] = 0;
   HEAP8[413248] = 0;
   HEAP32[103313] = HEAP32[$1 + 48 >> 2];
   jsvUnLock(jspEvaluateVar(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 52 >> 2], 17835));
   HEAP32[$1 + 4 >> 2] = HEAP32[103315] & 112;
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   HEAP32[103307] = $2;
   HEAP32[103308] = $0;
   HEAP32[103315] = HEAP32[$1 + 40 >> 2];
   $2 = HEAP32[$1 + 36 >> 2];
   $0 = HEAP32[$1 + 32 >> 2];
   HEAP32[103313] = $0;
   HEAP32[103314] = $2;
   $0 = HEAP32[$1 + 28 >> 2];
   $2 = HEAP32[$1 + 24 >> 2];
   HEAP32[103311] = $2;
   HEAP32[103312] = $0;
   $2 = HEAP32[$1 + 20 >> 2];
   $0 = HEAP32[$1 + 16 >> 2];
   HEAP32[103309] = $0;
   HEAP32[103310] = $2;
   HEAP32[103315] = HEAP32[$1 + 4 >> 2] | HEAP32[103315];
   jsvUnLock2(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 52 >> 2]);
   HEAP32[$1 + 60 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 44 >> 2]);
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP32[$1 + 60 >> 2];
 }
 
 function jspGetPrototypeOwner($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   block : {
    if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
     if (!(jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1)) {
      break block
     }
    }
    HEAP32[$1 + 12 >> 2] = jsvSkipNameAndUnLock(jsvObjectGetChildIfExists(HEAP32[$1 + 8 >> 2], 7797));
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswBinarySearch($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 40 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  HEAP32[$3 + 32 >> 2] = $2;
  HEAP8[$3 + 31 | 0] = HEAPU8[HEAP32[$3 + 40 >> 2] + 8 | 0];
  HEAP32[$3 + 24 >> 2] = 0;
  HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 31 | 0] - 1;
  block : {
   while (1) {
    if (HEAP32[$3 + 24 >> 2] <= HEAP32[$3 + 20 >> 2]) {
     HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 20 >> 2] >> 1;
     $0 = HEAP32[$3 + 40 >> 2];
     HEAP32[$3 + 12 >> 2] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] << 3);
     $0 = HEAP32[$3 + 40 >> 2];
     $1 = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 8 >> 2] = strcmp(HEAP32[$3 + 32 >> 2], (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) + (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8) | 0);
     if (HEAP32[$3 + 8 >> 2]) {
      if (HEAP32[$3 + 8 >> 2] < 0) {
       HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 16 >> 2] - 1;
       continue;
      }
      HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
      continue;
     } else {
      $0 = HEAP32[$3 + 12 >> 2];
      HEAP16[$3 + 6 >> 1] = HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8;
      if ((HEAPU16[$3 + 6 >> 1] & 32256) == 28672) {
       $0 = HEAP32[$3 + 12 >> 2];
       HEAP32[$3 + 44 >> 2] = jsnCallFunction(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24), HEAPU16[$3 + 6 >> 1], HEAP32[$3 + 36 >> 2], 0, 0);
       break block;
      }
      $0 = HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 44 >> 2] = jsvNewNativeFunction(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24), HEAPU16[$3 + 6 >> 1]);
      break block;
     }
    }
    break;
   };
   HEAP32[$3 + 44 >> 2] = 0;
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 44 >> 2];
 }
 
 function jswGetSymbolListForConstructorProto($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 4 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  block : {
   if (HEAP32[$1 + 4 >> 2] == 10) {
    HEAP32[$1 + 12 >> 2] = 157919;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 11) {
    HEAP32[$1 + 12 >> 2] = 157973;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 12) {
    HEAP32[$1 + 12 >> 2] = 157991;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 13) {
    HEAP32[$1 + 12 >> 2] = 158e3;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 14) {
    HEAP32[$1 + 12 >> 2] = 158009;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 15) {
    HEAP32[$1 + 12 >> 2] = 158018;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 16) {
    HEAP32[$1 + 12 >> 2] = 158027;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 17) {
    HEAP32[$1 + 12 >> 2] = 158036;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 18) {
    HEAP32[$1 + 12 >> 2] = 158108;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 19) {
    HEAP32[$1 + 12 >> 2] = 158189;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 20) {
    HEAP32[$1 + 12 >> 2] = 158207;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 21) {
    HEAP32[$1 + 12 >> 2] = 158225;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 22) {
    HEAP32[$1 + 12 >> 2] = 158243;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 23) {
    HEAP32[$1 + 12 >> 2] = 158261;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 24) {
    HEAP32[$1 + 12 >> 2] = 158279;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2] == 25) {
    HEAP32[$1 + 12 >> 2] = 158297;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function gen_jswrap_Graphics_Graphics() {
  return 0;
 }
 
 function gen_jswrap_StorageFile_StorageFile() {
  return 0;
 }
 
 function jswFindBuiltInFunction($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  block1 : {
   block8 : {
    block : {
     if (!HEAP32[$2 + 40 >> 2]) {
      break block
     }
     if (jsvIsRoot(HEAP32[$2 + 40 >> 2]) & 1) {
      break block
     }
     if (jsvIsNativeFunction(HEAP32[$2 + 40 >> 2]) & 1) {
      HEAP32[$2 + 28 >> 2] = jswGetSymbolListForObject(HEAP32[$2 + 40 >> 2]);
      if (HEAP32[$2 + 28 >> 2]) {
       HEAP32[$2 + 32 >> 2] = jswBinarySearch(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
       if (HEAP32[$2 + 32 >> 2]) {
        HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
        break block1;
       }
      }
     }
     if (jsvIsPin(HEAP32[$2 + 40 >> 2]) & 1) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(157865, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break block1;
      }
     }
     if (jsvIsArray(HEAP32[$2 + 40 >> 2]) & 1) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(157937, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break block1;
      }
     }
     if (!(!(jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1) | HEAPU8[HEAP32[$2 + 40 >> 2] + 5 | 0] != 129)) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(157955, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break block1;
      }
     }
     if (!(!(jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1) | HEAPU8[HEAP32[$2 + 40 >> 2] + 5 | 0] == 129)) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(157964, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break block1;
      }
     }
     if (jsvIsNumeric(HEAP32[$2 + 40 >> 2]) & 1) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(158072, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break block1;
      }
     }
     if (jsvIsFunction(HEAP32[$2 + 40 >> 2]) & 1) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(158099, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break block1;
      }
     }
     if (jsvIsString(HEAP32[$2 + 40 >> 2]) & 1) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(158126, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break block1;
      }
     }
     block4 : {
      if (jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1) {
       $0 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 40 >> 2], 20670));
       break block4;
      }
      $0 = 0;
     }
     HEAP32[$2 + 24 >> 2] = $0;
     block5 : {
      if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
       $0 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 24 >> 2], 7797));
       break block5;
      }
      $0 = 0;
     }
     HEAP32[$2 + 20 >> 2] = $0;
     jsvUnLock(HEAP32[$2 + 24 >> 2]);
     block7 : {
      block6 : {
       if (!HEAP32[$2 + 20 >> 2]) {
        break block6
       }
       if (!(jsvIsNativeFunction(HEAP32[$2 + 20 >> 2]) & 1)) {
        break block6
       }
       HEAP32[$2 + 16 >> 2] = jswGetSymbolListForConstructorProto(HEAP32[$2 + 20 >> 2]);
       jsvUnLock(HEAP32[$2 + 20 >> 2]);
       if (HEAP32[$2 + 16 >> 2]) {
        HEAP32[$2 + 32 >> 2] = jswBinarySearch(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
        if (HEAP32[$2 + 32 >> 2]) {
         HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
         break block1;
        }
       }
       break block7;
      }
      jsvUnLock(HEAP32[$2 + 20 >> 2]);
     }
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(158081, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break block1;
     }
     break block8;
    }
    HEAP8[$2 + 15 | 0] = jshGetPinFromString(HEAP32[$2 + 36 >> 2]);
    if (HEAPU8[$2 + 15 | 0] != 255) {
     HEAP32[$2 + 44 >> 2] = jsvNewFromPin(HEAPU8[$2 + 15 | 0]);
     break block1;
    }
    HEAP32[$2 + 44 >> 2] = jswBinarySearch(157874, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
    break block1;
   }
   HEAP32[$2 + 44 >> 2] = 0;
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jswGetSymbolListForObject($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsNativeFunction(HEAP32[$1 + 8 >> 2]) & 1) {
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 26) {
     HEAP32[$1 + 12 >> 2] = 157856;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 27) {
     HEAP32[$1 + 12 >> 2] = 157883;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 28) {
     HEAP32[$1 + 12 >> 2] = 157892;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 29) {
     HEAP32[$1 + 12 >> 2] = 157901;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 30) {
     HEAP32[$1 + 12 >> 2] = 157910;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 31) {
     HEAP32[$1 + 12 >> 2] = 157928;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 32) {
     HEAP32[$1 + 12 >> 2] = 157946;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 12) {
     HEAP32[$1 + 12 >> 2] = 157982;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 33) {
     HEAP32[$1 + 12 >> 2] = 158045;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 34) {
     HEAP32[$1 + 12 >> 2] = 158054;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 35) {
     HEAP32[$1 + 12 >> 2] = 158063;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 36) {
     HEAP32[$1 + 12 >> 2] = 158090;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 37) {
     HEAP32[$1 + 12 >> 2] = 158117;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 38) {
     HEAP32[$1 + 12 >> 2] = 158135;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 39) {
     HEAP32[$1 + 12 >> 2] = 158144;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 40) {
     HEAP32[$1 + 12 >> 2] = 158153;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 41) {
     HEAP32[$1 + 12 >> 2] = 158162;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 42) {
     HEAP32[$1 + 12 >> 2] = 158171;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 43) {
     HEAP32[$1 + 12 >> 2] = 158180;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 20) {
     HEAP32[$1 + 12 >> 2] = 158198;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 21) {
     HEAP32[$1 + 12 >> 2] = 158216;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 44) {
     HEAP32[$1 + 12 >> 2] = 158234;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 23) {
     HEAP32[$1 + 12 >> 2] = 158252;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 24) {
     HEAP32[$1 + 12 >> 2] = 158270;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 25) {
     HEAP32[$1 + 12 >> 2] = 158288;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 45) {
     HEAP32[$1 + 12 >> 2] = 158306;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 10) {
     HEAP32[$1 + 12 >> 2] = 158315;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 46) {
     HEAP32[$1 + 12 >> 2] = 158324;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 47) {
     HEAP32[$1 + 12 >> 2] = 158333;
     break block;
    }
   }
   if (HEAP32[$1 + 8 >> 2] == HEAP32[103307]) {
    HEAP32[$1 + 12 >> 2] = 157874;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function gen_jswrap_Bangle_Bangle() {
  return 0;
 }
 
 function gen_jswrap_E_E() {
  return 0;
 }
 
 function gen_jswrap_NRF_NRF() {
  return 0;
 }
 
 function gen_jswrap_Bluetooth_Bluetooth() {
  return 0;
 }
 
 function gen_jswrap_Unistroke_Unistroke() {
  return 0;
 }
 
 function gen_jswrap_console_console() {
  return 0;
 }
 
 function gen_jswrap_JSON_JSON() {
  return 0;
 }
 
 function gen_jswrap_timer_timer() {
  return 0;
 }
 
 function gen_jswrap_Modules_Modules() {
  return 0;
 }
 
 function gen_jswrap_Math_Math() {
  return 0;
 }
 
 function gen_jswrap_Flash_Flash() {
  return 0;
 }
 
 function gen_jswrap_fs_fs() {
  return 0;
 }
 
 function gen_jswrap_process_process() {
  return 0;
 }
 
 function gen_jswrap_Storage_Storage() {
  return 0;
 }
 
 function gen_jswrap_heatshrink_heatshrink() {
  return 0;
 }
 
 function gen_jswrap_crypto_crypto() {
  return 0;
 }
 
 function gen_jswrap_AES_AES() {
  return 0;
 }
 
 function jswGetSymbolListForObjectProto($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsNativeFunction(HEAP32[$1 + 8 >> 2]) & 1) {
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 26) {
     HEAP32[$1 + 12 >> 2] = 157865;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 32) {
     HEAP32[$1 + 12 >> 2] = 157937;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 48) {
     HEAP32[$1 + 12 >> 2] = 157955;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 49) {
     HEAP32[$1 + 12 >> 2] = 157964;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 35) {
     HEAP32[$1 + 12 >> 2] = 158072;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 50) {
     HEAP32[$1 + 12 >> 2] = 158099;
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 38) {
     HEAP32[$1 + 12 >> 2] = 158126;
     break block;
    }
   }
   block1 : {
    if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
     $0 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$1 + 8 >> 2], 7797));
     break block1;
    }
    $0 = 0;
   }
   HEAP32[$1 + 4 >> 2] = $0;
   block2 : {
    if (!HEAP32[$1 + 4 >> 2]) {
     break block2
    }
    if (!(jsvIsNativeFunction(HEAP32[$1 + 4 >> 2]) & 1)) {
     break block2
    }
    HEAP32[$1 >> 2] = jswGetSymbolListForConstructorProto(HEAP32[$1 + 4 >> 2]);
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    if (HEAP32[$1 >> 2]) {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
     break block;
    }
   }
   if (jsvIsPin(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 157865;
    break block;
   }
   if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 157937;
    break block;
   }
   if (!(!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) | HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] != 129)) {
    HEAP32[$1 + 12 >> 2] = 157955;
    break block;
   }
   if (!(!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) | HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 129)) {
    HEAP32[$1 + 12 >> 2] = 157964;
    break block;
   }
   if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 158072;
    break block;
   }
   if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 158099;
    break block;
   }
   if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 158126;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 158081;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function gen_jswrap_ArrayBufferView_ArrayBufferView() {
  return 0;
 }
 
 function jswIsBuiltInObject($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = 158342;
  HEAP32[$1 >> 2] = HEAP32[$1 + 4 >> 2];
  block : {
   while (1) {
    if (HEAPU8[HEAP32[$1 >> 2]]) {
     if (strcmp(HEAP32[$1 >> 2], HEAP32[$1 + 8 >> 2])) {
      HEAP32[$1 >> 2] = (strlen(HEAP32[$1 >> 2]) + 1 | 0) + HEAP32[$1 >> 2];
      continue;
     } else {
      HEAP8[$1 + 15 | 0] = 1;
      break block;
     }
    }
    break;
   };
   HEAP8[$1 + 15 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jswGetBuiltInLibrary($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!strcmp(HEAP32[$1 + 8 >> 2], 8035)) {
    HEAP32[$1 + 12 >> 2] = 37;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 16324)) {
    HEAP32[$1 + 12 >> 2] = 41;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 18116)) {
    HEAP32[$1 + 12 >> 2] = 44;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 15956)) {
    HEAP32[$1 + 12 >> 2] = 45;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 15097)) {
    HEAP32[$1 + 12 >> 2] = 46;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswGetBasicObjectName($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 129) {
     HEAP32[$1 + 12 >> 2] = 8255;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 1) {
     HEAP32[$1 + 12 >> 2] = 3698;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 65) {
     HEAP32[$1 + 12 >> 2] = 3680;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 17) {
     HEAP32[$1 + 12 >> 2] = 3709;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 2) {
     HEAP32[$1 + 12 >> 2] = 3719;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 18) {
     HEAP32[$1 + 12 >> 2] = 3731;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 3) {
     HEAP32[$1 + 12 >> 2] = 3755;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 4) {
     HEAP32[$1 + 12 >> 2] = 3767;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 20) {
     HEAP32[$1 + 12 >> 2] = 3779;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 36) {
     HEAP32[$1 + 12 >> 2] = 3790;
     break block;
    }
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 40) {
     HEAP32[$1 + 12 >> 2] = 3742;
     break block;
    }
   }
   if (jsvIsPin(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 15532;
    break block;
   }
   if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 3797;
    break block;
   }
   if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 8384;
    break block;
   }
   if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 5005;
    break block;
   }
   if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 15421;
    break block;
   }
   if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = 16889;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswGetBasicObjectPrototypeName($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3698)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3680)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3709)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3719)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3731)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3755)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3767)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3779)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3790)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 3742)) {
    HEAP32[$1 + 12 >> 2] = 4108;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = strcmp(HEAP32[$1 + 8 >> 2], 5005) ? 5005 : 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswIdle() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 15 | 0] = 0;
  if (jswrap_banglejs_idle() & 1) {
   HEAP8[$0 + 15 | 0] = 1
  }
  if (jswrap_pipe_idle() & 1) {
   HEAP8[$0 + 15 | 0] = 1
  }
  if (jswrap_serial_idle() & 1) {
   HEAP8[$0 + 15 | 0] = 1
  }
  if (jswrap_graphics_idle() & 1) {
   HEAP8[$0 + 15 | 0] = 1
  }
  if (jswrap_terminal_idle() & 1) {
   HEAP8[$0 + 15 | 0] = 1
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function jswHWInit() {
  jswrap_banglejs_hwinit();
 }
 
 function jswInit() {
  jswrap_graphics_init();
  jswrap_banglejs_init();
  jswrap_terminal_init();
 }
 
 function jswKill() {
  jswrap_banglejs_kill();
  jswrap_pipe_kill();
  jswrap_waveform_kill();
 }
 
 function jswGetPowerUsage($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jswrap_banglejs_powerusage(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswOnCharEvent($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 14 | 0] = $0;
  HEAP8[$2 + 13 | 0] = $1;
  block : {
   if (HEAPU8[$2 + 14 | 0] == 22) {
    HEAP8[$2 + 15 | 0] = jswrap_banglejs_gps_character(HEAP8[$2 + 13 | 0] << 24 >> 24) & 1;
    break block;
   }
   HEAP8[$2 + 15 | 0] = 0;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP8[$2 + 15 | 0] & 1;
 }
 
 function jswOnCustomEvent($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 15 | 0] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jswrap_waveform_eventHandler(HEAPU8[$3 + 15 | 0], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswGetBuiltInJSLibrary($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!strcmp(HEAP32[$1 + 8 >> 2], 18036)) {
    HEAP32[$1 + 12 >> 2] = 1967;
    break block;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2], 4361)) {
    HEAP32[$1 + 12 >> 2] = 8409;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswGetBuiltInLibraryNames() {
  return 4316;
 }
 
 function jswCallFunctionHack($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0.0;
  $5 = __stack_pointer - 576 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 568 >> 2] = $0;
  HEAP16[$5 + 566 >> 1] = $1;
  HEAP32[$5 + 560 >> 2] = $2;
  HEAP32[$5 + 556 >> 2] = $3;
  HEAP32[$5 + 552 >> 2] = $4;
  block125 : {
   block124 : {
    block57 : {
     block115 : {
      block96 : {
       block101 : {
        block123 : {
         block116 : {
          block75 : {
           block117 : {
            block105 : {
             block106 : {
              block109 : {
               block102 : {
                block119 : {
                 block118 : {
                  block80 : {
                   block59 : {
                    block110 : {
                     block113 : {
                      block120 : {
                       block103 : {
                        block13 : {
                         block27 : {
                          block61 : {
                           block33 : {
                            block76 : {
                             block95 : {
                              block92 : {
                               block89 : {
                                block48 : {
                                 block19 : {
                                  block53 : {
                                   block47 : {
                                    block49 : {
                                     block20 : {
                                      block40 : {
                                       block50 : {
                                        block35 : {
                                         block31 : {
                                          block62 : {
                                           block52 : {
                                            block60 : {
                                             block34 : {
                                              block36 : {
                                               block32 : {
                                                block44 : {
                                                 block30 : {
                                                  block51 : {
                                                   block54 : {
                                                    block41 : {
                                                     block46 : {
                                                      block14 : {
                                                       block23 : {
                                                        block11 : {
                                                         block56 : {
                                                          block22 : {
                                                           block18 : {
                                                            block24 : {
                                                             block87 : {
                                                              block88 : {
                                                               block17 : {
                                                                block7 : {
                                                                 block94 : {
                                                                  block93 : {
                                                                   block74 : {
                                                                    block64 : {
                                                                     block66 : {
                                                                      block45 : {
                                                                       block9 : {
                                                                        block8 : {
                                                                         block83 : {
                                                                          block91 : {
                                                                           block107 : {
                                                                            block114 : {
                                                                             block84 : {
                                                                              block71 : {
                                                                               block70 : {
                                                                                block3 : {
                                                                                 block112 : {
                                                                                  block97 : {
                                                                                   block98 : {
                                                                                    block55 : {
                                                                                     block122 : {
                                                                                      block16 : {
                                                                                       block108 : {
                                                                                        block77 : {
                                                                                         block6 : {
                                                                                          block90 : {
                                                                                           block111 : {
                                                                                            block86 : {
                                                                                             block68 : {
                                                                                              block78 : {
                                                                                               block100 : {
                                                                                                block99 : {
                                                                                                 block121 : {
                                                                                                  block73 : {
                                                                                                   block10 : {
                                                                                                    block82 : {
                                                                                                     block63 : {
                                                                                                      block26 : {
                                                                                                       block25 : {
                                                                                                        block42 : {
                                                                                                         block37 : {
                                                                                                          block5 : {
                                                                                                           block2 : {
                                                                                                            block28 : {
                                                                                                             block29 : {
                                                                                                              block1 : {
                                                                                                               block58 : {
                                                                                                                block15 : {
                                                                                                                 block : {
                                                                                                                  block4 : {
                                                                                                                   block21 : {
                                                                                                                    block12 : {
                                                                                                                     block65 : {
                                                                                                                      block67 : {
                                                                                                                       block69 : {
                                                                                                                        block39 : {
                                                                                                                         block43 : {
                                                                                                                          block38 : {
                                                                                                                           block81 : {
                                                                                                                            block79 : {
                                                                                                                             block104 : {
                                                                                                                              block85 : {
                                                                                                                               block72 : {
                                                                                                                                $0 = HEAPU16[$5 + 566 >> 1];
                                                                                                                                if ($0) {
                                                                                                                                 if (($0 | 0) == 1) {
                                                                                                                                  break block
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 3) {
                                                                                                                                  break block1
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 4) {
                                                                                                                                  break block2
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 7) {
                                                                                                                                  break block3
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 8) {
                                                                                                                                  break block4
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 9) {
                                                                                                                                  break block5
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 11) {
                                                                                                                                  break block6
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 12) {
                                                                                                                                  break block7
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 15) {
                                                                                                                                  break block8
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 16) {
                                                                                                                                  break block9
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 17) {
                                                                                                                                  break block10
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 23) {
                                                                                                                                  break block11
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 24) {
                                                                                                                                  break block12
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 28) {
                                                                                                                                  break block13
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 31) {
                                                                                                                                  break block14
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32) {
                                                                                                                                  break block15
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33) {
                                                                                                                                  break block16
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 35) {
                                                                                                                                  break block17
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 36) {
                                                                                                                                  break block18
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 41) {
                                                                                                                                  break block19
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 47) {
                                                                                                                                  break block20
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 56) {
                                                                                                                                  break block21
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 57) {
                                                                                                                                  break block22
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 60) {
                                                                                                                                  break block23
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 63) {
                                                                                                                                  break block24
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 72) {
                                                                                                                                  break block25
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 73) {
                                                                                                                                  break block26
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 75) {
                                                                                                                                  break block27
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 91) {
                                                                                                                                  break block28
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 96) {
                                                                                                                                  break block29
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 120) {
                                                                                                                                  break block30
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 136) {
                                                                                                                                  break block31
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 200) {
                                                                                                                                  break block32
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 201) {
                                                                                                                                  break block33
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 204) {
                                                                                                                                  break block34
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 264) {
                                                                                                                                  break block35
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 265) {
                                                                                                                                  break block36
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 288) {
                                                                                                                                  break block37
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 289) {
                                                                                                                                  break block38
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 292) {
                                                                                                                                  break block39
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 456) {
                                                                                                                                  break block40
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 463) {
                                                                                                                                  break block41
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 481) {
                                                                                                                                  break block42
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 511) {
                                                                                                                                  break block43
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 584) {
                                                                                                                                  break block44
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 585) {
                                                                                                                                  break block45
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 609) {
                                                                                                                                  break block46
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 744) {
                                                                                                                                  break block47
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 841) {
                                                                                                                                  break block48
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 1e3) {
                                                                                                                                  break block49
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 1481) {
                                                                                                                                  break block50
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 1608) {
                                                                                                                                  break block51
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 1609) {
                                                                                                                                  break block52
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 1640) {
                                                                                                                                  break block53
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 2127) {
                                                                                                                                  break block54
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 2313) {
                                                                                                                                  break block55
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 4095) {
                                                                                                                                  break block56
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 4681) {
                                                                                                                                  break block57
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 6216) {
                                                                                                                                  break block58
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 6433) {
                                                                                                                                  break block59
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 16968) {
                                                                                                                                  break block60
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 18507) {
                                                                                                                                  break block61
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 20473) {
                                                                                                                                  break block62
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 28673) {
                                                                                                                                  break block63
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 28676) {
                                                                                                                                  break block64
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 28677) {
                                                                                                                                  break block65
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 28679) {
                                                                                                                                  break block66
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32768) {
                                                                                                                                  break block67
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32769) {
                                                                                                                                  break block68
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32771) {
                                                                                                                                  break block69
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32772) {
                                                                                                                                  break block70
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32775) {
                                                                                                                                  break block71
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32776) {
                                                                                                                                  break block72
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32777) {
                                                                                                                                  break block73
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32779) {
                                                                                                                                  break block74
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32780) {
                                                                                                                                  break block75
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32784) {
                                                                                                                                  break block76
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32785) {
                                                                                                                                  break block77
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32788) {
                                                                                                                                  break block78
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32792) {
                                                                                                                                  break block79
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32793) {
                                                                                                                                  break block80
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32800) {
                                                                                                                                  break block81
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32801) {
                                                                                                                                  break block82
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32807) {
                                                                                                                                  break block83
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32831) {
                                                                                                                                  break block84
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32840) {
                                                                                                                                  break block85
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32841) {
                                                                                                                                  break block86
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32843) {
                                                                                                                                  break block87
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32844) {
                                                                                                                                  break block88
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32856) {
                                                                                                                                  break block89
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32865) {
                                                                                                                                  break block90
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32871) {
                                                                                                                                  break block91
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32888) {
                                                                                                                                  break block92
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32904) {
                                                                                                                                  break block93
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32905) {
                                                                                                                                  break block94
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32968) {
                                                                                                                                  break block95
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32969) {
                                                                                                                                  break block96
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 32993) {
                                                                                                                                  break block97
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33032) {
                                                                                                                                  break block98
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33033) {
                                                                                                                                  break block99
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33035) {
                                                                                                                                  break block100
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33057) {
                                                                                                                                  break block101
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33060) {
                                                                                                                                  break block102
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33097) {
                                                                                                                                  break block103
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33352) {
                                                                                                                                  break block104
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33353) {
                                                                                                                                  break block105
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33356) {
                                                                                                                                  break block106
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33383) {
                                                                                                                                  break block107
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33545) {
                                                                                                                                  break block108
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33569) {
                                                                                                                                  break block109
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33768) {
                                                                                                                                  break block110
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 33889) {
                                                                                                                                  break block111
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 34400) {
                                                                                                                                  break block112
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 35105) {
                                                                                                                                  break block113
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 37479) {
                                                                                                                                  break block114
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 39177) {
                                                                                                                                  break block115
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 47369) {
                                                                                                                                  break block116
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 49929) {
                                                                                                                                  break block117
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 51465) {
                                                                                                                                  break block118
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 51489) {
                                                                                                                                  break block119
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 55560) {
                                                                                                                                  break block120
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 61441) {
                                                                                                                                  break block121
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 61444) {
                                                                                                                                  break block122
                                                                                                                                 }
                                                                                                                                 if (($0 | 0) == 65529) {
                                                                                                                                  break block123
                                                                                                                                 }
                                                                                                                                 break block124;
                                                                                                                                }
                                                                                                                                HEAP32[$5 + 548 >> 2] = 0;
                                                                                                                                FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]();
                                                                                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 548 >> 2];
                                                                                                                                break block125;
                                                                                                                               }
                                                                                                                               HEAP32[$5 + 544 >> 2] = 0;
                                                                                                                               $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                               $0 = HEAP32[$5 + 560 >> 2];
                                                                                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                                $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                               } else {
                                                                                                                                $2 = 0
                                                                                                                               }
                                                                                                                               FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 544 >> 2];
                                                                                                                               break block125;
                                                                                                                              }
                                                                                                                              HEAP32[$5 + 540 >> 2] = 0;
                                                                                                                              $2 = HEAP32[$5 + 568 >> 2];
                                                                                                                              $1 = HEAP32[$5 + 560 >> 2];
                                                                                                                              if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                               $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                              } else {
                                                                                                                               $0 = 0
                                                                                                                              }
                                                                                                                              if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                               $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                                              } else {
                                                                                                                               $3 = 0
                                                                                                                              }
                                                                                                                              FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 540 >> 2];
                                                                                                                              break block125;
                                                                                                                             }
                                                                                                                             HEAP32[$5 + 536 >> 2] = 0;
                                                                                                                             $3 = HEAP32[$5 + 568 >> 2];
                                                                                                                             $2 = HEAP32[$5 + 560 >> 2];
                                                                                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                              $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                             } else {
                                                                                                                              $1 = 0
                                                                                                                             }
                                                                                                                             if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                                             } else {
                                                                                                                              $0 = 0
                                                                                                                             }
                                                                                                                             if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                                                              $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                                                                             } else {
                                                                                                                              $4 = 0
                                                                                                                             }
                                                                                                                             FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
                                                                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 536 >> 2];
                                                                                                                             break block125;
                                                                                                                            }
                                                                                                                            HEAP32[$5 + 532 >> 2] = 0;
                                                                                                                            $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                            $0 = HEAP32[$5 + 560 >> 2];
                                                                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                             $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                            } else {
                                                                                                                             $2 = 0
                                                                                                                            }
                                                                                                                            FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                                                                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 532 >> 2];
                                                                                                                            break block125;
                                                                                                                           }
                                                                                                                           HEAP32[$5 + 528 >> 2] = 0;
                                                                                                                           $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                           $0 = HEAP32[$5 + 560 >> 2];
                                                                                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                            $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                           } else {
                                                                                                                            $2 = 0
                                                                                                                           }
                                                                                                                           FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 528 >> 2];
                                                                                                                           break block125;
                                                                                                                          }
                                                                                                                          HEAP32[$5 + 524 >> 2] = 0;
                                                                                                                          $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                          } else {
                                                                                                                           $0 = 0
                                                                                                                          }
                                                                                                                          $0 = jsvGetInteger($0);
                                                                                                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                           $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                                          } else {
                                                                                                                           $2 = 0
                                                                                                                          }
                                                                                                                          HEAP32[$5 + 524 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 524 >> 2];
                                                                                                                          break block125;
                                                                                                                         }
                                                                                                                         HEAP32[$5 + 520 >> 2] = 0;
                                                                                                                         $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                         } else {
                                                                                                                          $1 = 0
                                                                                                                         }
                                                                                                                         $7 = jsvGetFloat($1);
                                                                                                                         if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                                         } else {
                                                                                                                          $1 = 0
                                                                                                                         }
                                                                                                                         HEAP32[$5 + 520 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0]($7, jsvGetFloat($1)));
                                                                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 520 >> 2];
                                                                                                                         break block125;
                                                                                                                        }
                                                                                                                        HEAP32[$5 + 516 >> 2] = 0;
                                                                                                                        $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                        } else {
                                                                                                                         $0 = 0
                                                                                                                        }
                                                                                                                        $0 = jsvGetInteger($0);
                                                                                                                        if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                                        } else {
                                                                                                                         $2 = 0
                                                                                                                        }
                                                                                                                        HEAP32[$5 + 516 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2)) | 0);
                                                                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 516 >> 2];
                                                                                                                        break block125;
                                                                                                                       }
                                                                                                                       HEAP32[$5 + 512 >> 2] = 0;
                                                                                                                       HEAP32[$5 + 512 >> 2] = jsvNewFromBool(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]) & 1);
                                                                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 512 >> 2];
                                                                                                                       break block125;
                                                                                                                      }
                                                                                                                      HEAP32[$5 + 508 >> 2] = 0;
                                                                                                                      FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]);
                                                                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 508 >> 2];
                                                                                                                      break block125;
                                                                                                                     }
                                                                                                                     HEAP32[$5 + 504 >> 2] = 0;
                                                                                                                     HEAP32[$5 + 504 >> 2] = jsvNewFromPin(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() & 255);
                                                                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 504 >> 2];
                                                                                                                     break block125;
                                                                                                                    }
                                                                                                                    HEAP32[$5 + 500 >> 2] = 0;
                                                                                                                    $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                     $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                    } else {
                                                                                                                     $1 = 0
                                                                                                                    }
                                                                                                                    FUNCTION_TABLE[$0 | 0](jsvGetBool($1) & 1);
                                                                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 500 >> 2];
                                                                                                                    break block125;
                                                                                                                   }
                                                                                                                   HEAP32[$5 + 496 >> 2] = 0;
                                                                                                                   $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                    $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                   } else {
                                                                                                                    $1 = 0
                                                                                                                   }
                                                                                                                   FUNCTION_TABLE[$0 | 0](jsvGetFloat($1));
                                                                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 496 >> 2];
                                                                                                                   break block125;
                                                                                                                  }
                                                                                                                  HEAP32[$5 + 492 >> 2] = 0;
                                                                                                                  $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                   $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                  } else {
                                                                                                                   $1 = 0
                                                                                                                  }
                                                                                                                  FUNCTION_TABLE[$0 | 0]($1);
                                                                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 492 >> 2];
                                                                                                                  break block125;
                                                                                                                 }
                                                                                                                 HEAP32[$5 + 488 >> 2] = 0;
                                                                                                                 HEAP32[$5 + 488 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]();
                                                                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 488 >> 2];
                                                                                                                 break block125;
                                                                                                                }
                                                                                                                HEAP32[$5 + 484 >> 2] = 0;
                                                                                                                $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                 $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                                } else {
                                                                                                                 $1 = 0
                                                                                                                }
                                                                                                                FUNCTION_TABLE[$0 | 0](jsvGetInteger($1));
                                                                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 484 >> 2];
                                                                                                                break block125;
                                                                                                               }
                                                                                                               HEAP32[$5 + 480 >> 2] = 0;
                                                                                                               $3 = HEAP32[$5 + 568 >> 2];
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                               } else {
                                                                                                                $1 = 0
                                                                                                               }
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                               } else {
                                                                                                                $0 = 0
                                                                                                               }
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                                                $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                                                               } else {
                                                                                                                $2 = 0
                                                                                                               }
                                                                                                               $2 = jsvGetInteger($2);
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 3) {
                                                                                                                $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                                                                                                               } else {
                                                                                                                $4 = 0
                                                                                                               }
                                                                                                               FUNCTION_TABLE[$3 | 0]($1, $0, $2, $4);
                                                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 480 >> 2];
                                                                                                               break block125;
                                                                                                              }
                                                                                                              HEAP32[$5 + 476 >> 2] = 0;
                                                                                                              HEAP32[$5 + 476 >> 2] = jsvNewFromBool(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() & 1);
                                                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 476 >> 2];
                                                                                                              break block125;
                                                                                                             }
                                                                                                             HEAP32[$5 + 472 >> 2] = 0;
                                                                                                             $1 = HEAP32[$5 + 568 >> 2];
                                                                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                             } else {
                                                                                                              $0 = 0
                                                                                                             }
                                                                                                             $0 = jsvGetInteger($0);
                                                                                                             if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                              $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                             } else {
                                                                                                              $2 = 0
                                                                                                             }
                                                                                                             FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 472 >> 2];
                                                                                                             break block125;
                                                                                                            }
                                                                                                            HEAP32[$5 + 468 >> 2] = 0;
                                                                                                            $1 = HEAP32[$5 + 568 >> 2];
                                                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                            } else {
                                                                                                             $0 = 0
                                                                                                            }
                                                                                                            $0 = jsvGetBool($0) & 1;
                                                                                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                             $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                            } else {
                                                                                                             $2 = 0
                                                                                                            }
                                                                                                            HEAP32[$5 + 468 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$1 | 0]($0, $2) & 1);
                                                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 468 >> 2];
                                                                                                            break block125;
                                                                                                           }
                                                                                                           HEAP32[$5 + 464 >> 2] = 0;
                                                                                                           HEAP32[$5 + 464 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() | 0);
                                                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 464 >> 2];
                                                                                                           break block125;
                                                                                                          }
                                                                                                          HEAP32[$5 + 460 >> 2] = 0;
                                                                                                          $0 = HEAP32[$5 + 568 >> 2];
                                                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                          } else {
                                                                                                           $1 = 0
                                                                                                          }
                                                                                                          HEAP32[$5 + 460 >> 2] = FUNCTION_TABLE[$0 | 0]($1);
                                                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 460 >> 2];
                                                                                                          break block125;
                                                                                                         }
                                                                                                         HEAP32[$5 + 456 >> 2] = 0;
                                                                                                         $1 = HEAP32[$5 + 568 >> 2];
                                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                          $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                         } else {
                                                                                                          $0 = 0
                                                                                                         }
                                                                                                         $0 = jsvGetInteger($0);
                                                                                                         if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                          $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                         } else {
                                                                                                          $2 = 0
                                                                                                         }
                                                                                                         FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 456 >> 2];
                                                                                                         break block125;
                                                                                                        }
                                                                                                        HEAP32[$5 + 452 >> 2] = 0;
                                                                                                        $1 = HEAP32[$5 + 568 >> 2];
                                                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                        } else {
                                                                                                         $0 = 0
                                                                                                        }
                                                                                                        $0 = jsvGetInteger($0);
                                                                                                        if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                        } else {
                                                                                                         $2 = 0
                                                                                                        }
                                                                                                        HEAP32[$5 + 452 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2));
                                                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 452 >> 2];
                                                                                                        break block125;
                                                                                                       }
                                                                                                       HEAP32[$5 + 448 >> 2] = 0;
                                                                                                       $1 = HEAP32[$5 + 568 >> 2];
                                                                                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                       } else {
                                                                                                        $0 = 0
                                                                                                       }
                                                                                                       if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                        $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                       } else {
                                                                                                        $2 = 0
                                                                                                       }
                                                                                                       FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 448 >> 2];
                                                                                                       break block125;
                                                                                                      }
                                                                                                      HEAP32[$5 + 444 >> 2] = 0;
                                                                                                      $1 = HEAP32[$5 + 568 >> 2];
                                                                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                      } else {
                                                                                                       $0 = 0
                                                                                                      }
                                                                                                      if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                       $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                      } else {
                                                                                                       $2 = 0
                                                                                                      }
                                                                                                      HEAP32[$5 + 444 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 444 >> 2];
                                                                                                      break block125;
                                                                                                     }
                                                                                                     HEAP32[$5 + 440 >> 2] = 0;
                                                                                                     HEAP32[$5 + 440 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]();
                                                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 440 >> 2];
                                                                                                     break block125;
                                                                                                    }
                                                                                                    HEAP32[$5 + 436 >> 2] = 0;
                                                                                                    $1 = HEAP32[$5 + 568 >> 2];
                                                                                                    $0 = HEAP32[$5 + 560 >> 2];
                                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                     $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                    } else {
                                                                                                     $2 = 0
                                                                                                    }
                                                                                                    HEAP32[$5 + 436 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 436 >> 2];
                                                                                                    break block125;
                                                                                                   }
                                                                                                   HEAP32[$5 + 432 >> 2] = 0;
                                                                                                   block162 : {
                                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                     $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                                                     break block162;
                                                                                                    }
                                                                                                    $0 = jsvNewEmptyArray();
                                                                                                   }
                                                                                                   HEAP32[$5 + 428 >> 2] = $0;
                                                                                                   HEAP32[$5 + 432 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 428 >> 2]);
                                                                                                   jsvUnLock(HEAP32[$5 + 428 >> 2]);
                                                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 432 >> 2];
                                                                                                   break block125;
                                                                                                  }
                                                                                                  HEAP32[$5 + 424 >> 2] = 0;
                                                                                                  $1 = HEAP32[$5 + 568 >> 2];
                                                                                                  $0 = HEAP32[$5 + 560 >> 2];
                                                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                   $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                  } else {
                                                                                                   $2 = 0
                                                                                                  }
                                                                                                  HEAP32[$5 + 424 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 424 >> 2];
                                                                                                  break block125;
                                                                                                 }
                                                                                                 HEAP32[$5 + 420 >> 2] = 0;
                                                                                                 HEAP32[$5 + 420 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]);
                                                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 420 >> 2];
                                                                                                 break block125;
                                                                                                }
                                                                                                HEAP32[$5 + 416 >> 2] = 0;
                                                                                                $2 = HEAP32[$5 + 568 >> 2];
                                                                                                $1 = HEAP32[$5 + 560 >> 2];
                                                                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                                } else {
                                                                                                 $0 = 0
                                                                                                }
                                                                                                if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                 $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                                } else {
                                                                                                 $3 = 0
                                                                                                }
                                                                                                HEAP32[$5 + 416 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3));
                                                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 416 >> 2];
                                                                                                break block125;
                                                                                               }
                                                                                               HEAP32[$5 + 412 >> 2] = 0;
                                                                                               $2 = HEAP32[$5 + 568 >> 2];
                                                                                               $1 = HEAP32[$5 + 560 >> 2];
                                                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                               } else {
                                                                                                $0 = 0
                                                                                               }
                                                                                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                               } else {
                                                                                                $3 = 0
                                                                                               }
                                                                                               HEAP32[$5 + 412 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3)) & 1);
                                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 412 >> 2];
                                                                                               break block125;
                                                                                              }
                                                                                              HEAP32[$5 + 408 >> 2] = 0;
                                                                                              block168 : {
                                                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                                                break block168;
                                                                                               }
                                                                                               $0 = jsvNewEmptyArray();
                                                                                              }
                                                                                              HEAP32[$5 + 404 >> 2] = $0;
                                                                                              HEAP32[$5 + 408 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2], HEAP32[$5 + 404 >> 2]) | 0);
                                                                                              jsvUnLock(HEAP32[$5 + 404 >> 2]);
                                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 408 >> 2];
                                                                                              break block125;
                                                                                             }
                                                                                             HEAP32[$5 + 400 >> 2] = 0;
                                                                                             HEAP32[$5 + 400 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]);
                                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 400 >> 2];
                                                                                             break block125;
                                                                                            }
                                                                                            HEAP32[$5 + 396 >> 2] = 0;
                                                                                            $2 = HEAP32[$5 + 568 >> 2];
                                                                                            $1 = HEAP32[$5 + 560 >> 2];
                                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                            } else {
                                                                                             $0 = 0
                                                                                            }
                                                                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                             $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                            } else {
                                                                                             $3 = 0
                                                                                            }
                                                                                            HEAP32[$5 + 396 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 396 >> 2];
                                                                                            break block125;
                                                                                           }
                                                                                           HEAP32[$5 + 392 >> 2] = 0;
                                                                                           block171 : {
                                                                                            if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                             $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 8 | 0, HEAP32[$5 + 552 >> 2] - 2 | 0);
                                                                                             break block171;
                                                                                            }
                                                                                            $0 = jsvNewEmptyArray();
                                                                                           }
                                                                                           HEAP32[$5 + 388 >> 2] = $0;
                                                                                           $2 = HEAP32[$5 + 568 >> 2];
                                                                                           $1 = HEAP32[$5 + 560 >> 2];
                                                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                           } else {
                                                                                            $0 = 0
                                                                                           }
                                                                                           $0 = jsvGetInteger($0);
                                                                                           if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                            $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                           } else {
                                                                                            $3 = 0
                                                                                           }
                                                                                           HEAP32[$5 + 392 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3, HEAP32[$5 + 388 >> 2]);
                                                                                           jsvUnLock(HEAP32[$5 + 388 >> 2]);
                                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 392 >> 2];
                                                                                           break block125;
                                                                                          }
                                                                                          HEAP32[$5 + 384 >> 2] = 0;
                                                                                          $2 = HEAP32[$5 + 568 >> 2];
                                                                                          $1 = HEAP32[$5 + 560 >> 2];
                                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                          } else {
                                                                                           $0 = 0
                                                                                          }
                                                                                          $0 = jsvGetInteger($0);
                                                                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                           $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                          } else {
                                                                                           $3 = 0
                                                                                          }
                                                                                          HEAP32[$5 + 384 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 384 >> 2];
                                                                                          break block125;
                                                                                         }
                                                                                         HEAP32[$5 + 380 >> 2] = 0;
                                                                                         $0 = HEAP32[$5 + 568 >> 2];
                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                         } else {
                                                                                          $1 = 0
                                                                                         }
                                                                                         HEAP32[$5 + 380 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$0 | 0]($1) & 1);
                                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 380 >> 2];
                                                                                         break block125;
                                                                                        }
                                                                                        HEAP32[$5 + 376 >> 2] = 0;
                                                                                        block177 : {
                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                          $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                                          break block177;
                                                                                         }
                                                                                         $0 = jsvNewEmptyArray();
                                                                                        }
                                                                                        HEAP32[$5 + 372 >> 2] = $0;
                                                                                        HEAP32[$5 + 376 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2], HEAP32[$5 + 372 >> 2]);
                                                                                        jsvUnLock(HEAP32[$5 + 372 >> 2]);
                                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 376 >> 2];
                                                                                        break block125;
                                                                                       }
                                                                                       HEAP32[$5 + 368 >> 2] = 0;
                                                                                       $3 = HEAP32[$5 + 568 >> 2];
                                                                                       $2 = HEAP32[$5 + 560 >> 2];
                                                                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                       } else {
                                                                                        $0 = 0
                                                                                       }
                                                                                       if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                        $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                       } else {
                                                                                        $1 = 0
                                                                                       }
                                                                                       $1 = jsvGetInteger($1);
                                                                                       if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                        $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                                       } else {
                                                                                        $4 = 0
                                                                                       }
                                                                                       HEAP32[$5 + 368 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $0, $1, $4);
                                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 368 >> 2];
                                                                                       break block125;
                                                                                      }
                                                                                      HEAP32[$5 + 364 >> 2] = 0;
                                                                                      $0 = HEAP32[$5 + 568 >> 2];
                                                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                      } else {
                                                                                       $1 = 0
                                                                                      }
                                                                                      HEAP32[$5 + 364 >> 2] = FUNCTION_TABLE[$0 | 0](jsvGetInteger($1));
                                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 364 >> 2];
                                                                                      break block125;
                                                                                     }
                                                                                     HEAP32[$5 + 360 >> 2] = 0;
                                                                                     HEAP32[$5 + 360 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]) | 0);
                                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 360 >> 2];
                                                                                     break block125;
                                                                                    }
                                                                                    HEAP32[$5 + 356 >> 2] = 0;
                                                                                    $2 = HEAP32[$5 + 568 >> 2];
                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                    } else {
                                                                                     $0 = 0
                                                                                    }
                                                                                    if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                     $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                    } else {
                                                                                     $1 = 0
                                                                                    }
                                                                                    $1 = jsvGetInteger($1);
                                                                                    if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                     $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                                    } else {
                                                                                     $3 = 0
                                                                                    }
                                                                                    HEAP32[$5 + 356 >> 2] = FUNCTION_TABLE[$2 | 0]($0, $1, jsvGetInteger($3));
                                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 356 >> 2];
                                                                                    break block125;
                                                                                   }
                                                                                   HEAP32[$5 + 352 >> 2] = 0;
                                                                                   $2 = HEAP32[$5 + 568 >> 2];
                                                                                   $1 = HEAP32[$5 + 560 >> 2];
                                                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                   } else {
                                                                                    $0 = 0
                                                                                   }
                                                                                   if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                    $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                   } else {
                                                                                    $3 = 0
                                                                                   }
                                                                                   FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3));
                                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 352 >> 2];
                                                                                   break block125;
                                                                                  }
                                                                                  HEAP32[$5 + 348 >> 2] = 0;
                                                                                  $2 = HEAP32[$5 + 568 >> 2];
                                                                                  $1 = HEAP32[$5 + 560 >> 2];
                                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                   $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                  } else {
                                                                                   $0 = 0
                                                                                  }
                                                                                  $0 = jsvGetInteger($0);
                                                                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                   $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                  } else {
                                                                                   $3 = 0
                                                                                  }
                                                                                  HEAP32[$5 + 348 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 348 >> 2];
                                                                                  break block125;
                                                                                 }
                                                                                 HEAP32[$5 + 344 >> 2] = 0;
                                                                                 $3 = HEAP32[$5 + 568 >> 2];
                                                                                 $2 = HEAP32[$5 + 560 >> 2];
                                                                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                  $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                                 } else {
                                                                                  $0 = 0
                                                                                 }
                                                                                 $1 = jsvGetInteger($0);
                                                                                 if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                  $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                                 } else {
                                                                                  $0 = 0
                                                                                 }
                                                                                 if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                  $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                                 } else {
                                                                                  $4 = 0
                                                                                 }
                                                                                 FUNCTION_TABLE[$3 | 0]($2, $1, $0, jsvGetBool($4) & 1);
                                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 344 >> 2];
                                                                                 break block125;
                                                                                }
                                                                                HEAP32[$5 + 340 >> 2] = 0;
                                                                                HEAP32[$5 + 340 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]());
                                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 340 >> 2];
                                                                                break block125;
                                                                               }
                                                                               HEAP32[$5 + 336 >> 2] = 0;
                                                                               HEAP32[$5 + 336 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]) | 0);
                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 336 >> 2];
                                                                               break block125;
                                                                              }
                                                                              HEAP32[$5 + 332 >> 2] = 0;
                                                                              HEAP32[$5 + 332 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]));
                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 332 >> 2];
                                                                              break block125;
                                                                             }
                                                                             HEAP32[$5 + 328 >> 2] = 0;
                                                                             $1 = HEAP32[$5 + 568 >> 2];
                                                                             $0 = HEAP32[$5 + 560 >> 2];
                                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                              $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                             } else {
                                                                              $2 = 0
                                                                             }
                                                                             HEAP32[$5 + 328 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2)));
                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 328 >> 2];
                                                                             break block125;
                                                                            }
                                                                            HEAP32[$5 + 324 >> 2] = 0;
                                                                            $4 = HEAP32[$5 + 568 >> 2];
                                                                            $3 = HEAP32[$5 + 560 >> 2];
                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                            } else {
                                                                             $0 = 0
                                                                            }
                                                                            $2 = jsvGetInteger($0);
                                                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                            } else {
                                                                             $1 = 0
                                                                            }
                                                                            if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                            } else {
                                                                             $0 = 0
                                                                            }
                                                                            if (HEAP32[$5 + 552 >> 2] > 3) {
                                                                             $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                                                                            } else {
                                                                             $6 = 0
                                                                            }
                                                                            HEAP32[$5 + 324 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$4 | 0]($3, $2, $1, $0, $6));
                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 324 >> 2];
                                                                            break block125;
                                                                           }
                                                                           HEAP32[$5 + 320 >> 2] = 0;
                                                                           $3 = HEAP32[$5 + 568 >> 2];
                                                                           $2 = HEAP32[$5 + 560 >> 2];
                                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                           } else {
                                                                            $0 = 0
                                                                           }
                                                                           $1 = jsvGetInteger($0);
                                                                           if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                           } else {
                                                                            $0 = 0
                                                                           }
                                                                           if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                            $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                           } else {
                                                                            $4 = 0
                                                                           }
                                                                           HEAP32[$5 + 320 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4));
                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 320 >> 2];
                                                                           break block125;
                                                                          }
                                                                          HEAP32[$5 + 316 >> 2] = 0;
                                                                          $2 = HEAP32[$5 + 568 >> 2];
                                                                          $1 = HEAP32[$5 + 560 >> 2];
                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                          } else {
                                                                           $0 = 0
                                                                          }
                                                                          $0 = jsvGetInteger($0);
                                                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                           $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                          } else {
                                                                           $3 = 0
                                                                          }
                                                                          HEAP32[$5 + 316 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$2 | 0]($1, $0, $3));
                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 316 >> 2];
                                                                          break block125;
                                                                         }
                                                                         HEAP32[$5 + 312 >> 2] = 0;
                                                                         $1 = HEAP32[$5 + 568 >> 2];
                                                                         $0 = HEAP32[$5 + 560 >> 2];
                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                          $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                         } else {
                                                                          $2 = 0
                                                                         }
                                                                         HEAP32[$5 + 312 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2)));
                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 312 >> 2];
                                                                         break block125;
                                                                        }
                                                                        HEAP32[$5 + 308 >> 2] = 0;
                                                                        $0 = HEAP32[$5 + 568 >> 2];
                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                         $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                        } else {
                                                                         $1 = 0
                                                                        }
                                                                        HEAP32[$5 + 308 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0]($1));
                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 308 >> 2];
                                                                        break block125;
                                                                       }
                                                                       HEAP32[$5 + 304 >> 2] = 0;
                                                                       block204 : {
                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                         $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                         break block204;
                                                                        }
                                                                        $0 = jsvNewEmptyArray();
                                                                       }
                                                                       HEAP32[$5 + 300 >> 2] = $0;
                                                                       FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 300 >> 2]);
                                                                       jsvUnLock(HEAP32[$5 + 300 >> 2]);
                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 304 >> 2];
                                                                       break block125;
                                                                      }
                                                                      HEAP32[$5 + 296 >> 2] = 0;
                                                                      $2 = HEAP32[$5 + 568 >> 2];
                                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                      } else {
                                                                       $1 = 0
                                                                      }
                                                                      if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                                      } else {
                                                                       $0 = 0
                                                                      }
                                                                      if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                       $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                                      } else {
                                                                       $3 = 0
                                                                      }
                                                                      HEAP32[$5 + 296 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 296 >> 2];
                                                                      break block125;
                                                                     }
                                                                     HEAP32[$5 + 292 >> 2] = 0;
                                                                     HEAP32[$5 + 292 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]());
                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 292 >> 2];
                                                                     break block125;
                                                                    }
                                                                    HEAP32[$5 + 288 >> 2] = 0;
                                                                    HEAP32[$5 + 288 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() | 0);
                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 288 >> 2];
                                                                    break block125;
                                                                   }
                                                                   HEAP32[$5 + 284 >> 2] = 0;
                                                                   $1 = HEAP32[$5 + 568 >> 2];
                                                                   $0 = HEAP32[$5 + 560 >> 2];
                                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                    $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                   } else {
                                                                    $2 = 0
                                                                   }
                                                                   HEAP32[$5 + 284 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$1 | 0]($0, $2) & 1);
                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 284 >> 2];
                                                                   break block125;
                                                                  }
                                                                  HEAP32[$5 + 280 >> 2] = 0;
                                                                  block209 : {
                                                                   if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                    $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 4 | 0, HEAP32[$5 + 552 >> 2] - 1 | 0);
                                                                    break block209;
                                                                   }
                                                                   $0 = jsvNewEmptyArray();
                                                                  }
                                                                  HEAP32[$5 + 276 >> 2] = $0;
                                                                  $1 = HEAP32[$5 + 568 >> 2];
                                                                  $0 = HEAP32[$5 + 560 >> 2];
                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                   $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                  } else {
                                                                   $2 = 0
                                                                  }
                                                                  FUNCTION_TABLE[$1 | 0]($0, $2, HEAP32[$5 + 276 >> 2]);
                                                                  jsvUnLock(HEAP32[$5 + 276 >> 2]);
                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 280 >> 2];
                                                                  break block125;
                                                                 }
                                                                 HEAP32[$5 + 272 >> 2] = 0;
                                                                 block211 : {
                                                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                   $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 4 | 0, HEAP32[$5 + 552 >> 2] - 1 | 0);
                                                                   break block211;
                                                                  }
                                                                  $0 = jsvNewEmptyArray();
                                                                 }
                                                                 HEAP32[$5 + 268 >> 2] = $0;
                                                                 $1 = HEAP32[$5 + 568 >> 2];
                                                                 $0 = HEAP32[$5 + 560 >> 2];
                                                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                  $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                 } else {
                                                                  $2 = 0
                                                                 }
                                                                 HEAP32[$5 + 272 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $2, HEAP32[$5 + 268 >> 2]);
                                                                 jsvUnLock(HEAP32[$5 + 268 >> 2]);
                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 272 >> 2];
                                                                 break block125;
                                                                }
                                                                HEAP32[$5 + 264 >> 2] = 0;
                                                                $0 = HEAP32[$5 + 568 >> 2];
                                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                 $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                                } else {
                                                                 $1 = 0
                                                                }
                                                                HEAP32[$5 + 264 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0]($1) | 0);
                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 264 >> 2];
                                                                break block125;
                                                               }
                                                               HEAP32[$5 + 260 >> 2] = 0;
                                                               $0 = HEAP32[$5 + 568 >> 2];
                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                               } else {
                                                                $1 = 0
                                                               }
                                                               HEAP32[$5 + 260 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$0 | 0](jsvGetInteger($1)) & 1);
                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 260 >> 2];
                                                               break block125;
                                                              }
                                                              HEAP32[$5 + 256 >> 2] = 0;
                                                              $2 = HEAP32[$5 + 568 >> 2];
                                                              $1 = HEAP32[$5 + 560 >> 2];
                                                              if (HEAP32[$5 + 552 >> 2] > 0) {
                                                               $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                              } else {
                                                               $0 = 0
                                                              }
                                                              if (HEAP32[$5 + 552 >> 2] > 1) {
                                                               $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                              } else {
                                                               $3 = 0
                                                              }
                                                              HEAP32[$5 + 256 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$2 | 0]($1, $0, $3) | 0);
                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 256 >> 2];
                                                              break block125;
                                                             }
                                                             HEAP32[$5 + 252 >> 2] = 0;
                                                             $2 = HEAP32[$5 + 568 >> 2];
                                                             $1 = HEAP32[$5 + 560 >> 2];
                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                             } else {
                                                              $0 = 0
                                                             }
                                                             if (HEAP32[$5 + 552 >> 2] > 1) {
                                                              $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                             } else {
                                                              $3 = 0
                                                             }
                                                             HEAP32[$5 + 252 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$2 | 0]($1, $0, $3) & 1);
                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 252 >> 2];
                                                             break block125;
                                                            }
                                                            HEAP32[$5 + 248 >> 2] = 0;
                                                            $0 = HEAP32[$5 + 568 >> 2];
                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                            } else {
                                                             $1 = 0
                                                            }
                                                            HEAP32[$5 + 248 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0](jsvGetFloat($1)));
                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 248 >> 2];
                                                            break block125;
                                                           }
                                                           HEAP32[$5 + 244 >> 2] = 0;
                                                           $0 = HEAP32[$5 + 568 >> 2];
                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                            $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                           } else {
                                                            $1 = 0
                                                           }
                                                           HEAP32[$5 + 244 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0](jsvGetInteger($1)) | 0);
                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 244 >> 2];
                                                           break block125;
                                                          }
                                                          HEAP32[$5 + 240 >> 2] = 0;
                                                          $0 = HEAP32[$5 + 568 >> 2];
                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                          } else {
                                                           $1 = 0
                                                          }
                                                          HEAP32[$5 + 240 >> 2] = FUNCTION_TABLE[$0 | 0](jsvGetFloat($1));
                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 240 >> 2];
                                                          break block125;
                                                         }
                                                         HEAP32[$5 + 236 >> 2] = 0;
                                                         $0 = HEAP32[$5 + 568 >> 2];
                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                         } else {
                                                          $1 = 0
                                                         }
                                                         $8 = jsvGetFloat($1);
                                                         if (HEAP32[$5 + 552 >> 2] > 1) {
                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                         } else {
                                                          $1 = 0
                                                         }
                                                         $7 = jsvGetFloat($1);
                                                         if (HEAP32[$5 + 552 >> 2] > 2) {
                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                         } else {
                                                          $1 = 0
                                                         }
                                                         HEAP32[$5 + 236 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0]($8, $7, jsvGetFloat($1)));
                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 236 >> 2];
                                                         break block125;
                                                        }
                                                        HEAP32[$5 + 232 >> 2] = 0;
                                                        block225 : {
                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                          $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                          break block225;
                                                         }
                                                         $0 = jsvNewEmptyArray();
                                                        }
                                                        HEAP32[$5 + 228 >> 2] = $0;
                                                        HEAP32[$5 + 232 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 228 >> 2]));
                                                        jsvUnLock(HEAP32[$5 + 228 >> 2]);
                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 232 >> 2];
                                                        break block125;
                                                       }
                                                       HEAP32[$5 + 224 >> 2] = 0;
                                                       $0 = HEAP32[$5 + 568 >> 2];
                                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                                        $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                       } else {
                                                        $1 = 0
                                                       }
                                                       HEAP32[$5 + 224 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0](jsvGetFloat($1)) | 0);
                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 224 >> 2];
                                                       break block125;
                                                      }
                                                      HEAP32[$5 + 220 >> 2] = 0;
                                                      $0 = HEAP32[$5 + 568 >> 2];
                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                      } else {
                                                       $1 = 0
                                                      }
                                                      HEAP32[$5 + 220 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0](jsvGetBool($1) & 1));
                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 220 >> 2];
                                                      break block125;
                                                     }
                                                     HEAP32[$5 + 216 >> 2] = 0;
                                                     $2 = HEAP32[$5 + 568 >> 2];
                                                     if (HEAP32[$5 + 552 >> 2] > 0) {
                                                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                     } else {
                                                      $0 = 0
                                                     }
                                                     $1 = jsvGetInteger($0);
                                                     if (HEAP32[$5 + 552 >> 2] > 1) {
                                                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                     } else {
                                                      $0 = 0
                                                     }
                                                     if (HEAP32[$5 + 552 >> 2] > 2) {
                                                      $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                     } else {
                                                      $3 = 0
                                                     }
                                                     HEAP32[$5 + 216 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 216 >> 2];
                                                     break block125;
                                                    }
                                                    HEAP32[$5 + 212 >> 2] = 0;
                                                    $1 = HEAP32[$5 + 568 >> 2];
                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                    } else {
                                                     $0 = 0
                                                    }
                                                    if (HEAP32[$5 + 552 >> 2] > 1) {
                                                     $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                    } else {
                                                     $2 = 0
                                                    }
                                                    HEAP32[$5 + 212 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2)));
                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 212 >> 2];
                                                    break block125;
                                                   }
                                                   HEAP32[$5 + 208 >> 2] = 0;
                                                   $2 = HEAP32[$5 + 568 >> 2];
                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                    $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                   } else {
                                                    $1 = 0
                                                   }
                                                   if (HEAP32[$5 + 552 >> 2] > 1) {
                                                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                   } else {
                                                    $0 = 0
                                                   }
                                                   if (HEAP32[$5 + 552 >> 2] > 2) {
                                                    $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                   } else {
                                                    $3 = 0
                                                   }
                                                   HEAP32[$5 + 208 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3)));
                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 208 >> 2];
                                                   break block125;
                                                  }
                                                  HEAP32[$5 + 204 >> 2] = 0;
                                                  $2 = HEAP32[$5 + 568 >> 2];
                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                   $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                  } else {
                                                   $1 = 0
                                                  }
                                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                                   $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                  } else {
                                                   $0 = 0
                                                  }
                                                  if (HEAP32[$5 + 552 >> 2] > 2) {
                                                   $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                  } else {
                                                   $3 = 0
                                                  }
                                                  FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 204 >> 2];
                                                  break block125;
                                                 }
                                                 HEAP32[$5 + 200 >> 2] = 0;
                                                 $0 = HEAP32[$5 + 568 >> 2];
                                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                 } else {
                                                  $1 = 0
                                                 }
                                                 $7 = jsvGetFloat($1);
                                                 if (HEAP32[$5 + 552 >> 2] > 1) {
                                                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                 } else {
                                                  $1 = 0
                                                 }
                                                 FUNCTION_TABLE[$0 | 0]($7, $1);
                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 200 >> 2];
                                                 break block125;
                                                }
                                                HEAP32[$5 + 196 >> 2] = 0;
                                                $2 = HEAP32[$5 + 568 >> 2];
                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                 $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                                } else {
                                                 $1 = 0
                                                }
                                                if (HEAP32[$5 + 552 >> 2] > 1) {
                                                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                                } else {
                                                 $0 = 0
                                                }
                                                if (HEAP32[$5 + 552 >> 2] > 2) {
                                                 $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                                } else {
                                                 $3 = 0
                                                }
                                                FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 196 >> 2];
                                                break block125;
                                               }
                                               HEAP32[$5 + 192 >> 2] = 0;
                                               $1 = HEAP32[$5 + 568 >> 2];
                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                               } else {
                                                $0 = 0
                                               }
                                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                                $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                               } else {
                                                $2 = 0
                                               }
                                               FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 192 >> 2];
                                               break block125;
                                              }
                                              HEAP32[$5 + 188 >> 2] = 0;
                                              $1 = HEAP32[$5 + 568 >> 2];
                                              if (HEAP32[$5 + 552 >> 2] > 0) {
                                               $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                              } else {
                                               $0 = 0
                                              }
                                              if (HEAP32[$5 + 552 >> 2] > 1) {
                                               $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                              } else {
                                               $2 = 0
                                              }
                                              HEAP32[$5 + 188 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 188 >> 2];
                                              break block125;
                                             }
                                             HEAP32[$5 + 184 >> 2] = 0;
                                             $1 = HEAP32[$5 + 568 >> 2];
                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                             } else {
                                              $0 = 0
                                             }
                                             if (HEAP32[$5 + 552 >> 2] > 1) {
                                              $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                             } else {
                                              $2 = 0
                                             }
                                             HEAP32[$5 + 184 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1) | 0);
                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 184 >> 2];
                                             break block125;
                                            }
                                            HEAP32[$5 + 180 >> 2] = 0;
                                            $3 = HEAP32[$5 + 568 >> 2];
                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                             $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                            } else {
                                             $2 = 0
                                            }
                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                            } else {
                                             $1 = 0
                                            }
                                            if (HEAP32[$5 + 552 >> 2] > 2) {
                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                            } else {
                                             $0 = 0
                                            }
                                            if (HEAP32[$5 + 552 >> 2] > 3) {
                                             $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                                            } else {
                                             $4 = 0
                                            }
                                            FUNCTION_TABLE[$3 | 0]($2, $1, $0, jsvGetInteger($4));
                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 180 >> 2];
                                            break block125;
                                           }
                                           HEAP32[$5 + 176 >> 2] = 0;
                                           $2 = HEAP32[$5 + 568 >> 2];
                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                            $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                           } else {
                                            $1 = 0
                                           }
                                           if (HEAP32[$5 + 552 >> 2] > 1) {
                                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                           } else {
                                            $0 = 0
                                           }
                                           if (HEAP32[$5 + 552 >> 2] > 2) {
                                            $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                           } else {
                                            $3 = 0
                                           }
                                           HEAP32[$5 + 176 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 176 >> 2];
                                           break block125;
                                          }
                                          HEAP32[$5 + 172 >> 2] = 0;
                                          $0 = HEAP32[$5 + 568 >> 2];
                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                          } else {
                                           $1 = 0
                                          }
                                          $9 = jsvGetFloat($1);
                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                          } else {
                                           $1 = 0
                                          }
                                          $8 = jsvGetFloat($1);
                                          if (HEAP32[$5 + 552 >> 2] > 2) {
                                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                          } else {
                                           $1 = 0
                                          }
                                          $7 = jsvGetFloat($1);
                                          if (HEAP32[$5 + 552 >> 2] > 3) {
                                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                                          } else {
                                           $1 = 0
                                          }
                                          HEAP32[$5 + 172 >> 2] = FUNCTION_TABLE[$0 | 0]($9, $8, $7, jsvGetInteger($1));
                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 172 >> 2];
                                          break block125;
                                         }
                                         HEAP32[$5 + 168 >> 2] = 0;
                                         block261 : {
                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                           $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 4 | 0, HEAP32[$5 + 552 >> 2] - 1 | 0);
                                           break block261;
                                          }
                                          $0 = jsvNewEmptyArray();
                                         }
                                         HEAP32[$5 + 164 >> 2] = $0;
                                         $0 = HEAP32[$5 + 568 >> 2];
                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                         } else {
                                          $1 = 0
                                         }
                                         FUNCTION_TABLE[$0 | 0]($1, HEAP32[$5 + 164 >> 2]);
                                         jsvUnLock(HEAP32[$5 + 164 >> 2]);
                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 168 >> 2];
                                         break block125;
                                        }
                                        HEAP32[$5 + 160 >> 2] = 0;
                                        $1 = HEAP32[$5 + 568 >> 2];
                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                        } else {
                                         $0 = 0
                                        }
                                        if (HEAP32[$5 + 552 >> 2] > 1) {
                                         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                        } else {
                                         $2 = 0
                                        }
                                        FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 160 >> 2];
                                        break block125;
                                       }
                                       HEAP32[$5 + 156 >> 2] = 0;
                                       block265 : {
                                        if (HEAP32[$5 + 552 >> 2] > 2) {
                                         $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 8 | 0, HEAP32[$5 + 552 >> 2] - 2 | 0);
                                         break block265;
                                        }
                                        $0 = jsvNewEmptyArray();
                                       }
                                       HEAP32[$5 + 152 >> 2] = $0;
                                       $1 = HEAP32[$5 + 568 >> 2];
                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                       } else {
                                        $0 = 0
                                       }
                                       if (HEAP32[$5 + 552 >> 2] > 1) {
                                        $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                       } else {
                                        $2 = 0
                                       }
                                       HEAP32[$5 + 156 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2), HEAP32[$5 + 152 >> 2]);
                                       jsvUnLock(HEAP32[$5 + 152 >> 2]);
                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 156 >> 2];
                                       break block125;
                                      }
                                      HEAP32[$5 + 148 >> 2] = 0;
                                      $1 = HEAP32[$5 + 568 >> 2];
                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                      } else {
                                       $0 = 0
                                      }
                                      if (HEAP32[$5 + 552 >> 2] > 1) {
                                       $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                      } else {
                                       $2 = 0
                                      }
                                      FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2));
                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 148 >> 2];
                                      break block125;
                                     }
                                     HEAP32[$5 + 144 >> 2] = 0;
                                     $0 = HEAP32[$5 + 568 >> 2];
                                     if (HEAP32[$5 + 552 >> 2] > 0) {
                                      $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                     } else {
                                      $1 = 0
                                     }
                                     HEAP32[$5 + 144 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0](jshGetPinFromVar($1) & 255));
                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 144 >> 2];
                                     break block125;
                                    }
                                    HEAP32[$5 + 140 >> 2] = 0;
                                    $1 = HEAP32[$5 + 568 >> 2];
                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                    } else {
                                     $0 = 0
                                    }
                                    $0 = jshGetPinFromVar($0) & 255;
                                    if (HEAP32[$5 + 552 >> 2] > 1) {
                                     $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                    } else {
                                     $2 = 0
                                    }
                                    $7 = jsvGetFloat($2);
                                    if (HEAP32[$5 + 552 >> 2] > 2) {
                                     $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                    } else {
                                     $2 = 0
                                    }
                                    FUNCTION_TABLE[$1 | 0]($0, $7, $2);
                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 140 >> 2];
                                    break block125;
                                   }
                                   HEAP32[$5 + 136 >> 2] = 0;
                                   $2 = HEAP32[$5 + 568 >> 2];
                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                   } else {
                                    $0 = 0
                                   }
                                   $1 = jshGetPinFromVar($0) & 255;
                                   if (HEAP32[$5 + 552 >> 2] > 1) {
                                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                   } else {
                                    $0 = 0
                                   }
                                   $0 = jsvGetBool($0) & 1;
                                   if (HEAP32[$5 + 552 >> 2] > 2) {
                                    $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                   } else {
                                    $3 = 0
                                   }
                                   FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 136 >> 2];
                                   break block125;
                                  }
                                  HEAP32[$5 + 132 >> 2] = 0;
                                  $2 = HEAP32[$5 + 568 >> 2];
                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                   $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                  } else {
                                   $0 = 0
                                  }
                                  $1 = jshGetPinFromVar($0) & 255;
                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                   $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                  } else {
                                   $0 = 0
                                  }
                                  if (HEAP32[$5 + 552 >> 2] > 2) {
                                   $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                  } else {
                                   $3 = 0
                                  }
                                  FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 132 >> 2];
                                  break block125;
                                 }
                                 HEAP32[$5 + 128 >> 2] = 0;
                                 $0 = HEAP32[$5 + 568 >> 2];
                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                 } else {
                                  $1 = 0
                                 }
                                 HEAP32[$5 + 128 >> 2] = FUNCTION_TABLE[$0 | 0](jshGetPinFromVar($1) & 255);
                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 128 >> 2];
                                 break block125;
                                }
                                HEAP32[$5 + 124 >> 2] = 0;
                                $2 = HEAP32[$5 + 568 >> 2];
                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                                } else {
                                 $0 = 0
                                }
                                if (HEAP32[$5 + 552 >> 2] > 1) {
                                 $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                                } else {
                                 $1 = 0
                                }
                                $1 = jshGetPinFromVar($1) & 255;
                                if (HEAP32[$5 + 552 >> 2] > 2) {
                                 $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                                } else {
                                 $3 = 0
                                }
                                HEAP32[$5 + 124 >> 2] = FUNCTION_TABLE[$2 | 0]($0, $1, $3);
                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 124 >> 2];
                                break block125;
                               }
                               HEAP32[$5 + 120 >> 2] = 0;
                               $2 = HEAP32[$5 + 568 >> 2];
                               $1 = HEAP32[$5 + 560 >> 2];
                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                               } else {
                                $0 = 0
                               }
                               $0 = jsvGetBool($0) & 1;
                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                               } else {
                                $3 = 0
                               }
                               FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 120 >> 2];
                               break block125;
                              }
                              HEAP32[$5 + 116 >> 2] = 0;
                              $1 = HEAP32[$5 + 568 >> 2];
                              $0 = HEAP32[$5 + 560 >> 2];
                              if (HEAP32[$5 + 552 >> 2] > 0) {
                               $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                              } else {
                               $2 = 0
                              }
                              $7 = jsvGetFloat($2);
                              if (HEAP32[$5 + 552 >> 2] > 1) {
                               $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                              } else {
                               $2 = 0
                              }
                              FUNCTION_TABLE[$1 | 0]($0, $7, $2);
                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 116 >> 2];
                              break block125;
                             }
                             HEAP32[$5 + 112 >> 2] = 0;
                             $2 = HEAP32[$5 + 568 >> 2];
                             $1 = HEAP32[$5 + 560 >> 2];
                             if (HEAP32[$5 + 552 >> 2] > 0) {
                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                             } else {
                              $0 = 0
                             }
                             if (HEAP32[$5 + 552 >> 2] > 1) {
                              $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                             } else {
                              $3 = 0
                             }
                             FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 112 >> 2];
                             break block125;
                            }
                            HEAP32[$5 + 108 >> 2] = 0;
                            block290 : {
                             if (HEAP32[$5 + 552 >> 2] > 0) {
                              $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                              break block290;
                             }
                             $0 = jsvNewEmptyArray();
                            }
                            HEAP32[$5 + 104 >> 2] = $0;
                            FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2], HEAP32[$5 + 104 >> 2]);
                            jsvUnLock(HEAP32[$5 + 104 >> 2]);
                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 108 >> 2];
                            break block125;
                           }
                           HEAP32[$5 + 100 >> 2] = 0;
                           $1 = HEAP32[$5 + 568 >> 2];
                           if (HEAP32[$5 + 552 >> 2] > 0) {
                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                           } else {
                            $0 = 0
                           }
                           if (HEAP32[$5 + 552 >> 2] > 1) {
                            $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                           } else {
                            $2 = 0
                           }
                           HEAP32[$5 + 100 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 100 >> 2];
                           break block125;
                          }
                          HEAP32[$5 + 96 >> 2] = 0;
                          $3 = HEAP32[$5 + 568 >> 2];
                          if (HEAP32[$5 + 552 >> 2] > 0) {
                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                          } else {
                           $1 = 0
                          }
                          if (HEAP32[$5 + 552 >> 2] > 1) {
                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                          } else {
                           $0 = 0
                          }
                          if (HEAP32[$5 + 552 >> 2] > 2) {
                           $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                          } else {
                           $2 = 0
                          }
                          $2 = jsvGetInteger($2);
                          if (HEAP32[$5 + 552 >> 2] > 3) {
                           $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                          } else {
                           $4 = 0
                          }
                          HEAP32[$5 + 96 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$3 | 0]($1, $0, $2, jsvGetInteger($4)) & 1);
                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 96 >> 2];
                          break block125;
                         }
                         HEAP32[$5 + 92 >> 2] = 0;
                         $1 = HEAP32[$5 + 568 >> 2];
                         if (HEAP32[$5 + 552 >> 2] > 0) {
                          $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                         } else {
                          $0 = 0
                         }
                         if (HEAP32[$5 + 552 >> 2] > 1) {
                          $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                         } else {
                          $2 = 0
                         }
                         HEAP32[$5 + 92 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$1 | 0]($0, $2) & 1);
                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 92 >> 2];
                         break block125;
                        }
                        HEAP32[$5 + 88 >> 2] = 0;
                        $0 = HEAP32[$5 + 568 >> 2];
                        if (HEAP32[$5 + 552 >> 2] > 0) {
                         $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                        } else {
                         $1 = 0
                        }
                        HEAP32[$5 + 88 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0](jsvGetBool($1) & 1) | 0);
                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 88 >> 2];
                        break block125;
                       }
                       HEAP32[$5 + 84 >> 2] = 0;
                       $2 = HEAP32[$5 + 568 >> 2];
                       $1 = HEAP32[$5 + 560 >> 2];
                       if (HEAP32[$5 + 552 >> 2] > 0) {
                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                       } else {
                        $0 = 0
                       }
                       if (HEAP32[$5 + 552 >> 2] > 1) {
                        $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                       } else {
                        $3 = 0
                       }
                       HEAP32[$5 + 84 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jshGetPinFromVar($3) & 255);
                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 84 >> 2];
                       break block125;
                      }
                      HEAP32[$5 + 80 >> 2] = 0;
                      $4 = HEAP32[$5 + 568 >> 2];
                      $3 = HEAP32[$5 + 560 >> 2];
                      if (HEAP32[$5 + 552 >> 2] > 0) {
                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                      } else {
                       $0 = 0
                      }
                      if (HEAP32[$5 + 552 >> 2] > 1) {
                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                      } else {
                       $1 = 0
                      }
                      $2 = jsvGetInteger($1);
                      if (HEAP32[$5 + 552 >> 2] > 2) {
                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                      } else {
                       $1 = 0
                      }
                      $1 = jsvGetInteger($1);
                      if (HEAP32[$5 + 552 >> 2] > 3) {
                       $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                      } else {
                       $6 = 0
                      }
                      FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, jshGetPinFromVar($6) & 255);
                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 80 >> 2];
                      break block125;
                     }
                     HEAP32[$5 + 76 >> 2] = 0;
                     $3 = HEAP32[$5 + 568 >> 2];
                     $2 = HEAP32[$5 + 560 >> 2];
                     if (HEAP32[$5 + 552 >> 2] > 0) {
                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                     } else {
                      $0 = 0
                     }
                     $1 = jsvGetInteger($0);
                     if (HEAP32[$5 + 552 >> 2] > 1) {
                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                     } else {
                      $0 = 0
                     }
                     $0 = jsvGetInteger($0);
                     if (HEAP32[$5 + 552 >> 2] > 2) {
                      $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                     } else {
                      $4 = 0
                     }
                     HEAP32[$5 + 76 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, jsvGetInteger($4));
                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 76 >> 2];
                     break block125;
                    }
                    HEAP32[$5 + 72 >> 2] = 0;
                    $2 = HEAP32[$5 + 568 >> 2];
                    $1 = HEAP32[$5 + 560 >> 2];
                    if (HEAP32[$5 + 552 >> 2] > 0) {
                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                    } else {
                     $0 = 0
                    }
                    $0 = jshGetPinFromVar($0) & 255;
                    if (HEAP32[$5 + 552 >> 2] > 1) {
                     $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                    } else {
                     $3 = 0
                    }
                    $7 = jsvGetFloat($3);
                    if (HEAP32[$5 + 552 >> 2] > 2) {
                     $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                    } else {
                     $3 = 0
                    }
                    FUNCTION_TABLE[$2 | 0]($1, $0, $7, $3);
                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 72 >> 2];
                    break block125;
                   }
                   HEAP32[$5 + 68 >> 2] = 0;
                   $3 = HEAP32[$5 + 568 >> 2];
                   if (HEAP32[$5 + 552 >> 2] > 0) {
                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                   } else {
                    $0 = 0
                   }
                   $2 = jsvGetInteger($0);
                   if (HEAP32[$5 + 552 >> 2] > 1) {
                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                   } else {
                    $0 = 0
                   }
                   $1 = jsvGetInteger($0);
                   if (HEAP32[$5 + 552 >> 2] > 2) {
                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                   } else {
                    $0 = 0
                   }
                   $0 = jsvGetInteger($0);
                   if (HEAP32[$5 + 552 >> 2] > 3) {
                    $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                   } else {
                    $4 = 0
                   }
                   HEAP32[$5 + 68 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 68 >> 2];
                   break block125;
                  }
                  HEAP32[$5 + 64 >> 2] = 0;
                  $1 = HEAP32[$5 + 568 >> 2];
                  $0 = HEAP32[$5 + 560 >> 2];
                  if (HEAP32[$5 + 552 >> 2] > 0) {
                   $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                  } else {
                   $2 = 0
                  }
                  HEAP32[$5 + 64 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 64 >> 2];
                  break block125;
                 }
                 HEAP32[$5 + 60 >> 2] = 0;
                 $4 = HEAP32[$5 + 568 >> 2];
                 $3 = HEAP32[$5 + 560 >> 2];
                 if (HEAP32[$5 + 552 >> 2] > 0) {
                  $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                 } else {
                  $0 = 0
                 }
                 if (HEAP32[$5 + 552 >> 2] > 1) {
                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                 } else {
                  $1 = 0
                 }
                 $2 = jsvGetInteger($1);
                 if (HEAP32[$5 + 552 >> 2] > 2) {
                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                 } else {
                  $1 = 0
                 }
                 $1 = jsvGetInteger($1);
                 if (HEAP32[$5 + 552 >> 2] > 3) {
                  $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                 } else {
                  $6 = 0
                 }
                 HEAP32[$5 + 60 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, jsvGetInteger($6));
                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 60 >> 2];
                 break block125;
                }
                HEAP32[$5 + 56 >> 2] = 0;
                $4 = HEAP32[$5 + 568 >> 2];
                $3 = HEAP32[$5 + 560 >> 2];
                if (HEAP32[$5 + 552 >> 2] > 0) {
                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
                } else {
                 $0 = 0
                }
                $2 = jsvGetInteger($0);
                if (HEAP32[$5 + 552 >> 2] > 1) {
                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
                } else {
                 $0 = 0
                }
                $1 = jsvGetInteger($0);
                if (HEAP32[$5 + 552 >> 2] > 2) {
                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
                } else {
                 $0 = 0
                }
                $0 = jsvGetInteger($0);
                if (HEAP32[$5 + 552 >> 2] > 3) {
                 $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
                } else {
                 $6 = 0
                }
                HEAP32[$5 + 56 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $2, $1, $0, jsvGetInteger($6));
                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 56 >> 2];
                break block125;
               }
               HEAP32[$5 + 52 >> 2] = 0;
               $2 = HEAP32[$5 + 568 >> 2];
               $1 = HEAP32[$5 + 560 >> 2];
               if (HEAP32[$5 + 552 >> 2] > 0) {
                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
               } else {
                $0 = 0
               }
               $0 = jsvGetInteger($0);
               if (HEAP32[$5 + 552 >> 2] > 1) {
                $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
               } else {
                $3 = 0
               }
               HEAP32[$5 + 52 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3)) | 0);
               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 52 >> 2];
               break block125;
              }
              HEAP32[$5 + 48 >> 2] = 0;
              $3 = HEAP32[$5 + 568 >> 2];
              $2 = HEAP32[$5 + 560 >> 2];
              if (HEAP32[$5 + 552 >> 2] > 0) {
               $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
              } else {
               $0 = 0
              }
              $1 = jsvGetInteger($0);
              if (HEAP32[$5 + 552 >> 2] > 1) {
               $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
              } else {
               $0 = 0
              }
              $0 = jsvGetInteger($0);
              if (HEAP32[$5 + 552 >> 2] > 2) {
               $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
              } else {
               $4 = 0
              }
              HEAP32[$5 + 48 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 48 >> 2];
              break block125;
             }
             HEAP32[$5 + 44 >> 2] = 0;
             $3 = HEAP32[$5 + 568 >> 2];
             $2 = HEAP32[$5 + 560 >> 2];
             if (HEAP32[$5 + 552 >> 2] > 0) {
              $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
             } else {
              $1 = 0
             }
             if (HEAP32[$5 + 552 >> 2] > 1) {
              $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
             } else {
              $0 = 0
             }
             if (HEAP32[$5 + 552 >> 2] > 2) {
              $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
             } else {
              $4 = 0
             }
             HEAP32[$5 + 44 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4) | 0);
             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 44 >> 2];
             break block125;
            }
            HEAP32[$5 + 40 >> 2] = 0;
            $3 = HEAP32[$5 + 568 >> 2];
            $2 = HEAP32[$5 + 560 >> 2];
            if (HEAP32[$5 + 552 >> 2] > 0) {
             $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
            } else {
             $1 = 0
            }
            if (HEAP32[$5 + 552 >> 2] > 1) {
             $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
            } else {
             $0 = 0
            }
            if (HEAP32[$5 + 552 >> 2] > 2) {
             $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
            } else {
             $4 = 0
            }
            HEAP32[$5 + 40 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 40 >> 2];
            break block125;
           }
           HEAP32[$5 + 36 >> 2] = 0;
           $4 = HEAP32[$5 + 568 >> 2];
           $3 = HEAP32[$5 + 560 >> 2];
           if (HEAP32[$5 + 552 >> 2] > 0) {
            $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
           } else {
            $1 = 0
           }
           if (HEAP32[$5 + 552 >> 2] > 1) {
            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
           } else {
            $0 = 0
           }
           $2 = jsvGetInteger($0);
           if (HEAP32[$5 + 552 >> 2] > 2) {
            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
           } else {
            $0 = 0
           }
           if (HEAP32[$5 + 552 >> 2] > 3) {
            $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
           } else {
            $6 = 0
           }
           HEAP32[$5 + 36 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $1, $2, $0, jsvGetInteger($6));
           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 36 >> 2];
           break block125;
          }
          HEAP32[$5 + 32 >> 2] = 0;
          $1 = HEAP32[$5 + 568 >> 2];
          $0 = HEAP32[$5 + 560 >> 2];
          if (HEAP32[$5 + 552 >> 2] > 0) {
           $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
          } else {
           $2 = 0
          }
          HEAP32[$5 + 32 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1 | 0]($0, $2) | 0);
          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 32 >> 2];
          break block125;
         }
         HEAP32[$5 + 28 >> 2] = 0;
         $4 = HEAP32[$5 + 568 >> 2];
         $3 = HEAP32[$5 + 560 >> 2];
         if (HEAP32[$5 + 552 >> 2] > 0) {
          $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
         } else {
          $0 = 0
         }
         if (HEAP32[$5 + 552 >> 2] > 1) {
          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
         } else {
          $1 = 0
         }
         $2 = jsvGetInteger($1);
         if (HEAP32[$5 + 552 >> 2] > 2) {
          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
         } else {
          $1 = 0
         }
         $1 = jsvGetInteger($1);
         if (HEAP32[$5 + 552 >> 2] > 3) {
          $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
         } else {
          $6 = 0
         }
         HEAP32[$5 + 28 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, jsvGetBool($6) & 1);
         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 28 >> 2];
         break block125;
        }
        HEAP32[$5 + 24 >> 2] = 0;
        $1 = HEAP32[$5 + 568 >> 2];
        $0 = HEAP32[$5 + 560 >> 2];
        if (HEAP32[$5 + 552 >> 2] > 0) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
        } else {
         $2 = 0
        }
        $9 = jsvGetFloat($2);
        if (HEAP32[$5 + 552 >> 2] > 1) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
        } else {
         $2 = 0
        }
        $8 = jsvGetFloat($2);
        if (HEAP32[$5 + 552 >> 2] > 2) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
        } else {
         $2 = 0
        }
        $7 = jsvGetFloat($2);
        if (HEAP32[$5 + 552 >> 2] > 3) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
        } else {
         $2 = 0
        }
        HEAP32[$5 + 24 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $9, $8, $7, jsvGetFloat($2));
        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 24 >> 2];
        break block125;
       }
       HEAP32[$5 + 20 >> 2] = 0;
       $2 = HEAP32[$5 + 568 >> 2];
       $1 = HEAP32[$5 + 560 >> 2];
       if (HEAP32[$5 + 552 >> 2] > 0) {
        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
       } else {
        $0 = 0
       }
       $0 = jsvGetInteger($0);
       if (HEAP32[$5 + 552 >> 2] > 1) {
        $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
       } else {
        $3 = 0
       }
       HEAP32[$5 + 20 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3));
       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 20 >> 2];
       break block125;
      }
      HEAP32[$5 + 16 >> 2] = 0;
      $2 = HEAP32[$5 + 568 >> 2];
      $1 = HEAP32[$5 + 560 >> 2];
      if (HEAP32[$5 + 552 >> 2] > 0) {
       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
      } else {
       $0 = 0
      }
      if (HEAP32[$5 + 552 >> 2] > 1) {
       $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
      } else {
       $3 = 0
      }
      HEAP32[$5 + 16 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 16 >> 2];
      break block125;
     }
     HEAP32[$5 + 12 >> 2] = 0;
     $4 = HEAP32[$5 + 568 >> 2];
     $3 = HEAP32[$5 + 560 >> 2];
     if (HEAP32[$5 + 552 >> 2] > 0) {
      $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
     } else {
      $0 = 0
     }
     if (HEAP32[$5 + 552 >> 2] > 1) {
      $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
     } else {
      $1 = 0
     }
     $2 = jsvGetInteger($1);
     if (HEAP32[$5 + 552 >> 2] > 2) {
      $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
     } else {
      $1 = 0
     }
     $1 = jsvGetInteger($1);
     if (HEAP32[$5 + 552 >> 2] > 3) {
      $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
     } else {
      $6 = 0
     }
     HEAP32[$5 + 12 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, $6);
     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 12 >> 2];
     break block125;
    }
    HEAP32[$5 + 8 >> 2] = 0;
    $3 = HEAP32[$5 + 568 >> 2];
    if (HEAP32[$5 + 552 >> 2] > 0) {
     $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2]
    } else {
     $2 = 0
    }
    if (HEAP32[$5 + 552 >> 2] > 1) {
     $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2]
    } else {
     $1 = 0
    }
    if (HEAP32[$5 + 552 >> 2] > 2) {
     $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2]
    } else {
     $0 = 0
    }
    if (HEAP32[$5 + 552 >> 2] > 3) {
     $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2]
    } else {
     $4 = 0
    }
    HEAP32[$5 + 8 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 8 >> 2];
    break block125;
   }
   HEAP32[$5 >> 2] = HEAPU16[$5 + 566 >> 1];
   jsExceptionHere(1, 19871, $5);
   HEAP32[$5 + 572 >> 2] = 0;
  }
  __stack_pointer = $5 + 576 | 0;
  return HEAP32[$5 + 572 >> 2];
 }
 
 function gen_jswrap_Float32Array_Float32Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(36, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Float64Array_Float64Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(40, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Int16Array_Int16Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(18, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Int32Array_Int32Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(20, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Int8Array_Int8Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(17, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Uint16Array_Uint16Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(2, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Uint24Array_Uint24Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(3, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Uint32Array_Uint32Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(4, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Uint8Array_Uint8Array($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(1, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Uint8ClampedArray_Uint8ClampedArray($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_typedarray_constructor(65, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_peek16($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 2);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_peek32($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 4);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_peek8($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_poke16($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 2);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function gen_jswrap_poke32($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 4);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function gen_jswrap_poke8($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function gen_jswrap_BTN() {
  return 17;
 }
 
 function gen_jswrap_BTN1() {
  return 17;
 }
 
 function gen_jswrap_HIGH() {
  return 1;
 }
 
 function gen_jswrap_I2C1() {
  return jspNewObject(22493, 21587) | 0;
 }
 
 function gen_jswrap_Infinity() {
  return Infinity;
 }
 
 function gen_jswrap_LED1() {
  return jspExecuteJSFunctionCode(28753, 1491, 233, 0, 0, 0) | 0;
 }
 
 function gen_jswrap_LED2() {
  return jspExecuteJSFunctionCode(28753, 1725, 233, 0, 0, 0) | 0;
 }
 
 function gen_jswrap_LOW() {
  return 0;
 }
 
 function gen_jswrap_LoopbackA() {
  return jspNewObject(21650, 15938) | 0;
 }
 
 function gen_jswrap_LoopbackB() {
  return jspNewObject(21596, 15938) | 0;
 }
 
 function gen_jswrap_NaN() {
  return NaN;
 }
 
 function gen_jswrap_SPI1() {
  return jspNewObject(22479, 21461) | 0;
 }
 
 function gen_jswrap_Serial1() {
  return jspNewObject(22444, 15938) | 0;
 }
 
 function gen_jswrap_Terminal() {
  return jspNewObject(15920, 15938) | 0;
 }
 
 function gen_jswrap_USB() {
  return jspNewObject(21610, 15938) | 0;
 }
 
 function gen_jswrap_VIBRATE() {
  return 19;
 }
 
 function gen_jswrap_dump() {
  jsiDumpState(7, 0);
 }
 
 function gen_jswrap_getTime() {
  return +((+(jshGetSystemTime() >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296.0) / (+(jshGetTimeFromMilliseconds(1.0e3) >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296.0));
 }
 
 function gen_jswrap_Bangle_load($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
  jsvUnLock(jspExecuteJSFunctionCode(20668, 22855, 157, 0, 1, $1 + 8 | 0));
  __stack_pointer = $1 + 16 | 0;
 }
 
 function gen_jswrap_Bangle_setUI($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  jsvUnLock(jspExecuteJSFunctionCode(18345, 158755, 3278, 0, 2, $2));
  __stack_pointer = $2 + 16 | 0;
 }
 
 function gen_jswrap_Bangle_drawWidgets() {
  jsvUnLock(jspExecuteJSFunctionCode(28753, 1099, 391, 0, 0, 0));
 }
 
 function gen_jswrap_Bangle_loadWidgets() {
  jsvUnLock(jspExecuteJSFunctionCode(28753, 3182, 258, 0, 0, 0));
 }
 
 function gen_jswrap_Bangle_showClock() {
  jsvUnLock(jspExecuteJSFunctionCode(28753, 24828, 23, 0, 0, 0));
 }
 
 function gen_jswrap_Bangle_showLauncher() {
  jsvUnLock(jspExecuteJSFunctionCode(28753, 19890, 508, 0, 0, 0));
 }
 
 function gen_jswrap_Bangle_showRecoveryMenu() {
  jsvUnLock(jspExecuteJSFunctionCode(28753, 24922, 1058, 0, 0, 0));
 }
 
 function gen_jswrap_Bangle_showTestScreen() {
  jsvUnLock(jspExecuteJSFunctionCode(28753, 162034, 2349, 0, 0, 0));
 }
 
 function gen_jswrap_E_showAlert($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  $0 = jspExecuteJSFunctionCode(20666, 164384, 240, 0, 2, $2);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_E_showMenu($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
  $0 = jspExecuteJSFunctionCode(15589, 164625, 3276, 0, 1, $1 + 8 | 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_E_showMessage($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  jsvUnLock(jspExecuteJSFunctionCode(20662, 26086, 912, 0, 2, $2));
  __stack_pointer = $2 + 16 | 0;
 }
 
 function gen_jswrap_E_showPrompt($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  $0 = jspExecuteJSFunctionCode(20658, 23013, 1513, 0, 2, $2);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_E_showScroller($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
  $0 = jspExecuteJSFunctionCode(19888, 167902, 1300, 0, 1, $1 + 8 | 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_E_getAnalogVRef() {
  return +jshReadVRef();
 }
 
 function gen_jswrap_E_internal() {
  return jsvLockAgain(HEAP32[103308]) | 0;
 }
 
 function gen_jswrap_NRF_setAdvertising($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function gen_jswrap_NRF_setServices($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function gen_jswrap_NRF_getAddress() {
  return jsvNewFromString(20495) | 0;
 }
 
 function gen_jswrap_NRF_getSecurityStatus() {
  return jsvNewObject() | 0;
 }
 
 function gen_jswrap_Bluetooth_setConsole() {
  
 }
 
 function gen_jswrap_Graphics_drawPoly($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_graphics_drawPoly_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_drawPolyAA($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_graphics_drawPoly_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_fillPoly($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_graphics_fillPoly_X(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_fillPolyAA($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_graphics_fillPoly_X(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_getBgColor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_graphics_getColorX(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_getColor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_graphics_getColorX(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_getHeight($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_graphics_getWidthOrHeight(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_getWidth($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_graphics_getWidthOrHeight(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_setBgColor($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = jswrap_graphics_setColorX(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 0);
  __stack_pointer = $4 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_setColor($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = jswrap_graphics_setColorX(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 1);
  __stack_pointer = $4 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_setFontBitmap($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_graphics_setFontSizeX(HEAP32[$1 + 12 >> 2], 8193, 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Graphics_setFontVector($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_graphics_setFontSizeX(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Array_pop($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvSkipNameAndUnLock(jsvArrayPop(HEAP32[$1 + 12 >> 2]));
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Array_isArray($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvIsArray(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function gen_jswrap_ArrayBuffer_byteLength($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8);
 }
 
 function gen_jswrap_ArrayBufferView_buffer($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_ArrayBufferView_byteLength($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return Math_imul(HEAPU8[HEAP32[$1 + 12 >> 2] + 5 | 0] & 15, HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8)) | 0;
 }
 
 function gen_jswrap_ArrayBufferView_byteOffset($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  return HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
 }
 
 function gen_jswrap_DataView_getFloat32($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 36, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_getFloat64($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 40, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_getInt16($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 18, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_getInt32($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 20, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_getInt8($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 17, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_getUint16($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 2, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_getUint32($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 4, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_getUint8($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 1, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_DataView_setFloat32($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 36, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_DataView_setFloat64($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 40, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_DataView_setInt16($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 18, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_DataView_setInt32($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 20, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_DataView_setInt8($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 17, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_DataView_setUint16($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 2, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_DataView_setUint32($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 4, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_DataView_setUint8($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP8[$4 + 3 | 0] = $3;
  jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 1, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function gen_jswrap_Number_MAX_VALUE() {
  return 1797693134862315708145274.0e284;
 }
 
 function gen_jswrap_Number_MIN_VALUE() {
  return 2.2250738585072014e-308;
 }
 
 function gen_jswrap_Number_NEGATIVE_INFINITY() {
  return -Infinity;
 }
 
 function gen_jswrap_Number_NaN() {
  return NaN;
 }
 
 function gen_jswrap_Number_POSITIVE_INFINITY() {
  return Infinity;
 }
 
 function gen_jswrap_Object_entries($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_object_values_or_entries(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Object_getOwnPropertyNames($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_object_keys_or_property_names(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Object_keys($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_object_keys_or_property_names(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Object_values($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_object_values_or_entries(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_String_includes($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
  __stack_pointer = $3 + 16 | 0;
  return ($0 | 0) >= 0 | 0;
 }
 
 function gen_jswrap_String_indexOf($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_String_lastIndexOf($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_String_padEnd($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_string_padX(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_String_padStart($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = jswrap_string_padX(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_String_removeAccents($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_string_removeAccents(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_String_toLowerCase($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_string_toUpperLowerCase(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_String_toUpperCase($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_string_toUpperLowerCase(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Math_acos($0) {
  $0 = +$0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = jswrap_math_asin(HEAPF64[$1 + 8 >> 3]);
  __stack_pointer = $1 + 16 | 0;
  return +(1.5707963267948966 - $0);
 }
 
 function gen_jswrap_Math_max($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = jswrap_math_minmax(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return +$2;
 }
 
 function gen_jswrap_Math_min($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = jswrap_math_minmax(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return +$2;
 }
 
 function gen_jswrap_Math_randInt($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (HEAP32[$1 + 12 >> 2] > 0) {
    $0 = (rand() | 0) % HEAP32[$1 + 12 >> 2] | 0;
    break block;
   }
   $0 = rand() ^ rand() << 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_Math_tan($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3]);
  $2 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3] + 1.5707963267948966);
  __stack_pointer = $1 + 16 | 0;
  return +($0 / $2);
 }
 
 function gen_jswrap_Math_E() {
  return 2.718281828459045;
 }
 
 function gen_jswrap_Math_LN10() {
  return 2.302585092994046;
 }
 
 function gen_jswrap_Math_LN2() {
  return .6931471805599453;
 }
 
 function gen_jswrap_Math_LOG10E() {
  return .4342944819032518;
 }
 
 function gen_jswrap_Math_LOG2E() {
  return 1.4426950408889634;
 }
 
 function gen_jswrap_Math_PI() {
  return 3.141592653589793;
 }
 
 function gen_jswrap_Math_SQRT1_2() {
  return .7071067811865476;
 }
 
 function gen_jswrap_Math_SQRT2() {
  return 1.4142135623730951;
 }
 
 function gen_jswrap_Math_random() {
  return +(+(rand() | 0) * 4.656612873077393e-10);
 }
 
 function gen_jswrap_process_version() {
  return jsvNewFromString(22253) | 0;
 }
 
 function gen_jswrap_Serial_find($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = jshGetDeviceObjectFor(768, 848, HEAPU8[$1 + 15 | 0]);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_SPI_find($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = jshGetDeviceObjectFor(512, 544, HEAPU8[$1 + 15 | 0]);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_I2C_find($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = jshGetDeviceObjectFor(640, 688, HEAPU8[$1 + 15 | 0]);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_crypto_SHA1($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_crypto_SHA224($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 224);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_crypto_SHA256($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 256);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_crypto_SHA384($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 384);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function gen_jswrap_crypto_SHA512($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 512);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jsfNameFromString($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $1;
  $2 = $3;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP8[$2 + 21 | 0] = 0;
  HEAP8[$2 + 22 | 0] = 0;
  HEAP8[$2 + 23 | 0] = 0;
  HEAP8[$2 + 24 | 0] = 0;
  HEAP8[$2 + 25 | 0] = 0;
  HEAP8[$2 + 26 | 0] = 0;
  HEAP8[$2 + 27 | 0] = 0;
  HEAP8[$2 + 28 | 0] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  strcpy($2, HEAP32[$2 + 44 >> 2]);
  $1 = HEAP32[$2 >> 2];
  $2 = HEAP32[$2 + 4 >> 2];
  $4 = $1;
  $1 = $0;
  HEAP32[$1 >> 2] = $4;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 24 >> 2] = HEAP32[$3 + 24 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  $2 = HEAP32[$3 + 16 >> 2];
  $4 = $2;
  $2 = $0;
  HEAP32[$2 + 16 >> 2] = $4;
  HEAP32[$2 + 20 >> 2] = $1;
  $2 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 8 >> 2];
  $4 = $1;
  $1 = $0;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $2;
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jsfNameFromVar($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $1;
  $2 = $3;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP8[$2 + 21 | 0] = 0;
  HEAP8[$2 + 22 | 0] = 0;
  HEAP8[$2 + 23 | 0] = 0;
  HEAP8[$2 + 24 | 0] = 0;
  HEAP8[$2 + 25 | 0] = 0;
  HEAP8[$2 + 26 | 0] = 0;
  HEAP8[$2 + 27 | 0] = 0;
  HEAP8[$2 + 28 | 0] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  jsvGetString(HEAP32[$2 + 44 >> 2], $2, 29);
  $1 = HEAP32[$2 >> 2];
  $2 = HEAP32[$2 + 4 >> 2];
  $4 = $1;
  $1 = $0;
  HEAP32[$1 >> 2] = $4;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 24 >> 2] = HEAP32[$3 + 24 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  $2 = HEAP32[$3 + 16 >> 2];
  $4 = $2;
  $2 = $0;
  HEAP32[$2 + 16 >> 2] = $4;
  HEAP32[$2 + 20 >> 2] = $1;
  $2 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 8 >> 2];
  $4 = $1;
  $1 = $0;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $2;
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jsfNameFromVarAndUnLock($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $1;
  jsfNameFromVar($0, HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsfVarFromName($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 28 | 0] = 0;
  $2 = $0;
  $0 = HEAP32[$2 >> 2];
  $3 = HEAP32[$2 + 4 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 24 >> 2] = HEAP32[$2 + 24 >> 2];
  $0 = HEAP32[$2 + 20 >> 2];
  $3 = HEAP32[$2 + 16 >> 2];
  HEAP32[$1 + 16 >> 2] = $3;
  HEAP32[$1 + 20 >> 2] = $0;
  $3 = HEAP32[$2 + 12 >> 2];
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 12 >> 2] = $3;
  $0 = jsvNewFromString($1);
  __stack_pointer = $1 + 32 | 0;
  return $0;
 }
 
 function jsfIsNameEqual($0, $1) {
  return !memcmp($0, $1, 28);
 }
 
 function jsfGetFileSize($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] & 16777215;
 }
 
 function jsfGetFileFlags($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] >>> 24 | 0;
 }
 
 function jsfEraseAll() {
  jsfCacheClear();
  HEAP32[103316] = 0;
  HEAP32[103317] = 0;
  jsvUpdateMemoryAddress(134217728, 8388608, 0);
  return jshFlashErasePages(134217728, 8388608) & 1;
 }
 
 function jsfCacheClear() {
  HEAP8[413272] = 0;
 }
 
 function jsfEraseFile($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 64 >> 2] = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$0 + 16 >> 2];
  $3 = HEAP32[$0 + 20 >> 2];
  HEAP32[$1 + 56 >> 2] = $2;
  HEAP32[$1 + 60 >> 2] = $3;
  $2 = HEAP32[$0 + 12 >> 2];
  $3 = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 48 >> 2] = $3;
  HEAP32[$1 + 52 >> 2] = $2;
  $3 = HEAP32[$0 + 4 >> 2];
  $2 = HEAP32[$0 >> 2];
  HEAP32[$1 + 40 >> 2] = $2;
  HEAP32[$1 + 44 >> 2] = $3;
  HEAP32[$1 + 72 >> 2] = jsfFindFile($1 + 40 | 0, $1 + 76 | 0);
  block : {
   if (!HEAP32[$1 + 72 >> 2]) {
    HEAP8[$1 + 111 | 0] = 0;
    break block;
   }
   HEAP32[$1 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
   $3 = HEAP32[$0 + 16 >> 2];
   $2 = HEAP32[$0 + 20 >> 2];
   HEAP32[$1 + 24 >> 2] = $3;
   HEAP32[$1 + 28 >> 2] = $2;
   $3 = HEAP32[$0 + 12 >> 2];
   $2 = HEAP32[$0 + 8 >> 2];
   HEAP32[$1 + 16 >> 2] = $2;
   HEAP32[$1 + 20 >> 2] = $3;
   $2 = HEAP32[$0 + 4 >> 2];
   $3 = HEAP32[$0 >> 2];
   HEAP32[$1 + 8 >> 2] = $3;
   HEAP32[$1 + 12 >> 2] = $2;
   jsfCacheClearFile($1 + 8 | 0);
   jsfEraseFileInternal(HEAP32[$1 + 72 >> 2], $1 + 76 | 0, 1);
   HEAP8[$1 + 111 | 0] = 1;
  }
  __stack_pointer = $1 + 112 | 0;
  return HEAP8[$1 + 111 | 0] & 1;
 }
 
 function jsfFindFile($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $1;
  jsfStripDriveFromName($0, 1);
  $4 = HEAP32[$2 + 104 >> 2];
  HEAP32[$2 + 64 >> 2] = HEAP32[$0 + 24 >> 2];
  $3 = $0;
  $0 = HEAP32[$3 + 16 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 60 >> 2] = $1;
  $0 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 8 >> 2];
  HEAP32[$2 + 48 >> 2] = $1;
  HEAP32[$2 + 52 >> 2] = $0;
  $1 = HEAP32[$3 + 4 >> 2];
  $0 = HEAP32[$3 >> 2];
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 44 >> 2] = $1;
  HEAP32[$2 + 100 >> 2] = jsfCacheFind($2 + 40 | 0, $4);
  if (HEAP32[$2 + 100 >> 2] == -1) {
   HEAP32[$2 + 32 >> 2] = HEAP32[$3 + 24 >> 2];
   $0 = HEAP32[$3 + 20 >> 2];
   $1 = HEAP32[$3 + 16 >> 2];
   HEAP32[$2 + 24 >> 2] = $1;
   HEAP32[$2 + 28 >> 2] = $0;
   $1 = HEAP32[$3 + 12 >> 2];
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$2 + 16 >> 2] = $0;
   HEAP32[$2 + 20 >> 2] = $1;
   $0 = HEAP32[$3 + 4 >> 2];
   $1 = HEAP32[$3 >> 2];
   HEAP32[$2 + 8 >> 2] = $1;
   HEAP32[$2 + 12 >> 2] = $0;
   HEAP32[$2 + 100 >> 2] = jsfBankFindFile(134217728, 142606336, $2 + 8 | 0, $2 + 68 | 0);
   if (!HEAP32[$2 + 100 >> 2]) {
    $1 = HEAP32[$3 + 4 >> 2];
    $0 = HEAP32[$3 >> 2];
    $5 = $0;
    $4 = $2 + 68 | 0;
    $0 = $4;
    HEAP32[$0 + 4 >> 2] = $5;
    HEAP32[$0 + 8 >> 2] = $1;
    HEAP32[$0 + 28 >> 2] = HEAP32[$3 + 24 >> 2];
    $0 = HEAP32[$3 + 20 >> 2];
    $1 = HEAP32[$3 + 16 >> 2];
    $5 = $1;
    $1 = $4;
    HEAP32[$1 + 20 >> 2] = $5;
    HEAP32[$1 + 24 >> 2] = $0;
    $1 = HEAP32[$3 + 12 >> 2];
    $0 = HEAP32[$3 + 8 >> 2];
    $3 = $0;
    $0 = $4;
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$0 + 16 >> 2] = $1;
   }
   jsfCachePut($2 + 68 | 0, HEAP32[$2 + 100 >> 2]);
   if (HEAP32[$2 + 104 >> 2]) {
    $0 = HEAP32[$2 + 72 >> 2];
    $1 = HEAP32[$2 + 68 >> 2];
    $3 = $1;
    $4 = HEAP32[$2 + 104 >> 2];
    $1 = $4;
    HEAP32[$1 >> 2] = $3;
    HEAP32[$1 + 4 >> 2] = $0;
    $1 = HEAP32[$2 + 96 >> 2];
    $0 = HEAP32[$2 + 92 >> 2];
    $3 = $0;
    $0 = $4;
    HEAP32[$0 + 24 >> 2] = $3;
    HEAP32[$0 + 28 >> 2] = $1;
    $0 = HEAP32[$2 + 88 >> 2];
    $1 = HEAP32[$2 + 84 >> 2];
    $3 = $1;
    $1 = $4;
    HEAP32[$1 + 16 >> 2] = $3;
    HEAP32[$1 + 20 >> 2] = $0;
    $1 = HEAP32[$2 + 80 >> 2];
    $0 = HEAP32[$2 + 76 >> 2];
    $3 = $0;
    $0 = $4;
    HEAP32[$0 + 8 >> 2] = $3;
    HEAP32[$0 + 12 >> 2] = $1;
   }
  }
  HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 100 >> 2];
  __stack_pointer = $2 + 112 | 0;
  return HEAP32[$2 + 108 >> 2];
 }
 
 function jsfCacheClearFile($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 60 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 60 >> 2] < HEAPU8[413272]) {
    $2 = Math_imul(HEAP32[$1 + 60 >> 2], 36) + 413280 | 0;
    HEAP32[$1 + 56 >> 2] = HEAP32[$2 + 32 >> 2];
    $3 = HEAP32[$2 + 24 >> 2];
    $4 = HEAP32[$2 + 28 >> 2];
    HEAP32[$1 + 48 >> 2] = $3;
    HEAP32[$1 + 52 >> 2] = $4;
    $3 = HEAP32[$2 + 20 >> 2];
    $4 = HEAP32[$2 + 16 >> 2];
    HEAP32[$1 + 40 >> 2] = $4;
    HEAP32[$1 + 44 >> 2] = $3;
    $4 = HEAP32[$2 + 12 >> 2];
    $3 = HEAP32[$2 + 8 >> 2];
    HEAP32[$1 + 32 >> 2] = $3;
    HEAP32[$1 + 36 >> 2] = $4;
    HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
    $2 = $0;
    $4 = HEAP32[$2 + 16 >> 2];
    $3 = HEAP32[$2 + 20 >> 2];
    HEAP32[$1 + 16 >> 2] = $4;
    HEAP32[$1 + 20 >> 2] = $3;
    $4 = HEAP32[$2 + 12 >> 2];
    $3 = HEAP32[$2 + 8 >> 2];
    HEAP32[$1 + 8 >> 2] = $3;
    HEAP32[$1 + 12 >> 2] = $4;
    $3 = HEAP32[$2 + 4 >> 2];
    $4 = HEAP32[$2 >> 2];
    HEAP32[$1 >> 2] = $4;
    HEAP32[$1 + 4 >> 2] = $3;
    if (jsfIsNameEqual($1 + 32 | 0, $1) & 1) {
     while (1) {
      if (HEAP32[$1 + 60 >> 2] < (HEAPU8[413272] - 1 | 0)) {
       $2 = Math_imul(HEAP32[$1 + 60 >> 2], 36) + 413316 | 0;
       $3 = HEAP32[$2 >> 2];
       $4 = HEAP32[$2 + 4 >> 2];
       $5 = $3;
       $0 = Math_imul(HEAP32[$1 + 60 >> 2], 36) + 413280 | 0;
       $3 = $0;
       HEAP32[$3 >> 2] = $5;
       HEAP32[$3 + 4 >> 2] = $4;
       HEAP32[$3 + 32 >> 2] = HEAP32[$2 + 32 >> 2];
       $3 = HEAP32[$2 + 28 >> 2];
       $4 = HEAP32[$2 + 24 >> 2];
       $5 = $4;
       $4 = $0;
       HEAP32[$4 + 24 >> 2] = $5;
       HEAP32[$4 + 28 >> 2] = $3;
       $4 = HEAP32[$2 + 20 >> 2];
       $3 = HEAP32[$2 + 16 >> 2];
       $5 = $3;
       $3 = $0;
       HEAP32[$3 + 16 >> 2] = $5;
       HEAP32[$3 + 20 >> 2] = $4;
       $3 = HEAP32[$2 + 12 >> 2];
       $4 = HEAP32[$2 + 8 >> 2];
       $2 = $4;
       $4 = $0;
       HEAP32[$4 + 8 >> 2] = $2;
       HEAP32[$4 + 12 >> 2] = $3;
       HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 60 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP8[413272] = HEAPU8[413272] - 1;
    } else {
     HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 60 >> 2] + 1;
     continue;
    }
   }
   break;
  };
  __stack_pointer = $1 - -64 | 0;
 }
 
 function jsfEraseFileInternal($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP8[$3 + 39 | 0] = $2;
  jsvUpdateMemoryAddress(HEAP32[$3 + 44 >> 2], jsfGetFileSize(HEAP32[$3 + 40 >> 2]), 0);
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] - 32;
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + ((HEAP32[$3 + 40 >> 2] + 4 | 0) - HEAP32[$3 + 40 >> 2] | 0);
  HEAP32[HEAP32[$3 + 40 >> 2] + 4 >> 2] = 0;
  jshFlashWrite(HEAP32[$3 + 40 >> 2] + 4 | 0, HEAP32[$3 + 44 >> 2], 4);
  if (!(!(HEAP8[$3 + 39 | 0] & 1) | HEAPU32[$3 + 44 >> 2] < 134217728 | HEAPU32[$3 + 44 >> 2] >= 142606336)) {
   HEAP32[$3 + 32 >> 2] = 0;
   if (HEAP32[103316]) {
    HEAP32[$3 + 32 >> 2] = HEAP32[103316] + HEAP32[103317]
   }
   jsfGetStorageStats($3 + 4 | 0, HEAP32[$3 + 32 >> 2], 1);
   if (HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 8 >> 2] >>> 0 > 200) {
    jsfBankCreateFileTable(134217728)
   }
  }
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jsfStripDriveFromName($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 8 >> 2] = $0;
  HEAP8[$3 + 7 | 0] = $1;
  block : {
   if (jsvIsDriveNameExplicit(HEAP32[$3 + 8 >> 2]) & 1) {
    HEAP8[$3 + 6 | 0] = HEAPU8[HEAP32[$3 + 8 >> 2]];
    $2 = HEAP32[$3 + 8 >> 2];
    $1 = HEAPU8[$2 + 10 | 0] | HEAPU8[$2 + 11 | 0] << 8 | (HEAPU8[$2 + 12 | 0] << 16 | HEAPU8[$2 + 13 | 0] << 24);
    $4 = $1;
    $0 = HEAPU8[$2 + 14 | 0] | HEAPU8[$2 + 15 | 0] << 8 | (HEAPU8[$2 + 16 | 0] << 16 | HEAPU8[$2 + 17 | 0] << 24);
    $7 = $0;
    $0 = HEAPU8[$2 + 18 | 0] | HEAPU8[$2 + 19 | 0] << 8 | (HEAPU8[$2 + 20 | 0] << 16 | HEAPU8[$2 + 21 | 0] << 24);
    $5 = $0;
    $1 = HEAPU8[$2 + 22 | 0] | HEAPU8[$2 + 23 | 0] << 8 | (HEAPU8[$2 + 24 | 0] << 16 | HEAPU8[$2 + 25 | 0] << 24);
    $8 = $1;
    $1 = HEAPU8[$2 + 2 | 0] | HEAPU8[$2 + 3 | 0] << 8 | (HEAPU8[$2 + 4 | 0] << 16 | HEAPU8[$2 + 5 | 0] << 24);
    $6 = $1;
    $0 = HEAPU8[$2 + 6 | 0] | HEAPU8[$2 + 7 | 0] << 8 | (HEAPU8[$2 + 8 | 0] << 16 | HEAPU8[$2 + 9 | 0] << 24);
    $9 = $0;
    $1 = HEAP32[$3 + 8 >> 2];
    $0 = HEAPU8[$2 + 26 | 0] | HEAPU8[$2 + 27 | 0] << 8;
    HEAP8[$1 + 24 | 0] = $0;
    HEAP8[$1 + 25 | 0] = $0 >>> 8;
    HEAP8[$1 + 16 | 0] = $5;
    HEAP8[$1 + 17 | 0] = $5 >>> 8;
    HEAP8[$1 + 18 | 0] = $5 >>> 16;
    HEAP8[$1 + 19 | 0] = $5 >>> 24;
    $0 = $8;
    HEAP8[$1 + 20 | 0] = $0;
    HEAP8[$1 + 21 | 0] = $0 >>> 8;
    HEAP8[$1 + 22 | 0] = $0 >>> 16;
    HEAP8[$1 + 23 | 0] = $0 >>> 24;
    HEAP8[$1 + 8 | 0] = $4;
    HEAP8[$1 + 9 | 0] = $4 >>> 8;
    HEAP8[$1 + 10 | 0] = $4 >>> 16;
    HEAP8[$1 + 11 | 0] = $4 >>> 24;
    $0 = $7;
    HEAP8[$1 + 12 | 0] = $0;
    HEAP8[$1 + 13 | 0] = $0 >>> 8;
    HEAP8[$1 + 14 | 0] = $0 >>> 16;
    HEAP8[$1 + 15 | 0] = $0 >>> 24;
    HEAP8[$1 | 0] = $6;
    HEAP8[$1 + 1 | 0] = $6 >>> 8;
    HEAP8[$1 + 2 | 0] = $6 >>> 16;
    HEAP8[$1 + 3 | 0] = $6 >>> 24;
    $0 = $9;
    HEAP8[$1 + 4 | 0] = $0;
    HEAP8[$1 + 5 | 0] = $0 >>> 8;
    HEAP8[$1 + 6 | 0] = $0 >>> 16;
    HEAP8[$1 + 7 | 0] = $0 >>> 24;
    HEAP8[HEAP32[$3 + 8 >> 2] + 26 | 0] = 0;
    HEAP8[HEAP32[$3 + 8 >> 2] + 27 | 0] = 0;
    HEAP8[$3 + 15 | 0] = HEAPU8[$3 + 6 | 0];
    break block;
   }
   HEAP8[$3 + 15 | 0] = 0;
  }
  __stack_pointer = $3 + 16 | 0;
  return HEAP8[$3 + 15 | 0] << 24 >> 24;
 }
 
 function jsfCacheFind($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $1;
  HEAP32[$2 + 100 >> 2] = 0;
  block : {
   while (1) {
    if (HEAP32[$2 + 100 >> 2] < HEAPU8[413272]) {
     $3 = Math_imul(HEAP32[$2 + 100 >> 2], 36) + 413280 | 0;
     HEAP32[$2 + 56 >> 2] = HEAP32[$3 + 32 >> 2];
     $1 = HEAP32[$3 + 24 >> 2];
     $4 = HEAP32[$3 + 28 >> 2];
     HEAP32[$2 + 48 >> 2] = $1;
     HEAP32[$2 + 52 >> 2] = $4;
     $1 = HEAP32[$3 + 20 >> 2];
     $4 = HEAP32[$3 + 16 >> 2];
     HEAP32[$2 + 40 >> 2] = $4;
     HEAP32[$2 + 44 >> 2] = $1;
     $4 = HEAP32[$3 + 12 >> 2];
     $1 = HEAP32[$3 + 8 >> 2];
     HEAP32[$2 + 32 >> 2] = $1;
     HEAP32[$2 + 36 >> 2] = $4;
     HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
     $3 = $0;
     $4 = HEAP32[$3 + 16 >> 2];
     $1 = HEAP32[$3 + 20 >> 2];
     HEAP32[$2 + 16 >> 2] = $4;
     HEAP32[$2 + 20 >> 2] = $1;
     $4 = HEAP32[$3 + 12 >> 2];
     $1 = HEAP32[$3 + 8 >> 2];
     HEAP32[$2 + 8 >> 2] = $1;
     HEAP32[$2 + 12 >> 2] = $4;
     $1 = HEAP32[$3 + 4 >> 2];
     $4 = HEAP32[$3 >> 2];
     HEAP32[$2 >> 2] = $4;
     HEAP32[$2 + 4 >> 2] = $1;
     if (jsfIsNameEqual($2 + 32 | 0, $2) & 1) {
      $3 = Math_imul(HEAP32[$2 + 100 >> 2], 36) + 413280 | 0;
      HEAP32[$2 + 96 >> 2] = HEAP32[$3 + 32 >> 2];
      $1 = HEAP32[$3 + 24 >> 2];
      $4 = HEAP32[$3 + 28 >> 2];
      HEAP32[$2 + 88 >> 2] = $1;
      HEAP32[$2 + 92 >> 2] = $4;
      $1 = HEAP32[$3 + 20 >> 2];
      $4 = HEAP32[$3 + 16 >> 2];
      HEAP32[$2 + 80 >> 2] = $4;
      HEAP32[$2 + 84 >> 2] = $1;
      $4 = HEAP32[$3 + 12 >> 2];
      $1 = HEAP32[$3 + 8 >> 2];
      HEAP32[$2 + 72 >> 2] = $1;
      HEAP32[$2 + 76 >> 2] = $4;
      $1 = HEAP32[$3 + 4 >> 2];
      $4 = HEAP32[$3 >> 2];
      HEAP32[$2 + 64 >> 2] = $4;
      HEAP32[$2 + 68 >> 2] = $1;
      if (HEAP32[$2 + 100 >> 2]) {
       HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 100 >> 2] - 1;
       while (1) {
        if (HEAP32[$2 + 60 >> 2] >= 0) {
         $3 = Math_imul(HEAP32[$2 + 60 >> 2], 36) + 413280 | 0;
         $1 = HEAP32[$3 >> 2];
         $4 = HEAP32[$3 + 4 >> 2];
         $5 = $1;
         $0 = Math_imul(HEAP32[$2 + 60 >> 2], 36) + 413316 | 0;
         $1 = $0;
         HEAP32[$1 >> 2] = $5;
         HEAP32[$1 + 4 >> 2] = $4;
         HEAP32[$1 + 32 >> 2] = HEAP32[$3 + 32 >> 2];
         $1 = HEAP32[$3 + 28 >> 2];
         $4 = HEAP32[$3 + 24 >> 2];
         $5 = $4;
         $4 = $0;
         HEAP32[$4 + 24 >> 2] = $5;
         HEAP32[$4 + 28 >> 2] = $1;
         $4 = HEAP32[$3 + 20 >> 2];
         $1 = HEAP32[$3 + 16 >> 2];
         $5 = $1;
         $1 = $0;
         HEAP32[$1 + 16 >> 2] = $5;
         HEAP32[$1 + 20 >> 2] = $4;
         $1 = HEAP32[$3 + 12 >> 2];
         $4 = HEAP32[$3 + 8 >> 2];
         $3 = $4;
         $4 = $0;
         HEAP32[$4 + 8 >> 2] = $3;
         HEAP32[$4 + 12 >> 2] = $1;
         HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] - 1;
         continue;
        }
        break;
       };
       $3 = $2 - -64 | 0;
       $1 = HEAP32[$3 + 4 >> 2];
       $4 = HEAP32[$3 + 8 >> 2];
       HEAP32[103321] = $1;
       HEAP32[103322] = $4;
       $1 = HEAP32[$3 + 32 >> 2];
       $4 = HEAP32[$3 + 28 >> 2];
       HEAP32[103327] = $4;
       HEAP32[103328] = $1;
       $4 = HEAP32[$3 + 24 >> 2];
       $1 = HEAP32[$3 + 20 >> 2];
       HEAP32[103325] = $1;
       HEAP32[103326] = $4;
       $1 = HEAP32[$3 + 16 >> 2];
       $4 = HEAP32[$3 + 12 >> 2];
       HEAP32[103323] = $4;
       HEAP32[103324] = $1;
       HEAP32[103320] = HEAP32[$2 + 64 >> 2];
      }
      if (HEAP32[$2 + 104 >> 2]) {
       $3 = $2 - -64 | 0;
       $1 = HEAP32[$3 + 4 >> 2];
       $4 = HEAP32[$3 + 8 >> 2];
       $5 = $1;
       $0 = HEAP32[$2 + 104 >> 2];
       $1 = $0;
       HEAP32[$1 >> 2] = $5;
       HEAP32[$1 + 4 >> 2] = $4;
       $1 = HEAP32[$3 + 32 >> 2];
       $4 = HEAP32[$3 + 28 >> 2];
       $5 = $4;
       $4 = $0;
       HEAP32[$4 + 24 >> 2] = $5;
       HEAP32[$4 + 28 >> 2] = $1;
       $4 = HEAP32[$3 + 24 >> 2];
       $1 = HEAP32[$3 + 20 >> 2];
       $5 = $1;
       $1 = $0;
       HEAP32[$1 + 16 >> 2] = $5;
       HEAP32[$1 + 20 >> 2] = $4;
       $1 = HEAP32[$3 + 16 >> 2];
       $4 = HEAP32[$3 + 12 >> 2];
       $3 = $4;
       $4 = $0;
       HEAP32[$4 + 8 >> 2] = $3;
       HEAP32[$4 + 12 >> 2] = $1;
      }
      HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 64 >> 2];
      break block;
     } else {
      HEAP32[$2 + 100 >> 2] = HEAP32[$2 + 100 >> 2] + 1;
      continue;
     }
    }
    break;
   };
   HEAP32[$2 + 108 >> 2] = -1;
  }
  __stack_pointer = $2 + 112 | 0;
  return HEAP32[$2 + 108 >> 2];
 }
 
 function jsfBankFindFile($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  $4 = __stack_pointer - 480 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 472 >> 2] = $0;
  HEAP32[$4 + 468 >> 2] = $1;
  HEAP32[$4 + 464 >> 2] = $3;
  HEAP32[$4 + 460 >> 2] = HEAP32[$4 + 472 >> 2];
  block2 : {
   block3 : {
    if (!(!HEAP32[103316] | HEAP32[$4 + 460 >> 2] != 134217728)) {
     HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 460 >> 2];
     HEAP32[$4 + 152 >> 2] = HEAP32[103316];
     HEAP32[$4 + 148 >> 2] = HEAP32[$4 + 152 >> 2] + HEAP32[103317];
     HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 148 >> 2] - HEAP32[$4 + 152 >> 2] >>> 5;
     while (1) {
      if (HEAP32[$4 + 144 >> 2]) {
       HEAP32[$4 + 140 >> 2] = HEAP32[$4 + 144 >> 2];
       if (HEAP32[$4 + 140 >> 2] > 8) {
        HEAP32[$4 + 140 >> 2] = 8
       }
       jshFlashRead($4 + 160 | 0, HEAP32[$4 + 152 >> 2], HEAP32[$4 + 140 >> 2] << 5);
       HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 152 >> 2] + (HEAP32[$4 + 140 >> 2] << 5);
       HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 144 >> 2] - HEAP32[$4 + 140 >> 2];
       HEAP32[$4 + 136 >> 2] = 0;
       while (1) {
        if (HEAP32[$4 + 136 >> 2] < HEAP32[$4 + 140 >> 2]) {
         $3 = ($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0;
         HEAP32[$4 + 64 >> 2] = HEAP32[$3 + 28 >> 2];
         $1 = HEAP32[$3 + 20 >> 2];
         $0 = HEAP32[$3 + 24 >> 2];
         HEAP32[$4 + 56 >> 2] = $1;
         HEAP32[$4 + 60 >> 2] = $0;
         $1 = HEAP32[$3 + 16 >> 2];
         $0 = HEAP32[$3 + 12 >> 2];
         HEAP32[$4 + 48 >> 2] = $0;
         HEAP32[$4 + 52 >> 2] = $1;
         $0 = HEAP32[$3 + 8 >> 2];
         $1 = HEAP32[$3 + 4 >> 2];
         HEAP32[$4 + 40 >> 2] = $1;
         HEAP32[$4 + 44 >> 2] = $0;
         HEAP32[$4 + 32 >> 2] = HEAP32[$2 + 24 >> 2];
         $3 = $2;
         $0 = HEAP32[$3 + 16 >> 2];
         $1 = HEAP32[$3 + 20 >> 2];
         HEAP32[$4 + 24 >> 2] = $0;
         HEAP32[$4 + 28 >> 2] = $1;
         $0 = HEAP32[$3 + 12 >> 2];
         $1 = HEAP32[$3 + 8 >> 2];
         HEAP32[$4 + 16 >> 2] = $1;
         HEAP32[$4 + 20 >> 2] = $0;
         $1 = HEAP32[$3 + 4 >> 2];
         $0 = HEAP32[$3 >> 2];
         HEAP32[$4 + 8 >> 2] = $0;
         HEAP32[$4 + 12 >> 2] = $1;
         if (jsfIsNameEqual($4 + 40 | 0, $4 + 8 | 0) & 1) {
          HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 156 >> 2] + HEAP32[($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) >> 2];
          if (!(!(jsfGetFileHeader(HEAP32[$4 + 132 >> 2], ($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0, 1) & 1) | !HEAP32[(($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0) + 4 >> 2])) {
           if (HEAP32[$4 + 464 >> 2]) {
            $3 = ($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0;
            $1 = HEAP32[$3 >> 2];
            $0 = HEAP32[$3 + 4 >> 2];
            $5 = $1;
            $2 = HEAP32[$4 + 464 >> 2];
            $1 = $2;
            HEAP32[$1 >> 2] = $5;
            HEAP32[$1 + 4 >> 2] = $0;
            $1 = HEAP32[$3 + 28 >> 2];
            $0 = HEAP32[$3 + 24 >> 2];
            $5 = $0;
            $0 = $2;
            HEAP32[$0 + 24 >> 2] = $5;
            HEAP32[$0 + 28 >> 2] = $1;
            $0 = HEAP32[$3 + 20 >> 2];
            $1 = HEAP32[$3 + 16 >> 2];
            $5 = $1;
            $1 = $2;
            HEAP32[$1 + 16 >> 2] = $5;
            HEAP32[$1 + 20 >> 2] = $0;
            $1 = HEAP32[$3 + 12 >> 2];
            $0 = HEAP32[$3 + 8 >> 2];
            $3 = $0;
            $0 = $2;
            HEAP32[$0 + 8 >> 2] = $3;
            HEAP32[$0 + 12 >> 2] = $1;
           }
           HEAP32[$4 + 476 >> 2] = HEAP32[$4 + 132 >> 2] + 32;
           break block2;
          }
         }
         HEAP32[$4 + 136 >> 2] = HEAP32[$4 + 136 >> 2] + 1;
         continue;
        }
        break;
       };
       continue;
      }
      break;
     };
     HEAP32[$4 + 460 >> 2] = HEAP32[103316] - 32;
     HEAP32[$4 + 432 >> 2] = 0;
     HEAP32[$4 + 428 >> 2] = HEAP32[103317];
     break block3;
    }
    if (!(jsfGetFileHeader(HEAP32[$4 + 460 >> 2], $4 + 428 | 0, 0) & 1)) {
     HEAP32[$4 + 476 >> 2] = 0;
     break block2;
    }
   }
   while (1) {
    if (HEAP32[$4 + 432 >> 2] == HEAP32[$2 >> 2]) {
     block4 : {
      if (!(jsfGetFileHeader(HEAP32[$4 + 460 >> 2], $4 + 428 | 0, 1) & 1)) {
       break block4
      }
      $3 = $4 + 428 | 0;
      HEAP32[$4 + 128 >> 2] = HEAP32[$3 + 28 >> 2];
      $1 = HEAP32[$3 + 20 >> 2];
      $0 = HEAP32[$3 + 24 >> 2];
      HEAP32[$4 + 120 >> 2] = $1;
      HEAP32[$4 + 124 >> 2] = $0;
      $1 = HEAP32[$3 + 16 >> 2];
      $0 = HEAP32[$3 + 12 >> 2];
      HEAP32[$4 + 112 >> 2] = $0;
      HEAP32[$4 + 116 >> 2] = $1;
      $0 = HEAP32[$3 + 8 >> 2];
      $1 = HEAP32[$3 + 4 >> 2];
      HEAP32[$4 + 104 >> 2] = $1;
      HEAP32[$4 + 108 >> 2] = $0;
      HEAP32[$4 + 96 >> 2] = HEAP32[$2 + 24 >> 2];
      $3 = $2;
      $0 = HEAP32[$3 + 16 >> 2];
      $1 = HEAP32[$3 + 20 >> 2];
      HEAP32[$4 + 88 >> 2] = $0;
      HEAP32[$4 + 92 >> 2] = $1;
      $0 = HEAP32[$3 + 12 >> 2];
      $1 = HEAP32[$3 + 8 >> 2];
      HEAP32[$4 + 80 >> 2] = $1;
      HEAP32[$4 + 84 >> 2] = $0;
      $1 = HEAP32[$3 + 4 >> 2];
      $0 = HEAP32[$3 >> 2];
      HEAP32[$4 + 72 >> 2] = $0;
      HEAP32[$4 + 76 >> 2] = $1;
      if (!(jsfIsNameEqual($4 + 104 | 0, $4 + 72 | 0) & 1)) {
       break block4
      }
      if (HEAP32[$4 + 464 >> 2]) {
       $0 = HEAP32[$4 + 432 >> 2];
       $1 = HEAP32[$4 + 428 >> 2];
       $3 = $1;
       $2 = HEAP32[$4 + 464 >> 2];
       $1 = $2;
       HEAP32[$1 >> 2] = $3;
       HEAP32[$1 + 4 >> 2] = $0;
       $1 = HEAP32[$4 + 456 >> 2];
       $0 = HEAP32[$4 + 452 >> 2];
       $3 = $0;
       $0 = $2;
       HEAP32[$0 + 24 >> 2] = $3;
       HEAP32[$0 + 28 >> 2] = $1;
       $0 = HEAP32[$4 + 448 >> 2];
       $1 = HEAP32[$4 + 444 >> 2];
       $3 = $1;
       $1 = $2;
       HEAP32[$1 + 16 >> 2] = $3;
       HEAP32[$1 + 20 >> 2] = $0;
       $1 = HEAP32[$4 + 440 >> 2];
       $0 = HEAP32[$4 + 436 >> 2];
       $3 = $0;
       $0 = $2;
       HEAP32[$0 + 8 >> 2] = $3;
       HEAP32[$0 + 12 >> 2] = $1;
      }
      HEAP32[$4 + 476 >> 2] = HEAP32[$4 + 460 >> 2] + 32;
      break block2;
     }
    }
    if (jsfGetNextFileHeader($4 + 460 | 0, $4 + 428 | 0, 3) & 1) {
     continue
    }
    break;
   };
   HEAP32[$4 + 476 >> 2] = 0;
  }
  __stack_pointer = $4 + 480 | 0;
  return HEAP32[$4 + 476 >> 2];
 }
 
 function jsfCachePut($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  if (HEAPU8[413272] < 32) {
   HEAP8[413272] = HEAPU8[413272] + 1
  }
  HEAP32[$3 + 4 >> 2] = HEAPU8[413272] - 2;
  while (1) {
   if (HEAP32[$3 + 4 >> 2] >= 0) {
    $2 = Math_imul(HEAP32[$3 + 4 >> 2], 36) + 413280 | 0;
    $1 = HEAP32[$2 >> 2];
    $0 = HEAP32[$2 + 4 >> 2];
    $4 = $1;
    $5 = Math_imul(HEAP32[$3 + 4 >> 2], 36) + 413316 | 0;
    $1 = $5;
    HEAP32[$1 >> 2] = $4;
    HEAP32[$1 + 4 >> 2] = $0;
    HEAP32[$1 + 32 >> 2] = HEAP32[$2 + 32 >> 2];
    $1 = HEAP32[$2 + 28 >> 2];
    $0 = HEAP32[$2 + 24 >> 2];
    $4 = $0;
    $0 = $5;
    HEAP32[$0 + 24 >> 2] = $4;
    HEAP32[$0 + 28 >> 2] = $1;
    $0 = HEAP32[$2 + 20 >> 2];
    $1 = HEAP32[$2 + 16 >> 2];
    $4 = $1;
    $1 = $5;
    HEAP32[$1 + 16 >> 2] = $4;
    HEAP32[$1 + 20 >> 2] = $0;
    $1 = HEAP32[$2 + 12 >> 2];
    $0 = HEAP32[$2 + 8 >> 2];
    $4 = $0;
    $0 = $5;
    HEAP32[$0 + 8 >> 2] = $4;
    HEAP32[$0 + 12 >> 2] = $1;
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] - 1;
    continue;
   }
   break;
  };
  $2 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$2 >> 2];
  $0 = HEAP32[$2 + 4 >> 2];
  HEAP32[103321] = $1;
  HEAP32[103322] = $0;
  $1 = HEAP32[$2 + 28 >> 2];
  $0 = HEAP32[$2 + 24 >> 2];
  HEAP32[103327] = $0;
  HEAP32[103328] = $1;
  $0 = HEAP32[$2 + 20 >> 2];
  $1 = HEAP32[$2 + 16 >> 2];
  HEAP32[103325] = $1;
  HEAP32[103326] = $0;
  $1 = HEAP32[$2 + 12 >> 2];
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[103323] = $0;
  HEAP32[103324] = $1;
  HEAP32[103320] = HEAP32[$3 + 8 >> 2];
 }
 
 function jsfGetStorageStats($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 76 >> 2] = $1;
  HEAP8[$3 + 75 | 0] = $2;
  if (!HEAP32[$3 + 76 >> 2]) {
   HEAP32[$3 + 76 >> 2] = 134217728
  }
  HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 76 >> 2];
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$3 + 56 >> 2] = 0;
  HEAP32[$3 + 60 >> 2] = 0;
  HEAP32[$3 + 48 >> 2] = 0;
  HEAP32[$3 + 52 >> 2] = 0;
  HEAP32[$3 + 40 >> 2] = 0;
  HEAP32[$3 + 44 >> 2] = 0;
  HEAP32[$3 + 32 >> 2] = 0;
  HEAP32[$3 + 36 >> 2] = 0;
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 76 >> 2];
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 76 >> 2];
  if (jsfGetFileHeader(HEAP32[$3 + 76 >> 2], $3 + 32 | 0, 0) & 1) {
   while (1) {
    if (!(!(jshFlashGetPage(HEAP32[$3 + 76 >> 2], $3 + 20 | 0, $3 + 16 | 0) & 1) | HEAP32[$3 + 20 >> 2] != HEAP32[$3 + 76 >> 2])) {
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 20 >> 2]
    }
    HEAP32[$3 + 12 >> 2] = jsfAlignAddress(jsfGetFileSize($3 + 32 | 0)) + 32;
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 76 >> 2] + HEAP32[$3 + 12 >> 2];
    block1 : {
     if (HEAP32[$3 + 36 >> 2]) {
      HEAP32[$0 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$0 >> 2];
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
      break block1;
     }
     HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$0 + 8 >> 2];
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
     if (!HEAP32[$0 + 24 >> 2]) {
      HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 24 >> 2]
     }
    }
    if (jsfGetNextFileHeader($3 + 76 | 0, $3 + 32 | 0, HEAP8[$3 + 75 | 0] & 1 ? 3 : 2) & 1) {
     continue
    }
    break;
   }
  }
  block2 : {
   if (HEAP8[$3 + 75 | 0] & 1) {
    $1 = jsfGetBankEndAddress(HEAP32[$3 + 68 >> 2]);
    break block2;
   }
   $1 = jsfGetAddressOfNextPage(HEAP32[$3 + 68 >> 2]);
  }
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 8 >> 2] - HEAP32[$3 + 68 >> 2];
  HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 8 >> 2] - HEAP32[$3 + 28 >> 2];
  __stack_pointer = $3 + 80 | 0;
 }
 
 function jsfBankCreateFileTable($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 192 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 184 >> 2] = $0;
  HEAP32[$1 + 176 >> 2] = 0;
  HEAP32[$1 + 180 >> 2] = 0;
  HEAP32[$1 + 168 >> 2] = 0;
  HEAP32[$1 + 172 >> 2] = 0;
  HEAP32[$1 + 160 >> 2] = 0;
  HEAP32[$1 + 164 >> 2] = 0;
  HEAP32[$1 + 152 >> 2] = 0;
  HEAP32[$1 + 156 >> 2] = 0;
  HEAP32[$1 + 148 >> 2] = 0;
  HEAP32[$1 + 144 >> 2] = HEAP32[$1 + 184 >> 2];
  if (jsfGetFileHeader(HEAP32[$1 + 144 >> 2], $1 + 152 | 0, 0) & 1) {
   while (1) {
    if (jsfIsRealFile($1 + 152 | 0) & 1) {
     HEAP32[$1 + 148 >> 2] = HEAP32[$1 + 148 >> 2] + 1
    }
    if (jsfGetNextFileHeader($1 + 144 | 0, $1 + 152 | 0, 1) & 1) {
     continue
    }
    break;
   }
  }
  jsfNameFromString($1 + 116 | 0, 20724);
  HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 140 >> 2];
  $0 = HEAP32[$1 + 136 >> 2];
  $2 = HEAP32[$1 + 132 >> 2];
  HEAP32[$1 + 56 >> 2] = $2;
  HEAP32[$1 + 60 >> 2] = $0;
  $2 = HEAP32[$1 + 128 >> 2];
  $0 = HEAP32[$1 + 124 >> 2];
  HEAP32[$1 + 48 >> 2] = $0;
  HEAP32[$1 + 52 >> 2] = $2;
  $0 = HEAP32[$1 + 120 >> 2];
  $2 = HEAP32[$1 + 116 >> 2];
  HEAP32[$1 + 40 >> 2] = $2;
  HEAP32[$1 + 44 >> 2] = $0;
  HEAP32[$1 + 112 >> 2] = jsfFindFile($1 + 40 | 0, $1 + 152 | 0);
  if (HEAP32[$1 + 112 >> 2]) {
   jsfEraseFileInternal(HEAP32[$1 + 112 >> 2], $1 + 152 | 0, 0)
  }
  HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 148 >> 2] << 5;
  block : {
   if (!HEAP32[$1 + 108 >> 2]) {
    HEAP32[$1 + 188 >> 2] = 0;
    break block;
   }
   $3 = HEAP32[$1 + 108 >> 2];
   HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 140 >> 2];
   $2 = HEAP32[$1 + 136 >> 2];
   $0 = HEAP32[$1 + 132 >> 2];
   HEAP32[$1 + 24 >> 2] = $0;
   HEAP32[$1 + 28 >> 2] = $2;
   $0 = HEAP32[$1 + 128 >> 2];
   $2 = HEAP32[$1 + 124 >> 2];
   HEAP32[$1 + 16 >> 2] = $2;
   HEAP32[$1 + 20 >> 2] = $0;
   $2 = HEAP32[$1 + 120 >> 2];
   $0 = HEAP32[$1 + 116 >> 2];
   HEAP32[$1 + 8 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = $2;
   HEAP32[$1 + 112 >> 2] = jsfCreateFile($1 + 8 | 0, $3, 32, $1 + 152 | 0);
   if (!HEAP32[$1 + 112 >> 2]) {
    HEAP32[$1 + 188 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 144 >> 2] = HEAP32[$1 + 184 >> 2];
   HEAP32[$1 + 104 >> 2] = HEAP32[$1 + 112 >> 2];
   if (jsfGetFileHeader(HEAP32[$1 + 144 >> 2], $1 + 152 | 0, 1) & 1) {
    while (1) {
     if (jsfIsRealFile($1 + 152 | 0) & 1) {
      $0 = HEAP32[$1 + 180 >> 2];
      $2 = HEAP32[$1 + 176 >> 2];
      HEAP32[$1 + 96 >> 2] = $2;
      HEAP32[$1 + 100 >> 2] = $0;
      $2 = HEAP32[$1 + 172 >> 2];
      $0 = HEAP32[$1 + 168 >> 2];
      HEAP32[$1 + 88 >> 2] = $0;
      HEAP32[$1 + 92 >> 2] = $2;
      $0 = HEAP32[$1 + 164 >> 2];
      $2 = HEAP32[$1 + 160 >> 2];
      HEAP32[$1 + 80 >> 2] = $2;
      HEAP32[$1 + 84 >> 2] = $0;
      $2 = HEAP32[$1 + 156 >> 2];
      $0 = HEAP32[$1 + 152 >> 2];
      HEAP32[$1 + 72 >> 2] = $0;
      HEAP32[$1 + 76 >> 2] = $2;
      HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 144 >> 2] - HEAP32[$1 + 184 >> 2];
      jshFlashWriteAligned($1 + 72 | 0, HEAP32[$1 + 104 >> 2], 32);
      HEAP32[$1 + 104 >> 2] = HEAP32[$1 + 104 >> 2] + 32;
     }
     if (jsfGetNextFileHeader($1 + 144 | 0, $1 + 152 | 0, 1) & 1) {
      continue
     }
     break;
    }
   }
   if (HEAP32[$1 + 184 >> 2] == 134217728) {
    HEAP32[103316] = HEAP32[$1 + 112 >> 2];
    HEAP32[103317] = HEAP32[$1 + 108 >> 2];
   }
   HEAP32[$1 + 188 >> 2] = HEAP32[$1 + 112 >> 2];
  }
  __stack_pointer = $1 + 192 | 0;
  return HEAP32[$1 + 188 >> 2];
 }
 
 function jsfGetFileHeader($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP8[$3 + 19 | 0] = $2;
  block : {
   if (!HEAP32[$3 + 24 >> 2]) {
    HEAP8[$3 + 31 | 0] = 0;
    break block;
   }
   jshFlashRead(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2], HEAP8[$3 + 19 | 0] & 1 ? 32 : 8);
   HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 24 >> 2] + 32 | 0) + jsfGetFileSize(HEAP32[$3 + 20 >> 2]);
   $0 = 0;
   block1 : {
    if (HEAP32[HEAP32[$3 + 20 >> 2] >> 2] == -1) {
     break block1
    }
    $0 = 0;
    if (!HEAP32[HEAP32[$3 + 20 >> 2] >> 2]) {
     break block1
    }
    $0 = HEAPU32[$3 + 12 >> 2] <= jsfGetBankEndAddress(HEAP32[$3 + 24 >> 2]) >>> 0;
   }
   HEAP8[$3 + 31 | 0] = $0;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 31 | 0] & 1;
 }
 
 function jsfAlignAddress($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[$1 + 12 >> 2] + 3 & -4;
 }
 
 function jsfGetNextFileHeader($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 0;
  HEAP32[$3 + 8 >> 2] = (HEAP32[$3 + 12 >> 2] + jsfGetFileSize(HEAP32[$3 + 20 >> 2]) | 0) + 32;
  HEAP32[$3 + 8 >> 2] = jsfAlignAddress(HEAP32[$3 + 8 >> 2]);
  block : {
   if (HEAPU32[$3 + 8 >> 2] < HEAPU32[$3 + 12 >> 2]) {
    HEAP8[$3 + 31 | 0] = 0;
    break block;
   }
   if (HEAP32[$3 + 8 >> 2] + 32 >>> 0 > jsfGetBankEndAddress(HEAP32[$3 + 12 >> 2]) >>> 0) {
    HEAP8[$3 + 31 | 0] = 0;
    break block;
   }
   HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
   HEAP8[$3 + 7 | 0] = jsfGetFileHeader(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], ((HEAP32[$3 + 16 >> 2] & 2) != 0 ^ -1) & 1) & 1;
   if (!(!(HEAP32[$3 + 16 >> 2] & 1) | HEAP8[$3 + 7 | 0] & 1)) {
    HEAP32[$3 + 8 >> 2] = jsfGetAddressOfNextPage(HEAP32[$3 + 8 >> 2]);
    HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
    if (!HEAP32[$3 + 8 >> 2]) {
     HEAP8[$3 + 31 | 0] = 0;
     break block;
    }
    HEAP8[$3 + 7 | 0] = jsfGetFileHeader(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], ((HEAP32[$3 + 16 >> 2] & 2) != 0 ^ -1) & 1) & 1;
   }
   HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 31 | 0] & 1;
 }
 
 function jsfGetBankEndAddress($0) {
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
  return 142606336;
 }
 
 function jsfGetAddressOfNextPage($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (!(jshFlashGetPage(HEAP32[$1 + 24 >> 2], $1 + 20 | 0, $1 + 16 | 0) & 1)) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsfGetBankEndAddress(HEAP32[$1 + 24 >> 2]);
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 20 >> 2] + HEAP32[$1 + 16 >> 2];
   if (HEAPU32[$1 + 24 >> 2] >= HEAPU32[$1 + 12 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 24 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsfBankCompact($0, $1) {
  var $2 = 0, $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  $2 = $3;
  __stack_pointer = $2;
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP8[$2 + 71 | 0] = $1;
  block : {
   if (!(jshFlashGetPage(HEAP32[$2 + 72 >> 2], $2 - -64 | 0, $2 + 60 | 0) & 1)) {
    HEAP8[$2 + 79 | 0] = 0;
    break block;
   }
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 60 >> 2] + 32;
   jsfGetStorageStats($2 + 28 | 0, HEAP32[$2 + 72 >> 2], 1);
   if (!HEAP32[$2 + 36 >> 2]) {
    HEAP8[$2 + 79 | 0] = 0;
    break block;
   }
   if (HEAP8[$2 + 71 | 0] & 1) {
    jsvUnLock(jspEvaluate(21907, 1))
   }
   HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 28 >> 2];
   if (HEAPU32[$2 + 24 >> 2] > HEAPU32[$2 + 56 >> 2]) {
    HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2]
   }
   HEAP8[$2 + 23 | 0] = 0;
   block1 : {
    if (HEAP32[$2 + 24 >> 2] + 256 >>> 0 < jsuGetFreeStack() >>> 0) {
     $3 = $3 - (HEAP32[$2 + 24 >> 2] + 15 & -16) | 0;
     __stack_pointer = $3;
     HEAP32[$2 + 16 >> 2] = $3;
     HEAP8[$2 + 23 | 0] = jsfCompactInternal(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2]) & 1;
     break block1;
    }
    HEAP32[$2 + 12 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 24 >> 2]);
    if (HEAP32[$2 + 12 >> 2]) {
     HEAP32[$2 + 8 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 12 >> 2]);
     HEAP8[$2 + 23 | 0] = jsfCompactInternal(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 24 >> 2]) & 1;
     jsvUnLock(HEAP32[$2 + 12 >> 2]);
    }
   }
   jsvUnLock(jspEvaluate(22188, 1));
   HEAP8[$2 + 79 | 0] = HEAP8[$2 + 23 | 0] & 1;
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAP8[$2 + 79 | 0] & 1;
 }
 
 function jsfCompactInternal($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 88 >> 2];
  jsiConsolePrintf(27660, 0);
  HEAP32[$3 + 72 >> 2] = 0;
  HEAP32[$3 + 68 >> 2] = 0;
  HEAP32[$3 + 64 >> 2] = 0;
  HEAP32[$3 + 56 >> 2] = 0;
  HEAP32[$3 + 60 >> 2] = 0;
  HEAP32[$3 + 48 >> 2] = 0;
  HEAP32[$3 + 52 >> 2] = 0;
  HEAP32[$3 + 40 >> 2] = 0;
  HEAP32[$3 + 44 >> 2] = 0;
  HEAP32[$3 + 32 >> 2] = 0;
  HEAP32[$3 + 36 >> 2] = 0;
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 88 >> 2];
  HEAP32[$3 + 24 >> 2] = 0;
  block1 : {
   if (jsfGetFileHeader(HEAP32[$3 + 28 >> 2], $3 + 32 | 0, 1) & 1) {
    while (1) {
     if (jsfIsRealFile($3 + 32 | 0) & 1) {
      HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 76 >> 2] + HEAP32[$3 + 64 >> 2];
      if (HEAP32[$3 + 28 >> 2] != HEAP32[$3 + 20 >> 2]) {
       jsvUpdateMemoryAddress(HEAP32[$3 + 28 >> 2], jsfGetFileSize($3 + 32 | 0) + 32 | 0, HEAP32[$3 + 20 >> 2])
      }
      memcpy_circular(HEAP32[$3 + 84 >> 2], $3 + 72 | 0, HEAP32[$3 + 80 >> 2], $3 + 32 | 0, 32);
      HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 64 >> 2] + 32;
      HEAP32[$3 + 16 >> 2] = jsfAlignAddress(jsfGetFileSize($3 + 32 | 0));
      HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 28 >> 2] + 32;
      jsfCompactWriteBuffer($3 + 76 | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $3 - -64 | 0, $3 + 68 | 0);
      while (1) {
       if (HEAP32[$3 + 16 >> 2]) {
        HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 64 >> 2];
        if (HEAPU32[$3 + 8 >> 2] > HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 72 >> 2] >>> 0) {
         HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 72 >> 2]
        }
        if (!(HEAPU32[$3 + 68 >> 2] <= HEAPU32[$3 + 72 >> 2] | HEAPU32[$3 + 8 >> 2] <= HEAP32[$3 + 68 >> 2] - HEAP32[$3 + 72 >> 2] >>> 0)) {
         HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 68 >> 2] - HEAP32[$3 + 72 >> 2]
        }
        if (!HEAP32[$3 + 8 >> 2]) {
         HEAP8[$3 + 95 | 0] = 0;
         break block1;
        }
        if (HEAPU32[$3 + 8 >> 2] > HEAPU32[$3 + 16 >> 2]) {
         HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 16 >> 2]
        }
        jshFlashRead(HEAP32[$3 + 84 >> 2] + HEAP32[$3 + 72 >> 2] | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
        HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 8 >> 2];
        HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 12 >> 2];
        HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 64 >> 2];
        HEAP32[$3 + 72 >> 2] = (HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 8 >> 2] >>> 0) % HEAPU32[$3 + 80 >> 2];
        jsfCompactWriteBuffer($3 + 76 | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $3 - -64 | 0, $3 + 68 | 0);
        continue;
       }
       break;
      };
      HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 28 >> 2] - HEAP32[$3 + 88 >> 2] >>> 14;
      if (HEAP32[$3 + 4 >> 2] != HEAP32[$3 + 24 >> 2]) {
       HEAP32[$3 >> 2] = HEAP8[(HEAP32[$3 + 4 >> 2] & 3) + 3462 | 0] << 24 >> 24;
       jsiConsolePrintf(20467, $3);
       HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 4 >> 2];
      }
     }
     jshKickWatchDog();
     jshKickSoftWatchDog();
     if (jsfGetNextFileHeader($3 + 28 | 0, $3 + 32 | 0, 1) & 1) {
      continue
     }
     break;
    }
   }
   jsfCompactWriteBuffer($3 + 76 | 0, jsfGetBankEndAddress(HEAP32[$3 + 76 >> 2]), HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $3 - -64 | 0, $3 + 68 | 0);
   if (HEAP32[$3 + 76 >> 2] != HEAP32[$3 + 88 >> 2]) {
    HEAP32[$3 + 76 >> 2] = jsfGetAddressOfNextPage(HEAP32[$3 + 76 >> 2] - 1 | 0)
   }
   if (HEAP32[$3 + 76 >> 2]) {
    if (!HEAP32[$3 + 28 >> 2]) {
     HEAP32[$3 + 28 >> 2] = jsfGetBankEndAddress(HEAP32[$3 + 76 >> 2])
    }
    jshFlashErasePages(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 28 >> 2] - HEAP32[$3 + 76 >> 2] | 0);
   }
   jsiConsolePrintf(28752, 0);
   HEAP8[$3 + 95 | 0] = 1;
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP8[$3 + 95 | 0] & 1;
 }
 
 function jsfIsRealFile($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsfGetFileFlags(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
   $2 = 1;
   block : {
    if (!HEAP32[$1 + 8 >> 2]) {
     break block
    }
    $2 = 1;
    if (HEAP32[$1 + 8 >> 2] == 64) {
     break block
    }
    $2 = HEAP32[$1 + 8 >> 2] == 128;
   }
  }
  return $2 & 1;
 }
 
 function memcpy_circular($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  HEAP32[$5 + 28 >> 2] = $0;
  HEAP32[$5 + 24 >> 2] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  while (1) {
   $0 = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 12 >> 2] = $0 - 1;
   if ($0) {
    $0 = HEAP32[$5 + 16 >> 2];
    HEAP32[$5 + 16 >> 2] = $0 + 1;
    HEAP8[HEAP32[$5 + 28 >> 2] + HEAP32[HEAP32[$5 + 24 >> 2] >> 2] | 0] = HEAPU8[$0 | 0];
    HEAP32[HEAP32[$5 + 24 >> 2] >> 2] = (HEAP32[HEAP32[$5 + 24 >> 2] >> 2] + 1 >>> 0) % HEAPU32[$5 + 20 >> 2];
    continue;
   }
   break;
  };
 }
 
 function jsfCompactWriteBuffer($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 48 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 44 >> 2] = $0;
  HEAP32[$6 + 40 >> 2] = $1;
  HEAP32[$6 + 36 >> 2] = $2;
  HEAP32[$6 + 32 >> 2] = $3;
  HEAP32[$6 + 28 >> 2] = $4;
  HEAP32[$6 + 24 >> 2] = $5;
  HEAP32[$6 + 20 >> 2] = jsfGetBankEndAddress(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
  HEAP32[$6 + 16 >> 2] = jsfGetAddressOfNextPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
  if (!HEAP32[$6 + 16 >> 2]) {
   HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2]
  }
  while (1) {
   block : {
    if (!HEAP32[HEAP32[$6 + 28 >> 2] >> 2]) {
     break block
    }
    HEAP32[$6 + 12 >> 2] = HEAP32[HEAP32[$6 + 28 >> 2] >> 2];
    if (HEAPU32[$6 + 32 >> 2] < HEAP32[$6 + 12 >> 2] + HEAP32[HEAP32[$6 + 24 >> 2] >> 2] >>> 0) {
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 32 >> 2] - HEAP32[HEAP32[$6 + 24 >> 2] >> 2]
    }
    if (HEAPU32[$6 + 16 >> 2] < HEAP32[$6 + 12 >> 2] + HEAP32[HEAP32[$6 + 44 >> 2] >> 2] >>> 0) {
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 16 >> 2] - HEAP32[HEAP32[$6 + 44 >> 2] >> 2]
    }
    if (HEAPU32[$6 + 40 >> 2] < HEAPU32[$6 + 16 >> 2]) {
     break block
    }
    if (!(!(jshFlashGetPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2], $6 + 8 | 0, $6 + 4 | 0) & 1) | HEAP32[$6 + 8 >> 2] != HEAP32[HEAP32[$6 + 44 >> 2] >> 2])) {
     jshFlashErasePage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2])
    }
    jshFlashWrite(HEAP32[$6 + 36 >> 2] + HEAP32[HEAP32[$6 + 24 >> 2] >> 2] | 0, HEAP32[HEAP32[$6 + 44 >> 2] >> 2], HEAP32[$6 + 12 >> 2]);
    $0 = HEAP32[$6 + 44 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$6 + 12 >> 2] + HEAP32[$0 >> 2];
    HEAP32[$6 + 16 >> 2] = jsfGetAddressOfNextPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
    if (!HEAP32[$6 + 16 >> 2]) {
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2]
    }
    HEAP32[HEAP32[$6 + 24 >> 2] >> 2] = (HEAP32[HEAP32[$6 + 24 >> 2] >> 2] + HEAP32[$6 + 12 >> 2] >>> 0) % HEAPU32[$6 + 32 >> 2];
    $0 = HEAP32[$6 + 28 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - HEAP32[$6 + 12 >> 2];
    jshKickWatchDog();
    jshKickSoftWatchDog();
    continue;
   }
   break;
  };
  __stack_pointer = $6 + 48 | 0;
 }
 
 function jsfCompact($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 14 | 0] = $0;
  block : {
   if ((jswrap_banglejs_getBattery() | 0) < 10) {
    jsiConsolePrintf(27936, 0);
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   jsfCacheClear();
   HEAP32[103316] = 0;
   HEAP32[103317] = 0;
   HEAP8[$1 + 13 | 0] = jsfBankCompact(134217728, HEAP8[$1 + 14 | 0] & 1) & 1;
   HEAP8[$1 + 15 | 0] = HEAP8[$1 + 13 | 0] & 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsfGetDriveBankAddress($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP8[$3 + 15 | 0] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = 134217728;
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = 142606336;
 }
 
 function jsvIsDriveNameExplicit($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0] == 58;
 }
 
 function jsfFindFileFromAddr($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block1 : {
   if (!(HEAPU32[$2 + 8 >> 2] < 134217728 | HEAPU32[$2 + 8 >> 2] > 142606336)) {
    HEAP32[$2 >> 2] = jsfBankFindFileFromAddr(134217728, 142606336, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
    if (HEAP32[$2 >> 2]) {
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
     break block1;
    }
   }
   HEAP32[$2 + 12 >> 2] = 0;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsfBankFindFileFromAddr($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 56 >> 2] = $0;
  HEAP32[$4 + 52 >> 2] = $1;
  HEAP32[$4 + 48 >> 2] = $2;
  HEAP32[$4 + 44 >> 2] = $3;
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 56 >> 2];
  HEAP32[$4 + 32 >> 2] = 0;
  HEAP32[$4 + 36 >> 2] = 0;
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 28 >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  HEAP32[$4 + 20 >> 2] = 0;
  HEAP32[$4 + 8 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  block1 : {
   if (jsfGetFileHeader(HEAP32[$4 + 40 >> 2], $4 + 8 | 0, 0) & 1) {
    while (1) {
     HEAP32[$4 + 4 >> 2] = (HEAP32[$4 + 40 >> 2] + 32 | 0) + jsfGetFileSize($4 + 8 | 0);
     if (!(!HEAP32[$4 + 12 >> 2] | HEAPU32[$4 + 40 >> 2] > HEAPU32[$4 + 48 >> 2] | HEAPU32[$4 + 48 >> 2] > HEAPU32[$4 + 4 >> 2])) {
      jsfGetFileHeader(HEAP32[$4 + 40 >> 2], $4 + 8 | 0, 1);
      if (HEAP32[$4 + 44 >> 2]) {
       $0 = HEAP32[$4 + 12 >> 2];
       $1 = HEAP32[$4 + 8 >> 2];
       $3 = $1;
       $2 = HEAP32[$4 + 44 >> 2];
       $1 = $2;
       HEAP32[$1 >> 2] = $3;
       HEAP32[$1 + 4 >> 2] = $0;
       $1 = HEAP32[$4 + 36 >> 2];
       $0 = HEAP32[$4 + 32 >> 2];
       $3 = $0;
       $0 = $2;
       HEAP32[$0 + 24 >> 2] = $3;
       HEAP32[$0 + 28 >> 2] = $1;
       $0 = HEAP32[$4 + 28 >> 2];
       $1 = HEAP32[$4 + 24 >> 2];
       $3 = $1;
       $1 = $2;
       HEAP32[$1 + 16 >> 2] = $3;
       HEAP32[$1 + 20 >> 2] = $0;
       $1 = HEAP32[$4 + 20 >> 2];
       $0 = HEAP32[$4 + 16 >> 2];
       $3 = $0;
       $0 = $2;
       HEAP32[$0 + 8 >> 2] = $3;
       HEAP32[$0 + 12 >> 2] = $1;
      }
      HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 40 >> 2] + 32;
      break block1;
     }
     if (jsfGetNextFileHeader($4 + 40 | 0, $4 + 8 | 0, 3) & 1) {
      continue
     }
     break;
    }
   }
   HEAP32[$4 + 60 >> 2] = 0;
  }
  __stack_pointer = $4 - -64 | 0;
  return HEAP32[$4 + 60 >> 2];
 }
 
 function jsfIsErased($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 160 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 152 >> 2] = $0;
  HEAP32[$2 + 148 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = 0;
  block : {
   while (1) {
    if (HEAP32[$2 + 148 >> 2]) {
     HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 148 >> 2];
     if (HEAPU32[$2 + 8 >> 2] > 128) {
      HEAP32[$2 + 8 >> 2] = 128
     }
     jshFlashRead($2 + 16 | 0, HEAP32[$2 + 152 >> 2], HEAP32[$2 + 8 >> 2]);
     HEAP32[$2 + 4 >> 2] = 0;
     while (1) {
      if (HEAPU32[$2 + 4 >> 2] < HEAPU32[$2 + 8 >> 2]) {
       if (HEAPU8[HEAP32[$2 + 4 >> 2] + ($2 + 16 | 0) | 0] != 255) {
        HEAP8[$2 + 159 | 0] = 0;
        break block;
       } else {
        HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
        continue;
       }
      }
      break;
     };
     HEAP32[$2 + 152 >> 2] = HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 152 >> 2];
     HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] - HEAP32[$2 + 8 >> 2];
     $0 = HEAP32[$2 + 12 >> 2];
     HEAP32[$2 + 12 >> 2] = $0 + 1;
     if (($0 | 0) > 500) {
      jshKickWatchDog();
      jshKickSoftWatchDog();
      HEAP32[$2 + 12 >> 2] = 0;
     }
     continue;
    }
    break;
   };
   HEAP8[$2 + 159 | 0] = 1;
  }
  __stack_pointer = $2 + 160 | 0;
  return HEAP8[$2 + 159 | 0] & 1;
 }
 
 function jsfReadFile($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 72 >> 2] = $1;
  HEAP32[$3 + 68 >> 2] = $2;
  HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
  $1 = $0;
  $0 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  HEAP32[$3 + 16 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $2;
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = HEAP32[$1 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $0;
  $2 = HEAP32[$1 + 4 >> 2];
  $0 = HEAP32[$1 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 + 32 >> 2] = jsfFindFile($3, $3 + 36 | 0);
  block : {
   if (!HEAP32[$3 + 32 >> 2]) {
    HEAP32[$3 + 76 >> 2] = 0;
    break block;
   }
   if (HEAP32[$3 + 72 >> 2] < 0) {
    HEAP32[$3 + 72 >> 2] = 0
   }
   HEAP32[$3 + 28 >> 2] = jsfGetFileSize($3 + 36 | 0);
   if (HEAP32[$3 + 68 >> 2] <= 0) {
    HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 28 >> 2]
   }
   if (HEAP32[$3 + 72 >> 2] > HEAP32[$3 + 28 >> 2]) {
    HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 28 >> 2]
   }
   if (HEAP32[$3 + 28 >> 2] < (HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 68 >> 2] | 0)) {
    HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 28 >> 2] - HEAP32[$3 + 72 >> 2]
   }
   if (HEAP32[$3 + 68 >> 2] <= 0) {
    HEAP32[$3 + 76 >> 2] = jsvNewFromEmptyString_800();
    break block;
   }
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 32 >> 2];
   HEAP32[$3 + 76 >> 2] = jsvAddressToVar(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 68 >> 2]);
  }
  __stack_pointer = $3 + 80 | 0;
  return HEAP32[$3 + 76 >> 2];
 }
 
 function jsvNewFromEmptyString_800() {
  return jsvNewWithFlags(29);
 }
 
 function jsvAddressToVar($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (!HEAP32[$2 + 4 >> 2]) {
    HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_800();
    break block;
   }
   HEAP32[$2 >> 2] = jshFlashGetMemMapAddress(HEAP32[$2 + 8 >> 2]);
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = jsvNewFlashString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewNativeString(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jsfWriteFile($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  $6 = __stack_pointer - 128 | 0;
  $5 = $6;
  __stack_pointer = $5;
  HEAP32[$5 + 120 >> 2] = $1;
  HEAP32[$5 + 116 >> 2] = $2;
  HEAP32[$5 + 112 >> 2] = $3;
  HEAP32[$5 + 108 >> 2] = $4;
  block1 : {
   if ((HEAP32[$5 + 112 >> 2] | HEAP32[$5 + 108 >> 2]) < 0) {
    HEAP8[$5 + 127 | 0] = 0;
    break block1;
   }
   HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 108 >> 2];
   HEAP32[$5 + 100 >> 2] = 0;
   HEAP32[$5 + 96 >> 2] = jsvGetDataPointer(HEAP32[$5 + 120 >> 2], $5 + 100 | 0);
   if (!(HEAP32[$5 + 96 >> 2] | !HEAP32[$5 + 120 >> 2])) {
    HEAP32[$5 + 100 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 120 >> 2]);
    block3 : {
     if (HEAP32[$5 + 100 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
      jsExceptionHere(1, 20608, 0);
      break block3;
     }
     $6 = $6 - (HEAP32[$5 + 100 >> 2] + 15 & -16) | 0;
     __stack_pointer = $6;
     HEAP32[$5 + 96 >> 2] = $6;
     jsvIterateCallbackToBytes(HEAP32[$5 + 120 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 100 >> 2]);
    }
   }
   if (!HEAP32[$5 + 96 >> 2]) {
    jsExceptionHere(1, 17493, 0);
    HEAP8[$5 + 127 | 0] = 0;
    break block1;
   }
   if (!HEAP32[$5 + 104 >> 2]) {
    HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 100 >> 2]
   }
   if (!HEAP32[$5 + 104 >> 2]) {
    jsExceptionHere(1, 17847, 0);
    HEAP8[$5 + 127 | 0] = 0;
    break block1;
   }
   HEAP32[$5 + 56 >> 2] = HEAP32[$0 + 24 >> 2];
   $1 = HEAP32[$0 + 16 >> 2];
   $2 = HEAP32[$0 + 20 >> 2];
   HEAP32[$5 + 48 >> 2] = $1;
   HEAP32[$5 + 52 >> 2] = $2;
   $1 = HEAP32[$0 + 12 >> 2];
   $2 = HEAP32[$0 + 8 >> 2];
   HEAP32[$5 + 40 >> 2] = $2;
   HEAP32[$5 + 44 >> 2] = $1;
   $2 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$0 >> 2];
   HEAP32[$5 + 32 >> 2] = $1;
   HEAP32[$5 + 36 >> 2] = $2;
   HEAP32[$5 + 60 >> 2] = jsfFindFile($5 + 32 | 0, $5 - -64 | 0);
   block5 : {
    block4 : {
     if (!(HEAP32[$5 + 60 >> 2] | HEAP32[$5 + 112 >> 2])) {
      break block4
     }
     if (HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 60 >> 2]) {
      break block5
     }
     if (HEAP32[$5 + 116 >> 2] != (jsfGetFileFlags($5 - -64 | 0) | 0)) {
      break block4
     }
     if (HEAP32[$5 + 104 >> 2] != (jsfGetFileSize($5 - -64 | 0) | 0)) {
      break block4
     }
     if (jsfIsErased(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 104 >> 2]) & 1) {
      break block5
     }
    }
    block6 : {
     if (HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 60 >> 2]) {
      break block6
     }
     if (HEAP32[$5 + 104 >> 2] != (jsfGetFileSize($5 - -64 | 0) | 0)) {
      break block6
     }
     if (HEAP32[$5 + 116 >> 2] != (jsfGetFileFlags($5 - -64 | 0) | 0) | HEAP32[$5 + 100 >> 2] != HEAP32[$5 + 104 >> 2]) {
      break block6
     }
     if (!(jsfIsEqual(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 100 >> 2]) & 1)) {
      break block6
     }
     HEAP8[$5 + 127 | 0] = 1;
     break block1;
    }
    if (HEAP32[$5 + 60 >> 2]) {
     jsfEraseFileInternal(HEAP32[$5 + 60 >> 2], $5 - -64 | 0, 1)
    }
    $3 = HEAP32[$5 + 104 >> 2];
    $4 = HEAP32[$5 + 116 >> 2];
    HEAP32[$5 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
    $2 = HEAP32[$0 + 16 >> 2];
    $1 = HEAP32[$0 + 20 >> 2];
    HEAP32[$5 + 16 >> 2] = $2;
    HEAP32[$5 + 20 >> 2] = $1;
    $2 = HEAP32[$0 + 12 >> 2];
    $1 = HEAP32[$0 + 8 >> 2];
    HEAP32[$5 + 8 >> 2] = $1;
    HEAP32[$5 + 12 >> 2] = $2;
    $1 = HEAP32[$0 + 4 >> 2];
    $2 = HEAP32[$0 >> 2];
    HEAP32[$5 >> 2] = $2;
    HEAP32[$5 + 4 >> 2] = $1;
    HEAP32[$5 + 60 >> 2] = jsfCreateFile($5, $3, $4, $5 - -64 | 0);
   }
   if (!HEAP32[$5 + 60 >> 2]) {
    jsExceptionHere(1, 17877, 0);
    HEAP8[$5 + 127 | 0] = 0;
    break block1;
   }
   if (HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 100 >> 2] >>> 0 > jsfGetFileSize($5 - -64 | 0) >>> 0) {
    jsExceptionHere(1, 17204, 0);
    HEAP8[$5 + 127 | 0] = 0;
    break block1;
   }
   HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 60 >> 2];
   if (!(jsfIsErased(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 100 >> 2]) & 1)) {
    jsExceptionHere(1, 20567, 0);
    HEAP8[$5 + 127 | 0] = 0;
    break block1;
   }
   jshFlashWriteAligned(HEAP32[$5 + 96 >> 2], HEAP32[$5 + 60 >> 2], HEAP32[$5 + 100 >> 2]);
   HEAP8[$5 + 127 | 0] = 1;
  }
  __stack_pointer = $5 + 128 | 0;
  return HEAP8[$5 + 127 | 0] & 1;
 }
 
 function jsfIsEqual($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 160 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 152 >> 2] = $0;
  HEAP32[$3 + 148 >> 2] = $1;
  HEAP32[$3 + 144 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = 0;
  block : {
   while (1) {
    if (HEAP32[$3 + 144 >> 2]) {
     HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 144 >> 2];
     if (HEAPU32[$3 + 8 >> 2] > 128) {
      HEAP32[$3 + 8 >> 2] = 128
     }
     jshFlashRead($3 + 16 | 0, HEAP32[$3 + 152 >> 2] + HEAP32[$3 + 12 >> 2] | 0, HEAP32[$3 + 8 >> 2]);
     if (memcmp($3 + 16 | 0, HEAP32[$3 + 148 >> 2] + HEAP32[$3 + 12 >> 2] | 0, HEAP32[$3 + 8 >> 2])) {
      HEAP8[$3 + 159 | 0] = 0;
      break block;
     } else {
      HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 144 >> 2] - HEAP32[$3 + 8 >> 2];
      continue;
     }
    }
    break;
   };
   HEAP8[$3 + 159 | 0] = 1;
  }
  __stack_pointer = $3 + 160 | 0;
  return HEAP8[$3 + 159 | 0] & 1;
 }
 
 function jsfCreateFile($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $1;
  HEAP32[$4 + 40 >> 2] = $2;
  HEAP32[$4 + 36 >> 2] = $3;
  $3 = HEAP32[$4 + 44 >> 2];
  $5 = HEAP32[$4 + 40 >> 2];
  $6 = HEAP32[$4 + 36 >> 2];
  HEAP32[$4 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
  $1 = $0;
  $0 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 28 >> 2] = $2;
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = HEAP32[$1 + 8 >> 2];
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 20 >> 2] = $0;
  $2 = HEAP32[$1 + 4 >> 2];
  $0 = HEAP32[$1 >> 2];
  HEAP32[$4 + 8 >> 2] = $0;
  HEAP32[$4 + 12 >> 2] = $2;
  $0 = _jsfCreateFile($4 + 8 | 0, $3, $5, $6, 0);
  __stack_pointer = $4 + 48 | 0;
  return $0;
 }
 
 function _jsfCreateFile($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 128 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 120 >> 2] = $1;
  HEAP32[$5 + 116 >> 2] = $2;
  HEAP32[$5 + 112 >> 2] = $3;
  HEAP8[$5 + 111 | 0] = $4;
  HEAP8[$5 + 110 | 0] = jsvIsDriveNameExplicit($0) & 1;
  HEAP8[$5 + 109 | 0] = jsfStripDriveFromName($0, HEAP8[$5 + 111 | 0] & 1);
  HEAP32[$5 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
  $3 = $0;
  $2 = HEAP32[$3 + 16 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  HEAP32[$5 + 24 >> 2] = $2;
  HEAP32[$5 + 28 >> 2] = $1;
  $2 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 8 >> 2];
  HEAP32[$5 + 16 >> 2] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  $1 = HEAP32[$3 + 4 >> 2];
  $2 = HEAP32[$3 >> 2];
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $1;
  jsfCacheClearFile($5 + 8 | 0);
  jsfGetDriveBankAddress(HEAP8[$5 + 109 | 0] << 24 >> 24, $5 + 104 | 0, $5 + 100 | 0);
  HEAP32[$5 + 96 >> 2] = jsfAlignAddress(HEAP32[$5 + 120 >> 2]) + 32;
  HEAP8[$5 + 95 | 0] = 0;
  HEAP32[$5 + 88 >> 2] = 0;
  HEAP32[$5 + 52 >> 2] = 0;
  block2 : {
   while (1) {
    if ((HEAP32[$5 + 52 >> 2] != 0 ^ -1) & 1) {
     HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 104 >> 2];
     HEAP32[$5 + 48 >> 2] = 0;
     HEAP32[$5 + 44 >> 2] = 0;
     HEAP32[$5 + 52 >> 2] = 0;
     while (1) {
      if (jsfGetFileHeader(HEAP32[$5 + 88 >> 2], $5 + 56 | 0, 0) & 1) {
       while (1) {
        if (!HEAP32[$5 + 60 >> 2]) {
         HEAP32[$5 + 44 >> 2] = jsfGetFileSize($5 + 56 | 0) + HEAP32[$5 + 44 >> 2]
        }
        if (jsfGetNextFileHeader($5 + 88 | 0, $5 + 56 | 0, 0) & 1) {
         continue
        }
        break;
       }
      }
      HEAP32[$5 + 40 >> 2] = jsfGetSpaceLeftInPage(HEAP32[$5 + 88 >> 2]);
      HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 48 >> 2];
      block : {
       if (HEAPU32[$5 + 40 >> 2] < HEAPU32[$5 + 96 >> 2]) {
        HEAP32[$5 + 88 >> 2] = jsfGetAddressOfNextPage(HEAP32[$5 + 88 >> 2]);
        break block;
       }
       HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 88 >> 2];
      }
      $1 = 0;
      $1 = HEAP32[$5 + 88 >> 2] ? HEAP32[$5 + 52 >> 2] != 0 ^ -1 : $1;
      if ($1 & 1) {
       continue
      }
      break;
     };
     if (!HEAP32[$5 + 52 >> 2]) {
      block3 : {
       if (!(HEAP8[$5 + 95 | 0] & 1 | HEAPU32[$5 + 96 >> 2] >= HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 44 >> 2] >>> 0)) {
        HEAP8[$5 + 95 | 0] = 1;
        if (!(jsfCompact(1) & 1)) {
         HEAP32[$5 + 124 >> 2] = 0;
         break block2;
        }
        HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 104 >> 2];
        break block3;
       }
       HEAP32[$5 + 124 >> 2] = 0;
       break block2;
      }
     }
     continue;
    }
    break;
   };
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 52 >> 2];
   HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 120 >> 2] | HEAP32[$5 + 116 >> 2] << 24;
   $1 = HEAP32[$0 >> 2];
   $2 = HEAP32[$3 + 4 >> 2];
   $4 = $1;
   $0 = $5 + 56 | 0;
   $1 = $0;
   HEAP32[$1 + 4 >> 2] = $4;
   HEAP32[$1 + 8 >> 2] = $2;
   HEAP32[$1 + 28 >> 2] = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 20 >> 2];
   $2 = HEAP32[$3 + 16 >> 2];
   $4 = $2;
   $2 = $0;
   HEAP32[$2 + 20 >> 2] = $4;
   HEAP32[$2 + 24 >> 2] = $1;
   $2 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 8 >> 2];
   $3 = $1;
   $1 = $0;
   HEAP32[$1 + 12 >> 2] = $3;
   HEAP32[$1 + 16 >> 2] = $2;
   jshFlashWrite($5 + 56 | 0, HEAP32[$5 + 88 >> 2], 32);
   if (HEAP32[$5 + 112 >> 2]) {
    $1 = HEAP32[$5 + 60 >> 2];
    $2 = HEAP32[$5 + 56 >> 2];
    $3 = $2;
    $0 = HEAP32[$5 + 112 >> 2];
    $2 = $0;
    HEAP32[$2 >> 2] = $3;
    HEAP32[$2 + 4 >> 2] = $1;
    $2 = HEAP32[$5 + 84 >> 2];
    $1 = HEAP32[$5 + 80 >> 2];
    $3 = $1;
    $1 = $0;
    HEAP32[$1 + 24 >> 2] = $3;
    HEAP32[$1 + 28 >> 2] = $2;
    $1 = HEAP32[$5 + 76 >> 2];
    $2 = HEAP32[$5 + 72 >> 2];
    $3 = $2;
    $2 = $0;
    HEAP32[$2 + 16 >> 2] = $3;
    HEAP32[$2 + 20 >> 2] = $1;
    $2 = HEAP32[$5 + 68 >> 2];
    $1 = HEAP32[$5 + 64 >> 2];
    $3 = $1;
    $1 = $0;
    HEAP32[$1 + 8 >> 2] = $3;
    HEAP32[$1 + 12 >> 2] = $2;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 32;
   jsfCachePut($5 + 56 | 0, HEAP32[$5 + 88 >> 2]);
   HEAP32[$5 + 124 >> 2] = HEAP32[$5 + 88 >> 2];
  }
  __stack_pointer = $5 + 128 | 0;
  return HEAP32[$5 + 124 >> 2];
 }
 
 function jsfListFiles($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   jsfBankListFiles(HEAP32[$3 + 12 >> 2], 134217728, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2], 0);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsfBankListFiles($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 80 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 76 >> 2] = $0;
  HEAP32[$6 + 72 >> 2] = $1;
  HEAP32[$6 + 68 >> 2] = $2;
  HEAP32[$6 + 64 >> 2] = $3;
  HEAP32[$6 + 60 >> 2] = $4;
  HEAP32[$6 + 56 >> 2] = $5;
  HEAP32[$6 + 48 >> 2] = 0;
  HEAP32[$6 + 52 >> 2] = 0;
  HEAP32[$6 + 40 >> 2] = 0;
  HEAP32[$6 + 44 >> 2] = 0;
  HEAP32[$6 + 32 >> 2] = 0;
  HEAP32[$6 + 36 >> 2] = 0;
  HEAP32[$6 + 24 >> 2] = 0;
  HEAP32[$6 + 28 >> 2] = 0;
  block3 : {
   block2 : {
    if (!(!HEAP32[103316] | HEAP32[$6 + 72 >> 2] != 134217728)) {
     HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 72 >> 2];
     HEAP32[$6 + 16 >> 2] = HEAP32[103316];
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 16 >> 2] + HEAP32[103317];
     while (1) {
      if (HEAPU32[$6 + 16 >> 2] < HEAPU32[$6 + 12 >> 2]) {
       jshFlashRead($6 + 24 | 0, HEAP32[$6 + 16 >> 2], 4);
       HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 32;
       HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 20 >> 2] + HEAP32[$6 + 24 >> 2];
       block1 : {
        if (!(jsfGetFileHeader(HEAP32[$6 + 8 >> 2], $6 + 24 | 0, 1) & 1)) {
         break block1
        }
        if (!(jsfIsRealFile($6 + 24 | 0) & 1)) {
         break block1
        }
        jsfBankListFilesHandleFile(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 8 >> 2], $6 + 24 | 0, HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2]);
       }
       continue;
      }
      break;
     };
     HEAP32[$6 + 72 >> 2] = HEAP32[103316] - 32;
     HEAP32[$6 + 28 >> 2] = 0;
     HEAP32[$6 + 24 >> 2] = HEAP32[103317];
     break block2;
    }
    if (!(jsfGetFileHeader(HEAP32[$6 + 72 >> 2], $6 + 24 | 0, 1) & 1)) {
     break block3
    }
   }
   while (1) {
    if (jsfIsRealFile($6 + 24 | 0) & 1) {
     jsfBankListFilesHandleFile(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 72 >> 2], $6 + 24 | 0, HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2])
    }
    if (jsfGetNextFileHeader($6 + 72 | 0, $6 + 24 | 0, 1) & 1) {
     continue
    }
    break;
   };
  }
  __stack_pointer = $6 + 80 | 0;
 }
 
 function jsfBankListFilesHandleFile($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0;
  $7 = __stack_pointer - 80 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 76 >> 2] = $0;
  HEAP32[$7 + 72 >> 2] = $1;
  HEAP32[$7 + 68 >> 2] = $2;
  HEAP32[$7 + 64 >> 2] = $3;
  HEAP32[$7 + 60 >> 2] = $4;
  HEAP32[$7 + 56 >> 2] = $5;
  HEAP32[$7 + 52 >> 2] = $6;
  HEAP32[$7 + 48 >> 2] = jsfGetFileFlags(HEAP32[$7 + 68 >> 2]);
  block : {
   if (!(!HEAP32[$7 + 60 >> 2] | HEAP32[$7 + 60 >> 2] & HEAP32[$7 + 48 >> 2]) | HEAP32[$7 + 56 >> 2] & HEAP32[$7 + 48 >> 2]) {
    break block
   }
   if (HEAP32[$7 + 48 >> 2] & 64) {
    HEAP32[$7 + 44 >> 2] = 0;
    while (1) {
     $0 = 0;
     if ((HEAP32[$7 + 44 >> 2] + 1 | 0) < 28) {
      $0 = HEAPU8[(HEAP32[$7 + 68 >> 2] + HEAP32[$7 + 44 >> 2] | 0) + 5 | 0] != 0
     }
     if ($0) {
      HEAP32[$7 + 44 >> 2] = HEAP32[$7 + 44 >> 2] + 1;
      continue;
     }
     break;
    };
    if (HEAPU8[HEAP32[$7 + 44 >> 2] + (HEAP32[$7 + 68 >> 2] + 4 | 0) | 0] != 1) {
     break block
    }
    if (HEAP32[$7 + 60 >> 2] & 64) {
     HEAP8[HEAP32[$7 + 44 >> 2] + (HEAP32[$7 + 68 >> 2] + 4 | 0) | 0] = 0
    }
   }
   $1 = HEAP32[$7 + 68 >> 2];
   HEAP32[$7 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
   $0 = HEAP32[$1 + 20 >> 2];
   $2 = HEAP32[$1 + 24 >> 2];
   HEAP32[$7 + 16 >> 2] = $0;
   HEAP32[$7 + 20 >> 2] = $2;
   $0 = HEAP32[$1 + 16 >> 2];
   $2 = HEAP32[$1 + 12 >> 2];
   HEAP32[$7 + 8 >> 2] = $2;
   HEAP32[$7 + 12 >> 2] = $0;
   $2 = HEAP32[$1 + 8 >> 2];
   $0 = HEAP32[$1 + 4 >> 2];
   HEAP32[$7 >> 2] = $0;
   HEAP32[$7 + 4 >> 2] = $2;
   HEAP32[$7 + 40 >> 2] = jsfVarFromName($7);
   HEAP8[$7 + 39 | 0] = 1;
   if (HEAP32[$7 + 64 >> 2]) {
    HEAP32[$7 + 32 >> 2] = jswrap_string_match(HEAP32[$7 + 40 >> 2], HEAP32[$7 + 64 >> 2]);
    $0 = 1;
    if (!(jsvIsUndefined(HEAP32[$7 + 32 >> 2]) & 1)) {
     $0 = jsvIsNull(HEAP32[$7 + 32 >> 2])
    }
    HEAP8[$7 + 39 | 0] = ($0 ^ -1) & 1;
    jsvUnLock(HEAP32[$7 + 32 >> 2]);
   }
   if (!(!HEAP32[$7 + 52 >> 2] | !(HEAP8[$7 + 39 | 0] & 1))) {
    HEAP32[HEAP32[$7 + 52 >> 2] >> 2] = HEAP32[HEAP32[$7 + 52 >> 2] >> 2] << 1 | HEAP32[HEAP32[$7 + 52 >> 2] >> 2] >>> 31;
    $0 = HEAP32[HEAP32[$7 + 52 >> 2] >> 2] ^ HEAP32[$7 + 72 >> 2];
    $1 = jsvGetIntegerAndUnLock(jswrap_espruino_CRC32(HEAP32[$7 + 40 >> 2]));
    HEAP32[HEAP32[$7 + 52 >> 2] >> 2] = $0 ^ $1;
   }
   if (!(!(HEAP8[$7 + 39 | 0] & 1) | !HEAP32[$7 + 76 >> 2])) {
    jsvArrayPushAndUnLock(HEAP32[$7 + 76 >> 2], HEAP32[$7 + 40 >> 2]);
    break block;
   }
   jsvUnLock(HEAP32[$7 + 40 >> 2]);
  }
  __stack_pointer = $7 + 80 | 0;
 }
 
 function jsfHashFiles($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = -1412571974;
  jsfBankListFiles(0, 134217728, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], $3);
  __stack_pointer = $3 + 16 | 0;
  return HEAP32[$3 >> 2];
 }
 
 function jsfSaveToFlash() {
  jsiConsolePrintString(28378);
 }
 
 function jsfLoadStateFromFlash() {
  
 }
 
 function jsfSaveBootCodeToFlash($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 192 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 188 >> 2] = $0;
  HEAP8[$2 + 187 | 0] = $1;
  jsfNameFromString($2 + 156 | 0, 18242);
  HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 180 >> 2];
  $0 = HEAP32[$2 + 176 >> 2];
  $1 = HEAP32[$2 + 172 >> 2];
  HEAP32[$2 + 56 >> 2] = $1;
  HEAP32[$2 + 60 >> 2] = $0;
  $1 = HEAP32[$2 + 168 >> 2];
  $0 = HEAP32[$2 + 164 >> 2];
  HEAP32[$2 + 48 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  $0 = HEAP32[$2 + 160 >> 2];
  $1 = HEAP32[$2 + 156 >> 2];
  HEAP32[$2 + 40 >> 2] = $1;
  HEAP32[$2 + 44 >> 2] = $0;
  jsfEraseFile($2 + 40 | 0);
  jsfNameFromString($2 + 128 | 0, 4449);
  HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 152 >> 2];
  $1 = HEAP32[$2 + 148 >> 2];
  $0 = HEAP32[$2 + 144 >> 2];
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP32[$2 + 92 >> 2] = $1;
  $0 = HEAP32[$2 + 140 >> 2];
  $1 = HEAP32[$2 + 136 >> 2];
  HEAP32[$2 + 80 >> 2] = $1;
  HEAP32[$2 + 84 >> 2] = $0;
  $1 = HEAP32[$2 + 132 >> 2];
  $0 = HEAP32[$2 + 128 >> 2];
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP32[$2 + 76 >> 2] = $1;
  jsfEraseFile($2 + 72 | 0);
  block : {
   if (jsvIsUndefined(HEAP32[$2 + 188 >> 2]) & 1) {
    break block
   }
   if (!jsvGetLength(HEAP32[$2 + 188 >> 2])) {
    break block
   }
   jsfNameFromString($2 + 100 | 0, HEAP8[$2 + 187 | 0] & 1 ? 4449 : 18242);
   $3 = HEAP32[$2 + 188 >> 2];
   HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 124 >> 2];
   $0 = HEAP32[$2 + 120 >> 2];
   $1 = HEAP32[$2 + 116 >> 2];
   HEAP32[$2 + 24 >> 2] = $1;
   HEAP32[$2 + 28 >> 2] = $0;
   $1 = HEAP32[$2 + 112 >> 2];
   $0 = HEAP32[$2 + 108 >> 2];
   HEAP32[$2 + 16 >> 2] = $0;
   HEAP32[$2 + 20 >> 2] = $1;
   $0 = HEAP32[$2 + 104 >> 2];
   $1 = HEAP32[$2 + 100 >> 2];
   HEAP32[$2 + 8 >> 2] = $1;
   HEAP32[$2 + 12 >> 2] = $0;
   jsfWriteFile($2 + 8 | 0, $3, 0, 0, 0);
  }
  __stack_pointer = $2 + 192 | 0;
 }
 
 function jsfGetBootCodeFromFlash($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 128 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 123 | 0] = $0;
  jsfNameFromString($1 + 88 | 0, 4449);
  HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 112 >> 2];
  $2 = HEAP32[$1 + 108 >> 2];
  $0 = HEAP32[$1 + 104 >> 2];
  HEAP32[$1 + 48 >> 2] = $0;
  HEAP32[$1 + 52 >> 2] = $2;
  $0 = HEAP32[$1 + 100 >> 2];
  $2 = HEAP32[$1 + 96 >> 2];
  HEAP32[$1 + 40 >> 2] = $2;
  HEAP32[$1 + 44 >> 2] = $0;
  $2 = HEAP32[$1 + 92 >> 2];
  $0 = HEAP32[$1 + 88 >> 2];
  HEAP32[$1 + 32 >> 2] = $0;
  HEAP32[$1 + 36 >> 2] = $2;
  HEAP32[$1 + 116 >> 2] = jsfReadFile($1 + 32 | 0, 0, 0);
  block1 : {
   if (HEAP8[$1 + 123 | 0] & 1 | HEAP32[$1 + 116 >> 2]) {
    HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 116 >> 2];
    break block1;
   }
   jsfNameFromString($1 + 60 | 0, 18242);
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 84 >> 2];
   $0 = HEAP32[$1 + 80 >> 2];
   $2 = HEAP32[$1 + 76 >> 2];
   HEAP32[$1 + 16 >> 2] = $2;
   HEAP32[$1 + 20 >> 2] = $0;
   $2 = HEAP32[$1 + 72 >> 2];
   $0 = HEAP32[$1 + 68 >> 2];
   HEAP32[$1 + 8 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = $2;
   $0 = HEAP32[$1 + 64 >> 2];
   $2 = HEAP32[$1 + 60 >> 2];
   HEAP32[$1 >> 2] = $2;
   HEAP32[$1 + 4 >> 2] = $0;
   HEAP32[$1 + 124 >> 2] = jsfReadFile($1, 0, 0);
  }
  __stack_pointer = $1 + 128 | 0;
  return HEAP32[$1 + 124 >> 2];
 }
 
 function jsfLoadBootCodeFromFlash($0) {
  var $1 = 0, $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
  $1 = __stack_pointer - 144 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 142 | 0] = $0;
  if (!(wasm2js_i32$0 = jshPinGetValue(17) & 1, wasm2js_i32$1 = 1, wasm2js_i32$2 = HEAPU16[207230] & 4096, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
   jsfNameFromString($1 + 108 | 0, 15578);
   HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 132 >> 2];
   $2 = HEAP32[$1 + 128 >> 2];
   $0 = HEAP32[$1 + 124 >> 2];
   HEAP32[$1 + 48 >> 2] = $0;
   HEAP32[$1 + 52 >> 2] = $2;
   $0 = HEAP32[$1 + 120 >> 2];
   $2 = HEAP32[$1 + 116 >> 2];
   HEAP32[$1 + 40 >> 2] = $2;
   HEAP32[$1 + 44 >> 2] = $0;
   $2 = HEAP32[$1 + 112 >> 2];
   $0 = HEAP32[$1 + 108 >> 2];
   HEAP32[$1 + 32 >> 2] = $0;
   HEAP32[$1 + 36 >> 2] = $2;
   HEAP32[$1 + 136 >> 2] = jsfReadFile($1 + 32 | 0, 0, 0);
   if (HEAP32[$1 + 136 >> 2]) {
    jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 136 >> 2], 0, 15578), HEAP32[$1 + 136 >> 2]);
    jsiCheckErrors(0);
   }
  }
  if (!(wasm2js_i32$0 = jshPinGetValue(17) & 1, wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAPU16[207230] & 4096, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
   $0 = HEAPU8[20852] | HEAPU8[20853] << 8 | (HEAPU8[20854] << 16 | HEAPU8[20855] << 24);
   HEAP8[$1 + 103 | 0] = $0;
   HEAP8[$1 + 104 | 0] = $0 >>> 8;
   HEAP8[$1 + 105 | 0] = $0 >>> 16;
   HEAP8[$1 + 106 | 0] = $0 >>> 24;
   HEAP32[$1 + 100 >> 2] = HEAPU8[20849] | HEAPU8[20850] << 8 | (HEAPU8[20851] << 16 | HEAPU8[20852] << 24);
   HEAP32[$1 + 96 >> 2] = 0;
   while (1) {
    if (HEAP32[$1 + 96 >> 2] < 4) {
     HEAP8[$1 + 105 | 0] = HEAP32[$1 + 96 >> 2] + 48;
     jsfNameFromString($1 - -64 | 0, $1 + 100 | 0);
     HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 88 >> 2];
     $0 = HEAP32[$1 + 84 >> 2];
     $2 = HEAP32[$1 + 80 >> 2];
     HEAP32[$1 + 16 >> 2] = $2;
     HEAP32[$1 + 20 >> 2] = $0;
     $2 = HEAP32[$1 + 76 >> 2];
     $0 = HEAP32[$1 + 72 >> 2];
     HEAP32[$1 + 8 >> 2] = $0;
     HEAP32[$1 + 12 >> 2] = $2;
     $0 = HEAP32[$1 + 68 >> 2];
     $2 = HEAP32[$1 + 64 >> 2];
     HEAP32[$1 >> 2] = $2;
     HEAP32[$1 + 4 >> 2] = $0;
     HEAP32[$1 + 92 >> 2] = jsfReadFile($1, 0, 0);
     if (HEAP32[$1 + 92 >> 2]) {
      jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 92 >> 2], 0, $1 + 100 | 0), HEAP32[$1 + 92 >> 2]);
      jsiCheckErrors(0);
     }
     HEAP32[$1 + 96 >> 2] = HEAP32[$1 + 96 >> 2] + 1;
     continue;
    }
    break;
   };
  }
  HEAP32[$1 + 60 >> 2] = jsfGetBootCodeFromFlash(HEAP8[$1 + 142 | 0] & 1);
  block1 : {
   if (!HEAP32[$1 + 60 >> 2]) {
    HEAP8[$1 + 143 | 0] = 0;
    break block1;
   }
   jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 60 >> 2], 0, 18232), HEAP32[$1 + 60 >> 2]);
   jsiCheckErrors(0);
   HEAP8[$1 + 143 | 0] = 1;
  }
  __stack_pointer = $1 + 144 | 0;
  return HEAP8[$1 + 143 | 0] & 1;
 }
 
 function jsfFlashContainsCode() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 128 | 0;
  __stack_pointer = $0;
  jsfNameFromString($0 + 100 | 0, 18242);
  HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 124 >> 2];
  $2 = HEAP32[$0 + 120 >> 2];
  $1 = HEAP32[$0 + 116 >> 2];
  HEAP32[$0 + 56 >> 2] = $1;
  HEAP32[$0 + 60 >> 2] = $2;
  $1 = HEAP32[$0 + 112 >> 2];
  $2 = HEAP32[$0 + 108 >> 2];
  HEAP32[$0 + 48 >> 2] = $2;
  HEAP32[$0 + 52 >> 2] = $1;
  $2 = HEAP32[$0 + 104 >> 2];
  $1 = HEAP32[$0 + 100 >> 2];
  HEAP32[$0 + 40 >> 2] = $1;
  HEAP32[$0 + 44 >> 2] = $2;
  $1 = 1;
  if (!jsfFindFile($0 + 40 | 0, 0)) {
   jsfNameFromString($0 + 72 | 0, 4449);
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 96 >> 2];
   $1 = HEAP32[$0 + 92 >> 2];
   $2 = HEAP32[$0 + 88 >> 2];
   HEAP32[$0 + 24 >> 2] = $2;
   HEAP32[$0 + 28 >> 2] = $1;
   $2 = HEAP32[$0 + 84 >> 2];
   $1 = HEAP32[$0 + 80 >> 2];
   HEAP32[$0 + 16 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = $2;
   $1 = HEAP32[$0 + 76 >> 2];
   $2 = HEAP32[$0 + 72 >> 2];
   HEAP32[$0 + 8 >> 2] = $2;
   HEAP32[$0 + 12 >> 2] = $1;
   $1 = (jsfFindFile($0 + 8 | 0, 0) | 0) != 0;
  }
  __stack_pointer = $0 + 128 | 0;
  return $1;
 }
 
 function jsfRemoveCodeFromFlash() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 128 | 0;
  __stack_pointer = $0;
  jsiConsolePrintString(22748);
  jsfNameFromString($0 + 100 | 0, 18242);
  HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 124 >> 2];
  $1 = HEAP32[$0 + 120 >> 2];
  $2 = HEAP32[$0 + 116 >> 2];
  HEAP32[$0 + 24 >> 2] = $2;
  HEAP32[$0 + 28 >> 2] = $1;
  $2 = HEAP32[$0 + 112 >> 2];
  $1 = HEAP32[$0 + 108 >> 2];
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $2;
  $1 = HEAP32[$0 + 104 >> 2];
  $2 = HEAP32[$0 + 100 >> 2];
  HEAP32[$0 + 8 >> 2] = $2;
  HEAP32[$0 + 12 >> 2] = $1;
  jsfEraseFile($0 + 8 | 0);
  jsfNameFromString($0 + 72 | 0, 4449);
  HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 96 >> 2];
  $2 = HEAP32[$0 + 92 >> 2];
  $1 = HEAP32[$0 + 88 >> 2];
  HEAP32[$0 + 56 >> 2] = $1;
  HEAP32[$0 + 60 >> 2] = $2;
  $1 = HEAP32[$0 + 84 >> 2];
  $2 = HEAP32[$0 + 80 >> 2];
  HEAP32[$0 + 48 >> 2] = $2;
  HEAP32[$0 + 52 >> 2] = $1;
  $2 = HEAP32[$0 + 76 >> 2];
  $1 = HEAP32[$0 + 72 >> 2];
  HEAP32[$0 + 40 >> 2] = $1;
  HEAP32[$0 + 44 >> 2] = $2;
  jsfEraseFile($0 + 40 | 0);
  jsiConsolePrintString(28743);
  __stack_pointer = $0 + 128 | 0;
 }
 
 function jsfResetStorage() {
  jsiConsolePrintf(28634, 0);
  jsfEraseAll();
  jsiConsolePrintf(28587, 0);
  block : {
   if (HEAP32[7189] < 8388608) {
    jsiConsolePrintf(27623, 0);
    jsfResetStorage_progress(28768, 134217728, HEAP32[7189]);
    jsiConsolePrintf(28569, 0);
    break block;
   }
   jsWarn(28683, 0);
  }
 }
 
 function jsfResetStorage_progress($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 20 >> 2]) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2];
    if (HEAPU32[$3 + 16 >> 2] > 8192) {
     HEAP32[$3 + 16 >> 2] = 8192
    }
    jshFlashWrite(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 28 >> 2];
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
    HEAP32[$3 >> 2] = HEAP8[(HEAP32[$3 + 12 >> 2] & 3) + 3462 | 0] << 24 >> 24;
    jsiConsolePrintf(20467, $3);
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsfCreateFileTable() {
  jsfBankCreateFileTable(134217728);
 }
 
 function jsfGetSpaceLeftInPage($0) {
  var $1 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 56 >> 2] = $0;
  block : {
   if (!(jshFlashGetPage(HEAP32[$1 + 56 >> 2], $1 + 52 | 0, $1 + 48 | 0) & 1)) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 44 >> 2] = jsfGetBankEndAddress(HEAP32[$1 + 56 >> 2]);
   HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 52 >> 2] + HEAP32[$1 + 48 >> 2];
   block1 : {
    if (HEAPU32[$1 + 40 >> 2] >= HEAPU32[$1 + 44 >> 2]) {
     break block1
    }
    if (jsfGetFileHeader(HEAP32[$1 + 40 >> 2], $1 + 8 | 0, 0) & 1) {
     break block1
    }
    HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 44 >> 2];
   }
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 40 >> 2] - HEAP32[$1 + 56 >> 2];
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP32[$1 + 60 >> 2];
 }
 
 function jshIsPinValid($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  if (HEAPU8[$1 + 15 | 0] < 48) {
   $2 = (HEAPU8[Math_imul(HEAPU8[$1 + 15 | 0], 3) + 183520 | 0] & 15) != 0
  }
  return $2;
 }
 
 function jshGetPinFromString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block5 : {
   if (!(!HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0] | !(HEAP8[HEAP32[$1 + 8 >> 2]] << 24 >> 24 <= 73 & HEAP8[HEAP32[$1 + 8 >> 2]] << 24 >> 24 >= 65) & HEAPU8[HEAP32[$1 + 8 >> 2]] != 86)) {
    HEAP32[$1 + 4 >> 2] = HEAPU8[HEAP32[$1 + 8 >> 2]] == 86 ? 10 : (HEAP8[HEAP32[$1 + 8 >> 2]] << 24 >> 24) + -64 | 0;
    HEAP32[$1 >> 2] = -1;
    if (!(HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] << 24 >> 24 < 48 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] << 24 >> 24 > 57)) {
     block3 : {
      if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0]) {
       HEAP32[$1 >> 2] = (HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] << 24 >> 24) - 48;
       break block3;
      }
      if (!(HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] << 24 >> 24 < 48 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] << 24 >> 24 > 57 | HEAPU8[HEAP32[$1 + 8 >> 2] + 3 | 0])) {
       HEAP32[$1 >> 2] = ((HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] << 24 >> 24) + Math_imul(HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] << 24 >> 24, 10) | 0) - 528
      }
     }
    }
    if (HEAP32[$1 >> 2] >= 0) {
     if (HEAP32[$1 + 4 >> 2] == 4 & HEAP32[$1 >> 2] < 48) {
      HEAP8[$1 + 15 | 0] = HEAP32[$1 >> 2];
      break block5;
     }
    }
   }
   HEAP8[$1 + 15 | 0] = 255;
  }
  return HEAPU8[$1 + 15 | 0];
 }
 
 function jshGetPinString($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  HEAP8[HEAP32[$2 + 12 >> 2]] = 0;
  block : {
   if (HEAPU8[$2 + 11 | 0] < 48) {
    HEAP8[HEAP32[$2 + 12 >> 2]] = 68;
    itostr_824(HEAPU8[$2 + 11 | 0], HEAP32[$2 + 12 >> 2] + 1 | 0, 10);
    break block;
   }
   strcpy(HEAP32[$2 + 12 >> 2], 19123);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function itostr_824($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jshGetPinFromVar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   if (!(!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) | HEAP8[HEAP32[$1 + 8 >> 2] + 5 | 0] << 24 >> 24)) {
    HEAP8[$1 + 15 | 0] = jshGetPinFromString(HEAP32[$1 + 8 >> 2]);
    break block1;
   }
   if (jsvIsInt(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP8[$1 + 15 | 0] = jsvGetInteger(HEAP32[$1 + 8 >> 2]);
    break block1;
   }
   HEAP8[$1 + 15 | 0] = 255;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAPU8[$1 + 15 | 0];
 }
 
 function jshGetPinFromVarAndUnLock($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAPU8[$1 + 11 | 0];
 }
 
 function jshGetPinStateIsManual($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  return HEAP32[(HEAPU8[$1 + 15 | 0] >>> 5 << 2) + 414432 >> 2] >>> HEAPU8[$1 + 15 | 0] & 1;
 }
 
 function jshSetPinStateIsManual($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  $1 = (HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 414432 | 0;
  if (HEAP8[$2 + 14 | 0] & 1) {
   $0 = 1 << HEAPU8[$2 + 15 | 0]
  } else {
   $0 = 0
  }
  HEAP32[$1 >> 2] = $0 | HEAP32[(HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 414432 >> 2] & __wasm_rotl_i32(-2, HEAPU8[$2 + 15 | 0]);
 }
 
 function jshGetPinShouldStayWatched($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  return HEAP32[(HEAPU8[$1 + 15 | 0] >>> 5 << 2) + 414440 >> 2] >>> HEAPU8[$1 + 15 | 0] & 1;
 }
 
 function jshSetPinShouldStayWatched($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  $1 = (HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 414440 | 0;
  if (HEAP8[$2 + 14 | 0] & 1) {
   $0 = 1 << HEAPU8[$2 + 15 | 0]
  } else {
   $0 = 0
  }
  HEAP32[$1 >> 2] = $0 | HEAP32[(HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 414440 >> 2] & __wasm_rotl_i32(-2, HEAPU8[$2 + 15 | 0]);
 }
 
 function jshResetPinStateIsManual() {
  HEAP32[103608] = 0;
  HEAP32[103609] = 0;
  HEAP32[103610] = 0;
  HEAP32[103611] = 0;
 }
 
 function jshPinInput($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP8[$1 + 14 | 0] = 0;
  block : {
   if (jshIsPinValid(HEAPU8[$1 + 15 | 0]) & 1) {
    if (!(jshGetPinStateIsManual(HEAPU8[$1 + 15 | 0]) & 1)) {
     jshPinSetState(HEAPU8[$1 + 15 | 0], 4)
    }
    HEAP8[$1 + 14 | 0] = jshPinGetValue(HEAPU8[$1 + 15 | 0]) & 1;
    break block;
   }
   jsExceptionHere(1, 15501, 0);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 14 | 0] & 1;
 }
 
 function jshPinOutput($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  block : {
   if (jshIsPinValid(HEAPU8[$2 + 15 | 0]) & 1) {
    jshPinSetValue(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0] & 1);
    if (!(jshGetPinStateIsManual(HEAPU8[$2 + 15 | 0]) & 1)) {
     jshPinSetState(HEAPU8[$2 + 15 | 0], 1)
    }
    break block;
   }
   jsExceptionHere(1, 15501, 0);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jshPinFunctionToString($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP16[$4 + 46 >> 1] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP32[$4 + 32 >> 2] = $3;
  HEAP32[$4 + 28 >> 2] = 28753;
  HEAP16[$4 + 26 >> 1] = HEAPU16[$4 + 46 >> 1] & 61440;
  HEAP16[$4 + 24 >> 1] = 0;
  HEAP32[$4 + 20 >> 2] = 0;
  HEAP8[HEAP32[$4 + 36 >> 2]] = 0;
  block3 : {
   if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 768 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 848)) {
    HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 40 >> 2] & 16 ? 15938 : 21002;
    HEAP16[$4 + 24 >> 1] = 768;
    block1 : {
     if (!HEAPU16[$4 + 26 >> 1]) {
      HEAP32[$4 + 20 >> 2] = 20940;
      break block1;
     }
     block2 : {
      if (HEAPU16[$4 + 26 >> 1] == 4096) {
       HEAP32[$4 + 20 >> 2] = 20856;
       break block2;
      }
      if (HEAPU16[$4 + 26 >> 1] == 8192) {
       HEAP32[$4 + 20 >> 2] = 21361
      }
     }
    }
    break block3;
   }
   block7 : {
    if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 512 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 544)) {
     HEAP32[$4 + 28 >> 2] = 21461;
     HEAP16[$4 + 24 >> 1] = 512;
     block5 : {
      if (!HEAPU16[$4 + 26 >> 1]) {
       HEAP32[$4 + 20 >> 2] = 21178;
       break block5;
      }
      block6 : {
       if (HEAPU16[$4 + 26 >> 1] == 4096) {
        HEAP32[$4 + 20 >> 2] = 21368;
        break block6;
       }
       if (HEAPU16[$4 + 26 >> 1] == 8192) {
        HEAP32[$4 + 20 >> 2] = 21351
       }
      }
     }
     break block7;
    }
    block10 : {
     if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 640 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 688)) {
      HEAP32[$4 + 28 >> 2] = 21587;
      HEAP16[$4 + 24 >> 1] = 640;
      block9 : {
       if (!HEAPU16[$4 + 26 >> 1]) {
        HEAP32[$4 + 20 >> 2] = 21312;
        break block9;
       }
       if (HEAPU16[$4 + 26 >> 1] == 4096) {
        HEAP32[$4 + 20 >> 2] = 21664
       }
      }
      break block10;
     }
     block12 : {
      if ((HEAPU16[$4 + 46 >> 1] & 4080) == 384) {
       HEAP32[$4 + 28 >> 2] = 21583;
       HEAP16[$4 + 24 >> 1] = 384;
       block11 : {
        if (!HEAPU16[$4 + 26 >> 1]) {
         HEAP32[$4 + 20 >> 2] = 22484;
         break block11;
        }
        if (HEAPU16[$4 + 26 >> 1] == 4096) {
         HEAP32[$4 + 20 >> 2] = 22419
        }
       }
       break block12;
      }
      if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 16 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 288)) {
       HEAP32[$4 + 28 >> 2] = 21230;
       HEAP16[$4 + 24 >> 1] = 16;
       HEAP32[$4 + 20 >> 2] = $4 + 15;
       HEAP8[$4 + 15 | 0] = 67;
       HEAP8[$4 + 16 | 0] = 72;
       HEAP8[$4 + 17 | 0] = ((HEAPU16[$4 + 26 >> 1] & 28672) >>> 12 | 0) + 49;
       block14 : {
        if (HEAPU16[$4 + 26 >> 1] & 32768) {
         HEAP8[$4 + 18 | 0] = 78;
         HEAP8[$4 + 19 | 0] = 0;
         break block14;
        }
        HEAP8[$4 + 18 | 0] = 0;
       }
      }
     }
    }
   }
  }
  HEAP32[$4 + 8 >> 2] = ((HEAPU16[$4 + 46 >> 1] & 4080) - HEAPU16[$4 + 24 >> 1] >> 4) + 1;
  block15 : {
   if (!HEAP32[$4 + 28 >> 2]) {
    HEAP32[$4 >> 2] = HEAPU16[$4 + 46 >> 1];
    jsiConsolePrintf(28443, $4);
    break block15;
   }
   if (HEAP32[$4 + 40 >> 2] & 1) {
    strncat(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 32 >> 2] - 1 | 0)
   }
   if (HEAP32[$4 + 40 >> 2] & 2) {
    itostr_824(HEAP32[$4 + 8 >> 2], HEAP32[$4 + 36 >> 2] + strlen(HEAP32[$4 + 36 >> 2]) | 0, 10)
   }
   if (HEAP32[$4 + 40 >> 2] & 4) {
    strncat(HEAP32[$4 + 36 >> 2], 27706, HEAP32[$4 + 32 >> 2] - (strlen(HEAP32[$4 + 36 >> 2]) + 1 | 0) | 0)
   }
   if (!HEAP32[$4 + 20 >> 2] | !(HEAP32[$4 + 40 >> 2] & 8)) {
    break block15
   }
   strncat(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 32 >> 2] - (strlen(HEAP32[$4 + 36 >> 2]) + 1 | 0) | 0);
  }
  __stack_pointer = $4 + 48 | 0;
 }
 
 function jshGetDeviceFor($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP16[$3 + 12 >> 1] = $0;
  HEAP16[$3 + 10 >> 1] = $1;
  HEAP8[$3 + 9 | 0] = $2;
  block : {
   if (!(jshIsPinValid(HEAPU8[$3 + 9 | 0]) & 1)) {
    HEAP16[$3 + 14 >> 1] = 0;
    break block;
   }
   HEAP32[$3 + 4 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 4 >> 2] < 0) {
     $0 = (Math_imul(HEAPU8[$3 + 9 | 0], 3) + 183523 | 0) + (HEAP32[$3 + 4 >> 2] << 1) | 0;
     HEAP16[$3 + 2 >> 1] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
     if (!(HEAPU16[$3 + 10 >> 1] < (HEAPU16[$3 + 2 >> 1] & 4080) | HEAPU16[$3 + 12 >> 1] > (HEAPU16[$3 + 2 >> 1] & 4080))) {
      HEAP16[$3 + 14 >> 1] = HEAPU16[$3 + 2 >> 1];
      break block;
     }
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP16[$3 + 14 >> 1] = 0;
  }
  __stack_pointer = $3 + 16 | 0;
  return HEAPU16[$3 + 14 >> 1];
 }
 
 function jshGetDeviceObjectFor($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP16[$3 + 42 >> 1] = $0;
  HEAP16[$3 + 40 >> 1] = $1;
  HEAP8[$3 + 39 | 0] = $2;
  HEAP16[$3 + 36 >> 1] = jshGetDeviceFor(HEAPU16[$3 + 42 >> 1], HEAPU16[$3 + 40 >> 1], HEAPU8[$3 + 39 | 0]);
  block : {
   if (!HEAPU16[$3 + 36 >> 1]) {
    HEAP32[$3 + 44 >> 2] = 0;
    break block;
   }
   jshPinFunctionToString(HEAPU16[$3 + 36 >> 1], 19, $3 + 16 | 0, 16);
   HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], $3 + 16 | 0);
   if (HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 12 >> 2];
    break block;
   }
   HEAP32[$3 + 44 >> 2] = jswFindBuiltInFunction(0, $3 + 16 | 0);
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 44 >> 2];
 }
 
 function jshGetPinStateString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 11 | 0] = $0;
  HEAP8[$1 + 10 | 0] = HEAPU8[$1 + 11 | 0] & 15;
  HEAP32[$1 + 4 >> 2] = 0;
  block9 : {
   block8 : {
    switch (HEAPU8[$1 + 10 | 0] - 1 | 0) {
    case 6:
     HEAP32[$1 + 4 >> 2] = 16563;
     break block9;
    case 3:
     HEAP32[$1 + 4 >> 2] = 4286;
     break block9;
    case 4:
     HEAP32[$1 + 4 >> 2] = 14869;
     break block9;
    case 5:
     HEAP32[$1 + 4 >> 2] = 15128;
     break block9;
    case 0:
     HEAP32[$1 + 4 >> 2] = 4279;
     break block9;
    case 1:
     HEAP32[$1 + 4 >> 2] = 15522;
     break block9;
    case 2:
     HEAP32[$1 + 4 >> 2] = 14882;
     break block9;
    case 7:
     HEAP32[$1 + 4 >> 2] = 4276;
     break block9;
    case 8:
     break block8;
    default:
     break block9;
    };
   }
   HEAP32[$1 + 4 >> 2] = 15519;
  }
  block10 : {
   if (HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = jsvNewFromString(HEAP32[$1 + 4 >> 2]);
    break block10;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsiGetDeviceFromClass($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   if (!(!HEAP32[$1 + 8 >> 2] | HEAPU8[HEAP32[$1 + 8 >> 2]] != 68 | (HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 69 | HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 86))) {
    HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[$1 + 8 >> 2] + 3 | 0];
    break block1;
   }
   HEAP8[$1 + 15 | 0] = 0;
  }
  return HEAPU8[$1 + 15 | 0];
 }
 
 function jsiGetClassNameFromDevice($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 11 | 0] = $0;
  HEAP32[$1 + 4 >> 2] = jshGetDeviceString(HEAPU8[$1 + 11 | 0]);
  block : {
   if (!HEAPU8[HEAP32[$1 + 4 >> 2]]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvFindChildFromString(HEAP32[103307], HEAP32[$1 + 4 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsiEcho() {
  return !(HEAPU16[207230] & 3);
 }
 
 function jsiPasswordProtected() {
  return (HEAPU16[207230] & 1024) != 0;
 }
 
 function jsiGetPreferredConsoleDevice() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 15 | 0] = 21;
  if (!(jshIsDeviceInitialised(HEAPU8[$0 + 15 | 0]) & 1)) {
   HEAP8[$0 + 15 | 0] = 20
  }
  if (jshIsUSBSERIALConnected() & 1) {
   HEAP8[$0 + 15 | 0] = 21
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAPU8[$0 + 15 | 0];
 }
 
 function jsiSetConsoleDevice($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 47 | 0] = $0;
  HEAP8[$2 + 46 | 0] = $1;
  block : {
   if (HEAP8[$2 + 46 | 0] & 1) {
    HEAP16[207230] = HEAPU16[207230] | 256;
    break block;
   }
   HEAP16[207230] = HEAPU16[207230] & -257;
  }
  block1 : {
   if (HEAPU8[$2 + 47 | 0] == HEAPU8[244432]) {
    break block1
   }
   block2 : {
    if (HEAPU8[$2 + 47 | 0] < 22 | HEAPU8[$2 + 47 | 0] > 22) {
     break block2
    }
    if (jshIsDeviceInitialised(HEAPU8[$2 + 47 | 0]) & 1) {
     break block2
    }
    jshUSARTInitInfo($2 + 33 | 0);
    jshUSARTSetup(HEAPU8[$2 + 47 | 0], $2 + 33 | 0);
   }
   HEAP8[$2 + 32 | 0] = jsiEcho() & 1;
   if (HEAPU8[244432] == 19) {
    HEAP8[$2 + 32 | 0] = 0;
    jshTransmitMove(19, HEAPU8[$2 + 47 | 0]);
    jshUSARTKick(HEAPU8[$2 + 47 | 0]);
   }
   if (HEAP8[$2 + 32 | 0] & 1) {
    jsiConsoleRemoveInputLine();
    HEAP32[$2 + 16 >> 2] = jshGetDeviceString(HEAPU8[$2 + 47 | 0]);
    jsiConsolePrintf(28021, $2 + 16 | 0);
   }
   HEAP8[$2 + 31 | 0] = HEAPU8[244432];
   HEAP8[244432] = HEAPU8[$2 + 47 | 0];
   if (!(HEAP8[$2 + 32 | 0] & 1)) {
    break block1
   }
   HEAP32[$2 >> 2] = jshGetDeviceString(HEAPU8[$2 + 31 | 0]);
   jsiConsolePrintf(28028, $2);
  }
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jsiConsoleRemoveInputLine() {
  if (!(HEAP8[414468] & 1)) {
   HEAP8[414468] = 1;
   if (!(!(jsiEcho() & 1) | !HEAP32[103616])) {
    jsiMoveCursorChar(HEAP32[103616], HEAP32[103618], 0);
    jsiConsolePrintChar(13);
    jsiConsoleEraseAfterCursor();
   }
  }
 }
 
 function jsiConsolePrintf($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  vcbprintf(575, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsiConsolePrintString($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  while (1) {
   if (HEAPU8[HEAP32[$1 + 12 >> 2]]) {
    if (HEAPU8[HEAP32[$1 + 12 >> 2]] == 10) {
     jsiConsolePrintChar(13)
    }
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$1 + 12 >> 2] = $0 + 1;
    jsiConsolePrintChar(HEAP8[$0 | 0] << 24 >> 24);
    continue;
   }
   break;
  };
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiGetConsoleDevice() {
  return HEAPU8[244432];
 }
 
 function jsiConsolePrintChar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jshTransmit(HEAPU8[244432], HEAPU8[$1 + 15 | 0]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function vcbprintf_callback_jsiConsolePrintString($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  if (HEAP32[$2 + 8 >> 2]) {
   $1 = strlen(HEAP32[$2 + 12 >> 2]);
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + $1;
  }
  jsiConsolePrintString(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsiConsolePrintStringVarUntilEOL($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP8[$4 + 51 | 0] = $3;
  HEAP32[$4 + 44 >> 2] = 0;
  jsvStringIteratorNew($4 + 4 | 0, HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2]);
  while (1) {
   $0 = 0;
   if (jsvStringIteratorHasChar_851($4 + 4 | 0) & 1) {
    $0 = HEAPU32[$4 + 44 >> 2] < HEAPU32[$4 + 52 >> 2]
   }
   block : {
    if (!$0) {
     break block
    }
    HEAP8[$4 + 3 | 0] = jsvStringIteratorGetCharAndNext($4 + 4 | 0);
    if (HEAPU8[$4 + 3 | 0] == 10) {
     break block
    }
    jsiConsolePrintChar(HEAP8[$4 + 3 | 0] << 24 >> 24);
    HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
    continue;
   }
   break;
  };
  jsvStringIteratorFree_852($4 + 4 | 0);
  if (HEAP8[$4 + 51 | 0] & 1) {
   jsiConsolePrintChar(32);
   HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
   while (1) {
    $0 = HEAP32[$4 + 44 >> 2];
    HEAP32[$4 + 44 >> 2] = $0 - 1;
    if ($0) {
     jsiConsolePrintChar(8);
     continue;
    }
    break;
   };
  }
  __stack_pointer = $4 - -64 | 0;
 }
 
 function jsvStringIteratorHasChar_851($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorFree_852($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiConsolePrintStringVarWithNewLineChar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP8[$3 + 55 | 0] = $2;
  jsvStringIteratorNew($3 + 12 | 0, HEAP32[$3 + 60 >> 2], HEAP32[$3 + 56 >> 2]);
  while (1) {
   if (jsvStringIteratorHasChar_851($3 + 12 | 0) & 1) {
    HEAP8[$3 + 11 | 0] = jsvStringIteratorGetCharAndNext($3 + 12 | 0);
    if (HEAPU8[$3 + 11 | 0] == 10) {
     jsiConsolePrintChar(13)
    }
    jsiConsolePrintChar(HEAP8[$3 + 11 | 0] << 24 >> 24);
    if (!(!HEAPU8[$3 + 55 | 0] | HEAPU8[$3 + 11 | 0] != 10)) {
     jsiConsolePrintChar(HEAP8[$3 + 55 | 0] << 24 >> 24)
    }
    continue;
   }
   break;
  };
  jsvStringIteratorFree_852($3 + 12 | 0);
  __stack_pointer = $3 - -64 | 0;
 }
 
 function jsiConsolePrintStringVar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsiConsolePrintStringVarWithNewLineChar(HEAP32[$1 + 12 >> 2], 0, 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiConsoleEraseAfterCursor() {
  jsiConsolePrintString(21364);
 }
 
 function jsiMoveCursor($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  while (1) {
   if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 4 >> 2]) {
    jsiConsolePrintString(21574);
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  while (1) {
   if (HEAPU32[$4 + 12 >> 2] > HEAPU32[$4 + 4 >> 2]) {
    jsiConsolePrintString(21561);
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] - 1;
    continue;
   }
   break;
  };
  while (1) {
   if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 >> 2]) {
    jsiConsolePrintString(21606);
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  while (1) {
   if (HEAPU32[$4 + 8 >> 2] > HEAPU32[$4 >> 2]) {
    jsiConsolePrintString(21660);
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] - 1;
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 16 | 0;
 }
 
 function jsiMoveCursorChar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  if (HEAP32[$3 + 24 >> 2] != HEAP32[$3 + 20 >> 2]) {
   jsvGetLineAndCol(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], $3 + 12 | 0, $3 + 16 | 0, 0);
   jsvGetLineAndCol(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2], $3 + 4 | 0, $3 + 8 | 0, 0);
   jsiMoveCursor(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsiConsoleReturnInputLine() {
  if (HEAP8[414468] & 1) {
   HEAP8[414468] = 0;
   if (jsiEcho() & 1) {
    if (jsiPasswordProtected() & 1) {
     jsiConsolePrintString(18358)
    }
    jsiConsolePrintChar(62);
    jsiConsolePrintStringVarWithNewLineChar(HEAP32[103616], 0, 58);
    jsiMoveCursorChar(HEAP32[103616], jsvGetStringLength(HEAP32[103616]), HEAP32[103618]);
   }
  }
 }
 
 function jsiClearInputLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  if (!(jsvIsEmptyString(HEAP32[103616]) & 1)) {
   if (HEAP8[$1 + 15 | 0] & 1) {
    jsiConsoleRemoveInputLine()
   }
   jsiInputLineCursorMoved();
   jsvUnLock(HEAP32[103616]);
   HEAP32[103616] = jsvNewFromEmptyString_861();
   HEAP32[103618] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiInputLineCursorMoved() {
  if (HEAP32[103624]) {
   jsvStringIteratorFree_852(414484);
   HEAP32[103624] = 0;
  }
  HEAP32[61109] = -1;
 }
 
 function jsvNewFromEmptyString_861() {
  return jsvNewWithFlags(29);
 }
 
 function jsiSetBusy($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  block : {
   if (HEAP8[$2 + 14 | 0] & 1) {
    HEAP8[414480] = HEAPU8[$2 + 15 | 0] | HEAPU8[414480];
    break block;
   }
   HEAP8[414480] = HEAPU8[414480] & ((HEAPU8[$2 + 15 | 0] ^ -1) & 255);
  }
  if (HEAPU8[244433] != 255) {
   jshPinOutput(HEAPU8[244433], HEAPU8[414480] != 0)
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsiSoftInit($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 31 | 0] = $0;
  HEAP8[413226] = 0;
  HEAP8[414479] = 0;
  HEAP32[103612] = jsvNewEmptyArray();
  HEAP32[103616] = jsvNewFromEmptyString_861();
  HEAP32[103618] = 0;
  jsiInputLineCursorMoved();
  HEAP32[103624] = 0;
  jsfSetFlag(1, 0);
  HEAP8[244433] = 255;
  HEAP8[244434] = 255;
  HEAP32[103613] = jsvObjectGetChild(HEAP32[103308], 7018, 3);
  HEAP32[103614] = jsvObjectGetChild(HEAP32[103308], 7361, 3);
  HEAP32[103632] = jshGetSystemTime();
  HEAP32[103633] = i64toi32_i32$HIGH_BITS;
  HEAP32[$1 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 7222);
  if (HEAP32[$1 + 24 >> 2]) {
   HEAP8[245204] = jsvGetIntegerAndUnLock(HEAP32[$1 + 24 >> 2]);
   jsvObjectRemoveChild(HEAP32[103308], 7222);
  }
  jswInit();
  jsfLoadBootCodeFromFlash(HEAP8[$1 + 31 | 0] & 1);
  HEAP32[$1 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 4780);
  if (HEAP32[$1 + 20 >> 2]) {
   jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 20 >> 2], 0, 18223), HEAP32[$1 + 20 >> 2]);
   jsiCheckErrors(0);
   jsvObjectRemoveChild(HEAP32[103308], 4780);
  }
  if (HEAP32[103614]) {
   jsvObjectIteratorNew($1 + 16 | 0, HEAP32[103614]);
   while (1) {
    if (jsvObjectIteratorHasValue_865($1 + 16 | 0) & 1) {
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_866($1 + 16 | 0);
     HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], 15509);
     HEAP8[$1 + 7 | 0] = jsvObjectGetBoolChild(HEAP32[$1 + 12 >> 2], 19262) & 1;
     jshPinWatch(jshGetPinFromVar(HEAP32[$1 + 8 >> 2]) & 255, 1, HEAP8[$1 + 7 | 0] & 1);
     jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
     jsvObjectIteratorNext($1 + 16 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_867($1 + 16 | 0);
  }
  jsiExecuteEventCallbackOn(21559, 4777, 0, 0);
  jsiCheckErrors(0);
  HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 4785);
  if (HEAP32[$1 >> 2]) {
   if (jsiEcho() & 1) {
    jsiConsolePrintString(28659)
   }
   jsiExecuteEventCallback(0, HEAP32[$1 >> 2], 0, 0);
   jsiCheckErrors(0);
   jsvUnLock(HEAP32[$1 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsiCheckErrors($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 176 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 175 | 0] = $0;
  if (HEAPU16[207230] & 32768) {
   jspSetInterrupted(0);
   HEAP16[207230] = HEAPU16[207230] & -32769;
   jsiConsoleRemoveInputLine();
   jsiConsolePrintString(28521);
  }
  HEAP8[$1 + 174 | 0] = 0;
  HEAP8[$1 + 173 | 0] = (HEAP32[103315] & 32) != 0;
  HEAP32[$1 + 168 >> 2] = jspGetException();
  if (HEAP8[$1 + 173 | 0] & 1) {
   if (jsiExecuteEventCallbackOn(6929, 15182, 1, $1 + 168 | 0) & 1) {
    jsvUnLock(HEAP32[$1 + 168 >> 2]);
    HEAP32[$1 + 168 >> 2] = jspGetException();
    if (!HEAP32[$1 + 168 >> 2]) {
     HEAP8[$1 + 173 | 0] = 0
    }
   }
  }
  if (HEAP8[$1 + 173 | 0] & 1) {
   jsiConsoleRemoveInputLine();
   HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 168 >> 2];
   jsiConsolePrintf(27728, $1 + 80 | 0);
   HEAP8[$1 + 174 | 0] = 1;
   if (jsfGetFlag(64) & 1) {
    HEAP8[$1 + 167 | 0] = 8;
    jshPinOutput(HEAPU8[$1 + 167 | 0], 1);
    $2 = jshGetTimeFromMilliseconds(200.0);
    $0 = i64toi32_i32$HIGH_BITS;
    jstPinOutputAtTime($2, $0, 0, $1 + 167 | 0, 1, 0);
   }
   HEAP32[$1 + 160 >> 2] = 0;
   block : {
    if (!(jsfGetFlag(32) & 1)) {
     break block
    }
    jsfNameFromString($1 + 132 | 0, 21152);
    HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 156 >> 2];
    $2 = HEAP32[$1 + 152 >> 2];
    $0 = HEAP32[$1 + 148 >> 2];
    HEAP32[$1 + 64 >> 2] = $0;
    HEAP32[$1 + 68 >> 2] = $2;
    $0 = HEAP32[$1 + 144 >> 2];
    $2 = HEAP32[$1 + 140 >> 2];
    HEAP32[$1 + 56 >> 2] = $2;
    HEAP32[$1 + 60 >> 2] = $0;
    $2 = HEAP32[$1 + 136 >> 2];
    $0 = HEAP32[$1 + 132 >> 2];
    HEAP32[$1 + 48 >> 2] = $0;
    HEAP32[$1 + 52 >> 2] = $2;
    if (jsfFindFile($1 + 48 | 0, 0)) {
     break block
    }
    HEAP32[$1 + 160 >> 2] = jsvAsString(HEAP32[$1 + 168 >> 2]);
   }
   if (jsvIsObject(HEAP32[$1 + 168 >> 2]) & 1) {
    HEAP32[$1 + 128 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 168 >> 2], 15983);
    if (HEAP32[$1 + 128 >> 2]) {
     jsiConsolePrintStringVar(HEAP32[$1 + 128 >> 2]);
     if (HEAP32[$1 + 160 >> 2]) {
      jsvAppendCharacter_870(HEAP32[$1 + 160 >> 2], 10);
      jsvAppendStringVarComplete(HEAP32[$1 + 160 >> 2], HEAP32[$1 + 128 >> 2]);
     }
     jsvUnLock(HEAP32[$1 + 128 >> 2]);
    }
   }
   if (HEAP32[$1 + 160 >> 2]) {
    jsfNameFromString($1 + 100 | 0, 21152);
    $3 = HEAP32[$1 + 160 >> 2];
    HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 124 >> 2];
    $0 = HEAP32[$1 + 120 >> 2];
    $2 = HEAP32[$1 + 116 >> 2];
    HEAP32[$1 + 32 >> 2] = $2;
    HEAP32[$1 + 36 >> 2] = $0;
    $2 = HEAP32[$1 + 112 >> 2];
    $0 = HEAP32[$1 + 108 >> 2];
    HEAP32[$1 + 24 >> 2] = $0;
    HEAP32[$1 + 28 >> 2] = $2;
    $0 = HEAP32[$1 + 104 >> 2];
    $2 = HEAP32[$1 + 100 >> 2];
    HEAP32[$1 + 16 >> 2] = $2;
    HEAP32[$1 + 20 >> 2] = $0;
    jsfWriteFile($1 + 16 | 0, $3, 0, 0, 0);
    jsvUnLock(HEAP32[$1 + 160 >> 2]);
    $0 = $1;
   } else {
    $0 = $2
   }
  }
  jsvUnLock(HEAP32[$1 + 168 >> 2]);
  if (jspIsInterrupted() & 1) {
   jsiConsoleRemoveInputLine();
   jsiConsolePrintString(28409);
   jspSetInterrupted(0);
   HEAP8[$1 + 174 | 0] = 1;
  }
  HEAP32[$1 + 96 >> 2] = jspGetStackTrace();
  if (HEAP32[$1 + 96 >> 2]) {
   if (HEAP8[$1 + 174 | 0] & 1) {
    jsiConsolePrintStringVar(HEAP32[$1 + 96 >> 2])
   }
   jsvUnLock(HEAP32[$1 + 96 >> 2]);
  }
  if (jspHasError() & 1) {
   HEAP32[103315] = HEAP32[103315] & -113
  }
  if (HEAPU8[414479] != HEAPU8[413226]) {
   HEAP8[$1 + 95 | 0] = HEAPU8[413226] & (HEAPU8[414479] ^ -1);
   if (HEAPU8[$1 + 95 | 0] & -9) {
    HEAP32[$1 + 88 >> 2] = jswrap_espruino_getErrorFlagArray(HEAPU8[$1 + 95 | 0]);
    jsiExecuteEventCallbackOn(21559, 17057, 1, $1 + 88 | 0);
    if (HEAP32[$1 + 88 >> 2]) {
     jsiConsoleRemoveInputLine();
     HEAP32[$1 >> 2] = HEAP32[$1 + 88 >> 2];
     jsiConsolePrintf(27741, $1);
     jsvUnLock(HEAP32[$1 + 88 >> 2]);
    }
   }
   HEAP8[414479] = HEAPU8[413226];
  }
  __stack_pointer = $1 + 176 | 0;
 }
 
 function jsvObjectIteratorHasValue_865($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_866($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_867($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiExecuteEventCallbackOn($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], HEAP32[$4 + 28 >> 2]);
  HEAP8[$4 + 11 | 0] = jsiExecuteEventCallbackName(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]) & 1;
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
  __stack_pointer = $4 + 32 | 0;
  return HEAP8[$4 + 11 | 0] & 1;
 }
 
 function jsiExecuteEventCallback($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 8 >> 2] = jsvSkipName(HEAP32[$4 + 20 >> 2]);
  block : {
   if (!HEAP32[$4 + 8 >> 2]) {
    HEAP8[$4 + 31 | 0] = 0;
    break block;
   }
   HEAP16[207230] = HEAPU16[207230] | 8192;
   HEAP8[$4 + 7 | 0] = jsiExecuteEventCallbackInner(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]) & 1;
   jsvUnLock(HEAP32[$4 + 8 >> 2]);
   HEAP16[207230] = HEAPU16[207230] & -24577;
   block1 : {
    if (HEAP8[$4 + 7 | 0] & 1) {
     if (!(jspIsInterrupted() & 1)) {
      break block1
     }
    }
    HEAP16[207230] = HEAPU16[207230] | 32768;
    HEAP8[$4 + 31 | 0] = 0;
    break block;
   }
   HEAP8[$4 + 31 | 0] = 1;
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP8[$4 + 31 | 0] & 1;
 }
 
 function jsvAppendCharacter_870($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 11 | 0, 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsiExecuteEventCallbackName($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP8[$4 + 15 | 0] = 0;
  if (jsvHasChildren(HEAP32[$4 + 28 >> 2]) & 1) {
   HEAP32[$4 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
   if (HEAP32[$4 + 8 >> 2]) {
    jsiExecuteEventCallback(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
    HEAP8[$4 + 15 | 0] = 1;
   }
   jsvUnLock(HEAP32[$4 + 8 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP8[$4 + 15 | 0] & 1;
 }
 
 function jsiExecuteEventCallbackInner($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  block : {
   if (!HEAP32[$4 + 20 >> 2]) {
    HEAP8[$4 + 31 | 0] = 0;
    break block;
   }
   HEAP8[$4 + 11 | 0] = 1;
   block2 : {
    if (jsvIsArray(HEAP32[$4 + 20 >> 2]) & 1) {
     jsvObjectIteratorNew($4 + 4 | 0, HEAP32[$4 + 20 >> 2]);
     while (1) {
      $0 = 0;
      block1 : {
       if (!(HEAP8[$4 + 11 | 0] & 1)) {
        break block1
       }
       $0 = 0;
       if (!(jsvObjectIteratorHasValue_865($4 + 4 | 0) & 1)) {
        break block1
       }
       $0 = (HEAPU16[207230] & 16384) != 0 ^ -1;
      }
      if ($0 & 1) {
       HEAP32[$4 >> 2] = jsvObjectIteratorGetValue_866($4 + 4 | 0);
       jsvObjectIteratorNext($4 + 4 | 0);
       HEAP8[$4 + 11 | 0] = jsiExecuteEventCallbackInner(HEAP32[$4 + 24 >> 2], HEAP32[$4 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]) & 1 & (HEAP8[$4 + 11 | 0] & 1);
       jsvUnLock(HEAP32[$4 >> 2]);
       continue;
      }
      break;
     };
     jsvObjectIteratorFree_867($4 + 4 | 0);
     break block2;
    }
    block3 : {
     if (jsvIsFunction(HEAP32[$4 + 20 >> 2]) & 1) {
      jsvUnLock(jspExecuteFunction(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]));
      break block3;
     }
     block4 : {
      if (jsvIsString(HEAP32[$4 + 20 >> 2]) & 1) {
       jsvUnLock(jspEvaluateVar(HEAP32[$4 + 20 >> 2], 0, 4616));
       break block4;
      }
      jsError(17389, 0);
     }
    }
   }
   HEAP8[$4 + 31 | 0] = HEAP8[$4 + 11 | 0] & 1;
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP8[$4 + 31 | 0] & 1;
 }
 
 function jsiDumpJSON($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = jsvGetIndexOf(HEAP32[103307], HEAP32[$4 + 20 >> 2], 1);
  block1 : {
   block : {
    if (!HEAP32[$4 + 12 >> 2]) {
     break block
    }
    if (!(jsvIsString(HEAP32[$4 + 12 >> 2]) & 1) | HEAP32[$4 + 12 >> 2] == HEAP32[$4 + 16 >> 2]) {
     break block
    }
    $0 = HEAP32[$4 + 28 >> 2];
    $1 = HEAP32[$4 + 24 >> 2];
    HEAP32[$4 >> 2] = HEAP32[$4 + 12 >> 2];
    cbprintf($0, $1, 4263, $4);
    break block1;
   }
   jsfGetJSONWithCallback(HEAP32[$4 + 20 >> 2], 0, 37, 0, HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jsiDumpObjectState($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP32[$4 + 48 >> 2] = $3;
  HEAP32[$4 + 44 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$4 + 48 >> 2]);
  jsvObjectIteratorNew($4 + 40 | 0, HEAP32[$4 + 48 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_865($4 + 40 | 0) & 1) {
    HEAP32[$4 + 36 >> 2] = jsvObjectIteratorGetKey_875($4 + 40 | 0);
    HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetValue_866($4 + 40 | 0);
    block : {
     if (HEAP32[$4 + 44 >> 2]) {
      if (FUNCTION_TABLE[HEAP32[$4 + 44 >> 2]](HEAP32[$4 + 36 >> 2]) & 1) {
       break block
      }
     }
     block1 : {
      if (jsvIsStringEqual(HEAP32[$4 + 36 >> 2], 17727) & 1) {
       HEAP32[$4 + 28 >> 2] = jsvNewFromStringVarComplete(HEAP32[$4 + 52 >> 2]);
       if (HEAP32[$4 + 28 >> 2]) {
        jsvAppendString(HEAP32[$4 + 28 >> 2], 17726);
        jsiDumpObjectState(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 32 >> 2]);
        jsvUnLock(HEAP32[$4 + 28 >> 2]);
       }
       break block1;
      }
      block2 : {
       if (jsvIsStringEqualOrStartsWith(HEAP32[$4 + 36 >> 2], 15492, 1) & 1) {
        if (jsvIsArray(HEAP32[$4 + 32 >> 2]) & 1) {
         jsvObjectIteratorNew($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
         while (1) {
          if (jsvObjectIteratorHasValue_865($4 + 24 | 0) & 1) {
           HEAP32[$4 + 20 >> 2] = jsvObjectIteratorGetValue_866($4 + 24 | 0);
           jsiDumpEvent(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 20 >> 2]);
           jsvUnLock(HEAP32[$4 + 20 >> 2]);
           jsvObjectIteratorNext($4 + 24 | 0);
           continue;
          }
          break;
         };
         jsvObjectIteratorFree_867($4 + 24 | 0);
         break block2;
        }
        jsiDumpEvent(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2]);
        break block2;
       }
       if (!(jsvIsNativeFunction(HEAP32[$4 + 32 >> 2]) & 1)) {
        $0 = HEAP32[$4 + 60 >> 2];
        $1 = HEAP32[$4 + 56 >> 2];
        $2 = HEAP32[$4 + 52 >> 2];
        HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 36 >> 2];
        HEAP32[$4 >> 2] = $2;
        cbprintf($0, $1, 27573, $4);
        jsiDumpJSON(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 32 >> 2], 0);
        FUNCTION_TABLE[HEAP32[$4 + 60 >> 2]](28503, HEAP32[$4 + 56 >> 2]);
       }
      }
     }
    }
    jsvUnLock2(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 36 >> 2]);
    jsvObjectIteratorNext($4 + 40 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_867($4 + 40 | 0);
  __stack_pointer = $4 - -64 | 0;
 }
 
 function jsvObjectIteratorGetKey_875($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsiDumpEvent($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 28 >> 2] = $0;
  HEAP32[$5 + 24 >> 2] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  HEAP32[$5 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$5 + 16 >> 2], 3, 2147483647);
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 24 >> 2];
  $2 = HEAP32[$5 + 20 >> 2];
  HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 8 >> 2];
  HEAP32[$5 >> 2] = $2;
  cbprintf($0, $1, 27681, $5);
  jsvUnLock(HEAP32[$5 + 8 >> 2]);
  jsiDumpJSON(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], 0);
  FUNCTION_TABLE[HEAP32[$5 + 28 >> 2]](28502, HEAP32[$5 + 24 >> 2]);
  __stack_pointer = $5 + 32 | 0;
 }
 
 function jsiDumpHardwareInitialisation($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
 }
 
 function jsiSoftKill() {
  var $0 = 0;
  $0 = __stack_pointer + -64 | 0;
  __stack_pointer = $0;
  jsiPacketFileEnd();
  jsiPacketExit();
  jsiExecuteEventCallbackOn(21559, 15760, 0, 0);
  jsiCheckErrors(0);
  HEAP32[103618] = 0;
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[103616]);
  HEAP32[103616] = 0;
  jswKill();
  jstReset();
  if (HEAP32[103612]) {
   jsvUnLock(HEAP32[103612]);
   HEAP32[103612] = 0;
  }
  if (HEAP32[103613]) {
   jsvUnLock(HEAP32[103613]);
   HEAP32[103613] = 0;
  }
  if (HEAP32[103614]) {
   jsvObjectIteratorNew($0 + 60 | 0, HEAP32[103614]);
   while (1) {
    if (jsvObjectIteratorHasValue_865($0 + 60 | 0) & 1) {
     HEAP32[$0 + 56 >> 2] = jsvObjectIteratorGetValue_866($0 + 60 | 0);
     HEAP32[$0 + 52 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 56 >> 2], 15509);
     jshPinWatch(jshGetPinFromVar(HEAP32[$0 + 52 >> 2]) & 255, 0, 0);
     jsvUnLock2(HEAP32[$0 + 52 >> 2], HEAP32[$0 + 56 >> 2]);
     jsvObjectIteratorNext($0 + 60 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_867($0 + 60 | 0);
   jsvUnLock(HEAP32[103614]);
   HEAP32[103614] = 0;
  }
  if (HEAPU8[245204]) {
   jsvObjectSetChildAndUnLock(HEAP32[103308], 7222, jsvNewFromInteger(HEAPU8[245204]))
  }
  HEAP32[$0 + 48 >> 2] = jsvNewFromEmptyString_861();
  if (HEAP32[$0 + 48 >> 2]) {
   jsvStringIteratorNew($0 + 8 | 0, HEAP32[$0 + 48 >> 2], 0);
   jsiDumpHardwareInitialisation(2, $0 + 8 | 0, 0);
   jsvStringIteratorFree_852($0 + 8 | 0);
   jsvObjectSetChild(HEAP32[103308], 4780, HEAP32[$0 + 48 >> 2]);
   jsvUnLock(HEAP32[$0 + 48 >> 2]);
  }
  HEAP16[207230] = HEAPU16[207230] & -2049;
  HEAP16[207230] = HEAPU16[207230] & -4097;
  __stack_pointer = $0 - -64 | 0;
 }
 
 function jsiPacketFileEnd() {
  jsvObjectRemoveChild(HEAP32[103308], 21545);
  jsiPacketFileSetTimeout(0);
 }
 
 function jsiPacketExit() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP8[414476] = 0;
  HEAP16[207268] = 0;
  HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 20979);
  if (HEAP32[$0 + 12 >> 2]) {
   jsiClearTimeout(HEAP32[$0 + 12 >> 2]);
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
  }
  jsvObjectRemoveChild(HEAP32[103308], 20979);
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[103616]);
  HEAP32[103616] = jsvObjectGetChildIfExists(HEAP32[103308], 21306);
  jsvObjectRemoveChild(HEAP32[103308], 21306);
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jsiSemiInit($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 111 | 0] = $0;
  HEAP32[$2 + 104 >> 2] = $1;
  jspInit();
  HEAP16[207230] = HEAPU16[207230] & 7904;
  HEAP8[244433] = 255;
  HEAP8[$2 + 103 | 0] = 0;
  if (HEAP32[$2 + 104 >> 2]) {
   $4 = HEAP32[103307];
   $1 = HEAP32[$2 + 104 >> 2];
   HEAP32[$2 + 64 >> 2] = HEAP32[$1 + 24 >> 2];
   $3 = HEAP32[$1 + 16 >> 2];
   $0 = HEAP32[$1 + 20 >> 2];
   HEAP32[$2 + 56 >> 2] = $3;
   HEAP32[$2 + 60 >> 2] = $0;
   $3 = HEAP32[$1 + 12 >> 2];
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$2 + 48 >> 2] = $0;
   HEAP32[$2 + 52 >> 2] = $3;
   $0 = HEAP32[$1 + 4 >> 2];
   $3 = HEAP32[$1 >> 2];
   HEAP32[$2 + 40 >> 2] = $3;
   HEAP32[$2 + 44 >> 2] = $0;
   jsvObjectSetChildAndUnLock($4, 20680, jsfVarFromName($2 + 40 | 0));
  }
  if (HEAP8[$2 + 111 | 0] & 1) {
   $5 = jsfFlashContainsCode()
  }
  HEAP8[$2 + 102 | 0] = $5 & 1;
  if (HEAP8[$2 + 102 | 0] & 1) {
   HEAP16[207230] = HEAPU16[207230] & -2049;
   jspSoftKill();
   jsvSoftKill();
   jsfLoadStateFromFlash();
   jsvSoftInit();
   jspSoftInit();
  }
  HEAP32[$2 + 96 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 18349);
  if (HEAP32[$2 + 96 >> 2]) {
   HEAP16[207230] = HEAPU16[207230] | 1024
  }
  jsvUnLock(HEAP32[$2 + 96 >> 2]);
  jsiSoftInit((HEAPU8[$2 + 111 | 0] ^ -1) & 1);
  if (jsiEcho() & 1) {
   if (!(HEAP8[$2 + 102 | 0] & 1)) {
    if (HEAPU8[244432] != 20) {
     jsiConsolePrintString(28035)
    }
    jsfNameFromString($2 + 68 | 0, 21152);
    HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 92 >> 2];
    $3 = HEAP32[$2 + 88 >> 2];
    $0 = HEAP32[$2 + 84 >> 2];
    HEAP32[$2 + 24 >> 2] = $0;
    HEAP32[$2 + 28 >> 2] = $3;
    $0 = HEAP32[$2 + 80 >> 2];
    $3 = HEAP32[$2 + 76 >> 2];
    HEAP32[$2 + 16 >> 2] = $3;
    HEAP32[$2 + 20 >> 2] = $0;
    $3 = HEAP32[$2 + 72 >> 2];
    $0 = HEAP32[$2 + 68 >> 2];
    HEAP32[$2 + 8 >> 2] = $0;
    HEAP32[$2 + 12 >> 2] = $3;
    if (jsfFindFile($2 + 8 | 0, 0)) {
     jsiConsolePrintString(27782)
    }
   }
   if (HEAPU8[244432] != 20) {
    jsiConsolePrintString(28752)
   }
   HEAP8[414468] = 1;
  }
  if (HEAP8[$2 + 103 | 0] & 1) {
   jsvUnLock(jspEvaluate(25984, 1))
  }
  __stack_pointer = $2 + 112 | 0;
 }
 
 function jsiInit($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP16[207230] = 6144;
  HEAP8[244432] = 19;
  jsiSemiInit(HEAP8[$1 + 15 | 0] & 1, 0);
  jsiSetBusy(1, 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiOneSecondAfterStartup() {
  block : {
   if (HEAPU8[244432] == 19) {
    HEAP8[244432] = jsiGetPreferredConsoleDevice();
    jshTransmitMove(19, HEAPU8[244432]);
    jshUSARTKick(HEAPU8[244432]);
    break block;
   }
   jshTransmitClearDevice(19);
  }
 }
 
 function jsiKill() {
  jsiSoftKill();
  jspKill();
 }
 
 function jsiCountBracketsInInput() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 144 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 140 >> 2] = 0;
  HEAP32[$0 >> 2] = jslSetLex($0 + 4 | 0);
  jslInit(HEAP32[103616]);
  while (1) {
   block1 : {
    $1 = 0;
    block : {
     if (!HEAPU16[$0 + 6 >> 1]) {
      break block
     }
     $1 = 0;
     if (HEAPU16[$0 + 6 >> 1] == 137) {
      break block
     }
     $1 = 0;
     if (HEAPU16[$0 + 6 >> 1] == 132) {
      break block
     }
     $1 = HEAPU16[$0 + 6 >> 1] != 134;
    }
    if (!$1) {
     break block1
    }
    if (!(!(HEAPU16[$0 + 6 >> 1] == 123 | HEAPU16[$0 + 6 >> 1] == 91) & HEAPU16[$0 + 6 >> 1] != 40)) {
     HEAP32[$0 + 140 >> 2] = HEAP32[$0 + 140 >> 2] + 1
    }
    if (!(!(HEAPU16[$0 + 6 >> 1] == 125 | HEAPU16[$0 + 6 >> 1] == 93) & HEAPU16[$0 + 6 >> 1] != 41)) {
     HEAP32[$0 + 140 >> 2] = HEAP32[$0 + 140 >> 2] - 1
    }
    if (HEAP32[$0 + 140 >> 2] < 0) {
     break block1
    }
    jslGetNextToken();
    continue;
   }
   break;
  };
  if (HEAPU16[$0 + 6 >> 1] == 132) {
   HEAP32[$0 + 140 >> 2] = 0
  }
  if (!(HEAPU16[$0 + 6 >> 1] != 137 & HEAPU16[$0 + 6 >> 1] != 134)) {
   HEAP32[$0 + 140 >> 2] = 1e3
  }
  jslKill();
  jslSetLex(HEAP32[$0 >> 2]);
  __stack_pointer = $0 + 144 | 0;
  return HEAP32[$0 + 140 >> 2];
 }
 
 function jsiFreeMoreMemory() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 3536);
  block : {
   if (!HEAP32[$0 + 8 >> 2]) {
    HEAP8[$0 + 15 | 0] = 0;
    break block;
   }
   HEAP32[$0 + 4 >> 2] = jsvArrayPopFirst(HEAP32[$0 + 8 >> 2]);
   HEAP8[$0 + 3 | 0] = HEAP32[$0 + 4 >> 2] != 0;
   jsvUnLock2(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
   HEAP8[$0 + 15 | 0] = HEAP8[$0 + 3 | 0] & 1;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function jsiHistoryAddLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 12 >> 2]) {
    break block
   }
   HEAP32[$1 + 8 >> 2] = jsvGetStringLength(HEAP32[$1 + 12 >> 2]);
   if (!HEAP32[$1 + 8 >> 2] | HEAPU32[$1 + 8 >> 2] > 500) {
    break block
   }
   HEAP32[$1 + 4 >> 2] = jsiGetHistory();
   if (!HEAP32[$1 + 4 >> 2]) {
    break block
   }
   HEAP32[$1 >> 2] = jsvGetIndexOf(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2], 0);
   if (HEAP32[$1 >> 2]) {
    jsvRemoveChildAndUnLock(HEAP32[$1 + 4 >> 2], HEAP32[$1 >> 2])
   }
   jsvArrayPush(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiGetHistory() {
  return jsvObjectGetChild(HEAP32[103308], 3536, 3);
 }
 
 function jsiGetHistoryLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 27 | 0] = $0;
  HEAP32[$1 + 20 >> 2] = jsiGetHistory();
  block : {
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 16 >> 2] = 0;
   HEAP32[$1 + 12 >> 2] = jsvGetIndexOf(HEAP32[$1 + 20 >> 2], HEAP32[103616], 1);
   block4 : {
    if (HEAP32[$1 + 12 >> 2]) {
     block2 : {
      block1 : {
       if (!(HEAP8[$1 + 27 | 0] & 1)) {
        break block1
       }
       if (!(jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
        break block1
       }
       HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvLock(jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535));
       break block2;
      }
      block3 : {
       if (HEAP8[$1 + 27 | 0] & 1) {
        break block3
       }
       if (!(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
        break block3
       }
       HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvLock(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535));
      }
     }
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
     break block4;
    }
    if (HEAP8[$1 + 27 | 0] & 1) {
     HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 20 >> 2], jsvGetArrayLength(HEAP32[$1 + 20 >> 2]) - 1 | 0))
    }
   }
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsiIsInHistory($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = jsiGetHistory();
  block : {
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP8[$1 + 31 | 0] = 0;
    break block;
   }
   HEAP32[$1 + 16 >> 2] = jsvGetIndexOf(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 24 >> 2], 1);
   HEAP8[$1 + 15 | 0] = HEAP32[$1 + 16 >> 2] != 0;
   jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
   HEAP8[$1 + 31 | 0] = HEAP8[$1 + 15 | 0] & 1;
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP8[$1 + 31 | 0] & 1;
 }
 
 function jsiReplaceInputLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (jsiShowInputLine() & 1) {
   jsiMoveCursorChar(HEAP32[103616], HEAP32[103618], 0);
   jsiConsoleEraseAfterCursor();
   jsiConsolePrintStringVarWithNewLineChar(HEAP32[$1 + 12 >> 2], 0, 58);
  }
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[103616]);
  HEAP32[103616] = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
  HEAP32[103618] = jsvGetStringLength(HEAP32[103616]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiShowInputLine() {
  var $0 = 0;
  $0 = 0;
  block : {
   if (!(jsiEcho() & 1)) {
    break block
   }
   $0 = 0;
   if (HEAP8[414468] & 1) {
    break block
   }
   $0 = jsiPasswordProtected() ^ -1;
  }
  return $0 & 1;
 }
 
 function jsiChangeToHistory($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP32[$1 + 8 >> 2] = jsiGetHistoryLine(HEAP8[$1 + 15 | 0] & 1);
  block : {
   if (HEAP32[$1 + 8 >> 2]) {
    jsiReplaceInputLine(HEAP32[$1 + 8 >> 2]);
    jsvUnLock(HEAP32[$1 + 8 >> 2]);
    HEAP8[414477] = 1;
    break block;
   }
   if (!(HEAP8[$1 + 15 | 0] & 1)) {
    if (jsiShowInputLine() & 1) {
     jsiMoveCursorChar(HEAP32[103616], HEAP32[103618], 0);
     jsiConsoleEraseAfterCursor();
    }
    jsiInputLineCursorMoved();
    jsvUnLock(HEAP32[103616]);
    HEAP32[103616] = jsvNewFromEmptyString_861();
    HEAP32[103618] = 0;
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiIsAboutToEditInputLine() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  if (HEAP8[414477] & 1) {
   HEAP8[414477] = 0;
   if (jsiIsInHistory(HEAP32[103616]) & 1) {
    HEAP32[$0 + 12 >> 2] = jsvCopy(HEAP32[103616], 0);
    if (HEAP32[$0 + 12 >> 2]) {
     jsiInputLineCursorMoved();
     jsvUnLock(HEAP32[103616]);
     HEAP32[103616] = HEAP32[$0 + 12 >> 2];
    }
   }
  }
  if (HEAP32[61109] < 0) {
   HEAP32[61109] = jsvGetStringLength(HEAP32[103616])
  }
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jsiHandleDelete($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 31 | 0] = $0;
  HEAP32[$1 + 24 >> 2] = jsvGetStringLength(HEAP32[103616]);
  block1 : {
   if (!(HEAP32[103618] | !(HEAP8[$1 + 31 | 0] & 1)) | !(HEAP8[$1 + 31 | 0] & 1 | HEAPU32[103618] < HEAPU32[$1 + 24 >> 2])) {
    break block1
   }
   block3 : {
    if (HEAP8[$1 + 31 | 0] & 1) {
     $0 = 1;
     if ((jsvGetCharInString(HEAP32[103616], HEAP32[103618] - 1 | 0) | 0) == 10) {
      break block3
     }
    }
    if (!(HEAP8[$1 + 31 | 0] & 1)) {
     $2 = (jsvGetCharInString(HEAP32[103616], HEAP32[103618]) | 0) == 10
    }
    $0 = $2;
   }
   HEAP8[$1 + 23 | 0] = $0 & 1;
   block4 : {
    if (!(HEAP8[$1 + 23 | 0] & 1)) {
     break block4
    }
    if (!(jsiShowInputLine() & 1)) {
     break block4
    }
    jsiConsoleEraseAfterCursor();
    if (HEAP8[$1 + 31 | 0] & 1) {
     jsiConsolePrintString(27705);
     jsiMoveCursorChar(HEAP32[103616], HEAP32[103618], HEAP32[103618] - 1 | 0);
     jsiInputLineCursorMoved();
    }
   }
   HEAP32[$1 + 16 >> 2] = jsvNewFromEmptyString_861();
   HEAP32[$1 + 12 >> 2] = HEAP32[103618];
   if (HEAP8[$1 + 31 | 0] & 1) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] - 1
   }
   if (HEAP32[$1 + 12 >> 2]) {
    jsvAppendStringVar(HEAP32[$1 + 16 >> 2], HEAP32[103616], 0, HEAP32[$1 + 12 >> 2])
   }
   if (HEAPU32[$1 + 24 >> 2] > HEAP32[$1 + 12 >> 2] + 1 >>> 0) {
    jsvAppendStringVar(HEAP32[$1 + 16 >> 2], HEAP32[103616], HEAP32[$1 + 12 >> 2] + 1 | 0, 2147483647)
   }
   jsiInputLineCursorMoved();
   jsvUnLock(HEAP32[103616]);
   HEAP32[103616] = HEAP32[$1 + 16 >> 2];
   if (HEAP8[$1 + 31 | 0] & 1) {
    HEAP32[103618] = HEAP32[103618] - 1
   }
   if (!(jsiShowInputLine() & 1)) {
    break block1
   }
   block5 : {
    if (HEAP8[$1 + 23 | 0] & 1) {
     jsiConsolePrintStringVarWithNewLineChar(HEAP32[103616], HEAP32[103618], 58);
     jsiMoveCursorChar(HEAP32[103616], jsvGetStringLength(HEAP32[103616]), HEAP32[103618]);
     break block5;
    }
    if (HEAP8[$1 + 31 | 0] & 1) {
     jsiConsolePrintChar(8)
    }
    jsiConsolePrintStringVarUntilEOL(HEAP32[103616], HEAP32[103618], -1, 1);
   }
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsiHandleHome() {
  var $0 = 0;
  while (1) {
   $0 = 0;
   if (HEAP32[103618]) {
    $0 = (jsvGetCharInString(HEAP32[103616], HEAP32[103618] - 1 | 0) | 0) != 10
   }
   if ($0) {
    if (jsiShowInputLine() & 1) {
     jsiConsolePrintChar(8)
    }
    HEAP32[103618] = HEAP32[103618] - 1;
    continue;
   }
   break;
  };
 }
 
 function jsiHandleEnd() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jsvGetStringLength(HEAP32[103616]);
  while (1) {
   $1 = 0;
   if (HEAPU32[103618] < HEAPU32[$0 + 12 >> 2]) {
    $1 = (jsvGetCharInString(HEAP32[103616], HEAP32[103618]) | 0) != 10
   }
   if ($1) {
    if (jsiShowInputLine() & 1) {
     jsiConsolePrintChar(jsvGetCharInString(HEAP32[103616], HEAP32[103618]) << 24 >> 24)
    }
    HEAP32[103618] = HEAP32[103618] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jsiHandlePageUpDown($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 31 | 0] = $0;
  jsvGetLineAndCol(HEAP32[103616], HEAP32[103618], $1 + 20 | 0, $1 + 24 | 0, 0);
  block : {
   if (!(HEAP8[$1 + 31 | 0] & 1)) {
    HEAP32[103618] = 0;
    break block;
   }
   HEAP32[103618] = jsvGetStringLength(HEAP32[103616]);
  }
  HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 24 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 20 >> 2];
  jsvGetLineAndCol(HEAP32[103616], HEAP32[103618], $1 + 12 | 0, $1 + 16 | 0, 0);
  jsiMoveCursor(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsiHandleMoveUpDown($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP32[$1 + 16 >> 2] = jsvGetLinesInString(HEAP32[103616]);
  jsvGetLineAndCol(HEAP32[103616], HEAP32[103618], $1 + 20 | 0, $1 + 24 | 0, 0);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 24 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 20 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + HEAP32[$1 + 28 >> 2];
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 8 >> 2] = 1
  }
  if (HEAPU32[$1 + 8 >> 2] > HEAPU32[$1 + 16 >> 2]) {
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 16 >> 2]
  }
  HEAP32[103618] = jsvGetIndexFromLineAndCol(HEAP32[103616], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvGetLineAndCol(HEAP32[103616], HEAP32[103618], $1 + 8 | 0, $1 + 12 | 0, 0);
  if (jsiShowInputLine() & 1) {
   jsiMoveCursor(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2])
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsiAtEndOfInputLine() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = HEAP32[103618];
  HEAP32[$0 + 4 >> 2] = jsvGetStringLength(HEAP32[103616]);
  block : {
   while (1) {
    if (HEAPU32[$0 + 8 >> 2] < HEAPU32[$0 + 4 >> 2]) {
     if (isWhitespace(jsvGetCharInString(HEAP32[103616], HEAP32[$0 + 8 >> 2]) << 24 >> 24) & 1) {
      HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
      continue;
     } else {
      HEAP8[$0 + 15 | 0] = 0;
      break block;
     }
    }
    break;
   };
   HEAP8[$0 + 15 | 0] = 1;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function jsiTabComplete_findCommon($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  block : {
   if (jsvGetStringLength(HEAP32[$2 + 8 >> 2]) >>> 0 <= HEAPU32[HEAP32[$2 + 4 >> 2] >> 2]) {
    break block
   }
   if (jsvCompareString(HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2], HEAP32[$2 + 8 >> 2], 0, 0, 1)) {
    break block
   }
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
   block1 : {
    if (HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
     HEAP32[$2 >> 2] = jsvGetCommonCharacters(HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2], HEAP32[$2 + 8 >> 2]);
     jsvUnLock(HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2]);
     HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2] = HEAP32[$2 >> 2];
     break block1;
    }
    $0 = jsvLockAgain(HEAP32[$2 + 8 >> 2]);
    HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2] = $0;
   }
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsiTabComplete_printCommon($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 28 >> 2];
  block : {
   if (jsvGetStringLength(HEAP32[$2 + 24 >> 2]) >>> 0 <= HEAPU32[HEAP32[$2 + 20 >> 2] >> 2]) {
    break block
   }
   if (jsvCompareString(HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2], HEAP32[$2 + 24 >> 2], 0, 0, 1)) {
    break block
   }
   block1 : {
    if (!HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2]) {
     HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
     jsiConsolePrintf(4263, $2);
     $0 = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
     HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = $0;
     break block1;
    }
    if (HEAPU32[HEAP32[$2 + 20 >> 2] + 16 >> 2] >= 20) {
     HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = 19
    }
    while (1) {
     if (HEAPU32[HEAP32[$2 + 20 >> 2] + 16 >> 2] < 20) {
      jsiConsolePrintChar(32);
      $0 = HEAP32[$2 + 20 >> 2];
      HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2];
    jsiConsolePrintf(27778, $2 + 16 | 0);
    HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = 0;
   }
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jsiTabComplete() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 320 | 0;
  __stack_pointer = $0;
  block : {
   if (!(jsvIsString(HEAP32[103616]) & 1)) {
    break block
   }
   HEAP32[$0 + 316 >> 2] = jsvLockAgain(HEAP32[103307]);
   HEAP32[$0 + 300 >> 2] = 0;
   HEAP32[$0 + 292 >> 2] = 0;
   HEAP32[$0 + 152 >> 2] = jslSetLex($0 + 156 | 0);
   jslInit(HEAP32[103616]);
   while (1) {
    $1 = 0;
    $1 = HEAP16[$0 + 158 >> 1] << 16 >> 16 ? HEAPU32[103618] >= HEAP32[$0 + 160 >> 2] + 1 >>> 0 : $1;
    if ($1) {
     block1 : {
      if (HEAPU16[$0 + 158 >> 1] == 46) {
       jsvGetString(HEAP32[$0 + 300 >> 2], $0 + 80 | 0, 64);
       HEAP32[$0 + 76 >> 2] = jspGetNamedField(HEAP32[$0 + 316 >> 2], $0 + 80 | 0, 0);
       jsvUnLock2(HEAP32[$0 + 316 >> 2], HEAP32[$0 + 300 >> 2]);
       HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 76 >> 2];
       if (!HEAP32[$0 + 316 >> 2]) {
        HEAP32[$0 + 316 >> 2] = jsvNewObject()
       }
       HEAP32[$0 + 300 >> 2] = 0;
       break block1;
      }
      block2 : {
       if (HEAPU16[$0 + 158 >> 1] == 128) {
        jsvUnLock(HEAP32[$0 + 300 >> 2]);
        HEAP32[$0 + 300 >> 2] = jslGetTokenValueAsVar();
        HEAP32[$0 + 292 >> 2] = HEAP32[$0 + 160 >> 2] + 1;
        break block2;
       }
       jsvUnLock(HEAP32[$0 + 316 >> 2]);
       HEAP32[$0 + 316 >> 2] = 0;
       jsvUnLock(HEAP32[$0 + 300 >> 2]);
       HEAP32[$0 + 300 >> 2] = 0;
      }
     }
     jslGetNextToken();
     continue;
    }
    break;
   };
   jslKill();
   jslSetLex(HEAP32[$0 + 152 >> 2]);
   if (!(HEAP32[$0 + 316 >> 2] | HEAP32[$0 + 300 >> 2])) {
    break block
   }
   block4 : {
    if (HEAP32[$0 + 300 >> 2]) {
     HEAP32[$0 + 296 >> 2] = jsvGetStringLength(HEAP32[$0 + 300 >> 2]);
     HEAP32[$0 + 72 >> 2] = (HEAP32[103618] + 1 | 0) - HEAP32[$0 + 292 >> 2];
     if (HEAPU32[$0 + 72 >> 2] > HEAPU32[$0 + 296 >> 2]) {
      jsvUnLock2(HEAP32[$0 + 316 >> 2], HEAP32[$0 + 300 >> 2]);
      break block;
     }
     if (HEAPU32[$0 + 72 >> 2] < HEAPU32[$0 + 296 >> 2]) {
      HEAP32[$0 + 68 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 300 >> 2], 0, HEAP32[$0 + 72 >> 2]);
      jsvUnLock(HEAP32[$0 + 300 >> 2]);
      HEAP32[$0 + 300 >> 2] = HEAP32[$0 + 68 >> 2];
      HEAP32[$0 + 296 >> 2] = HEAP32[$0 + 72 >> 2];
     }
     break block4;
    }
    HEAP32[$0 + 300 >> 2] = jsvNewFromEmptyString_861();
    HEAP32[$0 + 296 >> 2] = 0;
   }
   if (!HEAP32[$0 + 316 >> 2]) {
    jsvUnLock(HEAP32[$0 + 300 >> 2]);
    break block;
   }
   HEAP32[$0 + 304 >> 2] = 0;
   HEAP32[$0 + 308 >> 2] = 0;
   jswrap_object_keys_or_property_names_cb(HEAP32[$0 + 316 >> 2], 7, 576, $0 + 296 | 0);
   if (HEAP32[$0 + 308 >> 2] > 1) {
    jsiMoveCursorChar(HEAP32[103616], HEAP32[103618], HEAP32[61109]);
    HEAP8[414468] = 1;
    jsiConsolePrintString(28751);
    HEAP32[$0 + 312 >> 2] = 0;
    jswrap_object_keys_or_property_names_cb(HEAP32[$0 + 316 >> 2], 7, 577, $0 + 296 | 0);
    if (HEAP32[$0 + 312 >> 2]) {
     jsiConsolePrintString(28752)
    }
    jsiConsolePrintString(28752);
    jsiConsoleReturnInputLine();
   }
   jsvUnLock2(HEAP32[$0 + 316 >> 2], HEAP32[$0 + 300 >> 2]);
   if (!HEAP32[$0 + 304 >> 2]) {
    break block
   }
   jsvGetString(HEAP32[$0 + 304 >> 2], $0, 64);
   if (HEAPU32[$0 + 296 >> 2] < strlen($0) >>> 0) {
    jsiAppendStringToInputLine(HEAP32[$0 + 296 >> 2] + $0 | 0)
   }
   jsvUnLock(HEAP32[$0 + 304 >> 2]);
  }
  __stack_pointer = $0 + 320 | 0;
 }
 
 function jsiAppendStringToInputLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsiIsAboutToEditInputLine();
  HEAP32[$1 + 8 >> 2] = 1;
  while (1) {
   if (HEAPU8[HEAP32[$1 + 12 >> 2] + HEAP32[$1 + 8 >> 2] | 0]) {
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  block : {
   if (HEAP32[103618] >= HEAP32[61109]) {
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 12 >> 2];
    while (1) {
     if (HEAPU8[HEAP32[$1 + 4 >> 2]]) {
      $0 = HEAP32[$1 + 4 >> 2];
      HEAP32[$1 + 4 >> 2] = $0 + 1;
      jsiAppendToInputLine(HEAP8[$0 | 0] << 24 >> 24);
      continue;
     }
     break;
    };
    break block;
   }
   HEAP32[$1 >> 2] = jsvNewFromEmptyString_861();
   if (HEAP32[103618]) {
    jsvAppendStringVar(HEAP32[$1 >> 2], HEAP32[103616], 0, HEAP32[103618])
   }
   jsvAppendString(HEAP32[$1 >> 2], HEAP32[$1 + 12 >> 2]);
   jsvAppendStringVar(HEAP32[$1 >> 2], HEAP32[103616], HEAP32[103618], 2147483647);
   jsiInputLineCursorMoved();
   jsvUnLock(HEAP32[103616]);
   HEAP32[103616] = HEAP32[$1 >> 2];
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintStringVarUntilEOL(HEAP32[103616], HEAP32[103618], -1, 1)
   }
  }
  HEAP32[103618] = HEAP32[$1 + 8 >> 2] + HEAP32[103618];
  if (jsiShowInputLine() & 1) {
   jsiConsolePrintString(HEAP32[$1 + 12 >> 2])
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiAppendToInputLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  if (!HEAP32[103624]) {
   jsvStringIteratorNew(414484, HEAP32[103616], 0);
   jsvStringIteratorGotoEnd(414484);
   HEAP32[61109] = jsvGetStringLength(HEAP32[103616]);
  }
  jsvStringIteratorAppend(414484, HEAP8[$1 + 15 | 0] << 24 >> 24);
  HEAP32[61109] = HEAP32[61109] + 1;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiHandleNewLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 31 | 0] = $0;
  block3 : {
   if (jsiAtEndOfInputLine() & 1) {
    block : {
     if (!(HEAP8[$1 + 31 | 0] & 1)) {
      break block
     }
     if ((jsiCountBracketsInInput() | 0) > 0) {
      break block
     }
     if (jsiShowInputLine() & 1) {
      jsiConsolePrintString(28752)
     }
     if (!(HEAPU16[207230] & 2)) {
      HEAP8[414468] = 1
     }
     HEAP32[$1 + 24 >> 2] = jsvStringTrimRight(HEAP32[103616]);
     jsiClearInputLine(0);
     HEAP32[$1 + 20 >> 2] = jspEvaluateVar(HEAP32[$1 + 24 >> 2], 0, 21274);
     HEAP8[$1 + 19 | 0] = jsvIsEmptyString(HEAP32[$1 + 24 >> 2]) & 1;
     block1 : {
      if (HEAP8[$1 + 19 | 0] & 1) {
       break block1
      }
      if (!(jsiEcho() & 1)) {
       break block1
      }
      jsiHistoryAddLine(HEAP32[$1 + 24 >> 2]);
     }
     jsvUnLock(HEAP32[$1 + 24 >> 2]);
     block2 : {
      if (!(jsiEcho() & 1)) {
       break block2
      }
      if (jspHasError() & 1 | HEAP8[$1 + 19 | 0] & 1) {
       break block2
      }
      jsiConsolePrintChar(61);
      jsfPrintJSON(HEAP32[$1 + 20 >> 2], 813);
      jsiConsolePrintString(28752);
     }
     jsvUnLock(HEAP32[$1 + 20 >> 2]);
     jsiCheckErrors(1);
     HEAP16[207230] = HEAPU16[207230] & -3;
     break block3;
    }
    if (jsiShowInputLine() & 1) {
     jsiConsolePrintString(22238)
    }
    jsiIsAboutToEditInputLine();
    jsiAppendToInputLine(10);
    HEAP32[103618] = HEAP32[103618] + 1;
    break block3;
   }
   jsiIsAboutToEditInputLine();
   if (jsiShowInputLine() & 1) {
    jsiConsoleEraseAfterCursor()
   }
   HEAP32[$1 + 12 >> 2] = jsvNewFromEmptyString_861();
   if (HEAP32[103618]) {
    jsvAppendStringVar(HEAP32[$1 + 12 >> 2], HEAP32[103616], 0, HEAP32[103618])
   }
   jsvAppendCharacter_870(HEAP32[$1 + 12 >> 2], 10);
   jsvAppendStringVar(HEAP32[$1 + 12 >> 2], HEAP32[103616], HEAP32[103618], 2147483647);
   jsiInputLineCursorMoved();
   jsvUnLock(HEAP32[103616]);
   HEAP32[103616] = HEAP32[$1 + 12 >> 2];
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintStringVarWithNewLineChar(HEAP32[103616], HEAP32[103618], 58);
    jsiMoveCursorChar(HEAP32[103616], jsvGetStringLength(HEAP32[103616]), HEAP32[103618] + 1 | 0);
   }
   HEAP32[103618] = HEAP32[103618] + 1;
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsiQueueEvents($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = jsvNewObject();
  if (HEAP32[$4 + 12 >> 2]) {
   jsvUnLock(jsvAddNamedChild(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], 20453));
   if (HEAP32[$4 + 16 >> 2]) {
    HEAP32[$4 + 8 >> 2] = jsvNewArray(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
    if (HEAP32[$4 + 8 >> 2]) {
     jsvAddNamedChildAndUnLock(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], 7217)
    }
   }
   if (HEAP32[$4 + 28 >> 2]) {
    jsvUnLock(jsvAddNamedChild(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 28 >> 2], 7207))
   }
   jsvArrayPushAndUnLock(HEAP32[103612], HEAP32[$4 + 12 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jsiObjectHasCallbacks($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  HEAP8[$2 + 3 | 0] = (jsvIsUndefined(HEAP32[$2 + 4 >> 2]) ^ -1) & 1;
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP8[$2 + 3 | 0] & 1;
 }
 
 function jsiQueueObjectCallbacks($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
  if (HEAP32[$4 + 12 >> 2]) {
   jsiQueueEvents(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
   jsvUnLock(HEAP32[$4 + 12 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jsiExecuteEvents() {
  var $0 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 31 | 0] = (jsvArrayIsEmpty(HEAP32[103612]) ^ -1) & 1;
  if (HEAP8[$0 + 31 | 0] & 1) {
   jsiSetBusy(1, 1)
  }
  while (1) {
   if ((jsvArrayIsEmpty(HEAP32[103612]) ^ -1) & 1) {
    HEAP32[$0 + 24 >> 2] = jsvSkipNameAndUnLock(jsvArrayPopFirst(HEAP32[103612]));
    HEAP32[$0 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 24 >> 2], 20453);
    HEAP32[$0 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 24 >> 2], 7207);
    HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 24 >> 2], 7217);
    jsvUnLock(HEAP32[$0 + 24 >> 2]);
    jsiExecuteEventCallbackArgsArray(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2]);
    jsvUnLock(HEAP32[$0 + 12 >> 2]);
    jsvUnLock2(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 16 >> 2]);
    continue;
   }
   break;
  };
  if (HEAP8[$0 + 31 | 0] & 1) {
   jsiSetBusy(1, 0);
   if (jspIsInterrupted() & 1) {
    HEAP16[207230] = HEAPU16[207230] | 32768
   }
  }
  __stack_pointer = $0 + 32 | 0;
 }
 
 function jsvArrayIsEmpty($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) != 0 ^ -1;
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jsiExecuteEventCallbackArgsArray($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = 0;
  HEAP32[$3 + 8 >> 2] = 0;
  block : {
   if (HEAP32[$3 + 16 >> 2]) {
    HEAP32[$3 + 12 >> 2] = jsvGetArrayLength(HEAP32[$3 + 16 >> 2]);
    if (HEAP32[$3 + 12 >> 2]) {
     $0 = $3 - ((HEAP32[$3 + 12 >> 2] << 2) + 15 & -16) | 0;
     __stack_pointer = $0;
     HEAP32[$3 + 8 >> 2] = $0;
     if (!HEAP32[$3 + 8 >> 2]) {
      HEAP8[$3 + 31 | 0] = 0;
      break block;
     }
     jsvGetArrayItems(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
    }
   }
   HEAP8[$3 + 7 | 0] = jsiExecuteEventCallback(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]) & 1;
   jsvUnLockMany(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 31 | 0] & 1;
 }
 
 function jsiSetTimeout($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAPF64[$2 + 16 >> 3] = $1;
  HEAP32[$2 + 12 >> 2] = jsvNewNativeFunction(HEAP32[$2 + 24 >> 2], 0);
  block : {
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 8 >> 2] = jswrap_interface_setTimeout(HEAP32[$2 + 12 >> 2], HEAPF64[$2 + 16 >> 3], 0);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsiClearTimeout($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvNewArray($1 + 12 | 0, 1);
  jswrap_interface_clearTimeout(HEAP32[$1 + 8 >> 2]);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiShouldExecuteWatch($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  HEAP32[$2 + 4 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 12 >> 2], 18082);
  __stack_pointer = $2 + 16 | 0;
  $0 = 1;
  block : {
   if (!HEAP32[$2 + 4 >> 2]) {
    break block
   }
   if (HEAP8[$2 + 11 | 0] & 1) {
    $0 = 1;
    if (HEAP32[$2 + 4 >> 2] > 0) {
     break block
    }
   }
   $3 = HEAP8[$2 + 11 | 0] & 1 ? $3 : HEAP32[$2 + 4 >> 2] < 0;
   $0 = $3;
  }
  return $0 & 1;
 }
 
 function jsiIsWatchingPin($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 14 | 0] = $0;
  block : {
   if (jshGetPinShouldStayWatched(HEAPU8[$1 + 14 | 0]) & 1) {
    HEAP8[$1 + 15 | 0] = 1;
    break block;
   }
   HEAP8[$1 + 13 | 0] = 0;
   jsvObjectIteratorNew($1 + 8 | 0, HEAP32[103614]);
   while (1) {
    if (jsvObjectIteratorHasValue_865($1 + 8 | 0) & 1) {
     HEAP32[$1 + 4 >> 2] = jsvObjectIteratorGetValue_866($1 + 8 | 0);
     HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 4 >> 2], 15509);
     if ((jshGetPinFromVar(HEAP32[$1 >> 2]) & 255) == HEAPU8[$1 + 14 | 0]) {
      HEAP8[$1 + 13 | 0] = 1
     }
     jsvUnLock2(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
     jsvObjectIteratorNext($1 + 8 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_867($1 + 8 | 0);
   HEAP8[$1 + 15 | 0] = HEAP8[$1 + 13 | 0] & 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jsiCtrlC() {
  if (!(jsiPasswordProtected() & 1 | !(HEAPU8[414476] < 2 | HEAPU8[414476] > 4))) {
   HEAP32[103315] = HEAP32[103315] | 2048
  }
 }
 
 function jsiHandleIOEventForSerial($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP8[$4 + 27 | 0] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2] + 2;
  block : {
   if (HEAP32[$4 + 16 >> 2]) {
    $0 = jsvNewStringOfLength(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 20 >> 2]);
    break block;
   }
   $0 = 0;
  }
  HEAP32[$4 + 8 >> 2] = $0;
  if (HEAP32[$4 + 8 >> 2]) {
   while (1) {
    if (jshIsTopEvent(HEAPU8[$4 + 27 | 0] & 31) & 1) {
     jshPopIOEvent(HEAP32[$4 + 20 >> 2], $4 + 16 | 0);
     HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + (HEAP32[$4 + 16 >> 2] + 2 | 0);
     jsvAppendStringBuf(HEAP32[$4 + 8 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
     continue;
    }
    break;
   };
   jswrap_stream_pushData(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2], 1);
   jsvUnLock(HEAP32[$4 + 8 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 16 >> 2] + 2 | 0;
 }
 
 function jsiHandleIOEventForConsole($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsiSetBusy(1, 1);
  HEAP32[$2 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 4 >> 2] < HEAP32[$2 + 8 >> 2]) {
    jsiHandleConsoleChar(HEAP8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 4 >> 2] | 0] << 24 >> 24);
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  jsiSetBusy(1, 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsiHandleConsoleChar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 31 | 0] = $0;
  block3 : {
   if (jsiPasswordProtected() & 1) {
    if (!(HEAPU8[$1 + 31 | 0] != 13 & HEAPU8[$1 + 31 | 0] != 10)) {
     HEAP32[$1 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 18349);
     block1 : {
      if (!HEAP32[$1 + 24 >> 2]) {
       break block1
      }
      if (jsvCompareString(HEAP32[103616], HEAP32[$1 + 24 >> 2], 0, 0, 0)) {
       break block1
      }
      HEAP16[207230] = HEAPU16[207230] & -1025;
     }
     jsvUnLock(HEAP32[$1 + 24 >> 2]);
     jsiClearInputLine(0);
     block2 : {
      if (jsiPasswordProtected() & 1) {
       jsiConsolePrintString(21718);
       break block2;
      }
      jsiConsolePrintString(28506);
      HEAP8[414468] = 1;
      jsiConsoleReturnInputLine();
     }
     break block3;
    }
    if (jsvGetStringLength(HEAP32[103616]) >>> 0 < 20) {
     jsiAppendToInputLine(HEAP8[$1 + 31 | 0] << 24 >> 24)
    }
    break block3;
   }
   if (!(HEAPU8[$1 + 31 | 0] != 3 | HEAPU8[414476] < 2 | HEAPU8[414476] > 4)) {
    HEAP32[103315] = HEAP32[103315] & -6145
   }
   if (HEAPU8[414476] == 2) {
    if (jsvIsEmptyString(HEAP32[103616]) & 1) {
     HEAP16[207230] = HEAPU16[207230] & -3
    }
    HEAP16[207268] = HEAPU8[$1 + 31 | 0] << 8;
    HEAP8[414476] = 3;
    break block3;
   }
   block6 : {
    if (HEAPU8[414476] == 3) {
     HEAP16[207268] = HEAPU8[$1 + 31 | 0] | HEAPU16[207268];
     block5 : {
      if (!(HEAPU16[207268] & 8191)) {
       jsiPacketProcess();
       break block5;
      }
      HEAP8[414476] = 4;
     }
     break block6;
    }
    block7 : {
     if (HEAPU8[414476] == 4) {
      jsiAppendToInputLine(HEAP8[$1 + 31 | 0] << 24 >> 24);
      if (HEAP32[61109] >= (HEAPU16[207268] & 8191)) {
       jsiPacketProcess()
      }
      break block7;
     }
     block8 : {
      if (!HEAPU8[$1 + 31 | 0]) {
       HEAP8[414476] = 0;
       break block8;
      }
      block9 : {
       if (HEAPU8[$1 + 31 | 0] == 1) {
        if (HEAPU8[414476] == 5) {
         jsiPacketStart()
        }
        break block9;
       }
       if (HEAPU8[$1 + 31 | 0] != 3) {
        block10 : {
         if (HEAPU8[$1 + 31 | 0] == 5) {
          if (jsvIsEmptyString(HEAP32[103616]) & 1) {
           HEAP32[$1 + 4 >> 2] = 22407;
           HEAP32[$1 >> 2] = 22253;
           jsiConsolePrintf(27993, $1);
          }
          break block10;
         }
         block11 : {
          if (HEAPU8[$1 + 31 | 0] == 16) {
           if (jsvIsEmptyString(HEAP32[103616]) & 1) {
            HEAP16[207230] = HEAPU16[207230] | 2
           }
           HEAP8[414476] = 5;
           break block11;
          }
          block12 : {
           if (HEAPU8[$1 + 31 | 0] == 27) {
            HEAP8[414476] = 6;
            break block12;
           }
           block15 : {
            if (HEAPU8[414476] == 6) {
             HEAP8[414476] = 0;
             block13 : {
              if (HEAPU8[$1 + 31 | 0] == 79) {
               HEAP8[414476] = 7;
               break block13;
              }
              block14 : {
               if (HEAPU8[$1 + 31 | 0] == 91) {
                HEAP8[414476] = 8;
                break block14;
               }
               if (HEAPU8[$1 + 31 | 0] == 10) {
                jsiHandleNewLine(0)
               }
              }
             }
             break block15;
            }
            block22 : {
             if (HEAPU8[414476] == 7) {
              HEAP8[414476] = 0;
              block16 : {
               if (HEAPU8[$1 + 31 | 0] == 70) {
                jsiHandleEnd();
                break block16;
               }
               block17 : {
                if (HEAPU8[$1 + 31 | 0] == 72) {
                 jsiHandleHome();
                 break block17;
                }
                block18 : {
                 if (HEAPU8[$1 + 31 | 0] == 111) {
                  jsiHandleConsoleChar(47);
                  break block18;
                 }
                 block19 : {
                  if (HEAPU8[$1 + 31 | 0] == 106) {
                   jsiHandleConsoleChar(42);
                   break block19;
                  }
                  block20 : {
                   if (HEAPU8[$1 + 31 | 0] == 109) {
                    jsiHandleConsoleChar(45);
                    break block20;
                   }
                   block21 : {
                    if (HEAPU8[$1 + 31 | 0] == 107) {
                     jsiHandleConsoleChar(43);
                     break block21;
                    }
                    if (HEAPU8[$1 + 31 | 0] == 77) {
                     jsiHandleConsoleChar(13)
                    }
                   }
                  }
                 }
                }
               }
              }
              break block22;
             }
             block34 : {
              if (HEAPU8[414476] == 8) {
               HEAP8[414476] = 0;
               block24 : {
                if (!(HEAP8[$1 + 31 | 0] << 24 >> 24 < 48 | HEAP8[$1 + 31 | 0] << 24 >> 24 > 57)) {
                 HEAP16[207269] = (HEAP8[$1 + 31 | 0] << 24 >> 24) - 48;
                 HEAP8[414476] = 9;
                 break block24;
                }
                block25 : {
                 if (HEAPU8[$1 + 31 | 0] == 68) {
                  if (!HEAP32[103618]) {
                   break block25
                  }
                  if ((jsvGetCharInString(HEAP32[103616], HEAP32[103618] - 1 | 0) | 0) == 10) {
                   break block25
                  }
                  HEAP32[103618] = HEAP32[103618] - 1;
                  if (jsiShowInputLine() & 1) {
                   jsiConsolePrintString(21561)
                  }
                  break block25;
                 }
                 block26 : {
                  if (HEAPU8[$1 + 31 | 0] == 67) {
                   if (HEAPU32[103618] >= jsvGetStringLength(HEAP32[103616]) >>> 0) {
                    break block26
                   }
                   if ((jsvGetCharInString(HEAP32[103616], HEAP32[103618]) | 0) == 10) {
                    break block26
                   }
                   HEAP32[103618] = HEAP32[103618] + 1;
                   if (jsiShowInputLine() & 1) {
                    jsiConsolePrintString(21574)
                   }
                   break block26;
                  }
                  block29 : {
                   if (HEAPU8[$1 + 31 | 0] == 65) {
                    HEAP32[$1 + 20 >> 2] = jsvGetStringLength(HEAP32[103616]);
                    block28 : {
                     block27 : {
                      if (HEAP32[$1 + 20 >> 2]) {
                       if (!(jsiIsInHistory(HEAP32[103616]) & 1)) {
                        break block27
                       }
                      }
                      if (HEAP32[103618] != HEAP32[$1 + 20 >> 2]) {
                       break block27
                      }
                      jsiChangeToHistory(1);
                      break block28;
                     }
                     jsiHandleMoveUpDown(-1);
                    }
                    break block29;
                   }
                   block32 : {
                    if (HEAPU8[$1 + 31 | 0] == 66) {
                     HEAP32[$1 + 16 >> 2] = jsvGetStringLength(HEAP32[103616]);
                     block31 : {
                      block30 : {
                       if (HEAP32[$1 + 16 >> 2]) {
                        if (!(jsiIsInHistory(HEAP32[103616]) & 1)) {
                         break block30
                        }
                       }
                       if (HEAP32[103618] != HEAP32[$1 + 16 >> 2]) {
                        break block30
                       }
                       jsiChangeToHistory(0);
                       break block31;
                      }
                      jsiHandleMoveUpDown(1);
                     }
                     break block32;
                    }
                    block33 : {
                     if (HEAPU8[$1 + 31 | 0] == 70) {
                      jsiHandleEnd();
                      break block33;
                     }
                     if (HEAPU8[$1 + 31 | 0] == 72) {
                      jsiHandleHome()
                     }
                    }
                   }
                  }
                 }
                }
               }
               break block34;
              }
              block36 : {
               if (HEAPU8[414476] == 9) {
                if (!(HEAP8[$1 + 31 | 0] << 24 >> 24 < 48 | HEAP8[$1 + 31 | 0] << 24 >> 24 > 57)) {
                 HEAP16[207269] = ((HEAP8[$1 + 31 | 0] << 24 >> 24) + Math_imul(HEAPU16[207269], 10) | 0) - 48;
                 break block36;
                }
                block37 : {
                 if (HEAPU8[$1 + 31 | 0] == 72) {
                  if (HEAPU16[207269] == 2) {
                   jsiClearInputLine(1)
                  }
                  break block37;
                 }
                 if (HEAPU8[$1 + 31 | 0] == 126) {
                  block38 : {
                   if (HEAPU16[207269] == 1) {
                    jsiHandleHome();
                    break block38;
                   }
                   block39 : {
                    if (HEAPU16[207269] == 3) {
                     jsiHandleDelete(0);
                     break block39;
                    }
                    block40 : {
                     if (HEAPU16[207269] == 4) {
                      jsiHandleEnd();
                      break block40;
                     }
                     block41 : {
                      if (HEAPU16[207269] == 5) {
                       jsiHandlePageUpDown(0);
                       break block41;
                      }
                      if (HEAPU16[207269] == 6) {
                       jsiHandlePageUpDown(1)
                      }
                     }
                    }
                   }
                  }
                 }
                }
                HEAP8[414476] = 0;
                break block36;
               }
               HEAP8[414476] = 0;
               block43 : {
                if (!(HEAPU8[$1 + 31 | 0] != 8 & HEAPU8[$1 + 31 | 0] != 127)) {
                 jsiHandleDelete(1);
                 break block43;
                }
                block45 : {
                 if (!(HEAPU8[$1 + 31 | 0] != 10 | HEAPU8[414476] != 1)) {
                  HEAP8[414476] = 0;
                  break block45;
                 }
                 block47 : {
                  if (!(HEAPU8[$1 + 31 | 0] != 13 & HEAPU8[$1 + 31 | 0] != 10)) {
                   if (HEAPU8[$1 + 31 | 0] == 13) {
                    HEAP8[414476] = 1
                   }
                   jsiHandleNewLine(1);
                   break block47;
                  }
                  block49 : {
                   block48 : {
                    if (HEAPU8[$1 + 31 | 0] != 9) {
                     break block48
                    }
                    if (!(jsiEcho() & 1)) {
                     break block48
                    }
                    jsiTabComplete();
                    break block49;
                   }
                   if (!(HEAPU8[$1 + 31 | 0] != 9 & HEAPU8[$1 + 31 | 0] < 32)) {
                    HEAP8[$1 + 14 | 0] = HEAPU8[$1 + 31 | 0];
                    HEAP8[$1 + 15 | 0] = 0;
                    HEAP32[$1 + 8 >> 2] = HEAPU8[$1 + 31 | 0] == 9 ? 27695 : $1 + 14 | 0;
                    jsiAppendStringToInputLine(HEAP32[$1 + 8 >> 2]);
                   }
                  }
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsiPacketProcess() {
  var $0 = 0;
  $0 = __stack_pointer - 704 | 0;
  __stack_pointer = $0;
  HEAP16[$0 + 702 >> 1] = HEAPU16[207268] & 57344;
  HEAP16[207268] = HEAPU16[207268] & 8191;
  block1 : {
   if (HEAPU16[$0 + 702 >> 1] == 8192) {
    HEAP32[$0 + 696 >> 2] = jspEvaluateExpressionVar(HEAP32[103616]);
    block : {
     if (jspHasError() & 1) {
      jsiConsolePrintChar(21);
      jsiCheckErrors(1);
      break block;
     }
     jsiConsolePrintChar(6);
     HEAP32[$0 + 692 >> 2] = jswrap_espruino_toJS(HEAP32[$0 + 696 >> 2]);
     jsiPacketReply(0, HEAP32[$0 + 692 >> 2]);
     jsvUnLock(HEAP32[$0 + 692 >> 2]);
    }
    jsvUnLock(HEAP32[$0 + 696 >> 2]);
    break block1;
   }
   block2 : {
    if (HEAPU16[$0 + 702 >> 1] == 16384) {
     HEAP32[$0 + 688 >> 2] = jswrap_json_parse_liberal(HEAP32[103616], 1);
     HEAP8[$0 + 687 | 0] = jsvIsObject(HEAP32[$0 + 688 >> 2]) & 1;
     if (HEAP8[$0 + 687 | 0] & 1) {
      HEAP8[$0 + 687 | 0] = jsiExecuteEventCallbackOn(21559, 4984, 1, $0 + 688 | 0) & 1
     }
     jsvUnLock(HEAP32[$0 + 688 >> 2]);
     jsiConsolePrintChar(HEAP8[$0 + 687 | 0] & 1 ? 6 : 21);
     break block2;
    }
    block4 : {
     if (HEAPU16[$0 + 702 >> 1] == 40960) {
      HEAP32[$0 + 680 >> 2] = jswrap_json_parse_liberal(HEAP32[103616], 1);
      HEAP8[$0 + 679 | 0] = jsvIsObject(HEAP32[$0 + 680 >> 2]) & 1;
      if (HEAP8[$0 + 679 | 0] & 1) {
       HEAP32[$0 + 672 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 680 >> 2], 15554);
       HEAP8[$0 + 679 | 0] = jsvIsString(HEAP32[$0 + 672 >> 2]) & 1;
       HEAP32[$0 + 668 >> 2] = jswrap_storage_read(HEAP32[$0 + 672 >> 2], 0, 0);
       block3 : {
        if (HEAP32[$0 + 668 >> 2]) {
         jsiConsolePrintChar(6);
         HEAP32[$0 + 664 >> 2] = jsvGetStringLength(HEAP32[$0 + 668 >> 2]);
         HEAP32[$0 + 660 >> 2] = 0;
         while (1) {
          if (HEAPU32[$0 + 660 >> 2] < HEAPU32[$0 + 664 >> 2]) {
           HEAP32[$0 + 656 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 668 >> 2], HEAP32[$0 + 660 >> 2], 1024);
           jsiPacketReply(32768, HEAP32[$0 + 656 >> 2]);
           jsvUnLock(HEAP32[$0 + 656 >> 2]);
           HEAP32[$0 + 660 >> 2] = HEAP32[$0 + 660 >> 2] + 1024;
           continue;
          }
          break;
         };
         break block3;
        }
        HEAP8[$0 + 679 | 0] = 0;
       }
       jsvUnLock(HEAP32[$0 + 672 >> 2]);
       if (HEAP8[$0 + 679 | 0] & 1) {
        jsiPacketReply(32768, 0)
       }
      }
      if (!(HEAP8[$0 + 679 | 0] & 1)) {
       jsiConsolePrintChar(21)
      }
      break block4;
     }
     block6 : {
      if (HEAPU16[$0 + 702 >> 1] == 24576) {
       jsiPacketFileEnd();
       HEAP32[$0 + 652 >> 2] = jswrap_json_parse_liberal(HEAP32[103616], 1);
       HEAP8[$0 + 651 | 0] = jsvIsObject(HEAP32[$0 + 652 >> 2]) & 1;
       if (HEAP8[$0 + 651 | 0] & 1) {
        HEAP32[$0 + 644 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 652 >> 2], 15554);
        HEAP8[$0 + 651 | 0] = jsvIsString(HEAP32[$0 + 644 >> 2]) & 1;
        if (HEAP8[$0 + 651 | 0] & 1) {
         HEAP8[$0 + 651 | 0] = (jsvObjectGetIntegerChild(HEAP32[$0 + 652 >> 2], 7675) | 0) != 0
        }
        block5 : {
         if (!(HEAP8[$0 + 651 | 0] & 1)) {
          break block5
         }
         if (!(jsvObjectGetBoolChild(HEAP32[$0 + 652 >> 2], 7230) & 1)) {
          break block5
         }
         HEAP8[$0 + 651 | 0] = 0;
        }
        jsvUnLock(HEAP32[$0 + 644 >> 2]);
       }
       if (HEAP8[$0 + 651 | 0] & 1) {
        jsvObjectSetChild(HEAP32[103308], 21545, HEAP32[$0 + 652 >> 2]);
        jsiPacketFileSetTimeout(1);
       }
       jsvUnLock(HEAP32[$0 + 652 >> 2]);
       jsiConsolePrintChar(HEAP8[$0 + 651 | 0] & 1 ? 6 : 21);
       break block6;
      }
      block11 : {
       if (HEAPU16[$0 + 702 >> 1] == 32768) {
        HEAP32[$0 + 640 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 21545);
        HEAP32[$0 + 636 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 640 >> 2], 15554);
        block10 : {
         if (!(!HEAP32[$0 + 640 >> 2] | !HEAP32[$0 + 636 >> 2])) {
          HEAP32[$0 + 620 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 640 >> 2], 7675);
          HEAP32[$0 + 616 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 640 >> 2], 7228);
          HEAP32[$0 + 628 >> 2] = HEAP32[$0 + 636 >> 2];
          HEAP32[$0 + 624 >> 2] = 0;
          HEAP32[$0 + 612 >> 2] = 0;
          HEAP8[$0 + 608 | 0] = 1;
          block8 : {
           if (jsvObjectGetBoolChild(HEAP32[$0 + 640 >> 2], 20469) & 1) {
            HEAP32[$0 + 604 >> 2] = $0 + 80;
            jsvIteratorNew($0 + 16 | 0, HEAP32[103616], 1);
            heatshrink_decode_cb(578, $0 + 16 | 0, 579, $0 + 604 | 0);
            jsvIteratorFree($0 + 16 | 0);
            if (HEAP32[$0 + 612 >> 2] > 0) {
             HEAP32[$0 + 12 >> 2] = jsvNewNativeString(HEAP32[$0 + 604 >> 2], HEAP32[$0 + 612 >> 2]);
             packet_file_write($0 + 604 | 0, HEAP32[$0 + 12 >> 2]);
             jsvUnLock(HEAP32[$0 + 12 >> 2]);
            }
            break block8;
           }
           HEAP32[$0 + 612 >> 2] = HEAPU16[207268];
           packet_file_write($0 + 604 | 0, HEAP32[103616]);
          }
          HEAP8[$0 + 635 | 0] = HEAP8[$0 + 608 | 0] & 1;
          jsvUnLock(HEAP32[$0 + 624 >> 2]);
          jsvObjectSetChildAndUnLock(HEAP32[$0 + 640 >> 2], 7228, jsvNewFromInteger(HEAP32[$0 + 616 >> 2]));
          block9 : {
           if (HEAP32[$0 + 616 >> 2] >= HEAP32[$0 + 620 >> 2]) {
            jsiPacketFileEnd();
            break block9;
           }
           jsiPacketFileSetTimeout(1);
          }
          HEAP32[$0 + 8 >> 2] = jsvNewObject();
          jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 15943, jsvNewFromInteger(HEAPU16[207268]));
          jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 15123, jsvNewFromInteger(HEAP32[$0 + 616 >> 2]));
          jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 7675, jsvNewFromInteger(HEAP32[$0 + 620 >> 2]));
          jsvObjectSetChild(HEAP32[$0 + 8 >> 2], 15554, HEAP32[$0 + 636 >> 2]);
          jsiExecuteEventCallbackOn(21559, 19440, 1, $0 + 8 | 0);
          jsvUnLock(HEAP32[$0 + 8 >> 2]);
          break block10;
         }
         HEAP8[$0 + 635 | 0] = 0;
        }
        jsvUnLock2(HEAP32[$0 + 636 >> 2], HEAP32[$0 + 640 >> 2]);
        jsiConsolePrintChar(HEAP8[$0 + 635 | 0] & 1 ? 6 : 21);
        break block11;
       }
       jsiConsolePrintChar(21);
      }
     }
    }
   }
  }
  jsiPacketExit();
  __stack_pointer = $0 + 704 | 0;
 }
 
 function jsiPacketStart() {
  HEAP8[414476] = 2;
  jsiInputLineCursorMoved();
  jsvObjectSetChildAndUnLock(HEAP32[103308], 21306, HEAP32[103616]);
  jsvObjectSetChildAndUnLock(HEAP32[103308], 20979, jsiSetTimeout(580, 5.0e3));
  HEAP32[103616] = jsvNewFromEmptyString_861();
 }
 
 function jsiIdle() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  $0 = __stack_pointer - 384 | 0;
  __stack_pointer = $0;
  if (HEAPU8[414478] < 255) {
   HEAP8[414478] = HEAPU8[414478] + 1
  }
  HEAP8[$0 + 383 | 0] = 0;
  HEAP32[$0 + 296 >> 2] = jshGetEventsUsed();
  while (1) {
   $4 = HEAP32[$0 + 296 >> 2];
   HEAP32[$0 + 296 >> 2] = $4 - 1;
   $1 = 0;
   if (($4 | 0) > 0) {
    $4 = jshPopIOEvent($0 + 304 | 0, $0 + 300 | 0);
    HEAP8[$0 + 382 | 0] = $4;
    $1 = ($4 & 255) != 0;
   }
   if ($1) {
    jsiSetBusy(1, 1);
    HEAP8[$0 + 383 | 0] = 1;
    HEAP8[$0 + 295 | 0] = HEAPU8[$0 + 382 | 0] & 31;
    HEAP8[414478] = 0;
    block : {
     if (HEAPU8[$0 + 295 | 0] == HEAPU8[244432]) {
      jsiHandleIOEventForConsole($0 + 304 | 0, HEAP32[$0 + 300 >> 2]);
      break block;
     }
     block2 : {
      if (!(HEAPU8[$0 + 295 | 0] < 17 | HEAPU8[$0 + 295 | 0] > 22)) {
       HEAP32[$0 + 288 >> 2] = jsvSkipNameAndUnLock(jsiGetClassNameFromDevice(HEAPU8[$0 + 295 | 0]));
       if (jsvIsObject(HEAP32[$0 + 288 >> 2]) & 1) {
        $4 = jsiHandleIOEventForSerial(HEAP32[$0 + 288 >> 2], HEAPU8[$0 + 382 | 0], $0 + 304 | 0, HEAP32[$0 + 300 >> 2]);
        HEAP32[$0 + 296 >> 2] = HEAP32[$0 + 296 >> 2] - $4;
       }
       jsvUnLock(HEAP32[$0 + 288 >> 2]);
       break block2;
      }
      block4 : {
       if (!(HEAPU8[$0 + 295 | 0] < 23 | HEAPU8[$0 + 295 | 0] > 23)) {
        HEAP32[$0 + 284 >> 2] = jsvSkipNameAndUnLock(jsiGetClassNameFromDevice(HEAPU8[$0 + 382 | 0] - 1 & 31));
        if (jsvIsObject(HEAP32[$0 + 284 >> 2]) & 1) {
         if (HEAPU8[$0 + 382 | 0] & 32) {
          jsiExecuteEventCallbackName(HEAP32[$0 + 284 >> 2], 16984, 0, 0)
         }
         if (HEAPU8[$0 + 382 | 0] & 64) {
          jsiExecuteEventCallbackName(HEAP32[$0 + 284 >> 2], 3516, 0, 0)
         }
        }
        jsvUnLock(HEAP32[$0 + 284 >> 2]);
        break block4;
       }
       block5 : {
        if (HEAPU8[$0 + 295 | 0] == 24) {
         jstOnRunInterruptJSEvent($0 + 304 | 0, HEAP32[$0 + 300 >> 2]);
         break block5;
        }
        block6 : {
         if (HEAPU8[$0 + 295 | 0] == 25) {
          jstOnCustomEvent(HEAPU8[$0 + 382 | 0], $0 + 304 | 0, HEAP32[$0 + 300 >> 2]);
          jswOnCustomEvent(HEAPU8[$0 + 382 | 0], $0 + 304 | 0, HEAP32[$0 + 300 >> 2]);
          break block6;
         }
         block7 : {
          if (HEAPU8[$0 + 295 | 0] == 26) {
           jsbangle_exec_pending($0 + 304 | 0, HEAP32[$0 + 300 >> 2]);
           break block7;
          }
          if (!(!HEAPU8[$0 + 295 | 0] | HEAPU8[$0 + 295 | 0] > 16)) {
           jsvObjectIteratorNew($0 + 280 | 0, HEAP32[103614]);
           while (1) {
            if (jsvObjectIteratorHasValue_865($0 + 280 | 0) & 1) {
             HEAP8[$0 + 279 | 0] = 0;
             HEAP32[$0 + 272 >> 2] = jsvObjectIteratorGetValue_866($0 + 280 | 0);
             HEAP8[$0 + 271 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 272 >> 2], 15509));
             if (jshIsEventForPin(HEAPU8[$0 + 382 | 0], HEAPU8[$0 + 271 | 0]) & 1) {
              $5 = jshGetSystemTime();
              HEAP32[$0 + 256 >> 2] = $5;
              $2 = i64toi32_i32$HIGH_BITS;
              HEAP32[$0 + 260 >> 2] = $2;
              HEAP32[$0 + 252 >> 2] = HEAP32[$0 + 304 >> 2];
              $2 = HEAP32[$0 + 256 >> 2];
              if ($2 >>> 0 < HEAPU32[$0 + 252 >> 2]) {
               $5 = HEAP32[$0 + 256 >> 2];
               $4 = $5;
               $2 = HEAP32[$0 + 260 >> 2];
               $1 = 1;
               $1 = $2 - $1 | 0;
               HEAP32[$0 + 256 >> 2] = $4;
               HEAP32[$0 + 260 >> 2] = $1;
              }
              $1 = HEAP32[$0 + 252 >> 2];
              $2 = $1;
              $4 = HEAP32[$0 + 256 >> 2];
              $1 = HEAP32[$0 + 260 >> 2];
              $4 = $1;
              $6 = $10;
              $1 = $2;
              $1 = $6 | $1;
              HEAP32[$0 + 240 >> 2] = $1;
              $2 = $4;
              HEAP32[$0 + 244 >> 2] = $2;
              HEAP8[$0 + 239 | 0] = (HEAPU8[$0 + 382 | 0] & 32) != 0;
              HEAP8[$0 + 238 | 0] = 0;
              HEAP8[$0 + 238 | 0] = (HEAPU8[$0 + 382 | 0] & 64) != 0;
              HEAP8[$0 + 237 | 0] = 0;
              HEAP32[$0 + 232 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 272 >> 2], 18264);
              block9 : {
               if (HEAP32[$0 + 232 >> 2] <= 0) {
                HEAP8[$0 + 237 | 0] = (HEAPU8[$0 + 238 | 0] ^ -1) & 1;
                jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 239 | 0] & 1));
                break block9;
               }
               HEAP8[$0 + 231 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 272 >> 2], 17546) & 1;
               HEAP32[$0 + 224 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 272 >> 2], 4368);
               block11 : {
                if (HEAP32[$0 + 224 >> 2]) {
                 $2 = HEAP32[103632];
                 $4 = $2;
                 $1 = HEAP32[103633];
                 $3 = $1;
                 $1 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 224 >> 2], 17804));
                 $6 = $1;
                 $2 = i64toi32_i32$HIGH_BITS;
                 $1 = $2;
                 $2 = $3;
                 $3 = $2 + $1 | 0;
                 $5 = $4 + $6 | 0;
                 $3 = $5 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
                 HEAP32[$0 + 216 >> 2] = $5;
                 HEAP32[$0 + 220 >> 2] = $3;
                 $3 = HEAP32[$0 + 232 >> 2];
                 $4 = $3 >> 31;
                 $7 = $3;
                 $8 = $4;
                 $4 = HEAP32[$0 + 240 >> 2];
                 $2 = $4;
                 $3 = HEAP32[$0 + 244 >> 2];
                 $5 = $3;
                 $4 = HEAP32[103633];
                 $9 = $4;
                 $3 = HEAP32[103632];
                 $6 = $3;
                 $1 = $2 - $3 | 0;
                 $4 = $5;
                 $3 = $9;
                 $5 = $3 + ($2 >>> 0 < $6 >>> 0) | 0;
                 $5 = $4 - $5 | 0;
                 $2 = $5;
                 $6 = $1;
                 $4 = $7;
                 $3 = $1 + $4 | 0;
                 $5 = $8;
                 $1 = $5 + $2 | 0;
                 $1 = $3 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
                 jsvUnLock(jsvObjectSetChild(HEAP32[$0 + 224 >> 2], 17804, jsvNewFromLongInteger($3, $1)));
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 224 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 239 | 0] & 1));
                 block10 : {
                  if (!(HEAP8[$0 + 238 | 0] & 1)) {
                   $4 = HEAP32[$0 + 244 >> 2];
                   $2 = $4;
                   $1 = HEAP32[$0 + 240 >> 2];
                   $5 = $1;
                   $4 = HEAP32[$0 + 216 >> 2];
                   $6 = $4;
                   $1 = HEAP32[$0 + 220 >> 2];
                   $4 = $1;
                   $1 = $2;
                   if ($5 >>> 0 <= $6 >>> 0 & ($4 | 0) >= ($1 | 0) | ($1 | 0) < ($4 | 0) | (HEAP8[$0 + 239 | 0] & 1) == (HEAP8[$0 + 231 | 0] & 1)) {
                    break block10
                   }
                  }
                  HEAP8[$0 + 237 | 0] = (HEAPU8[$0 + 238 | 0] ^ -1) & 1;
                  $5 = HEAP32[$0 + 216 >> 2];
                  $6 = $5;
                  $1 = HEAP32[$0 + 220 >> 2];
                  $3 = $1;
                  $1 = HEAP32[$0 + 232 >> 2];
                  $5 = $1 >> 31;
                  $7 = $5;
                  $4 = $1;
                  $2 = $6 - $1 | 0;
                  $5 = $3;
                  $1 = $7;
                  $3 = $1 + ($4 >>> 0 > $6 >>> 0) | 0;
                  $3 = $5 - $3 | 0;
                  HEAP32[$0 + 240 >> 2] = $2;
                  HEAP32[$0 + 244 >> 2] = $3;
                  jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 239 | 0] & 1));
                  jsiClearTimeout(HEAP32[$0 + 224 >> 2]);
                  jsvObjectRemoveChild(HEAP32[$0 + 272 >> 2], 4368);
                 }
                 break block11;
                }
                block13 : {
                 if (!(HEAP8[$0 + 238 | 0] & 1 | (HEAP8[$0 + 239 | 0] & 1) == (HEAP8[$0 + 231 | 0] & 1))) {
                  HEAP32[$0 + 224 >> 2] = jsvNewObject();
                  if (HEAP32[$0 + 224 >> 2]) {
                   jsvObjectSetChild(HEAP32[$0 + 224 >> 2], 16521, HEAP32[$0 + 272 >> 2]);
                   $3 = HEAP32[$0 + 232 >> 2];
                   $6 = $3 >> 31;
                   $7 = $3;
                   $8 = $6;
                   $6 = HEAP32[$0 + 240 >> 2];
                   $5 = $6;
                   $3 = HEAP32[$0 + 244 >> 2];
                   $2 = $3;
                   $6 = HEAP32[103633];
                   $9 = $6;
                   $3 = HEAP32[103632];
                   $4 = $3;
                   $1 = $5 - $3 | 0;
                   $6 = $2;
                   $3 = $9;
                   $2 = $3 + ($4 >>> 0 > $5 >>> 0) | 0;
                   $2 = $6 - $2 | 0;
                   $4 = $1;
                   $6 = $7;
                   $3 = $1 + $6 | 0;
                   $5 = $2;
                   $2 = $8;
                   $1 = $5 + $2 | 0;
                   $1 = $4 >>> 0 > $3 >>> 0 ? $1 + 1 | 0 : $1;
                   jsvObjectSetChildAndUnLock(HEAP32[$0 + 224 >> 2], 17804, jsvNewFromLongInteger($3, $1));
                   jsvObjectSetChildAndUnLock(HEAP32[$0 + 224 >> 2], 20492, jsvObjectGetChildIfExists(HEAP32[$0 + 272 >> 2], 20492));
                   jsvObjectSetChildAndUnLock(HEAP32[$0 + 224 >> 2], 17809, jsvObjectGetChildIfExists(HEAP32[$0 + 272 >> 2], 17809));
                   jsvObjectSetChildAndUnLock(HEAP32[$0 + 224 >> 2], 15509, jsvNewFromPin(HEAPU8[$0 + 271 | 0]));
                   jsvObjectSetChildAndUnLock(HEAP32[$0 + 224 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 239 | 0] & 1));
                   jsiTimerAdd(HEAP32[$0 + 224 >> 2]);
                   jsvObjectSetChild(HEAP32[$0 + 272 >> 2], 4368, HEAP32[$0 + 224 >> 2]);
                  }
                  break block13;
                 }
                 if (HEAP8[$0 + 238 | 0] & 1) {
                  jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 239 | 0] & 1))
                 }
                }
               }
               jsvUnLock(HEAP32[$0 + 224 >> 2]);
              }
              if (HEAP8[$0 + 237 | 0] & 1) {
               $1 = HEAP32[$0 + 240 >> 2];
               $6 = HEAP32[$0 + 244 >> 2];
               HEAP32[$0 + 212 >> 2] = jsvNewFromFloat(jshGetMillisecondsFromTime($1, $6) / 1.0e3);
               if (jsiShouldExecuteWatch(HEAP32[$0 + 272 >> 2], HEAP8[$0 + 239 | 0] & 1) & 1) {
                HEAP32[$0 + 208 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 272 >> 2], 20492);
                HEAP8[$0 + 207 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 272 >> 2], 7677) & 1;
                HEAP32[$0 + 200 >> 2] = jsvNewObject();
                if (HEAP32[$0 + 200 >> 2]) {
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 200 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 239 | 0] & 1));
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 200 >> 2], 17809, jsvObjectGetChildIfExists(HEAP32[$0 + 272 >> 2], 17809));
                 jsvObjectSetChild(HEAP32[$0 + 200 >> 2], 17804, HEAP32[$0 + 212 >> 2]);
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 200 >> 2], 15509, jsvNewFromPin(HEAPU8[$0 + 271 | 0]));
                 HEAP8[$0 + 199 | 0] = jshGetEventDataPin(HEAPU8[$0 + 295 | 0]);
                 if (jshIsPinValid(HEAPU8[$0 + 199 | 0]) & 1) {
                  jsvObjectSetChildAndUnLock(HEAP32[$0 + 200 >> 2], 20636, jsvNewFromBool((HEAPU8[$0 + 382 | 0] & 64) != 0))
                 }
                }
                if (!(jsiExecuteEventCallback(0, HEAP32[$0 + 208 >> 2], 1, $0 + 200 | 0) & 1 | !(HEAP8[$0 + 207 | 0] & 1))) {
                 jsError(22662, 0);
                 HEAP8[413226] = HEAPU8[413226] | 4;
                 HEAP8[$0 + 207 | 0] = 0;
                }
                jsvUnLock(HEAP32[$0 + 200 >> 2]);
                if (!(HEAP8[$0 + 207 | 0] & 1)) {
                 jsvObjectIteratorRemoveAndGotoNext($0 + 280 | 0, HEAP32[103614]);
                 HEAP8[$0 + 279 | 0] = 1;
                 if (!(jsiIsWatchingPin(HEAPU8[$0 + 271 | 0]) & 1)) {
                  jshPinWatch(HEAPU8[$0 + 271 | 0], 0, 0)
                 }
                }
                jsvUnLock(HEAP32[$0 + 208 >> 2]);
               }
               jsvObjectSetChildAndUnLock(HEAP32[$0 + 272 >> 2], 17809, HEAP32[$0 + 212 >> 2]);
              }
             }
             jsvUnLock(HEAP32[$0 + 272 >> 2]);
             if (!(HEAP8[$0 + 279 | 0] & 1)) {
              jsvObjectIteratorNext($0 + 280 | 0)
             }
             continue;
            }
            break;
           };
           jsvObjectIteratorFree_867($0 + 280 | 0);
          }
         }
        }
       }
      }
     }
    }
    continue;
   }
   break;
  };
  if ((jshGetEventsUsed() | 0) < 383) {
   jshSetFlowControlAllReady()
  }
  HEAP32[$0 + 184 >> 2] = -1;
  HEAP32[$0 + 188 >> 2] = 2147483647;
  $6 = jshGetSystemTime();
  HEAP32[$0 + 176 >> 2] = $6;
  $1 = i64toi32_i32$HIGH_BITS;
  HEAP32[$0 + 180 >> 2] = $1;
  $1 = HEAP32[$0 + 176 >> 2];
  $2 = $1;
  $6 = HEAP32[$0 + 180 >> 2];
  $3 = $6;
  $1 = HEAP32[103633];
  $7 = $1;
  $6 = HEAP32[103632];
  $4 = $6;
  $5 = $2 - $4 | 0;
  HEAP32[$0 + 168 >> 2] = $5;
  $1 = $3;
  $6 = $7;
  $3 = $6 + ($2 >>> 0 < $4 >>> 0) | 0;
  $3 = $1 - $3 | 0;
  HEAP32[$0 + 172 >> 2] = $3;
  $2 = HEAP32[$0 + 180 >> 2];
  $3 = HEAP32[$0 + 176 >> 2];
  HEAP32[103632] = $3;
  HEAP32[103633] = $2;
  jsvObjectIteratorNew($0 + 164 | 0, HEAP32[103613]);
  while (1) {
   if (jsvObjectIteratorHasValue_865($0 + 164 | 0) & 1) {
    HEAP32[$0 + 160 >> 2] = jsvObjectIteratorGetValue_866($0 + 164 | 0);
    $2 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 160 >> 2], 17804));
    HEAP32[$0 + 152 >> 2] = $2;
    $3 = i64toi32_i32$HIGH_BITS;
    HEAP32[$0 + 156 >> 2] = $3;
    $3 = HEAP32[$0 + 152 >> 2];
    $1 = $3;
    $2 = HEAP32[$0 + 156 >> 2];
    $5 = $2;
    $3 = HEAP32[$0 + 172 >> 2];
    $7 = $3;
    $2 = HEAP32[$0 + 168 >> 2];
    $4 = $2;
    $6 = $1 - $2 | 0;
    HEAP32[$0 + 144 >> 2] = $6;
    $3 = $5;
    $2 = $7;
    $5 = $2 + ($1 >>> 0 < $4 >>> 0) | 0;
    $5 = $3 - $5 | 0;
    HEAP32[$0 + 148 >> 2] = $5;
    $5 = HEAP32[$0 + 144 >> 2];
    $1 = HEAP32[$0 + 148 >> 2];
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 160 >> 2], 17804, jsvNewFromLongInteger($5, $1));
    jsvUnLock(HEAP32[$0 + 160 >> 2]);
    jsvObjectIteratorNext($0 + 164 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_867($0 + 164 | 0);
  while (1) {
   HEAP16[207230] = HEAPU16[207230] & -5;
   jsvObjectIteratorNew($0 + 164 | 0, HEAP32[103613]);
   while (1) {
    $4 = 0;
    if (jsvObjectIteratorHasValue_865($0 + 164 | 0) & 1) {
     $4 = (HEAPU16[207230] & 4) != 0 ^ -1
    }
    if ($4 & 1) {
     HEAP8[$0 + 143 | 0] = 0;
     HEAP32[$0 + 136 >> 2] = jsvObjectIteratorGetValue_866($0 + 164 | 0);
     $1 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 136 >> 2], 17804));
     HEAP32[$0 + 128 >> 2] = $1;
     $5 = i64toi32_i32$HIGH_BITS;
     HEAP32[$0 + 132 >> 2] = $5;
     $5 = HEAP32[$0 + 128 >> 2];
     $3 = $5;
     $1 = HEAP32[$0 + 132 >> 2];
     if (($1 | 0) < 0) {
      $4 = 1
     } else {
      $4 = !$3 & ($1 | 0) <= 0
     }
     if ($4) {
      jsiSetBusy(1, 1);
      HEAP8[$0 + 383 | 0] = 1;
      HEAP32[$0 + 124 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 136 >> 2], 20492);
      HEAP32[$0 + 120 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 136 >> 2], 16521);
      HEAP8[$0 + 119 | 0] = 1;
      HEAP32[$0 + 112 >> 2] = 0;
      if (HEAP32[$0 + 120 >> 2]) {
       HEAP8[$0 + 111 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 120 >> 2], 17546) & 1;
       HEAP8[$0 + 110 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 136 >> 2], 17546) & 1;
       jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 110 | 0] & 1));
       HEAP8[$0 + 119 | 0] = 0;
       if ((HEAP8[$0 + 111 | 0] & 1) != (HEAP8[$0 + 110 | 0] & 1)) {
        HEAP32[$0 + 104 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 120 >> 2], 18264);
        $3 = HEAP32[103632];
        $4 = $3;
        $1 = HEAP32[103633];
        $6 = $1;
        $3 = HEAP32[$0 + 132 >> 2];
        $7 = $3;
        $1 = HEAP32[$0 + 128 >> 2];
        $5 = $1;
        $2 = $1 + $4 | 0;
        $3 = $6;
        $1 = $7;
        $6 = $3 + $1 | 0;
        $6 = $2 >>> 0 < $5 >>> 0 ? $6 + 1 | 0 : $6;
        $3 = $6;
        $6 = HEAP32[$0 + 104 >> 2];
        $4 = $6 >> 31;
        $7 = $4;
        $5 = $6;
        $1 = $2 - $5 | 0;
        $4 = $3;
        $6 = $7;
        $2 = $6 + ($2 >>> 0 < $5 >>> 0) | 0;
        $2 = $4 - $2 | 0;
        HEAP32[$0 + 100 >> 2] = jsvNewFromFloat(jshGetMillisecondsFromTime($1, $2) / 1.0e3);
        if (jsiShouldExecuteWatch(HEAP32[$0 + 120 >> 2], HEAP8[$0 + 110 | 0] & 1) & 1) {
         HEAP32[$0 + 112 >> 2] = jsvNewObject();
         if (HEAP32[$0 + 112 >> 2]) {
          HEAP8[$0 + 119 | 0] = 1;
          jsvObjectSetChildAndUnLock(HEAP32[$0 + 112 >> 2], 17546, jsvNewFromBool(HEAP8[$0 + 110 | 0] & 1));
          jsvObjectSetChildAndUnLock(HEAP32[$0 + 112 >> 2], 17809, jsvObjectGetChildIfExists(HEAP32[$0 + 120 >> 2], 17809));
          jsvObjectSetChild(HEAP32[$0 + 112 >> 2], 17804, HEAP32[$0 + 100 >> 2]);
          jsvObjectSetChildAndUnLock(HEAP32[$0 + 112 >> 2], 15509, jsvObjectGetChildIfExists(HEAP32[$0 + 120 >> 2], 15509));
         }
        }
        jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 17809, HEAP32[$0 + 100 >> 2]);
       }
      }
      HEAP8[$0 + 99 | 0] = 0;
      if (HEAP8[$0 + 119 | 0] & 1) {
       block15 : {
        if (HEAP32[$0 + 112 >> 2]) {
         HEAP8[$0 + 98 | 0] = jsiExecuteEventCallback(0, HEAP32[$0 + 124 >> 2], 1, $0 + 112 | 0) & 1;
         break block15;
        }
        HEAP32[$0 + 92 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 136 >> 2], 7217);
        HEAP8[$0 + 98 | 0] = jsiExecuteEventCallbackArgsArray(0, HEAP32[$0 + 124 >> 2], HEAP32[$0 + 92 >> 2]) & 1;
        jsvUnLock(HEAP32[$0 + 92 >> 2]);
       }
       if (!(HEAP8[$0 + 98 | 0] & 1)) {
        HEAP32[$0 + 88 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 136 >> 2], 7687);
        if (HEAP32[$0 + 88 >> 2]) {
         jsvUnLock(HEAP32[$0 + 88 >> 2]);
         jsError(22614, 0);
         HEAP8[413226] = HEAPU8[413226] | 4;
         HEAP8[$0 + 99 | 0] = 1;
        }
       }
      }
      jsvUnLock(HEAP32[$0 + 112 >> 2]);
      if (HEAP32[$0 + 120 >> 2]) {
       jsvObjectRemoveChild(HEAP32[$0 + 120 >> 2], 4368);
       if (HEAP8[$0 + 119 | 0] & 1) {
        HEAP8[$0 + 87 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 120 >> 2], 7677) & 1;
        if (!(HEAP8[$0 + 87 | 0] & 1)) {
         HEAP32[$0 + 80 >> 2] = jsvGetIndexOf(HEAP32[103614], HEAP32[$0 + 120 >> 2], 1);
         if (HEAP32[$0 + 80 >> 2]) {
          jsvRemoveChildAndUnLock(HEAP32[103614], HEAP32[$0 + 80 >> 2])
         }
         HEAP8[$0 + 79 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 120 >> 2], 15509));
         if (!(jsiIsWatchingPin(HEAPU8[$0 + 79 | 0]) & 1)) {
          jshPinWatch(HEAPU8[$0 + 79 | 0], 0, 0)
         }
        }
       }
       jsvUnLock(HEAP32[$0 + 120 >> 2]);
      }
      HEAP32[$0 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 136 >> 2], 7687);
      block17 : {
       if (!(!HEAP32[$0 + 72 >> 2] | HEAP8[$0 + 99 | 0] & 1)) {
        $2 = HEAP32[$0 + 128 >> 2];
        $4 = $2;
        $3 = HEAP32[$0 + 132 >> 2];
        $1 = $3;
        $3 = jsvGetLongInteger(HEAP32[$0 + 72 >> 2]);
        $2 = i64toi32_i32$HIGH_BITS;
        $7 = $2;
        $5 = $3;
        $6 = $3 + $4 | 0;
        $2 = $1;
        $3 = $7;
        $1 = $2 + $3 | 0;
        HEAP32[$0 + 128 >> 2] = $6;
        $1 = $5 >>> 0 > $6 >>> 0 ? $1 + 1 | 0 : $1;
        HEAP32[$0 + 132 >> 2] = $1;
        $1 = HEAP32[$0 + 128 >> 2];
        $4 = HEAP32[$0 + 132 >> 2];
        jsvObjectSetChildAndUnLock(HEAP32[$0 + 136 >> 2], 17804, jsvNewFromLongInteger($1, $4));
        break block17;
       }
       jsvObjectIteratorRemoveAndGotoNext($0 + 164 | 0, HEAP32[103613]);
       HEAP8[$0 + 143 | 0] = 1;
       HEAP32[$0 + 128 >> 2] = -1;
       HEAP32[$0 + 132 >> 2] = -1;
      }
      jsvUnLock2(HEAP32[$0 + 124 >> 2], HEAP32[$0 + 72 >> 2]);
     }
     $4 = HEAP32[$0 + 128 >> 2];
     $1 = HEAP32[$0 + 132 >> 2];
     block18 : {
      if (($1 | 0) < 0) {
       break block18
      }
      $2 = HEAP32[$0 + 128 >> 2];
      $5 = $2;
      $1 = HEAP32[$0 + 132 >> 2];
      $3 = $1;
      $2 = HEAP32[$0 + 188 >> 2];
      $6 = $2;
      $1 = HEAP32[$0 + 184 >> 2];
      $4 = $1;
      $2 = $3;
      $1 = $6;
      if ($4 >>> 0 <= $5 >>> 0 & ($2 | 0) >= ($1 | 0) | ($1 | 0) < ($2 | 0)) {
       break block18
      }
      $2 = HEAP32[$0 + 132 >> 2];
      $5 = HEAP32[$0 + 128 >> 2];
      HEAP32[$0 + 184 >> 2] = $5;
      HEAP32[$0 + 188 >> 2] = $2;
     }
     if (!(HEAP8[$0 + 143 | 0] & 1)) {
      jsvObjectIteratorNext($0 + 164 | 0)
     }
     jsvUnLock(HEAP32[$0 + 136 >> 2]);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_867($0 + 164 | 0);
   if (HEAPU16[207230] & 4) {
    continue
   }
   break;
  };
  if (jswIdle() & 1) {
   HEAP8[$0 + 383 | 0] = 1
  }
  block19 : {
   if (!(HEAP8[$0 + 383 | 0] & 1)) {
    if (jsvArrayIsEmpty(HEAP32[103612]) & 1) {
     break block19
    }
   }
   HEAP8[414478] = 0;
  }
  if (HEAP8[$0 + 383 | 0] & 1) {
   jsiSetBusy(1, 0)
  }
  if (!(jspIsInterrupted() & 1)) {
   jsiExecuteEvents()
  }
  if (HEAPU16[207230] & 224) {
   jsiSetBusy(1, 1);
   HEAP16[$0 + 70 >> 1] = HEAPU16[207230];
   if ((HEAPU16[$0 + 70 >> 1] & 128) == 128) {
    jsiKill();
    jsvReset();
    jshReset();
    jsiSemiInit(0, 0);
    HEAP16[207230] = HEAPU16[207230] & 65407;
   }
   if ((HEAPU16[$0 + 70 >> 1] & 32) == 32) {
    jsvGarbageCollect();
    jsiSoftKill();
    jspSoftKill();
    jsvSoftKill();
    jsfSaveToFlash();
    jshReset();
    jsvSoftInit();
    jspSoftInit();
    jsiSoftInit(0);
    HEAP16[207230] = HEAPU16[207230] & 65503;
   }
   if ((HEAPU16[$0 + 70 >> 1] & 64) == 64) {
    HEAP32[$0 + 64 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 19451);
    block20 : {
     if (HEAP32[$0 + 64 >> 2]) {
      jsfNameFromVarAndUnLock($0 + 36 | 0, HEAP32[$0 + 64 >> 2]);
      jsiKill();
      jsvReset();
      jshReset();
      jsiSemiInit(0, $0 + 36 | 0);
      HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 60 >> 2];
      $5 = HEAP32[$0 + 56 >> 2];
      $2 = HEAP32[$0 + 52 >> 2];
      HEAP32[$0 + 16 >> 2] = $2;
      HEAP32[$0 + 20 >> 2] = $5;
      $2 = HEAP32[$0 + 48 >> 2];
      $5 = HEAP32[$0 + 44 >> 2];
      HEAP32[$0 + 8 >> 2] = $5;
      HEAP32[$0 + 12 >> 2] = $2;
      $5 = HEAP32[$0 + 40 >> 2];
      $2 = HEAP32[$0 + 36 >> 2];
      HEAP32[$0 >> 2] = $2;
      HEAP32[$0 + 4 >> 2] = $5;
      HEAP32[$0 + 32 >> 2] = jsfReadFile($0, 0, 0);
      if (HEAP32[$0 + 32 >> 2]) {
       jsvUnLock2(jspEvaluateVar(HEAP32[$0 + 32 >> 2], 0, HEAP8[$0 + 63 | 0] << 24 >> 24 ? 19451 : $0 + 36 | 0), HEAP32[$0 + 32 >> 2])
      }
      break block20;
     }
     jsiSoftKill();
     jspSoftKill();
     jsvSoftKill();
     jsvReset();
     jshReset();
     jsfLoadStateFromFlash();
     jsvSoftInit();
     jspSoftInit();
     jsiSoftInit(0);
    }
    HEAP16[207230] = HEAPU16[207230] & 65471;
   }
   jsiSetBusy(1, 0);
  }
  if (HEAPU16[207230] & 512) {
   jshKickWatchDog()
  }
  block22 : {
   block21 : {
    if (HEAPU8[414478] != 1) {
     break block21
    }
    $5 = HEAP32[$0 + 184 >> 2];
    $4 = $5;
    $2 = HEAP32[$0 + 188 >> 2];
    $1 = $2;
    $2 = jshGetTimeFromMilliseconds(10.0);
    $3 = $2;
    $5 = i64toi32_i32$HIGH_BITS;
    $2 = $5;
    $5 = $1;
    $1 = $3;
    if (($5 | 0) <= ($2 | 0) & $4 >>> 0 <= $1 >>> 0 | ($2 | 0) > ($5 | 0)) {
     break block21
    }
    if (jsvMoreFreeVariablesThan(600) & 1) {
     break block21
    }
    jsiSetBusy(1, 1);
    jsvGarbageCollect();
    jsiSetBusy(1, 0);
    break block22;
   }
   if (!HEAPU8[414478]) {
    break block22
   }
   if (jshHasEvents() & 1) {
    break block22
   }
   $4 = HEAP32[$0 + 184 >> 2];
   $5 = HEAP32[$0 + 188 >> 2];
   jshSleep($4, $5);
  }
  __stack_pointer = $0 + 384 | 0;
 }
 
 function jsiTimerAdd($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvArrayAddToEnd(HEAP32[103613], HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 - 1 | 0;
 }
 
 function jsiLoop() {
  jshIdle();
  jsiIdle();
  jsiCheckErrors(0);
  if (!(!(HEAP32[103315] & 6144) | HEAPU8[414476] <= 4 & HEAPU8[414476] >= 2)) {
   HEAP32[103315] = HEAP32[103315] & -6145;
   block1 : {
    if (!(jsvIsEmptyString(HEAP32[103616]) & 1)) {
     break block1
    }
   }
   jsiClearInputLine(1);
  }
  jsiConsoleReturnInputLine();
  return !HEAPU8[414478];
 }
 
 function jsiDumpState($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0;
  $2 = __stack_pointer - 256 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 252 >> 2] = $0;
  HEAP32[$2 + 248 >> 2] = $1;
  jsvObjectIteratorNew($2 + 244 | 0, HEAP32[103307]);
  while (1) {
   if (jsvObjectIteratorHasValue_865($2 + 244 | 0) & 1) {
    HEAP32[$2 + 240 >> 2] = jsvObjectIteratorGetKey_875($2 + 244 | 0);
    HEAP32[$2 + 236 >> 2] = jsvObjectIteratorGetValue_866($2 + 244 | 0);
    jsvGetString(HEAP32[$2 + 240 >> 2], $2 + 160 | 0, 64);
    HEAP8[$2 + 159 | 0] = 0;
    HEAP32[$2 + 152 >> 2] = 169203;
    while (1) {
     if (HEAPU8[HEAP32[$2 + 152 >> 2]]) {
      if (!strcmp(HEAP32[$2 + 152 >> 2], $2 + 160 | 0)) {
       HEAP8[$2 + 159 | 0] = 1
      }
      HEAP32[$2 + 152 >> 2] = (strlen(HEAP32[$2 + 152 >> 2]) + 1 | 0) + HEAP32[$2 + 152 >> 2];
      continue;
     }
     break;
    };
    if (!(HEAP8[$2 + 159 | 0] & 1)) {
     block : {
      if (jswIsBuiltInObject($2 + 160 | 0) & 1) {
       jsiDumpObjectState(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 240 >> 2], HEAP32[$2 + 236 >> 2]);
       break block;
      }
      if (!(jsvIsStringEqualOrStartsWith(HEAP32[$2 + 240 >> 2], 15492, 1) & 1)) {
       if (!(jsvIsStringEqual(HEAP32[$2 + 240 >> 2], 7018) & 1)) {
        if (!(jsvIsStringEqual(HEAP32[$2 + 240 >> 2], 7361) & 1)) {
         block1 : {
          if (HEAPU8[HEAP32[$2 + 240 >> 2]] == 255) {
           break block1
          }
          if (jshFromDeviceString($2 + 160 | 0) & 255) {
           break block1
          }
          if (!(jsvIsNativeFunction(HEAP32[$2 + 236 >> 2]) & 1)) {
           block2 : {
            if (jsvIsFunction(HEAP32[$2 + 236 >> 2]) & 1) {
             $0 = HEAP32[$2 + 252 >> 2];
             $1 = HEAP32[$2 + 248 >> 2];
             HEAP32[$2 >> 2] = HEAP32[$2 + 240 >> 2];
             cbprintf($0, $1, 4198, $2);
             jsfGetJSONForFunctionWithCallback(HEAP32[$2 + 236 >> 2], 32, HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
             FUNCTION_TABLE[HEAP32[$2 + 252 >> 2]](28752, HEAP32[$2 + 248 >> 2]);
             jsiDumpObjectState(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 240 >> 2], HEAP32[$2 + 236 >> 2]);
             break block2;
            }
            $0 = HEAP32[$2 + 252 >> 2];
            $1 = HEAP32[$2 + 248 >> 2];
            HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 240 >> 2];
            cbprintf($0, $1, 27582, $2 + 32 | 0);
            HEAP8[$2 + 151 | 0] = 0;
            if (jsvIsObject(HEAP32[$2 + 236 >> 2]) & 1) {
             HEAP32[$2 + 144 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 236 >> 2], 20670);
             if (HEAP32[$2 + 144 >> 2]) {
              HEAP32[$2 + 140 >> 2] = jsvGetPathTo(HEAP32[103307], HEAP32[$2 + 144 >> 2], 4, HEAP32[$2 + 236 >> 2]);
              if (HEAP32[$2 + 140 >> 2]) {
               $0 = HEAP32[$2 + 252 >> 2];
               $1 = HEAP32[$2 + 248 >> 2];
               HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 140 >> 2];
               cbprintf($0, $1, 28486, $2 + 16 | 0);
               jsiDumpObjectState(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 240 >> 2], HEAP32[$2 + 236 >> 2]);
               HEAP8[$2 + 151 | 0] = 1;
              }
             }
            }
            if (!(HEAP8[$2 + 151 | 0] & 1)) {
             jsiDumpJSON(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 236 >> 2], HEAP32[$2 + 240 >> 2]);
             FUNCTION_TABLE[HEAP32[$2 + 252 >> 2]](28503, HEAP32[$2 + 248 >> 2]);
            }
           }
          }
         }
        }
       }
      }
     }
    }
    jsvUnLock2(HEAP32[$2 + 236 >> 2], HEAP32[$2 + 240 >> 2]);
    jsvObjectIteratorNext($2 + 244 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_867($2 + 244 | 0);
  jsvObjectIteratorNew($2 + 244 | 0, HEAP32[103613]);
  while (1) {
   if (jsvObjectIteratorHasValue_865($2 + 244 | 0) & 1) {
    HEAP32[$2 + 136 >> 2] = jsvObjectIteratorGetValue_866($2 + 244 | 0);
    HEAP32[$2 + 132 >> 2] = jsvObjectIteratorGetKey_875($2 + 244 | 0);
    HEAP32[$2 + 128 >> 2] = jsvSkipOneNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 136 >> 2], 20492));
    HEAP32[$2 + 124 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 136 >> 2], 7687);
    FUNCTION_TABLE[HEAP32[$2 + 252 >> 2]](HEAP32[$2 + 124 >> 2] ? 27011 : 26999, HEAP32[$2 + 248 >> 2]);
    jsiDumpJSON(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 128 >> 2], 0);
    $4 = HEAP32[$2 + 252 >> 2];
    $5 = HEAP32[$2 + 248 >> 2];
    block3 : {
     if (HEAP32[$2 + 124 >> 2]) {
      $0 = jsvGetLongInteger(HEAP32[$2 + 124 >> 2]);
      $3 = $0;
      $1 = i64toi32_i32$HIGH_BITS;
      $0 = $1;
      break block3;
     }
     $1 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$2 + 136 >> 2], 17804));
     $3 = $1;
     $0 = i64toi32_i32$HIGH_BITS;
    }
    $6 = jshGetMillisecondsFromTime($3, $0);
    HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 132 >> 2];
    HEAPF64[$2 + 48 >> 3] = $6;
    cbprintf($4, $5, 27768, $2 + 48 | 0);
    jsvUnLock3(HEAP32[$2 + 124 >> 2], HEAP32[$2 + 128 >> 2], HEAP32[$2 + 132 >> 2]);
    jsvUnLock(HEAP32[$2 + 136 >> 2]);
    jsvObjectIteratorNext($2 + 244 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_867($2 + 244 | 0);
  jsvObjectIteratorNew($2 + 244 | 0, HEAP32[103614]);
  while (1) {
   if (jsvObjectIteratorHasValue_865($2 + 244 | 0) & 1) {
    HEAP32[$2 + 120 >> 2] = jsvObjectIteratorGetValue_866($2 + 244 | 0);
    HEAP32[$2 + 116 >> 2] = jsvSkipOneNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 120 >> 2], 20492));
    HEAP8[$2 + 115 | 0] = jsvObjectGetBoolChild(HEAP32[$2 + 120 >> 2], 7677) & 1;
    HEAP32[$2 + 108 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 120 >> 2], 18082);
    HEAP32[$2 + 104 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 120 >> 2], 15509);
    HEAP32[$2 + 100 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 120 >> 2], 18264);
    FUNCTION_TABLE[HEAP32[$2 + 252 >> 2]](27038, HEAP32[$2 + 248 >> 2]);
    jsiDumpJSON(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 116 >> 2], 0);
    $0 = HEAP32[$2 + 252 >> 2];
    $1 = HEAP32[$2 + 248 >> 2];
    $3 = HEAP32[$2 + 104 >> 2];
    $4 = HEAP8[$2 + 115 | 0] & 1 ? 17314 : 17666;
    HEAP32[$2 + 88 >> 2] = HEAP32[$2 + 108 >> 2] < 0 ? 16995 : HEAP32[$2 + 108 >> 2] > 0 ? 16606 : 16174;
    HEAP32[$2 + 84 >> 2] = $4;
    HEAP32[$2 + 80 >> 2] = $3;
    cbprintf($0, $1, 27104, $2 + 80 | 0);
    if (HEAP32[$2 + 100 >> 2] > 0) {
     $3 = HEAP32[$2 + 252 >> 2];
     $4 = HEAP32[$2 + 248 >> 2];
     $0 = HEAP32[$2 + 100 >> 2];
     $1 = $0 >> 31;
     HEAPF64[$2 + 64 >> 3] = jshGetMillisecondsFromTime($0, $1);
     cbprintf($3, $4, 17169, $2 - -64 | 0);
    }
    FUNCTION_TABLE[HEAP32[$2 + 252 >> 2]](28480, HEAP32[$2 + 248 >> 2]);
    jsvUnLock2(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 116 >> 2]);
    jsvUnLock(HEAP32[$2 + 120 >> 2]);
    jsvObjectIteratorNext($2 + 244 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_867($2 + 244 | 0);
  jsiDumpHardwareInitialisation(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], 1);
  HEAP32[$2 + 96 >> 2] = jsfGetBootCodeFromFlash(0);
  if (HEAP32[$2 + 96 >> 2]) {
   cbprintf(HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2], 28344, 0);
   jslPrintTokenisedString(HEAP32[$2 + 96 >> 2], HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
   jsvUnLock(HEAP32[$2 + 96 >> 2]);
  }
  __stack_pointer = $2 + 256 | 0;
 }
 
 function jsiTimersChanged() {
  HEAP16[207230] = HEAPU16[207230] | 4;
 }
 
 function jsiPacketFileSetTimeout($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 20990);
  if (HEAP32[$1 + 8 >> 2]) {
   jsiClearTimeout(HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
  block : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    jsvObjectSetChildAndUnLock(HEAP32[103308], 20990, jsiSetTimeout(581, 1.0e4));
    break block;
   }
   jsvObjectRemoveChild(HEAP32[103308], 20990);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsiPacketFileTimeoutHandler() {
  jsiPacketFileEnd();
 }
 
 function jsiPacketReply($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP16[$2 + 14 >> 1] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP16[$2 + 6 >> 1] = HEAPU16[$2 + 14 >> 1] | jsvGetStringLength(HEAP32[$2 + 8 >> 2]) & 65535;
  jsiConsolePrintChar(16);
  jsiConsolePrintChar(1);
  jsiConsolePrintChar(HEAPU16[$2 + 6 >> 1] >>> 8 << 24 >> 24);
  jsiConsolePrintChar((HEAPU16[$2 + 6 >> 1] & 255) << 24 >> 24);
  if (HEAP32[$2 + 8 >> 2]) {
   jsiConsolePrintStringVar(HEAP32[$2 + 8 >> 2])
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function packet_decompress_cb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  $3 = HEAPU8[$2 + 15 | 0];
  $4 = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
  $0 = HEAP32[$2 + 4 >> 2];
  $1 = HEAP32[$0 + 8 >> 2];
  HEAP32[$0 + 8 >> 2] = $1 + 1;
  HEAP8[$1 + $4 | 0] = $3;
  if (HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2] >= 512) {
   HEAP32[$2 >> 2] = jsvNewNativeString(HEAP32[HEAP32[$2 + 4 >> 2] >> 2], HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2]);
   packet_file_write(HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]);
   jsvUnLock(HEAP32[$2 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function packet_file_write($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 60 >> 2] = $0;
  HEAP32[$2 + 56 >> 2] = $1;
  jsfNameFromVar($2 + 28 | 0, HEAP32[HEAP32[$2 + 60 >> 2] + 24 >> 2]);
  $3 = HEAP32[103616];
  $4 = HEAP32[HEAP32[$2 + 60 >> 2] + 12 >> 2];
  $5 = HEAP32[HEAP32[$2 + 60 >> 2] + 16 >> 2];
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 52 >> 2];
  $1 = HEAP32[$2 + 48 >> 2];
  $0 = HEAP32[$2 + 44 >> 2];
  HEAP32[$2 + 16 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = HEAP32[$2 + 36 >> 2];
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = $0;
  $1 = HEAP32[$2 + 32 >> 2];
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  $1 = jsfWriteFile($2, $3, 0, $4, $5);
  $0 = HEAP32[$2 + 60 >> 2];
  HEAP8[$0 + 4 | 0] = HEAP8[$0 + 4 | 0] & 1 | $1 & 1;
  $0 = HEAP32[$2 + 60 >> 2];
  HEAP32[$0 + 12 >> 2] = HEAP32[HEAP32[$2 + 60 >> 2] + 8 >> 2] + HEAP32[$0 + 12 >> 2];
  HEAP32[HEAP32[$2 + 60 >> 2] + 8 >> 2] = 0;
  __stack_pointer = $2 - -64 | 0;
 }
 
 function jsiPacketTimeoutHandler() {
  jsiConsolePrintChar(21);
  jsiPacketExit();
 }
 
 function jshInitDevices() {
  HEAP8[414548] = 0;
  jshResetDevices();
 }
 
 function jshResetDevices() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  jshResetPinStateIsManual();
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   block : {
    if (!HEAP32[$0 + 12 >> 2] | HEAP32[$0 + 12 >> 2] >= 2) {
     break block
    }
    if (HEAP32[$0 + 12 >> 2] == ((jsiGetConsoleDevice() & 255) - 21 | 0)) {
     break block
    }
    HEAP8[HEAP32[$0 + 12 >> 2] + 414548 | 0] = 0;
    HEAP8[HEAP32[$0 + 12 >> 2] + 414550 | 0] = 255;
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$0 + 8 >> 2] = 1;
  while (1) {
   if (HEAP32[$0 + 8 >> 2] <= 16) {
    HEAP32[(HEAP32[$0 + 8 >> 2] << 2) + 414556 >> 2] = 0;
    HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  jshSetPinStateIsManual(17, 1);
  jshPinSetState(17, 6);
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jshTransmit($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  block1 : {
   if (!(HEAPU8[$2 + 15 | 0] != 17 & HEAPU8[$2 + 15 | 0] != 18)) {
    jshPushIOCharEvent(HEAPU8[$2 + 15 | 0] == 18 ? 17 : 18, HEAP8[$2 + 14 | 0] << 24 >> 24);
    break block1;
   }
   if (HEAPU8[$2 + 15 | 0] == 20) {
    terminalSendChar(HEAP8[$2 + 14 | 0] << 24 >> 24);
    break block1;
   }
   block2 : {
    if (HEAPU8[$2 + 15 | 0] != 21) {
     break block2
    }
    if (jshIsUSBSERIALConnected() & 1) {
     break block2
    }
    jshTransmitClearDevice(21);
    break block1;
   }
   if (!HEAPU8[$2 + 15 | 0]) {
    break block1
   }
   HEAP8[$2 + 13 | 0] = HEAPU8[414540] + 1;
   if (HEAPU8[$2 + 13 | 0] == HEAPU8[414541]) {
    jsiSetBusy(2, 1);
    if (HEAPU8[$2 + 15 | 0] == 19) {
     $3 = (jsiGetConsoleDevice() & 255) == 19
    }
    HEAP8[$2 + 12 | 0] = $3;
    while (1) {
     if (HEAPU8[$2 + 13 | 0] == HEAPU8[414541]) {
      if (jshIsInInterrupt() & 1) {
       HEAP8[413226] = HEAPU8[413226] | 2;
       break block1;
      }
      jshBusyIdle();
      if (!(jshIsUSBSERIALConnected() & 1)) {
       jshTransmitClearDevice(21)
      }
      continue;
     }
     break;
    };
    block3 : {
     if (!(HEAP8[$2 + 12 | 0] & 1)) {
      break block3
     }
     if ((jsiGetConsoleDevice() & 255) == 19) {
      break block3
     }
     HEAP8[$2 + 15 | 0] = jsiGetConsoleDevice();
    }
    jsiSetBusy(2, 0);
   }
   HEAP8[(HEAPU8[414540] << 1) + 414624 | 0] = HEAPU8[$2 + 15 | 0];
   HEAP8[((HEAPU8[414540] << 1) + 414624 | 0) + 1 | 0] = HEAPU8[$2 + 14 | 0];
   HEAP8[414540] = HEAPU8[$2 + 13 | 0];
   jshUSARTKick(HEAPU8[$2 + 15 | 0]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jshPushIOCharEvent($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  jshPushIOCharEvents(HEAPU8[$2 + 15 | 0], $2 + 14 | 0, 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jshTransmitClearDevice($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  while (1) {
   if ((jshGetCharToTransmit(HEAPU8[$1 + 15 | 0]) | 0) >= 0) {
    continue
   }
   break;
  };
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jshPushIOCharEvents($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 31 | 0] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (jshPushIOCharEventsHandler(HEAPU8[$3 + 31 | 0], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]) & 1) {
    break block
   }
   block2 : {
    block1 : {
     if (HEAPU16[207272] == HEAPU16[207271] | HEAPU16[207272] == HEAPU16[207273] | (HEAPU8[(HEAPU16[207272] + 1 & 1023) + 415136 | 0] != HEAPU8[$3 + 31 | 0] | HEAPU8[HEAPU16[207272] + 415136 | 0] + HEAP32[$3 + 20 >> 2] >>> 0 >= 64)) {
      break block1
     }
     if ((jshGetIOCharEventsFree() | 0) <= 0) {
      break block1
     }
     $0 = HEAPU16[207272];
     HEAP8[$0 + 415136 | 0] = HEAPU8[$0 + 415136 | 0] + (HEAP32[$3 + 20 >> 2] & 255);
     HEAP32[$3 + 16 >> 2] = 0;
     while (1) {
      if (HEAPU32[$3 + 16 >> 2] < HEAPU32[$3 + 20 >> 2]) {
       HEAP8[HEAPU16[207271] + 415136 | 0] = HEAPU8[HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 16 >> 2] | 0];
       HEAP16[207271] = HEAPU16[207271] + 1 & 1023;
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
       continue;
      }
      break;
     };
     break block2;
    }
    while (1) {
     if (HEAP32[$3 + 20 >> 2]) {
      HEAP32[$3 + 12 >> 2] = HEAPU32[$3 + 20 >> 2] > 64 ? 64 : HEAP32[$3 + 20 >> 2];
      jshPushEvent(HEAPU8[$3 + 31 | 0], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
      HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 24 >> 2];
      continue;
     }
     break;
    };
   }
   if (HEAPU8[$3 + 31 | 0] < 21 | HEAPU8[$3 + 31 | 0] > 22) {
    break block
   }
   if ((jshGetEventsUsed() | 0) <= 767) {
    break block
   }
   jshSetFlowControlXON(HEAPU8[$3 + 31 | 0], 0);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jshGetCharToTransmit($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 11 | 0] = $0;
  block1 : {
   if (!(HEAPU8[$1 + 11 | 0] < 21 | HEAPU8[$1 + 11 | 0] > 22)) {
    HEAP32[$1 + 4 >> 2] = HEAPU8[$1 + 11 | 0] + 414527;
    if (HEAP8[HEAP32[$1 + 4 >> 2]] & 1) {
     HEAP8[HEAP32[$1 + 4 >> 2]] = HEAPU8[HEAP32[$1 + 4 >> 2]] & -2 | 4;
     HEAP32[$1 + 12 >> 2] = 19;
     break block1;
    }
    if (HEAPU8[HEAP32[$1 + 4 >> 2]] & 2) {
     HEAP8[HEAP32[$1 + 4 >> 2]] = HEAPU8[HEAP32[$1 + 4 >> 2]] & -7;
     HEAP32[$1 + 12 >> 2] = 17;
     break block1;
    }
   }
   HEAP8[$1 + 3 | 0] = HEAPU8[414541];
   while (1) {
    if (HEAPU8[414540] != HEAPU8[$1 + 3 | 0]) {
     if (HEAPU8[$1 + 11 | 0] == (HEAPU8[(HEAPU8[$1 + 3 | 0] << 1) + 414624 | 0] & 31)) {
      HEAP8[$1 + 2 | 0] = HEAPU8[((HEAPU8[$1 + 3 | 0] << 1) + 414624 | 0) + 1 | 0];
      if (HEAPU8[$1 + 3 | 0] != HEAPU8[414541]) {
       HEAP8[$1 + 1 | 0] = HEAPU8[$1 + 3 | 0];
       HEAP8[$1 | 0] = HEAPU8[$1 + 1 | 0] + 255;
       while (1) {
        if (HEAPU8[$1 + 1 | 0] != HEAPU8[414541]) {
         HEAP16[(HEAPU8[$1 + 1 | 0] << 1) + 414624 >> 1] = HEAPU16[(HEAPU8[$1 | 0] << 1) + 414624 >> 1];
         HEAP8[$1 + 1 | 0] = HEAPU8[$1 | 0];
         HEAP8[$1 | 0] = HEAPU8[$1 + 1 | 0] + 255;
         continue;
        }
        break;
       };
      }
      HEAP8[414541] = HEAPU8[414541] + 1;
      HEAP32[$1 + 12 >> 2] = HEAPU8[$1 + 2 | 0];
      break block1;
     } else {
      HEAP8[$1 + 3 | 0] = HEAPU8[$1 + 3 | 0] + 1;
      continue;
     }
    }
    break;
   };
   HEAP32[$1 + 12 >> 2] = -1;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jshGetDeviceToTransmit() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (!(jshHasTransmitData() & 1)) {
    HEAP8[$0 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$0 + 15 | 0] = HEAPU8[(HEAPU8[414541] << 1) + 414624 | 0] & 31;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAPU8[$0 + 15 | 0];
 }
 
 function jshHasTransmitData() {
  return HEAPU8[414540] != HEAPU8[414541];
 }
 
 function jshTransmitFlushDevice($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jsiSetBusy(2, 1);
  HEAP8[$1 + 14 | 0] = 0;
  while (1) {
   HEAP8[$1 + 14 | 0] = 0;
   HEAP8[$1 + 13 | 0] = HEAPU8[414541];
   while (1) {
    if (HEAPU8[414540] != HEAPU8[$1 + 13 | 0]) {
     if (HEAPU8[$1 + 15 | 0] == (HEAPU8[(HEAPU8[$1 + 13 | 0] << 1) + 414624 | 0] & 31)) {
      HEAP8[$1 + 14 | 0] = 1
     } else {
      HEAP8[$1 + 13 | 0] = HEAPU8[$1 + 13 | 0] + 1;
      continue;
     }
    }
    break;
   };
   if (HEAP8[$1 + 14 | 0] & 1) {
    continue
   }
   break;
  };
  jsiSetBusy(2, 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jshTransmitMove($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  block1 : {
   if (!(HEAPU8[$2 + 14 | 0] != 17 & HEAPU8[$2 + 14 | 0] != 18)) {
    HEAP8[$2 + 13 | 0] = HEAPU8[$2 + 14 | 0] == 18 ? 17 : 18;
    HEAP32[$2 + 8 >> 2] = jshGetCharToTransmit(HEAPU8[$2 + 15 | 0]);
    while (1) {
     if (HEAP32[$2 + 8 >> 2] >= 0) {
      jshPushIOCharEvent(HEAPU8[$2 + 13 | 0], HEAP32[$2 + 8 >> 2] << 24 >> 24);
      HEAP32[$2 + 8 >> 2] = jshGetCharToTransmit(HEAPU8[$2 + 15 | 0]);
      continue;
     }
     break;
    };
    break block1;
   }
   jshInterruptOff();
   HEAP8[$2 + 7 | 0] = HEAPU8[414541];
   while (1) {
    if (HEAPU8[$2 + 7 | 0] != HEAPU8[414540]) {
     if (HEAPU8[$2 + 15 | 0] == (HEAPU8[(HEAPU8[$2 + 7 | 0] << 1) + 414624 | 0] & 31)) {
      HEAP8[(HEAPU8[$2 + 7 | 0] << 1) + 414624 | 0] = HEAPU8[$2 + 14 | 0] | HEAPU8[(HEAPU8[$2 + 7 | 0] << 1) + 414624 | 0] & -32
     }
     HEAP8[$2 + 7 | 0] = HEAPU8[$2 + 7 | 0] + 1;
     continue;
    }
    break;
   };
   jshInterruptOn();
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jshIOEventOverflowed() {
  HEAP8[413226] = HEAPU8[413226] | 1;
 }
 
 function jshPushEvent($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 30 | 0] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  if (HEAPU32[$3 + 20 >> 2] > 64) {
   HEAP32[$3 + 20 >> 2] = 64
  }
  jshInterruptOff();
  block : {
   if ((jshGetIOCharEventsFree() | 0) < (HEAP32[$3 + 20 >> 2] + 2 | 0)) {
    jshInterruptOn();
    jshIOEventOverflowed();
    HEAP8[$3 + 31 | 0] = 0;
    break block;
   }
   HEAP16[$3 + 18 >> 1] = HEAPU16[207271];
   HEAP8[HEAPU16[$3 + 18 >> 1] + 415136 | 0] = HEAP32[$3 + 20 >> 2];
   HEAP16[$3 + 18 >> 1] = HEAPU16[$3 + 18 >> 1] + 1 & 1023;
   HEAP8[HEAPU16[$3 + 18 >> 1] + 415136 | 0] = HEAPU8[$3 + 30 | 0];
   HEAP16[$3 + 18 >> 1] = HEAPU16[$3 + 18 >> 1] + 1 & 1023;
   HEAP32[$3 + 12 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 20 >> 2]) {
     HEAP8[HEAPU16[$3 + 18 >> 1] + 415136 | 0] = HEAPU8[HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 12 >> 2] | 0];
     HEAP16[$3 + 18 >> 1] = HEAPU16[$3 + 18 >> 1] + 1 & 1023;
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP16[207272] = HEAPU16[207271];
   HEAP16[207271] = HEAPU16[$3 + 18 >> 1];
   jshInterruptOn();
   jshHadEvent();
   HEAP8[$3 + 31 | 0] = 1;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 31 | 0] & 1;
 }
 
 function jshGetIOCharEventsFree() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 1024 - jshGetEventsUsed();
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2] - 4 | 0;
 }
 
 function jshPushCustomEvent($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP16[$1 + 12 >> 1] = $0;
  jshPushEvent(25, $1 + 12 | 0, 2);
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jshPushIOCharEventsHandler($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 31 | 0] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP8[$3 + 19 | 0] = 0;
  HEAP32[$3 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 20 >> 2]) {
    block : {
     if (HEAPU8[HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 12 >> 2] | 0] != 3) {
      break block
     }
     if (HEAPU8[$3 + 31 | 0] != (jsiGetConsoleDevice() & 255)) {
      break block
     }
     jsiCtrlC();
    }
    HEAP8[$3 + 19 | 0] = jswOnCharEvent(HEAPU8[$3 + 31 | 0], HEAP8[HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 12 >> 2] | 0] << 24 >> 24) & 1 | HEAP8[$3 + 19 | 0] & 1;
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 19 | 0] & 1;
 }
 
 function jshGetEventsUsed() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  if (HEAPU16[207271] >= HEAPU16[207273]) {
   $1 = HEAPU16[207271] - HEAPU16[207273] | 0
  } else {
   $1 = (HEAPU16[207271] + 1024 | 0) - HEAPU16[207273] | 0
  }
  HEAP32[$0 + 12 >> 2] = $1;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jshSetFlowControlXON($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  if (!(HEAPU8[$2 + 15 | 0] < 21 | HEAPU8[$2 + 15 | 0] > 22)) {
   if (!(HEAP8[$2 + 14 | 0] & 1)) {
    HEAP8[416160] = 1
   }
   HEAP32[$2 + 8 >> 2] = HEAPU8[$2 + 15 | 0] - 21;
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2] + 414548;
   if (HEAPU8[HEAP32[$2 + 4 >> 2]] & 8) {
    block1 : {
     if (HEAP8[$2 + 14 | 0] & 1) {
      if ((HEAPU8[HEAP32[$2 + 4 >> 2]] & 6) == 4) {
       jshInterruptOff();
       $0 = HEAP32[$2 + 4 >> 2];
       HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 2;
       jshInterruptOn();
       jshUSARTKick(HEAPU8[$2 + 15 | 0]);
      }
      break block1;
     }
     if (!(HEAPU8[HEAP32[$2 + 4 >> 2]] & 5)) {
      jshInterruptOff();
      $0 = HEAP32[$2 + 4 >> 2];
      HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 1;
      jshInterruptOn();
      jshUSARTKick(HEAPU8[$2 + 15 | 0]);
     }
    }
   }
   HEAP8[$2 + 3 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + 414550 | 0];
   if (HEAPU8[$2 + 3 | 0] != 255) {
    jshPinSetValue(HEAPU8[$2 + 3 | 0], (HEAPU8[$2 + 14 | 0] ^ -1) & 1)
   }
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jshPushIOWatchEvent($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 31 | 0] = $0;
  HEAP8[$1 + 30 | 0] = jshGetWatchedPinState(HEAPU8[$1 + 31 | 0]) & 1;
  HEAP32[$1 + 24 >> 2] = HEAPU8[$1 + 31 | 0] - 1;
  block1 : {
   if (HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 414560 >> 2]) {
    block : {
     if ((HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 414560 >> 2] & -256) == -256) {
      HEAP8[$1 + 23 | 0] = HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 414560 >> 2];
      if (jshPinGetValue(HEAPU8[$1 + 23 | 0]) & 1) {
       HEAP8[$1 + 31 | 0] = HEAPU8[$1 + 31 | 0] | 64
      }
      break block;
     }
     FUNCTION_TABLE[HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 414560 >> 2]](HEAP8[$1 + 30 | 0] & 1, HEAPU8[$1 + 31 | 0]);
     break block1;
    }
   }
   if (HEAP8[$1 + 30 | 0] & 1) {
    HEAP8[$1 + 31 | 0] = HEAPU8[$1 + 31 | 0] | 32
   }
   HEAP32[$1 + 8 >> 2] = jshGetSystemTime();
   HEAP32[$1 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
   jshPushIOEvent(HEAPU8[$1 + 31 | 0], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jshPushIOEvent($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 31 | 0] = $0;
  HEAP32[$3 + 16 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2];
  jshPushEvent(HEAPU8[$3 + 31 | 0], $3 + 12 | 0, 4);
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jshPopIOEvent($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (HEAPU16[207271] == HEAPU16[207273]) {
    HEAP8[$2 + 31 | 0] = 0;
    break block;
   }
   if (HEAPU16[207272] == HEAPU16[207273]) {
    HEAP16[207272] = HEAPU16[207271]
   }
   HEAP16[$2 + 18 >> 1] = HEAPU16[207273];
   HEAP32[$2 + 12 >> 2] = HEAPU8[HEAPU16[$2 + 18 >> 1] + 415136 | 0];
   HEAP16[$2 + 18 >> 1] = HEAPU16[$2 + 18 >> 1] + 1 & 1023;
   HEAP8[$2 + 11 | 0] = HEAPU8[HEAPU16[$2 + 18 >> 1] + 415136 | 0];
   HEAP16[$2 + 18 >> 1] = HEAPU16[$2 + 18 >> 1] + 1 & 1023;
   if (HEAP32[$2 + 20 >> 2]) {
    HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAP32[$2 + 12 >> 2]
   }
   HEAP32[$2 + 4 >> 2] = 0;
   while (1) {
    if (HEAPU32[$2 + 4 >> 2] < HEAPU32[$2 + 12 >> 2]) {
     if (HEAP32[$2 + 24 >> 2]) {
      HEAP8[HEAP32[$2 + 24 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = HEAPU8[HEAPU16[$2 + 18 >> 1] + 415136 | 0]
     }
     HEAP16[$2 + 18 >> 1] = HEAPU16[$2 + 18 >> 1] + 1 & 1023;
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP16[207273] = HEAPU16[$2 + 18 >> 1];
   HEAP8[$2 + 31 | 0] = HEAPU8[$2 + 11 | 0];
  }
  return HEAPU8[$2 + 31 | 0];
 }
 
 function jshPopIOEventOfType($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 30 | 0] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP16[$3 + 18 >> 1] = HEAPU16[207273];
  block1 : {
   while (1) {
    if (HEAPU16[207271] != HEAPU16[$3 + 18 >> 1]) {
     HEAP32[$3 + 12 >> 2] = HEAPU8[HEAPU16[$3 + 18 >> 1] + 415136 | 0];
     HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 18 >> 1] + 1 & 1023;
     HEAP8[$3 + 9 | 0] = HEAPU8[HEAPU16[$3 + 10 >> 1] + 415136 | 0];
     if (HEAPU8[$3 + 30 | 0] == (HEAPU8[$3 + 9 | 0] & 31)) {
      HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] + 1 & 1023;
      jshInterruptOff();
      if (HEAP32[$3 + 20 >> 2]) {
       HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = HEAP32[$3 + 12 >> 2]
      }
      HEAP32[$3 + 4 >> 2] = 0;
      while (1) {
       if (HEAPU32[$3 + 4 >> 2] < HEAPU32[$3 + 12 >> 2]) {
        if (HEAP32[$3 + 24 >> 2]) {
         HEAP8[HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 4 >> 2] | 0] = HEAPU8[HEAPU16[$3 + 10 >> 1] + 415136 | 0]
        }
        HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] + 1 & 1023;
        HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
        continue;
       }
       break;
      };
      block : {
       if (HEAPU16[$3 + 18 >> 1] == HEAPU16[207273]) {
        HEAP16[207273] = HEAPU16[$3 + 10 >> 1];
        break block;
       }
       HEAP16[$3 + 2 >> 1] = (HEAPU16[$3 + 18 >> 1] + HEAP32[$3 + 12 >> 2] | 0) + 1 & 1023;
       HEAP16[$3 >> 1] = HEAPU16[$3 + 18 >> 1] + 1023 & 1023;
       while (1) {
        HEAP8[HEAPU16[$3 + 2 >> 1] + 415136 | 0] = HEAPU8[HEAPU16[$3 >> 1] + 415136 | 0];
        if (HEAPU16[$3 >> 1] != HEAPU16[207273]) {
         HEAP16[$3 >> 1] = HEAPU16[$3 >> 1] + 1023 & 1023;
         HEAP16[$3 + 2 >> 1] = HEAPU16[$3 + 2 >> 1] + 1023 & 1023;
         continue;
        }
        break;
       };
       HEAP16[207273] = HEAPU16[$3 + 2 >> 1];
      }
      HEAP16[207272] = HEAPU16[207271];
      jshInterruptOn();
      HEAP8[$3 + 31 | 0] = HEAPU8[$3 + 9 | 0];
      break block1;
     } else {
      HEAP16[$3 + 18 >> 1] = (HEAPU16[$3 + 18 >> 1] + HEAP32[$3 + 12 >> 2] | 0) + 2 & 1023;
      continue;
     }
    }
    break;
   };
   HEAP8[$3 + 31 | 0] = 0;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAPU8[$3 + 31 | 0];
 }
 
 function jshHasEvents() {
  return HEAPU16[207271] != HEAPU16[207273];
 }
 
 function jshIsTopEvent($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 14 | 0] = $0;
  block : {
   if (HEAPU16[207271] == HEAPU16[207273]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 14 | 0] == (HEAPU8[(HEAPU16[207273] + 1 & 1023) + 415136 | 0] & 31);
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jshGetDeviceString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 11 | 0] = $0;
  block10 : {
   block1 : {
    switch (HEAPU8[$1 + 11 | 0]) {
    case 0:
     HEAP32[$1 + 12 >> 2] = 15755;
     break block10;
    case 17:
     HEAP32[$1 + 12 >> 2] = 21650;
     break block10;
    case 18:
     HEAP32[$1 + 12 >> 2] = 21596;
     break block10;
    case 19:
     HEAP32[$1 + 12 >> 2] = 15119;
     break block10;
    case 21:
     HEAP32[$1 + 12 >> 2] = 21610;
     break block10;
    case 20:
     HEAP32[$1 + 12 >> 2] = 15920;
     break block10;
    case 22:
     HEAP32[$1 + 12 >> 2] = 22444;
     break block10;
    case 27:
     HEAP32[$1 + 12 >> 2] = 22479;
     break block10;
    case 28:
     HEAP32[$1 + 12 >> 2] = 22493;
     break block10;
    default:
     break block1;
    };
   }
   HEAP32[$1 + 12 >> 2] = 28753;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jshFromDeviceString($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (HEAPU8[HEAP32[$1 + 8 >> 2]] == 76) {
    if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 21651)) {
     HEAP8[$1 + 15 | 0] = 17;
     break block;
    }
    if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 21597)) {
     HEAP8[$1 + 15 | 0] = 18;
     break block;
    }
   }
   if (!(HEAPU8[HEAP32[$1 + 8 >> 2]] != 85 | HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 83 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] << 24 >> 24 | HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 66))) {
    HEAP8[$1 + 15 | 0] = 21;
    break block;
   }
   block2 : {
    if (HEAPU8[HEAP32[$1 + 8 >> 2]] == 84) {
     if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 15921)) {
      HEAP8[$1 + 15 | 0] = 20;
      break block;
     }
     break block2;
    }
    block5 : {
     if (HEAPU8[HEAP32[$1 + 8 >> 2]] == 83) {
      block3 : {
       if (HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 101 | HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 114 | (HEAPU8[HEAP32[$1 + 8 >> 2] + 3 | 0] != 105 | HEAPU8[HEAP32[$1 + 8 >> 2] + 4 | 0] != 97)) {
        break block3
       }
       if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] != 108 | HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] << 24 >> 24 < 49 | (HEAP8[HEAP32[$1 + 8 >> 2] + 7 | 0] << 24 >> 24 | ((HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] << 24 >> 24) - 49 | 0) > 0)) {
        break block3
       }
       HEAP8[$1 + 15 | 0] = (HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] << 24 >> 24) - 27;
       break block;
      }
      block4 : {
       if (HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 80 | HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 73 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] << 24 >> 24 < 49 | ((HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] << 24 >> 24) - 49 | 0) > 0)) {
        break block4
       }
       if (HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0] << 24 >> 24) {
        break block4
       }
       HEAP8[$1 + 15 | 0] = (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] << 24 >> 24) - 22;
       break block;
      }
      break block5;
     }
     block6 : {
      if (HEAPU8[HEAP32[$1 + 8 >> 2]] != 73 | HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 50 | (HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 67 | HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] << 24 >> 24 < 49)) {
       break block6
      }
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0] << 24 >> 24 | ((HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] << 24 >> 24) - 49 | 0) > 0) {
       break block6
      }
      HEAP8[$1 + 15 | 0] = (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] << 24 >> 24) - 21;
      break block;
     }
    }
   }
   HEAP8[$1 + 15 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAPU8[$1 + 15 | 0];
 }
 
 function jshSetFlowControlAllReady() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  if (HEAP8[416160] & 1) {
   HEAP32[$0 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$0 + 12 >> 2] < 2) {
     jshSetFlowControlXON(HEAP32[$0 + 12 >> 2] + 21 & 255, 1);
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP8[416160] = 0;
  }
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jshSetFlowControlEnabled($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 15 | 0] = $0;
  HEAP8[$3 + 14 | 0] = $1;
  HEAP8[$3 + 13 | 0] = $2;
  if (!(HEAPU8[$3 + 15 | 0] < 21 | HEAPU8[$3 + 15 | 0] > 22)) {
   HEAP32[$3 + 8 >> 2] = HEAPU8[$3 + 15 | 0] - 21;
   HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 8 >> 2] + 414548;
   block1 : {
    if (HEAP8[$3 + 14 | 0] & 1) {
     $0 = HEAP32[$3 + 4 >> 2];
     HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 8;
     break block1;
    }
    $0 = HEAP32[$3 + 4 >> 2];
    HEAP8[$0 | 0] = HEAPU8[$0 | 0] & -9;
   }
   HEAP8[HEAP32[$3 + 8 >> 2] + 414550 | 0] = 255;
   if (jshIsPinValid(HEAPU8[$3 + 13 | 0]) & 1) {
    jshPinSetState(HEAPU8[$3 + 13 | 0], 1);
    jshPinSetValue(HEAPU8[$3 + 13 | 0], 0);
    HEAP8[HEAP32[$3 + 8 >> 2] + 414550 | 0] = HEAPU8[$3 + 13 | 0];
   }
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jshSetEventCallback($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[(HEAPU8[$2 + 15 | 0] << 2) + 414556 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 
 function jshSetEventDataPin($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  HEAP32[(HEAPU8[$2 + 15 | 0] << 2) + 414556 >> 2] = HEAPU8[$2 + 14 | 0] | -256;
 }
 
 function jshGetEventDataPin($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 14 | 0] = $0;
  HEAP32[$1 + 8 >> 2] = HEAPU8[$1 + 14 | 0] - 1;
  block : {
   if ((HEAP32[(HEAP32[$1 + 8 >> 2] << 2) + 414560 >> 2] & -256) == -256) {
    HEAP8[$1 + 15 | 0] = HEAP32[(HEAP32[$1 + 8 >> 2] << 2) + 414560 >> 2];
    break block;
   }
   HEAP8[$1 + 15 | 0] = 255;
  }
  return HEAPU8[$1 + 15 | 0];
 }
 
 function jstUtilTimerTaskIsFinished($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = Math_imul(HEAP32[$1 + 12 >> 2], 25) + 416192;
  block2 : {
   block1 : {
    block : {
     if (HEAPU8[HEAP32[$1 + 8 >> 2] + 24 | 0] == 3 | HEAPU8[HEAP32[$1 + 8 >> 2] + 24 | 0] == 4 | (HEAPU8[HEAP32[$1 + 8 >> 2] + 24 | 0] == 5 | HEAPU8[HEAP32[$1 + 8 >> 2] + 24 | 0] == 6)) {
      break block
     }
     if (HEAPU8[HEAP32[$1 + 8 >> 2] + 24 | 0] == 7) {
      break block
     }
     if (HEAPU8[HEAP32[$1 + 8 >> 2] + 24 | 0] != 2) {
      break block1
     }
    }
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP8[$0 + 24 | 0] = HEAPU8[$0 + 24 | 0] | 16;
    jshPushCustomEvent((HEAP32[$1 + 12 >> 2] << 8 | 1) & 65535);
    break block2;
   }
   HEAP8[HEAP32[$1 + 8 >> 2] + 24 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jstUtilTimerSetupBuffer($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = _jsvGetAddressOf(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  $2 = HEAP32[$1 + 12 >> 2];
  HEAP8[$2 + 8 | 0] = $0;
  HEAP8[$2 + 9 | 0] = $0 >>> 8;
  HEAP8[$2 + 10 | 0] = $0 >>> 16;
  HEAP8[$2 + 11 | 0] = $0 >>> 24;
  $0 = HEAP32[$1 + 12 >> 2];
  block : {
   if (jsvIsFlatString(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP8[$0 + 18 | 0] = 14;
    HEAP8[$0 + 19 | 0] = 0;
    $0 = HEAP32[$1 + 12 >> 2];
    $2 = jsvGetCharactersInVar(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24));
    $0 = HEAP32[$1 + 12 >> 2];
    $2 = $2 + 14 | 0;
    HEAP8[$0 + 20 | 0] = $2;
    HEAP8[$0 + 21 | 0] = $2 >>> 8;
    break block;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 18 | 0] = 0;
   HEAP8[$0 + 19 | 0] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = jsvGetCharactersInVar(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24));
   $2 = HEAP32[$1 + 12 >> 2];
   HEAP8[$2 + 20 | 0] = $0;
   HEAP8[$2 + 21 | 0] = $0 >>> 8;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jstUtilTimerIsRunning() {
  return HEAP8[416163] & 1;
 }
 
 function jstUtilTimerWaitEmpty() {
  var $0 = 0, $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = 2e6;
  while (1) {
   $0 = 0;
   block : {
    if (!(jstUtilTimerIsRunning() & 1)) {
     break block
    }
    $0 = 0;
    if (jspIsInterrupted() & 1) {
     break block
    }
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$1 + 12 >> 2] = $0 - 1;
    $0 = ($0 | 0) > 0;
   }
   if ($0) {
    continue
   }
   break;
  };
  block1 : {
   if (jspIsInterrupted() & 1) {
    jsExceptionHere(4, 8066, 0);
    break block1;
   }
   if (HEAP32[$1 + 12 >> 2] <= 0) {
    jsExceptionHere(4, 8041, 0)
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jstGetUtilTimerOffset() {
  return HEAP32[104152];
 }
 
 function jstRestartUtilTimer() {
  var $0 = 0, $1 = 0;
  $0 = Math_imul(HEAPU8[HEAPU8[416162] + 416592 | 0], 25) + 416192 | 0;
  HEAP32[104044] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  $0 = jshGetSystemTime();
  HEAP32[104042] = $0;
  $1 = i64toi32_i32$HIGH_BITS;
  HEAP32[104043] = $1;
  if (HEAP32[104044] < 0) {
   HEAP32[104044] = 0
  }
  $1 = HEAP32[104044];
  $0 = $1 >> 31;
  jshUtilTimerStart($1, $0);
 }
 
 function utilTimerGetUnusedIndex($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 11 | 0] = $0;
  if (HEAP8[$1 + 11 | 0] & 1) {
   HEAP32[$1 + 4 >> 2] = 2e6;
   while (1) {
    $0 = 0;
    block : {
     if (!(utilTimerIsFull() & 1)) {
      break block
     }
     $0 = 0;
     if (jspIsInterrupted() & 1) {
      break block
     }
     $0 = HEAP32[$1 + 4 >> 2];
     HEAP32[$1 + 4 >> 2] = $0 - 1;
     $0 = ($0 | 0) > 0;
    }
    if ($0) {
     continue
    }
    break;
   };
   block1 : {
    if (jspIsInterrupted() & 1) {
     jsExceptionHere(4, 8066, 0);
     break block1;
    }
    if (HEAP32[$1 + 4 >> 2] <= 0) {
     jsExceptionHere(4, 8041, 0)
    }
   }
  }
  HEAP32[$1 >> 2] = 0;
  block2 : {
   while (1) {
    if (HEAP32[$1 >> 2] < 16) {
     if (HEAPU8[(Math_imul(HEAP32[$1 >> 2], 25) + 416192 | 0) + 24 | 0]) {
      HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
      continue;
     } else {
      HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
      break block2;
     }
    }
    break;
   };
   HEAP32[$1 + 12 >> 2] = -1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function utilTimerIsFull() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  HEAP8[$0 + 15 | 0] = HEAPU8[416161] + 1 & 15;
  return HEAPU8[$0 + 15 | 0] == HEAPU8[416162];
 }
 
 function utilTimerInsertTask($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 30 | 0] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP8[$3 + 23 | 0] = $2;
  HEAP32[$3 + 16 >> 2] = Math_imul(HEAPU8[$3 + 30 | 0], 25) + 416192;
  jshInterruptOff();
  if (HEAP32[$3 + 24 >> 2]) {
   $0 = HEAP32[$3 + 16 >> 2];
   $1 = (HEAP32[HEAP32[$3 + 24 >> 2] >> 2] - HEAP32[104152] | 0) + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0;
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
  }
  block : {
   if (HEAP8[416163] & 1) {
    $0 = jshGetSystemTime() - HEAP32[104042] | 0;
    break block;
   }
   $0 = 0;
  }
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP8[$3 + 11 | 0] = HEAPU8[416162];
  block1 : {
   while (1) {
    $0 = 0;
    if (HEAPU8[$3 + 11 | 0] != HEAPU8[416161]) {
     $0 = HEAP32[$3 + 16 >> 2];
     $1 = Math_imul(HEAPU8[HEAPU8[$3 + 11 | 0] + 416592 | 0], 25) + 416192 | 0;
     $0 = (HEAP32[$3 + 12 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0) > (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24));
    }
    if ($0) {
     if (HEAP8[$3 + 23 | 0] & 1) {
      jshInterruptOn();
      HEAP8[(Math_imul(HEAPU8[$3 + 30 | 0], 25) + 416192 | 0) + 24 | 0] = 0;
      HEAP8[$3 + 31 | 0] = 0;
      break block1;
     }
     HEAP8[$3 + 11 | 0] = HEAPU8[$3 + 11 | 0] + 1 & 15;
     continue;
    }
    break;
   };
   HEAP8[$3 + 10 | 0] = HEAPU8[$3 + 11 | 0] == HEAPU8[416162];
   HEAP32[$3 + 4 >> 2] = HEAPU8[416161];
   while (1) {
    if (HEAP32[$3 + 4 >> 2] != HEAPU8[$3 + 11 | 0]) {
     HEAP8[$3 + 3 | 0] = HEAP32[$3 + 4 >> 2] + 15 & 15;
     HEAP8[HEAP32[$3 + 4 >> 2] + 416592 | 0] = HEAPU8[HEAPU8[$3 + 3 | 0] + 416592 | 0];
     HEAP32[$3 + 4 >> 2] = HEAPU8[$3 + 3 | 0];
     continue;
    }
    break;
   };
   HEAP8[416161] = HEAPU8[416161] + 1 & 15;
   block3 : {
    if (HEAP8[$3 + 10 | 0] & 1) {
     HEAP32[$3 + 4 >> 2] = HEAPU8[416162];
     while (1) {
      if (HEAP32[$3 + 4 >> 2] != HEAPU8[416161]) {
       $0 = Math_imul(HEAPU8[HEAP32[$3 + 4 >> 2] + 416592 | 0], 25) + 416192 | 0;
       block2 : {
        if (HEAP32[$3 + 12 >> 2] < (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
         $0 = Math_imul(HEAPU8[HEAP32[$3 + 4 >> 2] + 416592 | 0], 25) + 416192 | 0;
         $1 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) - HEAP32[$3 + 12 >> 2] | 0;
         HEAP8[$0 | 0] = $1;
         HEAP8[$0 + 1 | 0] = $1 >>> 8;
         HEAP8[$0 + 2 | 0] = $1 >>> 16;
         HEAP8[$0 + 3 | 0] = $1 >>> 24;
         break block2;
        }
        $0 = Math_imul(HEAPU8[HEAP32[$3 + 4 >> 2] + 416592 | 0], 25) + 416192 | 0;
        HEAP8[$0 | 0] = 0;
        HEAP8[$0 + 1 | 0] = 0;
        HEAP8[$0 + 2 | 0] = 0;
        HEAP8[$0 + 3 | 0] = 0;
       }
       HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1 & 15;
       continue;
      }
      break;
     };
     break block3;
    }
    $0 = HEAP32[$3 + 16 >> 2];
    $1 = HEAP32[$3 + 12 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0;
    HEAP8[$0 | 0] = $1;
    HEAP8[$0 + 1 | 0] = $1 >>> 8;
    HEAP8[$0 + 2 | 0] = $1 >>> 16;
    HEAP8[$0 + 3 | 0] = $1 >>> 24;
   }
   HEAP8[HEAPU8[$3 + 11 | 0] + 416592 | 0] = HEAPU8[$3 + 30 | 0];
   if (!(!(HEAP8[$3 + 10 | 0] & 1) & (HEAP8[416163] & 1))) {
    HEAP8[416163] = 1;
    jstRestartUtilTimer();
   }
   jshInterruptOn();
   HEAP8[$3 + 31 | 0] = 1;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 31 | 0] & 1;
 }
 
 function utilTimerFindTask($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = 0;
  block : {
   while (1) {
    if (HEAP32[$2 >> 2] < 16) {
     if (FUNCTION_TABLE[HEAP32[$2 + 8 >> 2]](Math_imul(HEAP32[$2 >> 2], 25) + 416192 | 0, HEAP32[$2 + 4 >> 2]) & 1) {
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
      break block;
     } else {
      HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
      continue;
     }
    }
    break;
   };
   HEAP32[$2 + 12 >> 2] = -1;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function utilTimerRemoveTask($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  jshInterruptOff();
  jstUtilTimerTaskIsFinished(HEAP32[$1 + 8 >> 2]);
  HEAP8[$1 + 7 | 0] = HEAPU8[416161];
  block : {
   if (HEAPU8[$1 + 7 | 0] != HEAPU8[416162]) {
    HEAP8[$1 + 6 | 0] = HEAPU8[416162] + 15 & 15;
    HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 7 | 0] + 15 & 15;
    while (1) {
     if (HEAPU8[$1 + 7 | 0] != HEAPU8[$1 + 6 | 0]) {
      if (HEAPU8[HEAPU8[$1 + 7 | 0] + 416592 | 0] == HEAP32[$1 + 8 >> 2]) {
       $0 = Math_imul(HEAPU8[HEAPU8[$1 + 7 | 0] + 416592 | 0], 25) + 416192 | 0;
       HEAP8[$0 + 24 | 0] = HEAPU8[$0 + 24 | 0] | 16;
       HEAP8[$1 + 5 | 0] = HEAPU8[$1 + 7 | 0] + 15 & 15;
       while (1) {
        if (HEAPU8[$1 + 5 | 0] != HEAPU8[$1 + 6 | 0]) {
         HEAP8[HEAPU8[$1 + 7 | 0] + 416592 | 0] = HEAPU8[HEAPU8[$1 + 5 | 0] + 416592 | 0];
         HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 5 | 0];
         HEAP8[$1 + 5 | 0] = HEAPU8[$1 + 7 | 0] + 15 & 15;
         continue;
        }
        break;
       };
       HEAP8[416162] = HEAPU8[416162] + 1 & 15;
       jshInterruptOn();
       HEAP8[$1 + 15 | 0] = 1;
       break block;
      } else {
       HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 7 | 0] + 15 & 15;
       continue;
      }
     }
     break;
    };
   }
   jshInterruptOn();
   HEAP8[$1 + 15 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function utilTimerGetLastTask($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  jshInterruptOff();
  HEAP8[$4 + 15 | 0] = HEAPU8[416161];
  block : {
   if (HEAPU8[$4 + 15 | 0] != HEAPU8[416162]) {
    HEAP8[$4 + 15 | 0] = HEAPU8[$4 + 15 | 0] + 15 & 15;
    while (1) {
     if (HEAPU8[$4 + 15 | 0] != (HEAPU8[416162] + 15 & 15)) {
      if (FUNCTION_TABLE[HEAP32[$4 + 24 >> 2]](Math_imul(HEAPU8[HEAPU8[$4 + 15 | 0] + 416592 | 0], 25) + 416192 | 0, HEAP32[$4 + 20 >> 2]) & 1) {
       $3 = Math_imul(HEAPU8[HEAPU8[$4 + 15 | 0] + 416592 | 0], 25) + 416192 | 0;
       $0 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
       $2 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
       $5 = $0;
       $1 = HEAP32[$4 + 16 >> 2];
       $0 = $1;
       HEAP8[$0 | 0] = $5;
       HEAP8[$0 + 1 | 0] = $5 >>> 8;
       HEAP8[$0 + 2 | 0] = $5 >>> 16;
       HEAP8[$0 + 3 | 0] = $5 >>> 24;
       HEAP8[$0 + 4 | 0] = $2;
       HEAP8[$0 + 5 | 0] = $2 >>> 8;
       HEAP8[$0 + 6 | 0] = $2 >>> 16;
       HEAP8[$0 + 7 | 0] = $2 >>> 24;
       HEAP8[$0 + 24 | 0] = HEAPU8[$3 + 24 | 0];
       $0 = HEAPU8[$3 + 20 | 0] | HEAPU8[$3 + 21 | 0] << 8 | (HEAPU8[$3 + 22 | 0] << 16 | HEAPU8[$3 + 23 | 0] << 24);
       $2 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24);
       $5 = $2;
       $2 = $1;
       HEAP8[$2 + 16 | 0] = $5;
       HEAP8[$2 + 17 | 0] = $5 >>> 8;
       HEAP8[$2 + 18 | 0] = $5 >>> 16;
       HEAP8[$2 + 19 | 0] = $5 >>> 24;
       HEAP8[$2 + 20 | 0] = $0;
       HEAP8[$2 + 21 | 0] = $0 >>> 8;
       HEAP8[$2 + 22 | 0] = $0 >>> 16;
       HEAP8[$2 + 23 | 0] = $0 >>> 24;
       $2 = HEAPU8[$3 + 12 | 0] | HEAPU8[$3 + 13 | 0] << 8 | (HEAPU8[$3 + 14 | 0] << 16 | HEAPU8[$3 + 15 | 0] << 24);
       $0 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8 | (HEAPU8[$3 + 10 | 0] << 16 | HEAPU8[$3 + 11 | 0] << 24);
       $5 = $0;
       $0 = $1;
       HEAP8[$0 + 8 | 0] = $5;
       HEAP8[$0 + 9 | 0] = $5 >>> 8;
       HEAP8[$0 + 10 | 0] = $5 >>> 16;
       HEAP8[$0 + 11 | 0] = $5 >>> 24;
       HEAP8[$0 + 12 | 0] = $2;
       HEAP8[$0 + 13 | 0] = $2 >>> 8;
       HEAP8[$0 + 14 | 0] = $2 >>> 16;
       HEAP8[$0 + 15 | 0] = $2 >>> 24;
       jshInterruptOn();
       HEAP8[$4 + 31 | 0] = 1;
       break block;
      } else {
       HEAP8[$4 + 15 | 0] = HEAPU8[$4 + 15 | 0] + 15 & 15;
       continue;
      }
     }
     break;
    };
   }
   jshInterruptOn();
   HEAP8[$4 + 31 | 0] = 0;
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP8[$4 + 31 | 0] & 1;
 }
 
 function jstGetLastPinTimerTask($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = utilTimerGetLastTask(582, $2 + 15 | 0, HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0 & 1;
 }
 
 function jstPinTaskChecker($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (HEAPU8[HEAP32[$2 + 24 >> 2] + 24 | 0] != 2) {
    HEAP8[$2 + 31 | 0] = 0;
    break block;
   }
   HEAP8[$2 + 19 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2]];
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 12 >> 2] < 8) {
     if (HEAPU8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 24 >> 2] + 8 | 0) | 0] == HEAPU8[$2 + 19 | 0]) {
      HEAP8[$2 + 31 | 0] = 1;
      break block;
     }
     if (HEAPU8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 24 >> 2] + 8 | 0) | 0] == 255) {
      HEAP8[$2 + 31 | 0] = 0;
      break block;
     } else {
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
      continue;
     }
    }
    break;
   };
   HEAP8[$2 + 31 | 0] = 0;
  }
  return HEAP8[$2 + 31 | 0] & 1;
 }
 
 function jstBufferTaskChecker($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block1 : {
   if (!(HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 4 | HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 5 | (HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 6 | HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 7))) {
    HEAP8[$2 + 15 | 0] = 0;
    break block1;
   }
   HEAP16[$2 + 2 >> 1] = HEAPU16[HEAP32[$2 + 4 >> 2] >> 1];
   $0 = 1;
   $1 = HEAP32[$2 + 8 >> 2];
   if (HEAPU16[$2 + 2 >> 1] != (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
    $0 = HEAP32[$2 + 8 >> 2];
    $0 = HEAPU16[$2 + 2 >> 1] == (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8);
   }
   HEAP8[$2 + 15 | 0] = $0;
  }
  return HEAP8[$2 + 15 | 0] & 1;
 }
 
 function jstPinOutputAtTime($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 48 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 32 >> 2] = $0;
  HEAP32[$6 + 36 >> 2] = $1;
  HEAP32[$6 + 28 >> 2] = $2;
  HEAP32[$6 + 24 >> 2] = $3;
  HEAP32[$6 + 20 >> 2] = $4;
  HEAP8[$6 + 19 | 0] = $5;
  HEAP32[$6 + 12 >> 2] = utilTimerGetUnusedIndex(1);
  block : {
   if (HEAP32[$6 + 12 >> 2] < 0) {
    HEAP8[$6 + 47 | 0] = 0;
    break block;
   }
   HEAP32[$6 + 8 >> 2] = Math_imul(HEAP32[$6 + 12 >> 2], 25) + 416192;
   HEAP8[HEAP32[$6 + 8 >> 2] + 24 | 0] = 2;
   $0 = HEAP32[$6 + 8 >> 2];
   $1 = HEAP32[$6 + 32 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
   $0 = HEAP32[$6 + 8 >> 2];
   HEAP8[$0 + 4 | 0] = 0;
   HEAP8[$0 + 5 | 0] = 0;
   HEAP8[$0 + 6 | 0] = 0;
   HEAP8[$0 + 7 | 0] = 0;
   HEAP32[$6 + 4 >> 2] = 0;
   while (1) {
    if (HEAP32[$6 + 4 >> 2] < 8) {
     $1 = HEAP32[$6 + 4 >> 2] + (HEAP32[$6 + 8 >> 2] + 8 | 0) | 0;
     if (HEAP32[$6 + 4 >> 2] < HEAP32[$6 + 20 >> 2]) {
      $0 = HEAPU8[HEAP32[$6 + 24 >> 2] + HEAP32[$6 + 4 >> 2] | 0]
     } else {
      $0 = 255
     }
     HEAP8[$1 | 0] = $0;
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP8[HEAP32[$6 + 8 >> 2] + 16 | 0] = HEAPU8[$6 + 19 | 0];
   utilTimerInsertTask(HEAP32[$6 + 12 >> 2] & 255, HEAP32[$6 + 28 >> 2], 0);
   HEAP8[$6 + 47 | 0] = 1;
  }
  __stack_pointer = $6 + 48 | 0;
  return HEAP8[$6 + 47 | 0] & 1;
 }
 
 function jstStartSignal($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0;
  $9 = __stack_pointer - 48 | 0;
  __stack_pointer = $9;
  HEAP32[$9 + 32 >> 2] = $0;
  HEAP32[$9 + 36 >> 2] = $1;
  HEAP32[$9 + 24 >> 2] = $2;
  $1 = $3;
  HEAP32[$9 + 28 >> 2] = $1;
  HEAP8[$9 + 23 | 0] = $4;
  HEAP8[$9 + 22 | 0] = $5;
  HEAP32[$9 + 16 >> 2] = $6;
  HEAP32[$9 + 12 >> 2] = $7;
  HEAP8[$9 + 11 | 0] = $8;
  block : {
   if (!(jshIsPinValid(HEAPU8[$9 + 23 | 0]) & 1)) {
    HEAP32[$9 + 44 >> 2] = -1;
    break block;
   }
   HEAP32[$9 + 4 >> 2] = utilTimerGetUnusedIndex(1);
   if (HEAP32[$9 + 4 >> 2] < 0) {
    HEAP32[$9 + 44 >> 2] = -1;
    break block;
   }
   HEAP32[$9 >> 2] = Math_imul(HEAP32[$9 + 4 >> 2], 25) + 416192;
   HEAP8[HEAP32[$9 >> 2] + 24 | 0] = HEAPU8[$9 + 11 | 0];
   $0 = HEAP32[$9 >> 2];
   $1 = HEAP32[$9 + 24 >> 2];
   HEAP8[$0 + 4 | 0] = $1;
   HEAP8[$0 + 5 | 0] = $1 >>> 8;
   HEAP8[$0 + 6 | 0] = $1 >>> 16;
   HEAP8[$0 + 7 | 0] = $1 >>> 24;
   $1 = HEAP32[$9 + 36 >> 2];
   $0 = $1;
   $1 = HEAP32[$9 + 24 >> 2];
   $2 = $1;
   $3 = $1 + HEAP32[$9 + 32 >> 2] | 0;
   $1 = HEAP32[$9 + 28 >> 2];
   $0 = $0 + $1 | 0;
   $0 = HEAP32[$9 >> 2];
   HEAP8[$0 | 0] = $3;
   HEAP8[$0 + 1 | 0] = $3 >>> 8;
   HEAP8[$0 + 2 | 0] = $3 >>> 16;
   HEAP8[$0 + 3 | 0] = $3 >>> 24;
   block2 : {
    if (!(HEAPU8[$9 + 11 | 0] != 4 & HEAPU8[$9 + 11 | 0] != 6)) {
     HEAP8[HEAP32[$9 >> 2] + 22 | 0] = HEAPU8[$9 + 23 | 0];
     HEAP8[HEAP32[$9 >> 2] + 23 | 0] = HEAPU8[$9 + 22 | 0];
     break block2;
    }
    block4 : {
     if (!(HEAPU8[$9 + 11 | 0] != 5 & HEAPU8[$9 + 11 | 0] != 7)) {
      if (!HEAPU8[(Math_imul(HEAPU8[$9 + 23 | 0], 3) + 183520 | 0) + 2 | 0]) {
       HEAP32[$9 + 44 >> 2] = -1;
       break block;
      }
      HEAP8[HEAP32[$9 >> 2] + 22 | 0] = HEAPU8[$9 + 23 | 0];
      break block4;
     }
     HEAP32[$9 + 44 >> 2] = -1;
     break block;
    }
   }
   $0 = jsvGetRef(HEAP32[$9 + 16 >> 2]);
   $1 = HEAP32[$9 >> 2];
   HEAP8[$1 + 12 | 0] = $0;
   HEAP8[$1 + 13 | 0] = $0 >>> 8;
   block5 : {
    if (HEAP32[$9 + 12 >> 2]) {
     $0 = jsvGetRef(HEAP32[$9 + 12 >> 2]);
     $1 = HEAP32[$9 >> 2];
     HEAP8[$1 + 14 | 0] = $0;
     HEAP8[$1 + 15 | 0] = $0 >>> 8;
     break block5;
    }
    $0 = HEAP32[$9 >> 2];
    HEAP8[$0 + 14 | 0] = 0;
    HEAP8[$0 + 15 | 0] = 0;
   }
   jstUtilTimerSetupBuffer(HEAP32[$9 >> 2]);
   utilTimerInsertTask(HEAP32[$9 + 4 >> 2] & 255, 0, 0);
   HEAP32[$9 + 44 >> 2] = HEAP32[$9 + 4 >> 2];
  }
  __stack_pointer = $9 + 48 | 0;
  return HEAP32[$9 + 44 >> 2];
 }
 
 function jstStopBufferTimerTask($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP16[$1 + 10 >> 1] = jsvGetRef(HEAP32[$1 + 12 >> 2]);
  $0 = utilTimerRemoveTask(utilTimerFindTask(583, $1 + 10 | 0));
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jstReset() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  jshUtilTimerDisable();
  HEAP8[416163] = 0;
  HEAP8[416161] = 0;
  HEAP8[416162] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$0 + 12 >> 2] < 16) {
    if (HEAPU8[(Math_imul(HEAP32[$0 + 12 >> 2], 25) + 416192 | 0) + 24 | 0]) {
     jstOnTaskFinished(HEAP32[$0 + 12 >> 2])
    }
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[104152] = 0;
  HEAP32[104044] = 0;
  HEAP32[104042] = jshGetSystemTime();
  HEAP32[104043] = i64toi32_i32$HIGH_BITS;
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jstOnTaskFinished($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if ((HEAPU8[(Math_imul(HEAP32[$1 + 12 >> 2], 25) + 416192 | 0) + 24 | 0] & -17) == 3) {
   HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 21221);
   if (HEAP32[$1 + 8 >> 2]) {
    jsvRemoveArrayItem(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
    jsvUnLock(HEAP32[$1 + 8 >> 2]);
   }
  }
  HEAP8[(Math_imul(HEAP32[$1 + 12 >> 2], 25) + 416192 | 0) + 24 | 0] = 0;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jstSystemTimeChanged($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 12 >> 2] = $1;
 }
 
 function jstOnCustomEvent($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 31 | 0] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP16[$3 + 18 >> 1] = HEAPU16[HEAP32[$3 + 24 >> 2] >> 1];
  if ((HEAPU16[$3 + 18 >> 1] & 255) == 1) {
   HEAP32[$3 + 12 >> 2] = HEAPU16[$3 + 18 >> 1] >>> 8;
   if (HEAPU8[(Math_imul(HEAP32[$3 + 12 >> 2], 25) + 416192 | 0) + 24 | 0] & 16) {
    jstOnTaskFinished(HEAP32[$3 + 12 >> 2])
   }
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jsi2cPopulateI2CInfo($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  jshI2CInitInfo(HEAP32[$2 + 56 >> 2]);
  HEAP32[$2 + 16 >> 2] = 15853;
  HEAP16[$2 + 20 >> 1] = 13;
  HEAP16[($2 + 16 | 0) + 6 >> 1] = 0;
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2] + 4;
  HEAP32[$2 + 28 >> 2] = 20654;
  HEAP16[$2 + 32 >> 1] = 13;
  HEAP16[($2 + 16 | 0) + 18 >> 1] = 0;
  HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 56 >> 2] + 5;
  HEAP32[$2 + 40 >> 2] = 17571;
  HEAP16[$2 + 44 >> 1] = 10;
  HEAP16[($2 + 16 | 0) + 30 >> 1] = 0;
  HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 56 >> 2];
  block : {
   if (jsvReadConfigObject(HEAP32[$2 + 52 >> 2], $2 + 16 | 0, 3) & 1) {
    HEAP8[$2 + 15 | 0] = 1;
    $0 = HEAP32[$2 + 56 >> 2];
    if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) < 100) {
     jsExceptionHere(1, 17559, 0);
     HEAP8[$2 + 15 | 0] = 0;
    }
    HEAP8[$2 + 63 | 0] = HEAP8[$2 + 15 | 0] & 1;
    break block;
   }
   HEAP8[$2 + 63 | 0] = 0;
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP8[$2 + 63 | 0] & 1;
 }
 
 function jsi2cWrite($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 48 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 40 >> 2] = $0;
  HEAP8[$5 + 39 | 0] = $1;
  HEAP32[$5 + 32 >> 2] = $2;
  HEAP32[$5 + 28 >> 2] = $3;
  HEAP8[$5 + 27 | 0] = $4;
  block1 : {
   if (!(HEAPU8[HEAP32[$5 + 40 >> 2] + 4 | 0] != 255 & HEAPU8[HEAP32[$5 + 40 >> 2] + 5 | 0] != 255)) {
    HEAP8[$5 + 47 | 0] = 0;
    break block1;
   }
   i2c_initstruct($5 + 12 | 0, HEAP32[$5 + 40 >> 2]);
   i2c_start($5 + 12 | 0);
   if (!(i2c_wr($5 + 12 | 0, HEAPU8[$5 + 39 | 0] << 1) & 1)) {
    HEAP8[$5 + 47 | 0] = 0;
    break block1;
   }
   HEAP32[$5 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 32 >> 2]) {
     i2c_wr($5 + 12 | 0, HEAPU8[HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 8 >> 2] | 0]);
     HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP8[$5 + 27 | 0] & 1) {
    i2c_stop($5 + 12 | 0)
   }
   HEAP8[HEAP32[$5 + 40 >> 2] + 6 | 0] = HEAP8[$5 + 14 | 0] & 1;
   HEAP8[$5 + 47 | 0] = 1;
  }
  __stack_pointer = $5 + 48 | 0;
  return HEAP8[$5 + 47 | 0] & 1;
 }
 
 function i2c_initstruct($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP8[HEAP32[$2 + 12 >> 2] + 1 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + 5 | 0];
  HEAP8[HEAP32[$2 + 12 >> 2]] = HEAPU8[HEAP32[$2 + 8 >> 2] + 4 | 0];
  HEAP8[HEAP32[$2 + 12 >> 2] + 2 | 0] = HEAP8[HEAP32[$2 + 8 >> 2] + 6 | 0] & 1;
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = 25e4 / (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
  HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = HEAP8[HEAP32[$2 + 8 >> 2] + 7 | 0] & 1 ? 1e5 : 0;
 }
 
 function i2c_start($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] & 1) {
   i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
   dly(HEAP32[$1 + 12 >> 2]);
   i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
   HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
   while (1) {
    $0 = 0;
    if (!(jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1)) {
     $0 = HEAP32[$1 + 8 >> 2] != 0
    }
    if ($0) {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] - 1;
     continue;
    }
    break;
   };
   if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
    err(24527)
   }
   dly(HEAP32[$1 + 12 >> 2]);
  }
  block1 : {
   if (!HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]) {
    break block1
   }
   if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1) {
    break block1
   }
   err(24543);
  }
  i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
  dly(HEAP32[$1 + 12 >> 2]);
  i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2]]);
  dly(HEAP32[$1 + 12 >> 2]);
  HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] = 1;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function i2c_wr($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 4 >> 2] < 8) {
    i2c_wr_bit(HEAP32[$2 + 12 >> 2], (HEAP32[$2 + 8 >> 2] & 128) != 0);
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] << 1;
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  i2c_rd_bit(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return 1;
 }
 
 function i2c_stop($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
  dly(HEAP32[$1 + 12 >> 2]);
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
  HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
  while (1) {
   $0 = 0;
   if (!(jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1)) {
    $0 = HEAP32[$1 + 8 >> 2] != 0
   }
   if ($0) {
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] - 1;
    continue;
   }
   break;
  };
  if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
   err(24711)
  }
  dly(HEAP32[$1 + 12 >> 2]);
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
  dly(HEAP32[$1 + 12 >> 2]);
  block1 : {
   if (!HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]) {
    break block1
   }
   if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1) {
    break block1
   }
   err(24726);
  }
  dly(HEAP32[$1 + 12 >> 2]);
  HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] = 0;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function i2c_pin_wr1($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jshPinSetValue(HEAPU8[$1 + 15 | 0], 1);
  jshPinSetState(HEAPU8[$1 + 15 | 0], 1);
  jshPinSetState(HEAPU8[$1 + 15 | 0], 5);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function dly($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
   jshDelayMicroseconds(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2])
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function err($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
  jsExceptionHere(1, 7663, $1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function i2c_pin_wr0($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jshPinSetValue(HEAPU8[$1 + 15 | 0], 0);
  jshPinSetState(HEAPU8[$1 + 15 | 0], 1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function i2c_wr_bit($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  block : {
   if (HEAP8[$2 + 11 | 0] & 1) {
    i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
    break block;
   }
   i2c_pin_wr0(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
  }
  dly(HEAP32[$2 + 12 >> 2]);
  i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2]]);
  dly(HEAP32[$2 + 12 >> 2]);
  dly(HEAP32[$2 + 12 >> 2]);
  HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2];
  while (1) {
   $0 = 0;
   if (!(jshPinGetValue(HEAPU8[HEAP32[$2 + 12 >> 2]]) & 1)) {
    $0 = HEAP32[$2 + 4 >> 2] != 0
   }
   if ($0) {
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] - 1;
    continue;
   }
   break;
  };
  if (!(HEAP32[$2 + 4 >> 2] | !HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2])) {
   err(24698)
  }
  i2c_pin_wr0(HEAPU8[HEAP32[$2 + 12 >> 2]]);
  i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
  dly(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function i2c_rd_bit($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
  dly(HEAP32[$1 + 12 >> 2]);
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
  dly(HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
  while (1) {
   $0 = 0;
   if (!(jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1)) {
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$1 + 8 >> 2] = $0 - 1;
    $0 = ($0 | 0) != 0;
   }
   if ($0) {
    continue
   }
   break;
  };
  if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
   err(24852)
  }
  dly(HEAP32[$1 + 12 >> 2]);
  HEAP8[$1 + 7 | 0] = jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1;
  i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2]]);
  dly(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 7 | 0] & 1;
 }
 
 function jsi2cRead($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 48 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 40 >> 2] = $0;
  HEAP8[$5 + 39 | 0] = $1;
  HEAP32[$5 + 32 >> 2] = $2;
  HEAP32[$5 + 28 >> 2] = $3;
  HEAP8[$5 + 27 | 0] = $4;
  block1 : {
   if (!(HEAPU8[HEAP32[$5 + 40 >> 2] + 4 | 0] != 255 & HEAPU8[HEAP32[$5 + 40 >> 2] + 5 | 0] != 255)) {
    HEAP8[$5 + 47 | 0] = 0;
    break block1;
   }
   i2c_initstruct($5 + 12 | 0, HEAP32[$5 + 40 >> 2]);
   i2c_start($5 + 12 | 0);
   if (!(i2c_wr($5 + 12 | 0, HEAPU8[$5 + 39 | 0] << 1 | 1) & 1)) {
    HEAP8[$5 + 47 | 0] = 0;
    break block1;
   }
   HEAP32[$5 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 32 >> 2]) {
     $0 = i2c_rd($5 + 12 | 0, HEAP32[$5 + 8 >> 2] == (HEAP32[$5 + 32 >> 2] - 1 | 0));
     HEAP8[HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 8 >> 2] | 0] = $0;
     HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAP8[$5 + 27 | 0] & 1) {
    i2c_stop($5 + 12 | 0)
   }
   HEAP8[HEAP32[$5 + 40 >> 2] + 6 | 0] = HEAP8[$5 + 14 | 0] & 1;
   HEAP8[$5 + 47 | 0] = 1;
  }
  __stack_pointer = $5 + 48 | 0;
  return HEAP8[$5 + 47 | 0] & 1;
 }
 
 function i2c_rd($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 4 >> 2] < 8) {
    HEAP32[$2 >> 2] = HEAP32[$2 >> 2] << 1 | i2c_rd_bit(HEAP32[$2 + 12 >> 2]) & 1;
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  i2c_wr_bit(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0] & 1);
  i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 >> 2];
 }
 
 function jsserialHardwareFunc($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2]];
  jshTransmit(HEAPU8[$2 + 7 | 0], HEAP32[$2 + 12 >> 2] & 255);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsserialSoftwareFunc($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 76 >> 2] = $0;
  HEAP32[$2 + 72 >> 2] = $1;
  HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 72 >> 2];
  if (jshIsPinValid(HEAPU8[HEAP32[$2 + 68 >> 2] + 5 | 0]) & 1) {
   HEAP32[$2 + 64 >> 2] = (1 << HEAPU8[HEAP32[$2 + 68 >> 2] + 10 | 0]) - 1;
   HEAP32[$2 + 60 >> 2] = HEAPU8[HEAP32[$2 + 68 >> 2] + 10 | 0];
   HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 76 >> 2] & (1 << HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0]) - 1 | HEAP32[$2 + 64 >> 2] << HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0];
   HEAP32[$2 + 60 >> 2] = HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0] + HEAP32[$2 + 60 >> 2];
   HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 64 >> 2] << 1;
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] + 1;
   HEAP32[$2 + 56 >> 2] = jstGetUtilTimerOffset();
   $0 = HEAP32[$2 + 68 >> 2];
   $3 = jshGetTimeFromMilliseconds(1.0e3 / +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)));
   HEAP32[$2 + 48 >> 2] = $3;
   $0 = i64toi32_i32$HIGH_BITS;
   HEAP32[$2 + 52 >> 2] = $0;
   block : {
    if (jstGetLastPinTimerTask(HEAPU8[HEAP32[$2 + 68 >> 2] + 5 | 0], $2 + 15 | 0) & 1) {
     $0 = HEAPU8[$2 + 15 | 0] | HEAPU8[$2 + 16 | 0] << 8 | (HEAPU8[$2 + 17 | 0] << 16 | HEAPU8[$2 + 18 | 0] << 24);
     $3 = $0 >> 31;
     $5 = $3;
     $3 = HEAP32[$2 + 48 >> 2];
     $4 = $3;
     $1 = $0 + $3 | 0;
     $0 = HEAP32[$2 + 52 >> 2];
     $3 = $0;
     $0 = $5;
     $0 = $3 + $0 | 0;
     HEAP32[$2 + 40 >> 2] = $1;
     $0 = $1 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
     HEAP32[$2 + 44 >> 2] = $0;
     break block;
    }
    $0 = jshGetTimeFromMilliseconds(1.0);
    HEAP32[$2 + 40 >> 2] = $0;
    $1 = i64toi32_i32$HIGH_BITS;
    HEAP32[$2 + 44 >> 2] = $1;
   }
   HEAP32[$2 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 60 >> 2]) {
     HEAP8[$2 + 7 | 0] = HEAP32[$2 + 64 >> 2] & 1;
     HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 64 >> 2] >> 1;
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] - 1;
     $1 = HEAP32[$2 + 40 >> 2];
     $0 = HEAP32[$2 + 44 >> 2];
     jstPinOutputAtTime($1, $0, $2 + 56 | 0, HEAP32[$2 + 68 >> 2] + 5 | 0, 1, HEAP8[$2 + 7 | 0] & 1);
     $1 = HEAP32[$2 + 52 >> 2];
     $5 = $1;
     $0 = HEAP32[$2 + 48 >> 2];
     $1 = HEAP32[$2 + 40 >> 2];
     $4 = $1;
     $3 = $0 + $1 | 0;
     $0 = HEAP32[$2 + 44 >> 2];
     $1 = $0;
     $0 = $5;
     $1 = $1 + $0 | 0;
     HEAP32[$2 + 40 >> 2] = $3;
     $1 = $3 >>> 0 < $4 >>> 0 ? $1 + 1 | 0 : $1;
     HEAP32[$2 + 44 >> 2] = $1;
     continue;
    }
    break;
   };
   $1 = HEAP32[$2 + 40 >> 2];
   $5 = $1;
   $0 = HEAP32[$2 + 44 >> 2];
   $3 = $0;
   $0 = HEAP32[$2 + 48 >> 2];
   $6 = $0;
   $1 = HEAP32[$2 + 52 >> 2];
   $4 = $1;
   $1 = HEAP32[$2 + 8 >> 2];
   $0 = $1 >> 31;
   $7 = $0;
   $0 = $4;
   $4 = $1;
   $1 = $7;
   $1 = __wasm_i64_mul($6, $0, $4, $1);
   $4 = $1;
   $0 = i64toi32_i32$HIGH_BITS;
   $1 = $0;
   $0 = $3;
   $3 = $0 + $1 | 0;
   $0 = $5;
   $1 = $4 + $0 | 0;
   $3 = $1 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
   HEAP32[$2 + 40 >> 2] = $1;
   HEAP32[$2 + 44 >> 2] = $3;
   $3 = HEAP32[$2 + 40 >> 2];
   $0 = HEAP32[$2 + 44 >> 2];
   jstPinOutputAtTime($3, $0, $2 + 56 | 0, HEAP32[$2 + 68 >> 2] + 5 | 0, 1, 1);
  }
  __stack_pointer = $2 + 80 | 0;
 }
 
 function jsserialPopulateUSARTInfo($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 192 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 188 >> 2] = $0;
  HEAP32[$3 + 184 >> 2] = $1;
  HEAP32[$3 + 180 >> 2] = $2;
  jshUSARTInitInfo(HEAP32[$3 + 188 >> 2]);
  HEAP32[$3 + 176 >> 2] = 0;
  HEAP32[$3 + 172 >> 2] = 0;
  HEAP32[$3 + 168 >> 2] = HEAPU8[HEAP32[$3 + 188 >> 2] + 8 | 0];
  HEAP32[$3 + 164 >> 2] = HEAPU8[HEAP32[$3 + 188 >> 2] + 10 | 0];
  HEAP32[$3 + 48 >> 2] = 3810;
  HEAP16[$3 + 52 >> 1] = 13;
  HEAP16[($3 + 48 | 0) + 6 >> 1] = 0;
  HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 188 >> 2] + 4;
  HEAP32[$3 + 60 >> 2] = 3807;
  HEAP16[$3 + 64 >> 1] = 13;
  HEAP16[($3 + 48 | 0) + 18 >> 1] = 0;
  HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 188 >> 2] + 5;
  HEAP32[$3 + 72 >> 2] = 15995;
  HEAP16[$3 + 76 >> 1] = 13;
  HEAP16[($3 + 48 | 0) + 30 >> 1] = 0;
  HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 188 >> 2] + 6;
  HEAP32[$3 + 84 >> 2] = 6917;
  HEAP16[$3 + 88 >> 1] = 13;
  HEAP16[($3 + 48 | 0) + 42 >> 1] = 0;
  HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 188 >> 2] + 7;
  HEAP32[$3 + 96 >> 2] = 17195;
  HEAP16[$3 + 100 >> 1] = 10;
  HEAP16[($3 + 48 | 0) + 54 >> 1] = 0;
  HEAP32[$3 + 104 >> 2] = $3 + 168;
  HEAP32[$3 + 108 >> 2] = 6885;
  HEAP16[$3 + 112 >> 1] = 10;
  HEAP16[($3 + 48 | 0) + 66 >> 1] = 0;
  HEAP32[$3 + 116 >> 2] = $3 + 164;
  HEAP32[$3 + 120 >> 2] = 3519;
  HEAP16[$3 + 124 >> 1] = 5;
  HEAP16[($3 + 48 | 0) + 78 >> 1] = 0;
  HEAP32[$3 + 128 >> 2] = $3 + 176;
  HEAP32[$3 + 132 >> 2] = 3988;
  HEAP16[$3 + 136 >> 1] = 5;
  HEAP16[($3 + 48 | 0) + 90 >> 1] = 0;
  HEAP32[$3 + 140 >> 2] = $3 + 172;
  HEAP32[$3 + 144 >> 2] = 6978;
  HEAP16[$3 + 148 >> 1] = 12;
  HEAP16[($3 + 48 | 0) + 102 >> 1] = 0;
  HEAP32[$3 + 152 >> 2] = HEAP32[$3 + 188 >> 2] + 12;
  if (!(jsvIsUndefined(HEAP32[$3 + 184 >> 2]) & 1)) {
   HEAP32[$3 + 44 >> 2] = jsvGetInteger(HEAP32[$3 + 184 >> 2]);
   block1 : {
    if (!(HEAP32[$3 + 44 >> 2] <= 1e7 & HEAP32[$3 + 44 >> 2] > 100)) {
     HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 44 >> 2];
     jsExceptionHere(1, 19850, $3 + 32 | 0);
     break block1;
    }
    $0 = HEAP32[$3 + 188 >> 2];
    $1 = HEAP32[$3 + 44 >> 2];
    HEAP8[$0 | 0] = $1;
    HEAP8[$0 + 1 | 0] = $1 >>> 8;
    HEAP8[$0 + 2 | 0] = $1 >>> 16;
    HEAP8[$0 + 3 | 0] = $1 >>> 24;
   }
  }
  HEAP8[$3 + 43 | 0] = 1;
  if (jsvReadConfigObject(HEAP32[$3 + 180 >> 2], $3 + 48 | 0, 9) & 1) {
   HEAP8[HEAP32[$3 + 188 >> 2] + 8 | 0] = HEAP32[$3 + 168 >> 2];
   HEAP8[HEAP32[$3 + 188 >> 2] + 10 | 0] = HEAP32[$3 + 164 >> 2];
   HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = 0;
   block3 : {
    if (jsvIsString(HEAP32[$3 + 176 >> 2]) & 1) {
     block2 : {
      if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 15123) & 1)) {
       if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 19270) & 1)) {
        break block2
       }
      }
      HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = 1;
      break block3;
     }
     block4 : {
      if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 18347) & 1)) {
       if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 15557) & 1)) {
        break block4
       }
      }
      HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = 2;
     }
     break block3;
    }
    if (jsvIsInt(HEAP32[$3 + 176 >> 2]) & 1) {
     $0 = jsvGetInteger(HEAP32[$3 + 176 >> 2]);
     HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = $0;
    }
   }
   if (HEAPU8[HEAP32[$3 + 188 >> 2] + 9 | 0] > 2) {
    HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 188 >> 2] + 9 | 0];
    jsExceptionHere(1, 19684, $3 + 16 | 0);
    HEAP8[$3 + 43 | 0] = 0;
   }
   if (HEAP8[$3 + 43 | 0] & 1) {
    block7 : {
     block6 : {
      block5 : {
       if (jsvIsUndefined(HEAP32[$3 + 172 >> 2]) & 1) {
        break block5
       }
       if (jsvIsNull(HEAP32[$3 + 172 >> 2]) & 1) {
        break block5
       }
       if (!(jsvIsStringEqual(HEAP32[$3 + 172 >> 2], 17797) & 1)) {
        break block6
       }
      }
      HEAP8[HEAP32[$3 + 188 >> 2] + 11 | 0] = 0;
      break block7;
     }
     block8 : {
      if (jsvIsStringEqual(HEAP32[$3 + 172 >> 2], 15154) & 1) {
       HEAP8[HEAP32[$3 + 188 >> 2] + 11 | 0] = 1;
       break block8;
      }
      HEAP32[$3 >> 2] = HEAP32[$3 + 172 >> 2];
      jsExceptionHere(1, 14837, $3);
      HEAP8[$3 + 43 | 0] = 0;
     }
    }
   }
  }
  jsvUnLock2(HEAP32[$3 + 176 >> 2], HEAP32[$3 + 172 >> 2]);
  __stack_pointer = $3 + 192 | 0;
  return HEAP8[$3 + 43 | 0] & 1;
 }
 
 function jsserialGetSendFunction($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 40 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  HEAP32[$3 + 32 >> 2] = $2;
  HEAP8[$3 + 31 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 40 >> 2]);
  block2 : {
   if (!(HEAPU8[$3 + 31 | 0] < 17 | HEAPU8[$3 + 31 | 0] > 22)) {
    block1 : {
     if (HEAPU8[$3 + 31 | 0] < 22 | HEAPU8[$3 + 31 | 0] > 22) {
      break block1
     }
     if (jshIsDeviceInitialised(HEAPU8[$3 + 31 | 0]) & 1) {
      break block1
     }
     jshUSARTInitInfo($3 + 18 | 0);
     jshUSARTSetup(HEAPU8[$3 + 31 | 0], $3 + 18 | 0);
    }
    HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 584;
    HEAP8[HEAP32[$3 + 32 >> 2]] = HEAPU8[$3 + 31 | 0];
    HEAP8[$3 + 47 | 0] = 1;
    break block2;
   }
   if (!HEAPU8[$3 + 31 | 0]) {
    HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 17579);
    HEAP32[$3 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 7138);
    jsserialPopulateUSARTInfo($3 + 18 | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 585;
    $0 = HEAPU8[$3 + 22 | 0] | HEAPU8[$3 + 23 | 0] << 8 | (HEAPU8[$3 + 24 | 0] << 16 | HEAPU8[$3 + 25 | 0] << 24);
    $1 = HEAPU8[$3 + 18 | 0] | HEAPU8[$3 + 19 | 0] << 8 | (HEAPU8[$3 + 20 | 0] << 16 | HEAPU8[$3 + 21 | 0] << 24);
    $4 = $1;
    $2 = HEAP32[$3 + 32 >> 2];
    $1 = $2;
    HEAP8[$1 | 0] = $4;
    HEAP8[$1 + 1 | 0] = $4 >>> 8;
    HEAP8[$1 + 2 | 0] = $4 >>> 16;
    HEAP8[$1 + 3 | 0] = $4 >>> 24;
    HEAP8[$1 + 4 | 0] = $0;
    HEAP8[$1 + 5 | 0] = $0 >>> 8;
    HEAP8[$1 + 6 | 0] = $0 >>> 16;
    HEAP8[$1 + 7 | 0] = $0 >>> 24;
    $1 = HEAPU8[$3 + 27 | 0] | HEAPU8[$3 + 28 | 0] << 8 | (HEAPU8[$3 + 29 | 0] << 16 | HEAPU8[$3 + 30 | 0] << 24);
    $0 = HEAPU8[$3 + 23 | 0] | HEAPU8[$3 + 24 | 0] << 8 | (HEAPU8[$3 + 25 | 0] << 16 | HEAPU8[$3 + 26 | 0] << 24);
    $4 = $0;
    $0 = $2;
    HEAP8[$0 + 5 | 0] = $4;
    HEAP8[$0 + 6 | 0] = $4 >>> 8;
    HEAP8[$0 + 7 | 0] = $4 >>> 16;
    HEAP8[$0 + 8 | 0] = $4 >>> 24;
    HEAP8[$0 + 9 | 0] = $1;
    HEAP8[$0 + 10 | 0] = $1 >>> 8;
    HEAP8[$0 + 11 | 0] = $1 >>> 16;
    HEAP8[$0 + 12 | 0] = $1 >>> 24;
    HEAP8[$3 + 47 | 0] = 1;
    break block2;
   }
   HEAP8[$3 + 47 | 0] = 0;
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP8[$3 + 47 | 0] & 1;
 }
 
 function jsserialGetSerialList($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = jsvObjectGetChild(HEAP32[103308], 15929, HEAP8[$1 + 15 | 0] & 1 ? 3 : 0);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsserialEventCallbackInit($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(96);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    jsExceptionHere(1, 20859, 0);
    HEAP8[$2 + 31 | 0] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 20641, HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 12 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 16 >> 2]);
   HEAP8[HEAP32[$2 + 12 >> 2] + 64 | 0] = 0;
   $0 = jshGetSystemTime();
   $1 = $0;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 72 >> 2] = $1;
   HEAP32[$0 + 76 >> 2] = i64toi32_i32$HIGH_BITS;
   $0 = HEAP32[$2 + 20 >> 2];
   HEAP32[HEAP32[$2 + 12 >> 2] + 80 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   HEAP32[HEAP32[$2 + 12 >> 2] + 84 >> 2] = 0;
   HEAP8[HEAP32[$2 + 12 >> 2] + 88 | 0] = 0;
   HEAP8[HEAP32[$2 + 12 >> 2] + 89 | 0] = !!HEAPU8[HEAP32[$2 + 20 >> 2] + 9 | 0] + (HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0] + HEAPU8[HEAP32[$2 + 20 >> 2] + 10 | 0] | 0);
   HEAP8[$2 + 11 | 0] = jshPinWatch(HEAPU8[HEAP32[$2 + 20 >> 2] + 4 | 0], 1, 1);
   block1 : {
    if (HEAPU8[$2 + 11 | 0]) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 16164, jsvNewFromInteger(HEAPU8[$2 + 11 | 0]));
     HEAP32[$2 + 4 >> 2] = jsserialGetSerialList(1);
     if (!HEAP32[$2 + 4 >> 2]) {
      HEAP8[$2 + 31 | 0] = 0;
      break block;
     }
     jsvSetArrayItem(HEAP32[$2 + 4 >> 2], HEAPU8[$2 + 11 | 0], HEAP32[$2 + 24 >> 2]);
     jsvUnLock(HEAP32[$2 + 4 >> 2]);
     jshSetEventCallback(HEAPU8[$2 + 11 | 0], 586);
     break block1;
    }
    HEAP32[$2 >> 2] = HEAPU8[HEAP32[$2 + 20 >> 2] + 4 | 0];
    jsExceptionHere(1, 20897, $2);
    HEAP8[$2 + 31 | 0] = 0;
    break block;
   }
   HEAP8[$2 + 31 | 0] = 1;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP8[$2 + 31 | 0] & 1;
 }
 
 function jsserialEventCallback($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0.0, $5 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 47 | 0] = $0;
  HEAP8[$2 + 46 | 0] = $1;
  HEAP32[$2 + 40 >> 2] = jsserialGetSerialList(0);
  block : {
   if (!HEAP32[$2 + 40 >> 2]) {
    break block
   }
   HEAP32[$2 + 36 >> 2] = jsvGetArrayItem(HEAP32[$2 + 40 >> 2], HEAPU8[$2 + 46 | 0]);
   if (!HEAP32[$2 + 36 >> 2]) {
    break block
   }
   HEAP32[$2 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 36 >> 2], 20641);
   HEAP32[$2 + 28 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 32 >> 2]);
   if (!HEAP32[$2 + 28 >> 2]) {
    break block
   }
   HEAP32[$2 + 16 >> 2] = jshGetSystemTime();
   HEAP32[$2 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
   $1 = HEAP32[$2 + 20 >> 2];
   $3 = HEAP32[$2 + 28 >> 2];
   $0 = HEAP32[$3 + 72 >> 2];
   $5 = HEAP32[$3 + 76 >> 2];
   $3 = HEAP32[$2 + 16 >> 2];
   HEAP32[$2 + 8 >> 2] = $3 - $0;
   $0 = ($3 >>> 0 < $0 >>> 0) + $5 | 0;
   $0 = $1 - $0 | 0;
   HEAP32[$2 + 12 >> 2] = $0;
   $3 = HEAP32[$2 + 20 >> 2];
   $0 = HEAP32[$2 + 16 >> 2];
   $1 = $0;
   $0 = HEAP32[$2 + 28 >> 2];
   HEAP32[$0 + 72 >> 2] = $1;
   HEAP32[$0 + 76 >> 2] = $3;
   HEAP8[$2 + 7 | 0] = (HEAPU8[$2 + 47 | 0] ^ -1) & 1;
   $3 = HEAP32[$2 + 8 >> 2];
   $0 = HEAP32[$2 + 12 >> 2];
   $4 = jshGetMillisecondsFromTime($3, $0) * +HEAP32[HEAP32[$2 + 28 >> 2] + 80 >> 2] / 1.0e3 + .5;
   if (Math_abs($4) < 2147483647.0) {
    $0 = ~~$4
   } else {
    $0 = -2147483648
   }
   HEAP32[$2 >> 2] = $0;
   if (!(HEAPU8[HEAP32[$2 + 28 >> 2] + 88 | 0] | !(HEAP8[$2 + 7 | 0] & 1)) | HEAP32[$2 >> 2] > 12) {
    break block
   }
   if (HEAP8[$2 + 7 | 0] & 1) {
    $0 = HEAP32[$2 + 28 >> 2];
    HEAP32[$0 + 84 >> 2] = HEAP32[$0 + 84 >> 2] | (1 << HEAP32[$2 >> 2]) - 1 << HEAPU8[HEAP32[$2 + 28 >> 2] + 88 | 0];
   }
   $0 = HEAP32[$2 + 28 >> 2];
   HEAP8[$0 + 88 | 0] = HEAP32[$2 >> 2] + HEAPU8[$0 + 88 | 0];
   jsserialCheckForCharacter(HEAP32[$2 + 28 >> 2]);
  }
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jsserialCheckForCharacter($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAPU8[HEAP32[$1 + 12 >> 2] + 88 | 0] >= HEAPU8[HEAP32[$1 + 12 >> 2] + 89 | 0]) {
   HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 84 >> 2] >>> 1 & 255;
   if (HEAPU8[HEAP32[$1 + 12 >> 2] + 64 | 0] < 64) {
    $3 = HEAP32[$1 + 8 >> 2];
    $0 = HEAP32[$1 + 12 >> 2];
    $2 = HEAPU8[$0 + 64 | 0];
    HEAP8[$0 + 64 | 0] = $2 + 1;
    HEAP8[$0 + $2 | 0] = $3;
    jshHasEvents();
   }
   HEAP8[HEAP32[$1 + 12 >> 2] + 88 | 0] = 0;
   HEAP32[HEAP32[$1 + 12 >> 2] + 84 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsserialEventCallbackKill($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 28 >> 2], 16164);
  if (HEAP32[$2 + 20 >> 2]) {
   HEAP8[$2 + 19 | 0] = jsvGetIntegerAndUnLock(HEAP32[$2 + 20 >> 2]);
   jshPinWatch(HEAPU8[$2 + 19 | 0], 0, 0);
   HEAP32[$2 + 12 >> 2] = jsserialGetSerialList(0);
   if (HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 8 >> 2] = jsvGetArrayIndex(HEAP32[$2 + 12 >> 2], HEAPU8[$2 + 19 | 0]);
    if (HEAP32[$2 + 8 >> 2]) {
     jsvRemoveChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2])
    }
    if (!jsvGetChildren(HEAP32[$2 + 12 >> 2])) {
     jsvObjectRemoveChild(HEAP32[103308], 15929)
    }
    jsvUnLock2(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
   }
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jsserialEventCallbackIdle() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0;
  $0 = __stack_pointer - 48 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 46 | 0] = 0;
  HEAP32[$0 + 40 >> 2] = jsserialGetSerialList(0);
  block : {
   if (!HEAP32[$0 + 40 >> 2]) {
    HEAP8[$0 + 47 | 0] = 0;
    break block;
   }
   jsvObjectIteratorNew($0 + 36 | 0, HEAP32[$0 + 40 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1011($0 + 36 | 0) & 1) {
     HEAP32[$0 + 32 >> 2] = jsvObjectIteratorGetValue_1012($0 + 36 | 0);
     HEAP32[$0 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 32 >> 2], 20641);
     HEAP32[$0 + 24 >> 2] = jsvGetFlatStringPointer(HEAP32[$0 + 28 >> 2]);
     if (HEAP32[$0 + 24 >> 2]) {
      if (HEAPU8[HEAP32[$0 + 24 >> 2] + 88 | 0]) {
       HEAP32[$0 + 16 >> 2] = jshGetSystemTime();
       HEAP32[$0 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
       $5 = HEAP32[$0 + 20 >> 2];
       $2 = HEAP32[$0 + 24 >> 2];
       $3 = HEAP32[$2 + 72 >> 2];
       $1 = HEAP32[$2 + 76 >> 2];
       $2 = HEAP32[$0 + 16 >> 2];
       HEAP32[$0 + 8 >> 2] = $2 - $3;
       HEAP32[$0 + 12 >> 2] = $5 - (($2 >>> 0 < $3 >>> 0) + $1 | 0);
       $2 = HEAP32[$0 + 12 >> 2];
       $4 = jshGetMillisecondsFromTime(HEAP32[$0 + 8 >> 2], $2) * +HEAP32[HEAP32[$0 + 24 >> 2] + 80 >> 2] / 1.0e3 + .5;
       if (Math_abs($4) < 2147483647.0) {
        $1 = ~~$4
       } else {
        $1 = -2147483648
       }
       HEAP32[$0 + 4 >> 2] = $1;
       block1 : {
        if (HEAP32[$0 + 4 >> 2] > 10) {
         $1 = HEAP32[$0 + 24 >> 2];
         HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] | (1 << HEAP32[$0 + 4 >> 2]) - 1 << HEAPU8[HEAP32[$0 + 24 >> 2] + 88 | 0];
         $1 = HEAP32[$0 + 24 >> 2];
         HEAP8[$1 + 88 | 0] = HEAP32[$0 + 4 >> 2] + HEAPU8[$1 + 88 | 0];
         jsserialCheckForCharacter(HEAP32[$0 + 24 >> 2]);
         HEAP8[HEAP32[$0 + 24 >> 2] + 88 | 0] = 0;
         break block1;
        }
        HEAP8[$0 + 46 | 0] = 1;
       }
      }
      if (HEAPU8[HEAP32[$0 + 24 >> 2] + 64 | 0]) {
       HEAP32[$0 >> 2] = jsvNewStringOfLength(HEAPU8[HEAP32[$0 + 24 >> 2] + 64 | 0], HEAP32[$0 + 24 >> 2]);
       HEAP8[HEAP32[$0 + 24 >> 2] + 64 | 0] = 0;
       if (HEAP32[$0 >> 2]) {
        jswrap_stream_pushData(HEAP32[$0 + 32 >> 2], HEAP32[$0 >> 2], 1);
        jsvUnLock(HEAP32[$0 >> 2]);
       }
      }
     }
     jsvUnLock2(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 32 >> 2]);
     jsvObjectIteratorNext($0 + 36 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1013($0 + 36 | 0);
   jsvUnLock(HEAP32[$0 + 40 >> 2]);
   HEAP8[$0 + 47 | 0] = HEAP8[$0 + 46 | 0] & 1;
  }
  __stack_pointer = $0 + 48 | 0;
  return HEAP8[$0 + 47 | 0] & 1;
 }
 
 function jsvObjectIteratorHasValue_1011($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1012($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1013($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsspiHardwareFunc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP8[$4 + 15 | 0] = HEAPU8[HEAP32[$4 + 16 >> 2]];
  jshSPISetReceive(HEAPU8[$4 + 15 | 0], HEAP32[$4 + 24 >> 2] != 0);
  jshSPISendMany(HEAPU8[$4 + 15 | 0], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], 0);
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jsspiFastSoftwareFunc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2];
  HEAP32[$4 + 8 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 + 20 >> 2]) {
    HEAP32[$4 + 4 >> 2] = HEAPU8[HEAP32[$4 + 28 >> 2] + HEAP32[$4 + 8 >> 2] | 0];
    $0 = HEAP32[$4 + 12 >> 2];
    HEAP32[$4 >> 2] = (HEAPU8[$0 + 10 | 0] | HEAPU8[$0 + 11 | 0] << 8 | (HEAPU8[$0 + 12 | 0] << 16 | HEAPU8[$0 + 13 | 0] << 24)) - 1;
    while (1) {
     if (HEAP32[$4 >> 2] >= 0) {
      jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 7 | 0], HEAP32[$4 + 4 >> 2] >> HEAP32[$4 >> 2] & 1);
      jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 5 | 0], 1);
      jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 5 | 0], 0);
      HEAP32[$4 >> 2] = HEAP32[$4 >> 2] - 1;
      continue;
     }
     break;
    };
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jsspiSoftwareFunc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP32[$4 + 32 >> 2] = $3;
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 32 >> 2];
  HEAP8[$4 + 27 | 0] = HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1;
  HEAP8[$4 + 26 | 0] = (HEAPU8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 2) != 0;
  HEAP32[$4 + 20 >> 2] = HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1 ? -1 : 1;
  if (HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) {
   $0 = -1
  } else {
   $0 = HEAP32[$4 + 28 >> 2];
   $0 = HEAPU8[$0 + 10 | 0] | HEAPU8[$0 + 11 | 0] << 8 | (HEAPU8[$0 + 12 | 0] << 16 | HEAPU8[$0 + 13 | 0] << 24);
  }
  HEAP32[$4 + 16 >> 2] = $0;
  HEAP32[$4 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 36 >> 2]) {
    HEAP32[$4 + 8 >> 2] = HEAPU8[HEAP32[$4 + 44 >> 2] + HEAP32[$4 + 12 >> 2] | 0];
    HEAP32[$4 + 4 >> 2] = 0;
    block : {
     if (HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) {
      $0 = HEAP32[$4 + 28 >> 2];
      $0 = (HEAPU8[$0 + 10 | 0] | HEAPU8[$0 + 11 | 0] << 8 | (HEAPU8[$0 + 12 | 0] << 16 | HEAPU8[$0 + 13 | 0] << 24)) - 1 | 0;
      break block;
     }
     $0 = 0;
    }
    HEAP32[$4 >> 2] = $0;
    while (1) {
     if (HEAP32[$4 >> 2] != HEAP32[$4 + 16 >> 2]) {
      block1 : {
       if (!(HEAP8[$4 + 27 | 0] & 1)) {
        if (HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0] != 255) {
         jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0], HEAP32[$4 + 8 >> 2] >> HEAP32[$4 >> 2] & 1)
        }
        if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
         jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], (HEAPU8[$4 + 26 | 0] ^ -1) & 1)
        }
        if (HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0] != 255) {
         HEAP32[$4 + 4 >> 2] = (jshPinGetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0]) & 1) << HEAP32[$4 >> 2] | HEAP32[$4 + 4 >> 2]
        }
        if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
         jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], HEAP8[$4 + 26 | 0] & 1)
        }
        break block1;
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], (HEAPU8[$4 + 26 | 0] ^ -1) & 1)
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0], HEAP32[$4 + 8 >> 2] >> HEAP32[$4 >> 2] & 1)
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], HEAP8[$4 + 26 | 0] & 1)
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0] != 255) {
        HEAP32[$4 + 4 >> 2] = (jshPinGetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0]) & 1) << HEAP32[$4 >> 2] | HEAP32[$4 + 4 >> 2]
       }
      }
      HEAP32[$4 >> 2] = HEAP32[$4 + 20 >> 2] + HEAP32[$4 >> 2];
      continue;
     }
     break;
    };
    if (HEAP32[$4 + 40 >> 2]) {
     HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 12 >> 2] | 0] = HEAP32[$4 + 4 >> 2]
    }
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 48 | 0;
 }
 
 function jsspiPopulateSPIInfo($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 128 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 124 >> 2] = $0;
  HEAP32[$2 + 120 >> 2] = $1;
  jshSPIInitInfo(HEAP32[$2 + 124 >> 2]);
  HEAP32[$2 + 116 >> 2] = 0;
  HEAP32[$2 + 112 >> 2] = HEAPU8[HEAP32[$2 + 124 >> 2] + 8 | 0];
  HEAP32[$2 + 16 >> 2] = 15971;
  HEAP16[$2 + 20 >> 1] = 13;
  HEAP16[($2 + 16 | 0) + 6 >> 1] = 0;
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 124 >> 2] + 5;
  HEAP32[$2 + 28 >> 2] = 15104;
  HEAP16[$2 + 32 >> 1] = 13;
  HEAP16[($2 + 16 | 0) + 18 >> 1] = 0;
  HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 124 >> 2] + 6;
  HEAP32[$2 + 40 >> 2] = 16169;
  HEAP16[$2 + 44 >> 1] = 13;
  HEAP16[($2 + 16 | 0) + 30 >> 1] = 0;
  HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 124 >> 2] + 7;
  HEAP32[$2 + 52 >> 2] = 18353;
  HEAP16[$2 + 56 >> 1] = 10;
  HEAP16[($2 + 16 | 0) + 42 >> 1] = 0;
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 124 >> 2];
  HEAP32[$2 + 64 >> 2] = 18218;
  HEAP16[$2 + 68 >> 1] = 10;
  HEAP16[($2 + 16 | 0) + 54 >> 1] = 0;
  HEAP32[$2 + 72 >> 2] = $2 + 112;
  HEAP32[$2 + 76 >> 2] = 8300;
  HEAP16[$2 + 80 >> 1] = 5;
  HEAP16[($2 + 16 | 0) + 66 >> 1] = 0;
  HEAP32[$2 + 84 >> 2] = $2 + 116;
  HEAP32[$2 + 88 >> 2] = 6912;
  HEAP16[$2 + 92 >> 1] = 10;
  HEAP16[($2 + 16 | 0) + 78 >> 1] = 0;
  HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 124 >> 2] + 10;
  HEAP8[$2 + 15 | 0] = 1;
  if (jsvReadConfigObject(HEAP32[$2 + 120 >> 2], $2 + 16 | 0, 7) & 1) {
   HEAP8[HEAP32[$2 + 124 >> 2] + 8 | 0] = HEAP32[$2 + 112 >> 2] & 3;
   block1 : {
    block : {
     if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
      break block
     }
     if (!(jsvIsStringEqual(HEAP32[$2 + 116 >> 2], 20471) & 1)) {
      break block
     }
     HEAP8[HEAP32[$2 + 124 >> 2] + 9 | 0] = 1;
     break block1;
    }
    block3 : {
     block2 : {
      if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
       break block2
      }
      if (!(jsvIsStringEqual(HEAP32[$2 + 116 >> 2], 20475) & 1)) {
       break block2
      }
      HEAP8[HEAP32[$2 + 124 >> 2] + 9 | 0] = 0;
      break block3;
     }
     if (!(jsvIsUndefined(HEAP32[$2 + 116 >> 2]) & 1)) {
      jsExceptionHere(1, 27202, 0);
      HEAP8[$2 + 15 | 0] = 0;
     }
    }
   }
   $0 = HEAP32[$2 + 124 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) < 100) {
    jsExceptionHere(1, 17597, 0);
    HEAP8[$2 + 15 | 0] = 0;
   }
  }
  jsvUnLock(HEAP32[$2 + 116 >> 2]);
  __stack_pointer = $2 + 128 | 0;
  return HEAP8[$2 + 15 | 0] & 1;
 }
 
 function jsspiGetSendFunction($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 40 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  HEAP32[$3 + 32 >> 2] = $2;
  HEAP8[$3 + 31 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 40 >> 2]);
  block1 : {
   if (!(HEAPU8[$3 + 31 | 0] < 27 | HEAPU8[$3 + 31 | 0] > 27)) {
    if (!(jshIsDeviceInitialised(HEAPU8[$3 + 31 | 0]) & 1)) {
     jshSPIInitInfo($3 + 17 | 0);
     jshSPISetup(HEAPU8[$3 + 31 | 0], $3 + 17 | 0);
    }
    HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 587;
    HEAP8[HEAP32[$3 + 32 >> 2]] = HEAPU8[$3 + 31 | 0];
    HEAP8[$3 + 47 | 0] = 1;
    break block1;
   }
   if (!HEAPU8[$3 + 31 | 0]) {
    HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 7138);
    jsspiPopulateSPIInfo($3 + 17 | 0, HEAP32[$3 + 12 >> 2]);
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    block3 : {
     block2 : {
      if (HEAPU8[$3 + 24 | 0] == 255 | HEAPU8[$3 + 23 | 0] != 255 | (HEAPU8[$3 + 25 | 0] | HEAPU8[$3 + 22 | 0] == 255)) {
       break block2
      }
      if (!(HEAP8[$3 + 26 | 0] & 1)) {
       break block2
      }
      HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 588;
      break block3;
     }
     HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 589;
    }
    $0 = HEAPU8[$3 + 21 | 0] | HEAPU8[$3 + 22 | 0] << 8 | (HEAPU8[$3 + 23 | 0] << 16 | HEAPU8[$3 + 24 | 0] << 24);
    $1 = HEAPU8[$3 + 17 | 0] | HEAPU8[$3 + 18 | 0] << 8 | (HEAPU8[$3 + 19 | 0] << 16 | HEAPU8[$3 + 20 | 0] << 24);
    $4 = $1;
    $2 = HEAP32[$3 + 32 >> 2];
    $1 = $2;
    HEAP8[$1 | 0] = $4;
    HEAP8[$1 + 1 | 0] = $4 >>> 8;
    HEAP8[$1 + 2 | 0] = $4 >>> 16;
    HEAP8[$1 + 3 | 0] = $4 >>> 24;
    HEAP8[$1 + 4 | 0] = $0;
    HEAP8[$1 + 5 | 0] = $0 >>> 8;
    HEAP8[$1 + 6 | 0] = $0 >>> 16;
    HEAP8[$1 + 7 | 0] = $0 >>> 24;
    $1 = HEAPU8[$3 + 27 | 0] | HEAPU8[$3 + 28 | 0] << 8 | (HEAPU8[$3 + 29 | 0] << 16 | HEAPU8[$3 + 30 | 0] << 24);
    $0 = HEAPU8[$3 + 23 | 0] | HEAPU8[$3 + 24 | 0] << 8 | (HEAPU8[$3 + 25 | 0] << 16 | HEAPU8[$3 + 26 | 0] << 24);
    $4 = $0;
    $0 = $2;
    HEAP8[$0 + 6 | 0] = $4;
    HEAP8[$0 + 7 | 0] = $4 >>> 8;
    HEAP8[$0 + 8 | 0] = $4 >>> 16;
    HEAP8[$0 + 9 | 0] = $4 >>> 24;
    HEAP8[$0 + 10 | 0] = $1;
    HEAP8[$0 + 11 | 0] = $1 >>> 8;
    HEAP8[$0 + 12 | 0] = $1 >>> 16;
    HEAP8[$0 + 13 | 0] = $1 >>> 24;
    HEAP8[$3 + 47 | 0] = 1;
    break block1;
   }
   HEAP8[$3 + 47 | 0] = 0;
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP8[$3 + 47 | 0] & 1;
 }
 
 function jsspiSend4bit($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP8[$4 + 15 | 0] = $0;
  HEAP8[$4 + 14 | 0] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 4 >> 2] = $3;
  HEAP8[$4 | 0] = HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 8 >> 2] << 4;
  HEAP8[$4 + 1 | 0] = HEAP32[$4 + 4 >> 2] | HEAP32[$4 + 8 >> 2] << 4;
  HEAP8[$4 + 2 | 0] = HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 4 >> 2] << 4;
  HEAP8[$4 + 3 | 0] = HEAP32[$4 + 4 >> 2] | HEAP32[$4 + 4 >> 2] << 4;
  jshSPISend16(HEAPU8[$4 + 15 | 0], HEAPU8[(HEAPU8[$4 + 14 | 0] >>> 4 & 3) + $4 | 0] | HEAPU8[(HEAPU8[$4 + 14 | 0] >>> 6 | 0) + $4 | 0] << 8);
  jshSPISend16(HEAPU8[$4 + 15 | 0], HEAPU8[(HEAPU8[$4 + 14 | 0] & 3) + $4 | 0] | HEAPU8[(HEAPU8[$4 + 14 | 0] >>> 2 & 3) + $4 | 0] << 8);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function jsspiSend8bit($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP8[$4 + 15 | 0] = $0;
  HEAP8[$4 + 14 | 0] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 4 >> 2] = $3;
  $2 = HEAPU8[$4 + 15 | 0];
  if (HEAPU8[$4 + 14 | 0] >>> 6 & 1) {
   $0 = HEAP32[$4 + 4 >> 2]
  } else {
   $0 = HEAP32[$4 + 8 >> 2]
  }
  if (HEAPU8[$4 + 14 | 0] >>> 7 | 0) {
   $1 = HEAP32[$4 + 4 >> 2]
  } else {
   $1 = HEAP32[$4 + 8 >> 2]
  }
  jshSPISend($2, $0 | $1 << 8);
  $2 = HEAPU8[$4 + 15 | 0];
  if (HEAPU8[$4 + 14 | 0] >>> 4 & 1) {
   $0 = HEAP32[$4 + 4 >> 2]
  } else {
   $0 = HEAP32[$4 + 8 >> 2]
  }
  if (HEAPU8[$4 + 14 | 0] >>> 5 & 1) {
   $1 = HEAP32[$4 + 4 >> 2]
  } else {
   $1 = HEAP32[$4 + 8 >> 2]
  }
  jshSPISend($2, $0 | $1 << 8);
  $2 = HEAPU8[$4 + 15 | 0];
  if (HEAPU8[$4 + 14 | 0] >>> 2 & 1) {
   $0 = HEAP32[$4 + 4 >> 2]
  } else {
   $0 = HEAP32[$4 + 8 >> 2]
  }
  if (HEAPU8[$4 + 14 | 0] >>> 3 & 1) {
   $1 = HEAP32[$4 + 4 >> 2]
  } else {
   $1 = HEAP32[$4 + 8 >> 2]
  }
  jshSPISend($2, $0 | $1 << 8);
  $2 = HEAPU8[$4 + 15 | 0];
  if (HEAP8[$4 + 14 | 0] & 1) {
   $0 = HEAP32[$4 + 4 >> 2]
  } else {
   $0 = HEAP32[$4 + 8 >> 2]
  }
  if (HEAPU8[$4 + 14 | 0] >>> 1 & 1) {
   $1 = HEAP32[$4 + 4 >> 2]
  } else {
   $1 = HEAP32[$4 + 8 >> 2]
  }
  jshSPISend($2, $0 | $1 << 8);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function jshUSARTInitInfo($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 | 0] = 128;
  HEAP8[$0 + 1 | 0] = 37;
  HEAP8[$0 + 2 | 0] = 0;
  HEAP8[$0 + 3 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 8 | 0] = 8;
  HEAP8[HEAP32[$1 + 12 >> 2] + 9 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 1;
  HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
 }
 
 function jshSPIInitInfo($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 | 0] = 160;
  HEAP8[$0 + 1 | 0] = 134;
  HEAP8[$0 + 2 | 0] = 1;
  HEAP8[$0 + 3 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 8 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 9 | 0] = 1;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 10 | 0] = 8;
  HEAP8[$0 + 11 | 0] = 0;
  HEAP8[$0 + 12 | 0] = 0;
  HEAP8[$0 + 13 | 0] = 0;
 }
 
 function jshI2CInitInfo($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 255;
  HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 | 0] = 160;
  HEAP8[$0 + 1 | 0] = 134;
  HEAP8[$0 + 2 | 0] = 1;
  HEAP8[$0 + 3 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 1;
 }
 
 function jshFlashWriteAligned($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block1 : {
   if (!(HEAPU32[$3 + 24 >> 2] < 134217728 | HEAPU32[$3 + 24 >> 2] >= 142606336)) {
    jshFlashWrite(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
    break block1;
   }
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 28 >> 2];
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 24 >> 2] & 3;
   if (HEAP32[$3 + 12 >> 2]) {
    jshFlashRead($3 + 8 | 0, HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 12 >> 2] | 0, 4);
    HEAP32[$3 + 4 >> 2] = 4 - HEAP32[$3 + 12 >> 2];
    if (HEAPU32[$3 + 4 >> 2] > HEAPU32[$3 + 20 >> 2]) {
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 20 >> 2]
    }
    $1 = HEAP32[$3 + 12 >> 2];
    $2 = HEAP32[$3 + 16 >> 2];
    $0 = HEAP32[$3 + 4 >> 2];
    if ($0) {
     wasm2js_memory_copy(($3 + 8 | 0) + $1 | 0, $2, $0)
    }
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 4 >> 2] + HEAP32[$3 + 16 >> 2];
    jshFlashWrite($3 + 8 | 0, HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 12 >> 2] | 0, 4);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 4 >> 2] + HEAP32[$3 + 24 >> 2];
    if (HEAPU32[$3 + 4 >> 2] >= HEAPU32[$3 + 20 >> 2]) {
     break block1
    }
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 4 >> 2];
   }
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2] & 3;
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 12 >> 2];
   if (HEAP32[$3 + 20 >> 2]) {
    jshFlashWrite(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2])
   }
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 16 >> 2];
   if (!HEAP32[$3 + 12 >> 2]) {
    break block1
   }
   jshFlashRead($3, HEAP32[$3 + 24 >> 2], 4);
   $1 = HEAP32[$3 + 16 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   if ($0) {
    wasm2js_memory_copy($3, $1, $0)
   }
   jshFlashWrite($3, HEAP32[$3 + 24 >> 2], 4);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jshSPISendMany($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 48 | 0;
  __stack_pointer = $5;
  HEAP8[$5 + 47 | 0] = $0;
  HEAP32[$5 + 40 >> 2] = $1;
  HEAP32[$5 + 36 >> 2] = $2;
  HEAP32[$5 + 32 >> 2] = $3;
  HEAP32[$5 + 28 >> 2] = $4;
  HEAP32[$5 + 24 >> 2] = 0;
  HEAP32[$5 + 20 >> 2] = 0;
  while (1) {
   $0 = 0;
   if (HEAPU32[$5 + 24 >> 2] < HEAPU32[$5 + 32 >> 2]) {
    $0 = jspIsInterrupted() ^ -1
   }
   if ($0 & 1) {
    $1 = HEAPU8[$5 + 47 | 0];
    $2 = HEAP32[$5 + 40 >> 2];
    $0 = HEAP32[$5 + 24 >> 2];
    HEAP32[$5 + 24 >> 2] = $0 + 1;
    HEAP32[$5 + 16 >> 2] = jshSPISend($1, HEAPU8[$2 + $0 | 0]);
    if (HEAP32[$5 + 36 >> 2] ? HEAP32[$5 + 16 >> 2] >= 0 : 0) {
     $1 = HEAP32[$5 + 16 >> 2];
     $2 = HEAP32[$5 + 36 >> 2];
     $0 = HEAP32[$5 + 20 >> 2];
     HEAP32[$5 + 20 >> 2] = $0 + 1;
     HEAP8[$2 + $0 | 0] = $1;
    }
    continue;
   }
   break;
  };
  block : {
   if (HEAP32[$5 + 36 >> 2]) {
    while (1) {
     $0 = 0;
     if (HEAPU32[$5 + 20 >> 2] < HEAPU32[$5 + 32 >> 2]) {
      $0 = jspIsInterrupted() ^ -1
     }
     if ($0 & 1) {
      HEAP32[$5 + 12 >> 2] = jshSPISend(HEAPU8[$5 + 47 | 0], -1);
      $1 = HEAP32[$5 + 12 >> 2];
      $2 = HEAP32[$5 + 36 >> 2];
      $0 = HEAP32[$5 + 20 >> 2];
      HEAP32[$5 + 20 >> 2] = $0 + 1;
      HEAP8[$2 + $0 | 0] = $1;
      continue;
     }
     break;
    };
    break block;
   }
   jshSPIWait(HEAPU8[$5 + 47 | 0]);
  }
  if (HEAP32[$5 + 28 >> 2]) {
   FUNCTION_TABLE[HEAP32[$5 + 28 >> 2]]()
  }
  __stack_pointer = $5 + 48 | 0;
  return 1;
 }
 
 function jshUSARTUnSetup($0) {
  HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
 }
 
 function jshFlashErasePages($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2] + HEAP32[$2 + 20 >> 2];
  block : {
   if (!(jshFlashGetPage(HEAP32[$2 + 24 >> 2], $2 + 12 | 0, $2 + 8 | 0) & 1)) {
    HEAP8[$2 + 31 | 0] = 0;
    break block;
   }
   while (1) {
    $0 = 0;
    if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 16 >> 2]) {
     $0 = jspIsInterrupted() ^ -1
    }
    if ($0 & 1) {
     jshFlashErasePage(HEAP32[$2 + 12 >> 2]);
     if (!(jshFlashGetPage(HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0, $2 + 12 | 0, $2 + 8 | 0) & 1)) {
      HEAP8[$2 + 31 | 0] = 1;
      break block;
     }
     jshKickWatchDog();
     jshKickSoftWatchDog();
     continue;
    }
    break;
   };
   HEAP8[$2 + 31 | 0] = (jspIsInterrupted() ^ -1) & 1;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP8[$2 + 31 | 0] & 1;
 }
 
 function jshKickSoftWatchDog() {
  jswrap_banglejs_kickPollWatchdog();
  if (HEAP32[103315] & 4096) {
   HEAP32[103315] = HEAP32[103315] & -4097 | 2048
  }
 }
 
 function jshHadEvent() {
  HEAP8[416612] = 1;
 }
 
 function jsvGetProcessorPowerUsage($0) {
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 }
 
 function jshGetSystemClock() {
  return 0;
 }
 
 function heatshrink_encoder_reset($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 512;
  $2 = HEAP32[$1 + 12 >> 2];
  $0 = HEAP32[$1 + 8 >> 2];
  if ($0) {
   wasm2js_memory_fill($2 + 15 | 0, 0, $0)
  }
  HEAP16[HEAP32[$1 + 12 >> 2] >> 1] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 14 | 0] = 128;
  HEAP8[HEAP32[$1 + 12 >> 2] + 13 | 0] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] + 4 >> 1] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] + 8 >> 1] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 0;
 }
 
 function heatshrink_encoder_sink($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  block2 : {
   if (HEAP32[$4 + 12 >> 2] ? !HEAP32[$4 + 24 >> 2] | !HEAP32[$4 + 20 >> 2] : 1) {
    HEAP32[$4 + 28 >> 2] = -1;
    break block2;
   }
   if (is_finishing(HEAP32[$4 + 24 >> 2])) {
    HEAP32[$4 + 28 >> 2] = -2;
    break block2;
   }
   if (HEAPU8[HEAP32[$4 + 24 >> 2] + 12 | 0]) {
    HEAP32[$4 + 28 >> 2] = -2;
    break block2;
   }
   HEAP16[$4 + 10 >> 1] = (get_input_offset(HEAP32[$4 + 24 >> 2]) & 65535) + HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
   HEAP16[$4 + 8 >> 1] = get_input_buffer_size(HEAP32[$4 + 24 >> 2]);
   HEAP16[$4 + 6 >> 1] = HEAPU16[$4 + 8 >> 1] - HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
   if (HEAPU16[$4 + 6 >> 1] < HEAPU32[$4 + 16 >> 2]) {
    $0 = HEAPU16[$4 + 6 >> 1]
   } else {
    $0 = HEAP32[$4 + 16 >> 2]
   }
   HEAP16[$4 + 4 >> 1] = $0;
   $1 = HEAP32[$4 + 24 >> 2];
   $2 = HEAPU16[$4 + 10 >> 1];
   $3 = HEAP32[$4 + 20 >> 2];
   $0 = HEAPU16[$4 + 4 >> 1];
   if ($0) {
    wasm2js_memory_copy(($1 + 15 | 0) + $2 | 0, $3, $0)
   }
   HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAPU16[$4 + 4 >> 1];
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP16[$0 >> 1] = HEAPU16[$4 + 4 >> 1] + HEAPU16[$0 >> 1];
   if (HEAPU16[$4 + 4 >> 1] == HEAPU16[$4 + 6 >> 1]) {
    HEAP8[HEAP32[$4 + 24 >> 2] + 12 | 0] = 1
   }
   HEAP32[$4 + 28 >> 2] = 0;
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 28 >> 2];
 }
 
 function is_finishing($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] & 1;
 }
 
 function get_input_offset($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = get_input_buffer_size(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 65535;
 }
 
 function get_input_buffer_size($0) {
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
  return 256;
 }
 
 function heatshrink_encoder_poll($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 40 >> 2] = $0;
  HEAP32[$4 + 36 >> 2] = $1;
  HEAP32[$4 + 32 >> 2] = $2;
  HEAP32[$4 + 28 >> 2] = $3;
  block2 : {
   if (HEAP32[$4 + 28 >> 2] ? !HEAP32[$4 + 40 >> 2] | !HEAP32[$4 + 36 >> 2] : 1) {
    HEAP32[$4 + 44 >> 2] = -1;
    break block2;
   }
   if (!HEAP32[$4 + 32 >> 2]) {
    HEAP32[$4 + 44 >> 2] = -2;
    break block2;
   }
   HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = 0;
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 32 >> 2];
   HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 28 >> 2];
   while (1) {
    HEAP8[$4 + 15 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 12 | 0];
    block14 : {
     block13 : {
      switch (HEAPU8[$4 + 15 | 0]) {
      case 0:
       HEAP32[$4 + 44 >> 2] = 0;
       break block2;
      case 1:
       do_indexing(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = 2;
       break block14;
      case 2:
       $0 = st_step_search(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
       break block14;
      case 3:
       $0 = st_yield_tag_bit(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
       break block14;
      case 4:
       $0 = st_e_yield_literal(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
       break block14;
      case 5:
       $0 = st_yield_br_index(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
       break block14;
      case 6:
       $0 = st_yield_br_length(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
       break block14;
      case 7:
       $0 = st_save_backlog(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
       break block14;
      case 8:
       $0 = st_flush_bit_buffer(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
       HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
       HEAP32[$4 + 44 >> 2] = 0;
       break block2;
      case 9:
       HEAP32[$4 + 44 >> 2] = 0;
       break block2;
      default:
       break block13;
      };
     }
     HEAP32[$4 + 44 >> 2] = -2;
     break block2;
    }
    if (!(HEAPU8[HEAP32[$4 + 40 >> 2] + 12 | 0] == HEAPU8[$4 + 15 | 0] & HEAP32[HEAP32[$4 + 28 >> 2] >> 2] == HEAP32[$4 + 32 >> 2])) {
     continue
    }
    break;
   };
   HEAP32[$4 + 44 >> 2] = 1;
  }
  __stack_pointer = $4 + 48 | 0;
  return HEAP32[$4 + 44 >> 2];
 }
 
 function do_indexing($0) {
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 }
 
 function st_step_search($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP16[$1 + 22 >> 1] = get_input_buffer_size(HEAP32[$1 + 24 >> 2]);
  HEAP16[$1 + 20 >> 1] = get_lookahead_size(HEAP32[$1 + 24 >> 2]);
  HEAP16[$1 + 18 >> 1] = HEAPU16[HEAP32[$1 + 24 >> 2] + 2 >> 1];
  HEAP8[$1 + 17 | 0] = (is_finishing(HEAP32[$1 + 24 >> 2]) | 0) != 0;
  block : {
   if (HEAPU16[$1 + 18 >> 1] > (HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - (HEAP8[$1 + 17 | 0] & 1 ? 1 : HEAPU16[$1 + 20 >> 1]) | 0)) {
    HEAP32[$1 + 28 >> 2] = HEAP8[$1 + 17 | 0] & 1 ? 8 : 7;
    break block;
   }
   HEAP16[$1 + 14 >> 1] = get_input_offset(HEAP32[$1 + 24 >> 2]);
   HEAP16[$1 + 12 >> 1] = HEAPU16[$1 + 14 >> 1] + HEAPU16[$1 + 18 >> 1];
   HEAP16[$1 + 10 >> 1] = HEAPU16[$1 + 12 >> 1] - HEAPU16[$1 + 22 >> 1];
   HEAP16[$1 + 8 >> 1] = HEAPU16[$1 + 20 >> 1];
   if (HEAPU16[$1 + 20 >> 1] > (HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - HEAPU16[$1 + 18 >> 1] | 0)) {
    HEAP16[$1 + 8 >> 1] = HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - HEAPU16[$1 + 18 >> 1]
   }
   HEAP16[$1 + 6 >> 1] = 0;
   HEAP16[$1 + 4 >> 1] = find_longest_match(HEAP32[$1 + 24 >> 2], HEAPU16[$1 + 10 >> 1], HEAPU16[$1 + 12 >> 1], HEAPU16[$1 + 8 >> 1], $1 + 6 | 0);
   if (HEAPU16[$1 + 4 >> 1] == 65535) {
    $0 = HEAP32[$1 + 24 >> 2];
    HEAP16[$0 + 2 >> 1] = HEAPU16[$0 + 2 >> 1] + 1;
    HEAP16[HEAP32[$1 + 24 >> 2] + 4 >> 1] = 0;
    HEAP32[$1 + 28 >> 2] = 3;
    break block;
   }
   HEAP16[HEAP32[$1 + 24 >> 2] + 6 >> 1] = HEAPU16[$1 + 4 >> 1];
   HEAP16[HEAP32[$1 + 24 >> 2] + 4 >> 1] = HEAPU16[$1 + 6 >> 1];
   HEAP32[$1 + 28 >> 2] = 3;
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function st_yield_tag_bit($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
    if (!HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1]) {
     add_tag_bit(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 1);
     HEAP32[$2 + 12 >> 2] = 4;
     break block;
    }
    add_tag_bit(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 0);
    HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1] - 1;
    HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 8;
    HEAP32[$2 + 12 >> 2] = 5;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 3;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function st_e_yield_literal($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
    push_literal_byte(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
    HEAP32[$2 + 12 >> 2] = 2;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 4;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function st_yield_br_index($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
    if (push_outgoing_bits(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 255) {
     HEAP32[$2 + 12 >> 2] = 5;
     break block;
    }
    HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] - 1;
    HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 6;
    HEAP32[$2 + 12 >> 2] = 6;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 5;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function st_yield_br_length($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
    if (push_outgoing_bits(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 255) {
     HEAP32[$2 + 12 >> 2] = 6;
     break block;
    }
    $0 = HEAP32[$2 + 8 >> 2];
    HEAP16[$0 + 2 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] + HEAPU16[$0 + 2 >> 1];
    HEAP16[HEAP32[$2 + 8 >> 2] + 4 >> 1] = 0;
    HEAP32[$2 + 12 >> 2] = 2;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 6;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function st_save_backlog($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  save_backlog(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return 0;
 }
 
 function st_flush_bit_buffer($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (HEAPU8[HEAP32[$2 + 8 >> 2] + 14 | 0] == 128) {
    HEAP32[$2 + 12 >> 2] = 9;
    break block;
   }
   if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
    $3 = HEAPU8[HEAP32[$2 + 8 >> 2] + 13 | 0];
    $4 = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
    $0 = HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2];
    $1 = HEAP32[$0 >> 2];
    HEAP32[$0 >> 2] = $1 + 1;
    HEAP8[$1 + $4 | 0] = $3;
    HEAP32[$2 + 12 >> 2] = 9;
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 8;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function get_lookahead_size($0) {
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
  return 64;
 }
 
 function find_longest_match($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 48 | 0;
  HEAP32[$5 + 40 >> 2] = $0;
  HEAP16[$5 + 38 >> 1] = $1;
  HEAP16[$5 + 36 >> 1] = $2;
  HEAP16[$5 + 34 >> 1] = $3;
  HEAP32[$5 + 28 >> 2] = $4;
  HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 40 >> 2] + 15;
  HEAP16[$5 + 22 >> 1] = 0;
  HEAP16[$5 + 20 >> 1] = 65535;
  HEAP16[$5 + 18 >> 1] = 0;
  HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 24 >> 2] + HEAPU16[$5 + 36 >> 1];
  HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 36 >> 1] - 1;
  while (1) {
   block : {
    if (((HEAP16[$5 + 10 >> 1] << 16 >> 16) - (HEAP16[$5 + 38 >> 1] << 16 >> 16) | 0) < 0) {
     break block
    }
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 24 >> 2] + (HEAP16[$5 + 10 >> 1] << 16 >> 16);
    if (!(HEAPU8[HEAP32[$5 + 4 >> 2] + HEAPU16[$5 + 22 >> 1] | 0] != HEAPU8[HEAP32[$5 + 12 >> 2] + HEAPU16[$5 + 22 >> 1] | 0] | HEAPU8[HEAP32[$5 + 4 >> 2]] != HEAPU8[HEAP32[$5 + 12 >> 2]])) {
     HEAP16[$5 + 18 >> 1] = 1;
     while (1) {
      if (!(HEAPU8[HEAP32[$5 + 4 >> 2] + HEAPU16[$5 + 18 >> 1] | 0] != HEAPU8[HEAP32[$5 + 12 >> 2] + HEAPU16[$5 + 18 >> 1] | 0] | HEAPU16[$5 + 18 >> 1] >= HEAPU16[$5 + 34 >> 1])) {
       HEAP16[$5 + 18 >> 1] = HEAPU16[$5 + 18 >> 1] + 1;
       continue;
      }
      break;
     };
     if (HEAPU16[$5 + 18 >> 1] > HEAPU16[$5 + 22 >> 1]) {
      HEAP16[$5 + 22 >> 1] = HEAPU16[$5 + 18 >> 1];
      HEAP16[$5 + 20 >> 1] = HEAPU16[$5 + 10 >> 1];
      if (HEAPU16[$5 + 18 >> 1] == HEAPU16[$5 + 34 >> 1]) {
       break block
      }
     }
    }
    HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 10 >> 1] - 1;
    continue;
   }
   break;
  };
  HEAP32[$5 >> 2] = 15;
  block3 : {
   if (HEAPU16[$5 + 22 >> 1] > 1) {
    HEAP16[HEAP32[$5 + 28 >> 2] >> 1] = HEAPU16[$5 + 22 >> 1];
    HEAP16[$5 + 46 >> 1] = HEAPU16[$5 + 36 >> 1] - HEAPU16[$5 + 20 >> 1];
    break block3;
   }
   HEAP16[$5 + 46 >> 1] = 65535;
  }
  return HEAPU16[$5 + 46 >> 1];
 }
 
 function can_take_byte($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function add_tag_bit($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  push_bits(HEAP32[$3 + 12 >> 2], 1, HEAPU8[$3 + 7 | 0], HEAP32[$3 + 8 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function push_literal_byte($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP16[$2 + 6 >> 1] = HEAPU16[HEAP32[$2 + 12 >> 2] + 2 >> 1] - 1;
  HEAP16[$2 + 4 >> 1] = (get_input_offset(HEAP32[$2 + 12 >> 2]) & 65535) + HEAPU16[$2 + 6 >> 1];
  HEAP8[$2 + 3 | 0] = HEAPU8[HEAPU16[$2 + 4 >> 1] + (HEAP32[$2 + 12 >> 2] + 15 | 0) | 0];
  push_bits(HEAP32[$2 + 12 >> 2], 8, HEAPU8[$2 + 3 | 0], HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function push_outgoing_bits($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP8[$2 + 7 | 0] = 0;
  HEAP8[$2 + 6 | 0] = 0;
  block : {
   if (HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0] > 8) {
    HEAP8[$2 + 7 | 0] = 8;
    HEAP8[$2 + 6 | 0] = HEAPU16[HEAP32[$2 + 12 >> 2] + 8 >> 1] >> HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0] - 8;
    break block;
   }
   HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0];
   HEAP8[$2 + 6 | 0] = HEAPU16[HEAP32[$2 + 12 >> 2] + 8 >> 1];
  }
  if (HEAPU8[$2 + 7 | 0]) {
   push_bits(HEAP32[$2 + 12 >> 2], HEAPU8[$2 + 7 | 0], HEAPU8[$2 + 6 | 0], HEAP32[$2 + 8 >> 2]);
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP8[$0 + 10 | 0] = HEAPU8[$0 + 10 | 0] - HEAPU8[$2 + 7 | 0];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAPU8[$2 + 7 | 0];
 }
 
 function save_backlog($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = get_input_buffer_size(HEAP32[$1 + 12 >> 2]) & 65535;
  HEAP16[$1 + 6 >> 1] = HEAPU16[HEAP32[$1 + 12 >> 2] + 2 >> 1];
  HEAP16[$1 + 4 >> 1] = HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 6 >> 1];
  HEAP16[$1 + 2 >> 1] = HEAP32[$1 + 8 >> 2] + HEAPU16[$1 + 4 >> 1];
  $2 = HEAP32[$1 + 12 >> 2];
  $3 = HEAP32[$1 + 12 >> 2];
  $4 = HEAP32[$1 + 8 >> 2];
  $5 = HEAPU16[$1 + 4 >> 1];
  $0 = HEAPU16[$1 + 2 >> 1];
  if ($0) {
   wasm2js_memory_copy($2 + 15 | 0, $3 + 15 + ($4 - $5) | 0, $0)
  }
  HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP16[$0 >> 1] = HEAPU16[$0 >> 1] - (HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 4 >> 1] | 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function heatshrink_encoder_finish($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = -1;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP8[$0 + 11 | 0] = HEAPU8[$0 + 11 | 0] | 1;
   if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 12 | 0]) {
    HEAP8[HEAP32[$1 + 8 >> 2] + 12 | 0] = 1
   }
   HEAP32[$1 + 12 >> 2] = HEAPU8[HEAP32[$1 + 8 >> 2] + 12 | 0] != 9;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function push_bits($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP8[$4 + 27 | 0] = $1;
  HEAP8[$4 + 26 | 0] = $2;
  HEAP32[$4 + 20 >> 2] = $3;
  block1 : {
   if (!(HEAPU8[$4 + 27 | 0] != 8 | HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0] != 128)) {
    $2 = HEAPU8[$4 + 26 | 0];
    $3 = HEAP32[HEAP32[$4 + 20 >> 2] >> 2];
    $0 = HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2];
    $1 = HEAP32[$0 >> 2];
    HEAP32[$0 >> 2] = $1 + 1;
    HEAP8[$1 + $3 | 0] = $2;
    break block1;
   }
   HEAP32[$4 + 16 >> 2] = HEAPU8[$4 + 27 | 0] - 1;
   while (1) {
    if (HEAP32[$4 + 16 >> 2] >= 0) {
     HEAP8[$4 + 15 | 0] = (HEAPU8[$4 + 26 | 0] & 1 << HEAP32[$4 + 16 >> 2]) != 0;
     if (HEAP8[$4 + 15 | 0] & 1) {
      $0 = HEAP32[$4 + 28 >> 2];
      HEAP8[$0 + 13 | 0] = HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0] | HEAPU8[$0 + 13 | 0];
     }
     $0 = HEAP32[$4 + 28 >> 2];
     HEAP8[$0 + 14 | 0] = HEAPU8[$0 + 14 | 0] >>> 1;
     if (!HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0]) {
      HEAP8[HEAP32[$4 + 28 >> 2] + 14 | 0] = 128;
      $2 = HEAPU8[HEAP32[$4 + 28 >> 2] + 13 | 0];
      $3 = HEAP32[HEAP32[$4 + 20 >> 2] >> 2];
      $0 = HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2];
      $1 = HEAP32[$0 >> 2];
      HEAP32[$0 >> 2] = $1 + 1;
      HEAP8[$1 + $3 | 0] = $2;
      HEAP8[HEAP32[$4 + 28 >> 2] + 13 | 0] = 0;
     }
     HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] - 1;
     continue;
    }
    break;
   };
  }
 }
 
 function heatshrink_decoder_reset($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 256;
  HEAP32[$1 + 4 >> 2] = 32;
  $2 = HEAP32[$1 + 12 >> 2];
  $0 = HEAP32[$1 + 8 >> 2] + HEAP32[$1 + 4 >> 2] | 0;
  if ($0) {
   wasm2js_memory_fill($2 + 13 | 0, 0, $0)
  }
  HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] >> 1] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
  HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] + 4 >> 1] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] + 6 >> 1] = 0;
  HEAP16[HEAP32[$1 + 12 >> 2] + 8 >> 1] = 0;
 }
 
 function heatshrink_decoder_sink($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  block2 : {
   if (HEAP32[$4 + 12 >> 2] ? !HEAP32[$4 + 24 >> 2] | !HEAP32[$4 + 20 >> 2] : 1) {
    HEAP32[$4 + 28 >> 2] = -1;
    break block2;
   }
   HEAP32[$4 + 8 >> 2] = 32 - HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
   if (!HEAP32[$4 + 8 >> 2]) {
    HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = 0;
    HEAP32[$4 + 28 >> 2] = 1;
    break block2;
   }
   if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 + 16 >> 2]) {
    $0 = HEAP32[$4 + 8 >> 2]
   } else {
    $0 = HEAP32[$4 + 16 >> 2]
   }
   HEAP32[$4 + 16 >> 2] = $0;
   $1 = HEAP32[$4 + 24 >> 2];
   $2 = HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
   $3 = HEAP32[$4 + 20 >> 2];
   $0 = HEAP32[$4 + 16 >> 2];
   if ($0) {
    wasm2js_memory_copy(($1 + 13 | 0) + $2 | 0, $3, $0)
   }
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP16[$0 >> 1] = HEAP32[$4 + 16 >> 2] + HEAPU16[$0 >> 1];
   HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[$4 + 16 >> 2];
   HEAP32[$4 + 28 >> 2] = 0;
  }
  return HEAP32[$4 + 28 >> 2];
 }
 
 function heatshrink_decoder_poll($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 40 >> 2] = $0;
  HEAP32[$4 + 36 >> 2] = $1;
  HEAP32[$4 + 32 >> 2] = $2;
  HEAP32[$4 + 28 >> 2] = $3;
  block2 : {
   if (HEAP32[$4 + 28 >> 2] ? !HEAP32[$4 + 40 >> 2] | !HEAP32[$4 + 36 >> 2] : 1) {
    HEAP32[$4 + 44 >> 2] = -1;
    break block2;
   }
   HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = 0;
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 32 >> 2];
   HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 28 >> 2];
   while (1) {
    HEAP8[$4 + 15 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 10 | 0];
    block11 : {
     block10 : {
      switch (HEAPU8[$4 + 15 | 0]) {
      case 0:
       $0 = st_tag_bit(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
       break block11;
      case 1:
       $0 = st_d_yield_literal(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
       HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
       break block11;
      case 2:
       $0 = st_backref_index_msb(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
       break block11;
      case 3:
       $0 = st_backref_index_lsb(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
       break block11;
      case 4:
       $0 = st_backref_count_msb(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
       break block11;
      case 5:
       $0 = st_backref_count_lsb(HEAP32[$4 + 40 >> 2]);
       HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
       break block11;
      case 6:
       $0 = st_yield_backref(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
       HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
       break block11;
      default:
       break block10;
      };
     }
     HEAP32[$4 + 44 >> 2] = -2;
     break block2;
    }
    if (HEAPU8[HEAP32[$4 + 40 >> 2] + 10 | 0] != HEAPU8[$4 + 15 | 0]) {
     continue
    }
    break;
   };
   if (HEAP32[HEAP32[$4 + 28 >> 2] >> 2] == HEAP32[$4 + 32 >> 2]) {
    HEAP32[$4 + 44 >> 2] = 1;
    break block2;
   }
   HEAP32[$4 + 44 >> 2] = 0;
  }
  __stack_pointer = $4 + 48 | 0;
  return HEAP32[$4 + 44 >> 2];
 }
 
 function st_tag_bit($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = get_bits(HEAP32[$1 + 8 >> 2], 1) & 65535;
  block : {
   if (HEAP32[$1 + 4 >> 2] == 65535) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 1;
    break block;
   }
   HEAP16[HEAP32[$1 + 8 >> 2] + 6 >> 1] = 0;
   HEAP32[$1 + 12 >> 2] = 3;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function st_d_yield_literal($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (HEAPU32[HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] >> 2] < HEAPU32[HEAP32[$2 + 20 >> 2] + 4 >> 2]) {
    HEAP16[$2 + 18 >> 1] = get_bits(HEAP32[$2 + 24 >> 2], 8);
    if (HEAPU16[$2 + 18 >> 1] == 65535) {
     HEAP32[$2 + 28 >> 2] = 1;
     break block;
    }
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 24 >> 2] + 45;
    HEAP16[$2 + 10 >> 1] = 255;
    HEAP8[$2 + 9 | 0] = HEAPU16[$2 + 18 >> 1];
    $3 = HEAPU8[$2 + 9 | 0];
    $4 = HEAP32[$2 + 12 >> 2];
    $0 = HEAP32[$2 + 24 >> 2];
    $1 = HEAPU16[$0 + 8 >> 1];
    HEAP16[$0 + 8 >> 1] = $1 + 1;
    HEAP8[(HEAPU16[$2 + 10 >> 1] & $1) + $4 | 0] = $3;
    push_byte(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAPU8[$2 + 9 | 0]);
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 28 >> 2] = 1;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function st_backref_index_msb($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = 8;
  HEAP16[$1 + 4 >> 1] = get_bits(HEAP32[$1 + 8 >> 2], HEAPU8[$1 + 7 | 0] - 8 & 255);
  block : {
   if (HEAPU16[$1 + 4 >> 1] == 65535) {
    HEAP32[$1 + 12 >> 2] = 2;
    break block;
   }
   HEAP16[HEAP32[$1 + 8 >> 2] + 6 >> 1] = HEAPU16[$1 + 4 >> 1] << 8;
   HEAP32[$1 + 12 >> 2] = 3;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function st_backref_index_lsb($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = 8;
  $2 = HEAP32[$1 + 8 >> 2];
  if (HEAPU8[$1 + 7 | 0] < 8) {
   $0 = HEAPU8[$1 + 7 | 0]
  } else {
   $0 = 8
  }
  HEAP16[$1 + 4 >> 1] = get_bits($2, $0);
  block1 : {
   if (HEAPU16[$1 + 4 >> 1] == 65535) {
    HEAP32[$1 + 12 >> 2] = 3;
    break block1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP16[$0 + 6 >> 1] = HEAPU16[$1 + 4 >> 1] | HEAPU16[$0 + 6 >> 1];
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP16[$0 + 6 >> 1] = HEAPU16[$0 + 6 >> 1] + 1;
   HEAP8[$1 + 3 | 0] = 6;
   HEAP16[HEAP32[$1 + 8 >> 2] + 4 >> 1] = 0;
   HEAP32[$1 + 12 >> 2] = HEAPU8[$1 + 3 | 0] > 8 ? 4 : 5;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function st_backref_count_msb($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = 6;
  HEAP16[$1 + 4 >> 1] = get_bits(HEAP32[$1 + 8 >> 2], HEAPU8[$1 + 7 | 0] - 8 & 255);
  block : {
   if (HEAPU16[$1 + 4 >> 1] == 65535) {
    HEAP32[$1 + 12 >> 2] = 4;
    break block;
   }
   HEAP16[HEAP32[$1 + 8 >> 2] + 4 >> 1] = HEAPU16[$1 + 4 >> 1] << 8;
   HEAP32[$1 + 12 >> 2] = 5;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function st_backref_count_lsb($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = 6;
  $2 = HEAP32[$1 + 8 >> 2];
  if (HEAPU8[$1 + 7 | 0] < 8) {
   $0 = HEAPU8[$1 + 7 | 0]
  } else {
   $0 = 8
  }
  HEAP16[$1 + 4 >> 1] = get_bits($2, $0);
  block1 : {
   if (HEAPU16[$1 + 4 >> 1] == 65535) {
    HEAP32[$1 + 12 >> 2] = 5;
    break block1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP16[$0 + 4 >> 1] = HEAPU16[$1 + 4 >> 1] | HEAPU16[$0 + 4 >> 1];
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP16[$0 + 4 >> 1] = HEAPU16[$0 + 4 >> 1] + 1;
   HEAP32[$1 + 12 >> 2] = 6;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function st_yield_backref($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2] - HEAP32[HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] >> 2];
  block : {
   if (HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    if (HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1] < HEAPU32[$2 + 16 >> 2]) {
     HEAP32[$2 + 16 >> 2] = HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1]
    }
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 24 >> 2] + 45;
    HEAP16[$2 + 6 >> 1] = 255;
    HEAP16[$2 + 4 >> 1] = HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1];
    HEAP32[$2 + 12 >> 2] = 0;
    while (1) {
     if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 16 >> 2]) {
      HEAP8[$2 + 3 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + (HEAPU16[$2 + 6 >> 1] & HEAPU16[HEAP32[$2 + 24 >> 2] + 8 >> 1] - HEAPU16[$2 + 4 >> 1]) | 0];
      push_byte(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAPU8[$2 + 3 | 0]);
      HEAP8[HEAP32[$2 + 8 >> 2] + (HEAPU16[HEAP32[$2 + 24 >> 2] + 8 >> 1] & HEAPU16[$2 + 6 >> 1]) | 0] = HEAPU8[$2 + 3 | 0];
      $0 = HEAP32[$2 + 24 >> 2];
      HEAP16[$0 + 8 >> 1] = HEAPU16[$0 + 8 >> 1] + 1;
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
      continue;
     }
     break;
    };
    $0 = HEAP32[$2 + 24 >> 2];
    HEAP16[$0 + 4 >> 1] = HEAPU16[$0 + 4 >> 1] - HEAP32[$2 + 16 >> 2];
    if (!HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1]) {
     HEAP32[$2 + 28 >> 2] = 0;
     break block;
    }
   }
   HEAP32[$2 + 28 >> 2] = 6;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function get_bits($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP8[$2 + 7 | 0] = $1;
  HEAP16[$2 + 4 >> 1] = 0;
  HEAP32[$2 >> 2] = 0;
  block : {
   if (HEAPU8[$2 + 7 | 0] > 15) {
    HEAP16[$2 + 14 >> 1] = 65535;
    break block;
   }
   if (!HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
    if (HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0] < 1 << HEAPU8[$2 + 7 | 0] - 1) {
     HEAP16[$2 + 14 >> 1] = 65535;
     break block;
    }
   }
   HEAP32[$2 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 >> 2] < HEAPU8[$2 + 7 | 0]) {
     if (!HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0]) {
      if (!HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
       HEAP16[$2 + 14 >> 1] = 65535;
       break block;
      }
      $0 = HEAP32[$2 + 8 >> 2];
      $1 = HEAPU16[$0 + 2 >> 1];
      HEAP16[$0 + 2 >> 1] = $1 + 1;
      HEAP8[HEAP32[$2 + 8 >> 2] + 11 | 0] = HEAPU8[($0 + 13 | 0) + $1 | 0];
      if (HEAPU16[HEAP32[$2 + 8 >> 2] + 2 >> 1] == HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
       HEAP16[HEAP32[$2 + 8 >> 2] + 2 >> 1] = 0;
       HEAP16[HEAP32[$2 + 8 >> 2] >> 1] = 0;
      }
      HEAP8[HEAP32[$2 + 8 >> 2] + 12 | 0] = 128;
     }
     HEAP16[$2 + 4 >> 1] = HEAPU16[$2 + 4 >> 1] << 1;
     if (HEAPU8[HEAP32[$2 + 8 >> 2] + 11 | 0] & HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0]) {
      HEAP16[$2 + 4 >> 1] = HEAPU16[$2 + 4 >> 1] | 1
     }
     $0 = HEAP32[$2 + 8 >> 2];
     HEAP8[$0 + 12 | 0] = HEAPU8[$0 + 12 | 0] >>> 1;
     HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
     continue;
    }
    break;
   };
   block1 : {
    if (HEAPU8[$2 + 7 | 0] <= 1) {
     break block1
    }
   }
   HEAP16[$2 + 14 >> 1] = HEAPU16[$2 + 4 >> 1];
  }
  return HEAPU16[$2 + 14 >> 1];
 }
 
 function push_byte($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  $1 = HEAPU8[$3 + 7 | 0];
  $0 = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
  $3 = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2];
  $2 = HEAP32[$3 >> 2];
  HEAP32[$3 >> 2] = $2 + 1;
  HEAP8[$2 + $0 | 0] = $1;
 }
 
 function heatshrink_decoder_finish($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = -1;
    break block;
   }
   block4 : {
    switch (HEAPU8[HEAP32[$1 + 8 >> 2] + 10 | 0]) {
    case 0:
     HEAP32[$1 + 12 >> 2] = !!HEAPU16[HEAP32[$1 + 8 >> 2] >> 1];
     break block;
    case 2:
    case 3:
    case 4:
    case 5:
     HEAP32[$1 + 12 >> 2] = !!HEAPU16[HEAP32[$1 + 8 >> 2] >> 1];
     break block;
    case 1:
     HEAP32[$1 + 12 >> 2] = !!HEAPU16[HEAP32[$1 + 8 >> 2] >> 1];
     break block;
    default:
     break block4;
    };
   }
   HEAP32[$1 + 12 >> 2] = 1;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function heatshrink_ptr_output_cb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  $0 = HEAPU8[$2 + 15 | 0];
  $2 = HEAP32[$2 + 4 >> 2];
  $1 = HEAP32[$2 >> 2];
  HEAP32[$2 >> 2] = $1 + 1;
  HEAP8[$1 | 0] = $0;
 }
 
 function heatshrink_var_output_cb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  jsvStringIteratorSetCharAndNext(HEAP32[$2 + 4 >> 2], HEAP8[$2 + 15 | 0] << 24 >> 24);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function heatshrink_var_input_cb($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
  HEAP32[$1 + 4 >> 2] = -1;
  if (jsvIteratorHasElement(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 4 >> 2] = jsvIteratorGetIntegerValue(HEAP32[$1 + 8 >> 2]) & 255
  }
  jsvIteratorNext(HEAP32[$1 + 8 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function heatshrink_encode_cb($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 832 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 828 >> 2] = $0;
  HEAP32[$4 + 824 >> 2] = $1;
  HEAP32[$4 + 820 >> 2] = $2;
  HEAP32[$4 + 816 >> 2] = $3;
  heatshrink_encoder_reset($4 + 288 | 0);
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 20 >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  HEAP32[$4 + 8 >> 2] = 0;
  while (1) {
   $0 = 1;
   $0 = HEAP32[$4 + 16 >> 2] < 0 ? HEAP32[$4 + 12 >> 2] != 0 : $0;
   if ($0) {
    if (!HEAP32[$4 + 12 >> 2]) {
     HEAP32[$4 + 8 >> 2] = 0;
     while (1) {
      $0 = 0;
      $0 = HEAPU32[$4 + 12 >> 2] < 128 ? HEAP32[$4 + 16 >> 2] >= 0 : $0;
      if ($0) {
       HEAP32[$4 + 16 >> 2] = FUNCTION_TABLE[HEAP32[$4 + 828 >> 2]](HEAP32[$4 + 824 >> 2]);
       if (HEAP32[$4 + 16 >> 2] >= 0) {
        $1 = HEAP32[$4 + 16 >> 2];
        $0 = HEAP32[$4 + 12 >> 2];
        HEAP32[$4 + 12 >> 2] = $0 + 1;
        HEAP8[($4 + 160 | 0) + $0 | 0] = $1;
       }
       continue;
      }
      break;
     };
    }
    HEAP8[$4 + 7 | 0] = (heatshrink_encoder_sink($4 + 288 | 0, HEAP32[$4 + 8 >> 2] + ($4 + 160 | 0) | 0, HEAP32[$4 + 12 >> 2], $4 + 24 | 0) | 0) >= 0;
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] - HEAP32[$4 + 24 >> 2];
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 8 >> 2];
    if (!(HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] >= 0)) {
     heatshrink_encoder_finish($4 + 288 | 0)
    }
    while (1) {
     HEAP32[$4 >> 2] = heatshrink_encoder_poll($4 + 288 | 0, $4 + 32 | 0, 128, $4 + 24 | 0);
     if (HEAP32[$4 + 820 >> 2]) {
      HEAP32[$4 + 28 >> 2] = 0;
      while (1) {
       if (HEAPU32[$4 + 28 >> 2] < HEAPU32[$4 + 24 >> 2]) {
        FUNCTION_TABLE[HEAP32[$4 + 820 >> 2]](HEAPU8[HEAP32[$4 + 28 >> 2] + ($4 + 32 | 0) | 0], HEAP32[$4 + 816 >> 2]);
        HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] + 1;
        continue;
       }
       break;
      };
     }
     HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 20 >> 2];
     if (HEAP32[$4 >> 2] == 1) {
      continue
     }
     break;
    };
    if (!(HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] >= 0)) {
     heatshrink_encoder_finish($4 + 288 | 0)
    }
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 832 | 0;
  return HEAP32[$4 + 20 >> 2];
 }
 
 function heatshrink_decode_cb($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 608 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 604 >> 2] = $0;
  HEAP32[$4 + 600 >> 2] = $1;
  HEAP32[$4 + 596 >> 2] = $2;
  HEAP32[$4 + 592 >> 2] = $3;
  heatshrink_decoder_reset($4 + 290 | 0);
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 20 >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  HEAP32[$4 + 8 >> 2] = 0;
  while (1) {
   $0 = 1;
   $0 = HEAP32[$4 + 16 >> 2] < 0 ? HEAP32[$4 + 12 >> 2] != 0 : $0;
   if ($0) {
    if (!HEAP32[$4 + 12 >> 2]) {
     HEAP32[$4 + 8 >> 2] = 0;
     while (1) {
      $0 = 0;
      $0 = HEAPU32[$4 + 12 >> 2] < 128 ? HEAP32[$4 + 16 >> 2] >= 0 : $0;
      if ($0) {
       HEAP32[$4 + 16 >> 2] = FUNCTION_TABLE[HEAP32[$4 + 604 >> 2]](HEAP32[$4 + 600 >> 2]);
       if (HEAP32[$4 + 16 >> 2] >= 0) {
        $1 = HEAP32[$4 + 16 >> 2];
        $0 = HEAP32[$4 + 12 >> 2];
        HEAP32[$4 + 12 >> 2] = $0 + 1;
        HEAP8[($4 + 160 | 0) + $0 | 0] = $1;
       }
       continue;
      }
      break;
     };
    }
    HEAP8[$4 + 7 | 0] = (heatshrink_decoder_sink($4 + 290 | 0, HEAP32[$4 + 8 >> 2] + ($4 + 160 | 0) | 0, HEAP32[$4 + 12 >> 2], $4 + 24 | 0) | 0) >= 0;
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] - HEAP32[$4 + 24 >> 2];
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 8 >> 2];
    if (!(HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] >= 0)) {
     heatshrink_decoder_finish($4 + 290 | 0)
    }
    while (1) {
     HEAP32[$4 >> 2] = heatshrink_decoder_poll($4 + 290 | 0, $4 + 32 | 0, 128, $4 + 24 | 0);
     if (HEAP32[$4 + 596 >> 2]) {
      HEAP32[$4 + 28 >> 2] = 0;
      while (1) {
       if (HEAPU32[$4 + 28 >> 2] < HEAPU32[$4 + 24 >> 2]) {
        FUNCTION_TABLE[HEAP32[$4 + 596 >> 2]](HEAPU8[HEAP32[$4 + 28 >> 2] + ($4 + 32 | 0) | 0], HEAP32[$4 + 592 >> 2]);
        HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] + 1;
        continue;
       }
       break;
      };
     }
     HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 20 >> 2];
     if (HEAP32[$4 >> 2] == 1) {
      continue
     }
     break;
    };
    if (HEAP32[$4 + 16 >> 2] < 0) {
     heatshrink_decoder_finish($4 + 290 | 0)
    }
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 608 | 0;
  return HEAP32[$4 + 20 >> 2];
 }
 
 function heatshrink_decode($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = HEAP32[$3 + 4 >> 2];
  $0 = heatshrink_decode_cb(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] ? 590 : 0, HEAP32[$3 + 4 >> 2] ? $3 : 0);
  __stack_pointer = $3 + 16 | 0;
  return $0;
 }
 
 function graphicsDrawChar4x6($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0;
  $7 = __stack_pointer - 48 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 44 >> 2] = $0;
  HEAP32[$7 + 40 >> 2] = $1;
  HEAP32[$7 + 36 >> 2] = $2;
  HEAP8[$7 + 35 | 0] = $3;
  HEAP16[$7 + 32 >> 1] = $4;
  HEAP16[$7 + 30 >> 1] = $5;
  HEAP8[$7 + 29 | 0] = $6;
  HEAP32[$7 + 24 >> 2] = HEAPU8[$7 + 35 | 0] - 33;
  block1 : {
   if (!(HEAP32[$7 + 24 >> 2] < 100 & HEAP32[$7 + 24 >> 2] >= 0)) {
    if (HEAP8[$7 + 29 | 0] & 1) {
     $0 = HEAP32[$7 + 44 >> 2];
     graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 40 >> 2] + (HEAPU16[$7 + 32 >> 1] << 1) | 0, HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 5) | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
    }
    break block1;
   }
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 24 >> 2] % 5;
   HEAP32[$7 + 24 >> 2] = Math_imul(HEAP32[$7 + 24 >> 2] / 5 | 0, 6);
   HEAP32[$7 + 16 >> 2] = 0;
   while (1) {
    if (HEAP32[$7 + 16 >> 2] < 6) {
     HEAP32[$7 + 12 >> 2] = HEAPU16[(HEAP32[$7 + 24 >> 2] + HEAP32[$7 + 16 >> 2] << 1) + 169216 >> 1] >> Math_imul(HEAP32[$7 + 20 >> 2], 3);
     HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 36 >> 2] + Math_imul(HEAP32[$7 + 16 >> 2], HEAPU16[$7 + 30 >> 1]);
     HEAP32[$7 + 4 >> 2] = 0;
     while (1) {
      if (HEAP32[$7 + 4 >> 2] < 3) {
       HEAP8[$7 + 3 | 0] = (HEAP32[$7 + 12 >> 2] & 4) != 0;
       if (HEAP8[$7 + 29 | 0] & 1 | HEAP8[$7 + 3 | 0] & 1) {
        $1 = HEAP32[$7 + 44 >> 2];
        $2 = HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 4 >> 2], HEAPU16[$7 + 32 >> 1]) | 0;
        $3 = HEAP32[$7 + 8 >> 2];
        $4 = (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], HEAP32[$7 + 4 >> 2] + 1 | 0) | 0) - 1 | 0;
        $5 = (HEAP32[$7 + 8 >> 2] + HEAPU16[$7 + 30 >> 1] | 0) - 1 | 0;
        block3 : {
         if (HEAP8[$7 + 3 | 0] & 1) {
          $0 = HEAP32[$7 + 44 >> 2];
          $0 = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
          break block3;
         }
         $0 = HEAP32[$7 + 44 >> 2];
         $0 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
        }
        graphicsFillRect($1, $2, $3, $4, $5, $0);
       }
       HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] << 1;
       HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
     continue;
    }
    break;
   };
   if (!(HEAP8[$7 + 29 | 0] & 1)) {
    break block1
   }
   $0 = HEAP32[$7 + 44 >> 2];
   graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 3) | 0, HEAP32[$7 + 36 >> 2], (HEAP32[$7 + 40 >> 2] + (HEAPU16[$7 + 32 >> 1] << 2) | 0) - 1 | 0, (HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 6) | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
  }
  __stack_pointer = $7 + 48 | 0;
 }
 
 function graphicsDrawChar6x8($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0;
  $7 = __stack_pointer - 48 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 44 >> 2] = $0;
  HEAP32[$7 + 40 >> 2] = $1;
  HEAP32[$7 + 36 >> 2] = $2;
  HEAP8[$7 + 35 | 0] = $3;
  HEAP16[$7 + 32 >> 1] = $4;
  HEAP16[$7 + 30 >> 1] = $5;
  HEAP8[$7 + 29 | 0] = $6;
  HEAP32[$7 + 24 >> 2] = HEAPU8[$7 + 35 | 0] - 33;
  block1 : {
   if (!(HEAP32[$7 + 24 >> 2] < 223 & HEAP32[$7 + 24 >> 2] >= 0)) {
    if (HEAP8[$7 + 29 | 0] & 1) {
     $0 = HEAP32[$7 + 44 >> 2];
     graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 5) | 0, HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 7) | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
    }
    break block1;
   }
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 24 >> 2] % 6;
   HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 24 >> 2] / 6 << 3;
   HEAP32[$7 + 16 >> 2] = 0;
   while (1) {
    if (HEAP32[$7 + 16 >> 2] < 8) {
     HEAP32[$7 + 12 >> 2] = HEAP32[(HEAP32[$7 + 24 >> 2] + HEAP32[$7 + 16 >> 2] << 2) + 169456 >> 2] >>> Math_imul(HEAP32[$7 + 20 >> 2], 5);
     HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 36 >> 2] + Math_imul(HEAP32[$7 + 16 >> 2], HEAPU16[$7 + 30 >> 1]);
     HEAP32[$7 + 4 >> 2] = 0;
     while (1) {
      if (HEAP32[$7 + 4 >> 2] < 5) {
       HEAP8[$7 + 3 | 0] = (HEAP32[$7 + 12 >> 2] & 16) != 0;
       if (HEAP8[$7 + 29 | 0] & 1 | HEAP8[$7 + 3 | 0] & 1) {
        $1 = HEAP32[$7 + 44 >> 2];
        $2 = HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 4 >> 2], HEAPU16[$7 + 32 >> 1]) | 0;
        $3 = HEAP32[$7 + 8 >> 2];
        $4 = (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], HEAP32[$7 + 4 >> 2] + 1 | 0) | 0) - 1 | 0;
        $5 = (HEAP32[$7 + 8 >> 2] + HEAPU16[$7 + 30 >> 1] | 0) - 1 | 0;
        block3 : {
         if (HEAP8[$7 + 3 | 0] & 1) {
          $0 = HEAP32[$7 + 44 >> 2];
          $0 = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
          break block3;
         }
         $0 = HEAP32[$7 + 44 >> 2];
         $0 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
        }
        graphicsFillRect($1, $2, $3, $4, $5, $0);
       }
       HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] << 1;
       HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
     continue;
    }
    break;
   };
   if (!(HEAP8[$7 + 29 | 0] & 1)) {
    break block1
   }
   $0 = HEAP32[$7 + 44 >> 2];
   graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 5) | 0, HEAP32[$7 + 36 >> 2], (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 6) | 0) - 1 | 0, (HEAP32[$7 + 36 >> 2] + (HEAPU16[$7 + 30 >> 1] << 3) | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
  }
  __stack_pointer = $7 + 48 | 0;
 }
 
 function vfGetCharFromPtr($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0;
  $8 = __stack_pointer - 256 | 0;
  __stack_pointer = $8;
  HEAP32[$8 + 252 >> 2] = $0;
  HEAP32[$8 + 248 >> 2] = $1;
  HEAP32[$8 + 244 >> 2] = $2;
  HEAP32[$8 + 240 >> 2] = $3;
  HEAP32[$8 + 236 >> 2] = $4;
  HEAP32[$8 + 232 >> 2] = $5;
  HEAP32[$8 + 228 >> 2] = $6;
  HEAP32[$8 + 224 >> 2] = $7;
  HEAP32[$8 + 244 >> 2] = (HEAP32[$8 + 244 >> 2] << 4) - 8;
  HEAP32[$8 + 240 >> 2] = (HEAP32[$8 + 240 >> 2] << 4) - 8;
  HEAP32[$8 + 220 >> 2] = 0;
  HEAP32[$8 + 216 >> 2] = 0;
  while (1) {
   if (HEAP32[$8 + 216 >> 2] < HEAP32[$8 + 224 >> 2]) {
    HEAP32[$8 + 24 >> 2] = vfGetPolyPtr(HEAPU8[HEAP32[$8 + 228 >> 2] + HEAP32[$8 + 216 >> 2] | 0], $8 + 28 | 0);
    HEAP32[$8 + 20 >> 2] = 0;
    while (1) {
     if (HEAP32[$8 + 20 >> 2] < HEAP32[$8 + 28 >> 2]) {
      HEAP8[$8 + 19 | 0] = HEAPU8[HEAP32[$8 + 24 >> 2] + HEAP32[$8 + 20 >> 2] | 0];
      HEAP32[$8 + 12 >> 2] = HEAPU8[$8 + 19 | 0] % 13;
      HEAP32[$8 + 8 >> 2] = HEAPU8[$8 + 19 | 0] / 13;
      if (HEAP32[$8 + 12 >> 2] > HEAP32[$8 + 220 >> 2]) {
       HEAP32[$8 + 220 >> 2] = HEAP32[$8 + 12 >> 2]
      }
      HEAP16[($8 + 32 | 0) + (HEAP32[$8 + 20 >> 2] << 2) >> 1] = HEAP32[$8 + 244 >> 2] + ((Math_imul(HEAP32[$8 + 12 >> 2], HEAP32[$8 + 236 >> 2]) << 4) / 16 | 0);
      HEAP16[((HEAP32[$8 + 20 >> 2] << 2) + $8 | 0) + 34 >> 1] = HEAP32[$8 + 240 >> 2] + ((Math_imul(HEAP32[$8 + 232 >> 2], HEAP32[$8 + 8 >> 2] - 2 | 0) << 4) / 16 | 0);
      HEAP32[$8 + 20 >> 2] = HEAP32[$8 + 20 >> 2] + 1;
      continue;
     }
     break;
    };
    FUNCTION_TABLE[HEAP32[$8 + 252 >> 2]](HEAP32[$8 + 248 >> 2], HEAP32[$8 + 28 >> 2], $8 + 32 | 0);
    HEAP32[$8 + 216 >> 2] = HEAP32[$8 + 216 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $8 + 256 | 0;
  return ((Math_imul(HEAP32[$8 + 236 >> 2], HEAP32[$8 + 220 >> 2] + 2 | 0) << 4) / 16 | 0) + 7 >> 4;
 }
 
 function vfGetPolyPtr($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP8[$2 + 27 | 0] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (HEAPU8[$2 + 27 | 0] >= 201) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[HEAPU8[$2 + 27 | 0] + 170672 | 0];
   HEAP32[$2 + 16 >> 2] = 170880;
   HEAP8[$2 + 15 | 0] = 0;
   while (1) {
    if (HEAPU8[$2 + 15 | 0] < HEAPU8[$2 + 27 | 0]) {
     HEAP32[$2 + 16 >> 2] = HEAPU8[HEAPU8[$2 + 15 | 0] + 170672 | 0] + HEAP32[$2 + 16 >> 2];
     HEAP8[$2 + 15 | 0] = HEAPU8[$2 + 15 | 0] + 1;
     continue;
    }
    break;
   };
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  return HEAP32[$2 + 28 >> 2];
 }
 
 function graphicsVectorCharWidth($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP8[$2 + 39 | 0] = $1;
  HEAP32[$2 + 28 >> 2] = vfGetCharPtr(HEAP8[$2 + 39 | 0] << 24 >> 24, $2 + 32 | 0);
  block : {
   if (!HEAP32[$2 + 28 >> 2]) {
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 40 >> 2] >>> 1;
    break block;
   }
   HEAP32[$2 + 24 >> 2] = 0;
   HEAP32[$2 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 20 >> 2] < HEAP32[$2 + 32 >> 2]) {
     HEAP32[$2 + 12 >> 2] = vfGetPolyPtr(HEAPU8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 20 >> 2] | 0], $2 + 16 | 0);
     HEAP32[$2 + 8 >> 2] = 0;
     while (1) {
      if (HEAP32[$2 + 8 >> 2] < HEAP32[$2 + 16 >> 2]) {
       HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0];
       HEAP32[$2 >> 2] = HEAPU8[$2 + 7 | 0] % 13;
       if (HEAP32[$2 >> 2] > HEAP32[$2 + 24 >> 2]) {
        HEAP32[$2 + 24 >> 2] = HEAP32[$2 >> 2]
       }
       HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$2 + 44 >> 2] = (Math_imul(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 24 >> 2] + 2 | 0) & 268435455) + 7 >>> 4;
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function vfGetCharPtr($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP8[$2 + 27 | 0] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP8[$2 + 19 | 0] = HEAPU8[$2 + 27 | 0];
  block1 : {
   if (!(HEAPU8[$2 + 19 | 0] <= 255 & HEAPU8[$2 + 19 | 0] >= 33)) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block1;
   }
   HEAP8[$2 + 19 | 0] = HEAPU8[$2 + 19 | 0] - 33;
   HEAP32[$2 + 12 >> 2] = 172784;
   HEAP8[$2 + 11 | 0] = 0;
   while (1) {
    if (HEAPU8[$2 + 11 | 0] < HEAPU8[$2 + 19 | 0]) {
     HEAP32[$2 + 12 >> 2] = HEAPU8[HEAPU8[$2 + 11 | 0] + 173136 | 0] + HEAP32[$2 + 12 >> 2];
     HEAP8[$2 + 11 | 0] = HEAPU8[$2 + 11 | 0] + 1;
     continue;
    }
    break;
   };
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[HEAPU8[$2 + 19 | 0] + 173136 | 0];
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  return HEAP32[$2 + 28 >> 2];
 }
 
 function graphicsGetVectorChar($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0;
  $7 = __stack_pointer - 48 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 40 >> 2] = $0;
  HEAP32[$7 + 36 >> 2] = $1;
  HEAP32[$7 + 32 >> 2] = $2;
  HEAP32[$7 + 28 >> 2] = $3;
  HEAP32[$7 + 24 >> 2] = $4;
  HEAP32[$7 + 20 >> 2] = $5;
  HEAP8[$7 + 19 | 0] = $6;
  HEAP32[$7 + 8 >> 2] = vfGetCharPtr(HEAP8[$7 + 19 | 0] << 24 >> 24, $7 + 12 | 0);
  block : {
   if (!HEAP32[$7 + 8 >> 2]) {
    HEAP32[$7 + 44 >> 2] = HEAP32[$7 + 24 >> 2] / 2;
    break block;
   }
   HEAP32[$7 + 44 >> 2] = vfGetCharFromPtr(HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 32 >> 2], HEAP32[$7 + 28 >> 2], HEAP32[$7 + 24 >> 2], HEAP32[$7 + 20 >> 2], HEAP32[$7 + 8 >> 2], HEAP32[$7 + 12 >> 2]);
  }
  __stack_pointer = $7 + 48 | 0;
  return HEAP32[$7 + 44 >> 2];
 }
 
 function jspbfFontNew($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jsvLockAgain(HEAP32[$2 + 8 >> 2]);
  HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = $0;
  jsvStringIteratorNew(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2], 0);
  $0 = jspbfGetU8(HEAP32[$2 + 12 >> 2] + 4 | 0);
  HEAP8[HEAP32[$2 + 12 >> 2] + 44 | 0] = $0;
  $0 = jspbfGetU8(HEAP32[$2 + 12 >> 2] + 4 | 0);
  HEAP8[HEAP32[$2 + 12 >> 2] + 45 | 0] = $0;
  $0 = jspbfGetU16(HEAP32[$2 + 12 >> 2] + 4 | 0);
  HEAP16[HEAP32[$2 + 12 >> 2] + 46 >> 1] = $0;
  jspbfGetU16(HEAP32[$2 + 12 >> 2] + 4 | 0);
  HEAP16[HEAP32[$2 + 12 >> 2] + 48 >> 1] = 6;
  HEAP8[HEAP32[$2 + 12 >> 2] + 50 | 0] = 255;
  HEAP8[HEAP32[$2 + 12 >> 2] + 64 | 0] = 0;
  HEAP8[HEAP32[$2 + 12 >> 2] + 52 | 0] = 6;
  HEAP8[HEAP32[$2 + 12 >> 2] + 51 | 0] = 2;
  if (HEAPU8[HEAP32[$2 + 12 >> 2] + 44 | 0] >= 2) {
   HEAP16[HEAP32[$2 + 12 >> 2] + 48 >> 1] = 8;
   $0 = jspbfGetU8(HEAP32[$2 + 12 >> 2] + 4 | 0);
   HEAP8[HEAP32[$2 + 12 >> 2] + 50 | 0] = $0;
   $0 = jspbfGetU8(HEAP32[$2 + 12 >> 2] + 4 | 0);
   HEAP8[HEAP32[$2 + 12 >> 2] + 51 | 0] = $0;
  }
  if (HEAPU8[HEAP32[$2 + 12 >> 2] + 44 | 0] >= 3) {
   $0 = jspbfGetU8(HEAP32[$2 + 12 >> 2] + 4 | 0);
   HEAP16[HEAP32[$2 + 12 >> 2] + 48 >> 1] = $0 & 255;
   HEAP8[$2 + 7 | 0] = jspbfGetU8(HEAP32[$2 + 12 >> 2] + 4 | 0);
   if (HEAP8[$2 + 7 | 0] & 1) {
    HEAP8[HEAP32[$2 + 12 >> 2] + 52 | 0] = 4
   }
   if (HEAPU8[$2 + 7 | 0] & 128) {
    HEAP8[HEAP32[$2 + 12 >> 2] + 64 | 0] = 1
   }
  }
  HEAP32[HEAP32[$2 + 12 >> 2] + 56 >> 2] = HEAPU16[HEAP32[$2 + 12 >> 2] + 48 >> 1] + (HEAPU8[HEAP32[$2 + 12 >> 2] + 50 | 0] << 2);
  HEAP32[HEAP32[$2 + 12 >> 2] + 60 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 56 >> 2] + Math_imul(HEAPU16[HEAP32[$2 + 12 >> 2] + 46 >> 1], HEAPU8[HEAP32[$2 + 12 >> 2] + 52 | 0]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jspbfGetU8($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvStringIteratorGetCharAndNext(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 255;
 }
 
 function jspbfGetU16($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvStringIteratorGetCharAndNext(HEAP32[$1 + 12 >> 2]) & 255;
  $2 = (jsvStringIteratorGetCharAndNext(HEAP32[$1 + 12 >> 2]) & 255) << 8;
  __stack_pointer = $1 + 16 | 0;
  return $0 | $2;
 }
 
 function jspbfFontFree($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvStringIteratorFree_1085(HEAP32[$1 + 12 >> 2] + 4 | 0);
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsvStringIteratorFree_1085($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jspbfFontFindGlyph($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 40 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  HEAP32[$3 + 32 >> 2] = $2;
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 36 >> 2] % HEAPU8[HEAP32[$3 + 40 >> 2] + 50 | 0];
  jsvStringIteratorGoto(HEAP32[$3 + 40 >> 2] + 4 | 0, HEAP32[HEAP32[$3 + 40 >> 2] >> 2], HEAPU16[HEAP32[$3 + 40 >> 2] + 48 >> 1] + (HEAP32[$3 + 28 >> 2] << 2) | 0);
  HEAP8[$3 + 27 | 0] = jspbfGetU8(HEAP32[$3 + 40 >> 2] + 4 | 0);
  HEAP8[$3 + 26 | 0] = jspbfGetU8(HEAP32[$3 + 40 >> 2] + 4 | 0);
  HEAP16[$3 + 24 >> 1] = jspbfGetU16(HEAP32[$3 + 40 >> 2] + 4 | 0);
  HEAP32[$3 + 20 >> 2] = HEAPU16[$3 + 24 >> 1] + HEAP32[HEAP32[$3 + 40 >> 2] + 56 >> 2];
  if (HEAP8[HEAP32[$3 + 40 >> 2] + 64 | 0] & 1) {
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + (HEAPU8[$3 + 27 | 0] << 16)
  }
  jsvStringIteratorGoto(HEAP32[$3 + 40 >> 2] + 4 | 0, HEAP32[HEAP32[$3 + 40 >> 2] >> 2], HEAP32[$3 + 20 >> 2]);
  block3 : {
   while (1) {
    block : {
     $0 = HEAPU8[$3 + 26 | 0];
     HEAP8[$3 + 26 | 0] = $0 - 1;
     if (!$0) {
      break block
     }
     block1 : {
      if (HEAPU8[HEAP32[$3 + 40 >> 2] + 51 | 0] == 2) {
       $0 = jspbfGetU16(HEAP32[$3 + 40 >> 2] + 4 | 0) & 65535;
       break block1;
      }
      $0 = jspbfGetU32(HEAP32[$3 + 40 >> 2] + 4 | 0);
     }
     HEAP32[$3 + 16 >> 2] = $0;
     block2 : {
      if (HEAPU8[HEAP32[$3 + 40 >> 2] + 52 | 0] == 4) {
       $0 = jspbfGetU16(HEAP32[$3 + 40 >> 2] + 4 | 0) & 65535;
       break block2;
      }
      $0 = jspbfGetU32(HEAP32[$3 + 40 >> 2] + 4 | 0);
     }
     HEAP32[$3 + 12 >> 2] = $0;
     if (HEAP32[$3 + 16 >> 2] != HEAP32[$3 + 36 >> 2]) {
      continue
     }
     jsvStringIteratorGoto(HEAP32[$3 + 40 >> 2] + 4 | 0, HEAP32[HEAP32[$3 + 40 >> 2] >> 2], HEAP32[HEAP32[$3 + 40 >> 2] + 60 >> 2] + HEAP32[$3 + 12 >> 2] | 0);
     $0 = jspbfGetU8(HEAP32[$3 + 40 >> 2] + 4 | 0);
     HEAP8[HEAP32[$3 + 32 >> 2]] = $0;
     $0 = jspbfGetU8(HEAP32[$3 + 40 >> 2] + 4 | 0);
     HEAP8[HEAP32[$3 + 32 >> 2] + 1 | 0] = $0;
     $0 = jspbfGetU8(HEAP32[$3 + 40 >> 2] + 4 | 0);
     HEAP8[HEAP32[$3 + 32 >> 2] + 2 | 0] = $0;
     $0 = jspbfGetU8(HEAP32[$3 + 40 >> 2] + 4 | 0);
     HEAP8[HEAP32[$3 + 32 >> 2] + 3 | 0] = $0;
     $0 = jspbfGetU8(HEAP32[$3 + 40 >> 2] + 4 | 0);
     HEAP8[HEAP32[$3 + 32 >> 2] + 4 | 0] = $0;
     HEAP8[HEAP32[$3 + 32 >> 2] + 5 | 0] = 1;
     if (HEAPU8[HEAP32[$3 + 32 >> 2] + 4 | 0] & 128) {
      $0 = HEAP32[$3 + 32 >> 2];
      HEAP8[$0 + 4 | 0] = HEAP8[$0 + 4 | 0] << 24 >> 24 & 127;
      HEAP8[HEAP32[$3 + 32 >> 2] + 5 | 0] = 2;
     }
     HEAP8[$3 + 47 | 0] = 1;
     break block3;
    }
    break;
   };
   HEAP8[$3 + 47 | 0] = 0;
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP8[$3 + 47 | 0] & 1;
 }
 
 function jspbfGetU32($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvStringIteratorGetCharAndNext(HEAP32[$1 + 12 >> 2]) & 255 | (jsvStringIteratorGetCharAndNext(HEAP32[$1 + 12 >> 2]) & 255) << 8 | (jsvStringIteratorGetCharAndNext(HEAP32[$1 + 12 >> 2]) & 255) << 16;
  $2 = (jsvStringIteratorGetCharAndNext(HEAP32[$1 + 12 >> 2]) & 255) << 24;
  __stack_pointer = $1 + 16 | 0;
  return $0 | $2;
 }
 
 function jspbfFontRenderGlyph($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0;
  $8 = __stack_pointer + -64 | 0;
  __stack_pointer = $8;
  HEAP32[$8 + 60 >> 2] = $0;
  HEAP32[$8 + 56 >> 2] = $1;
  HEAP32[$8 + 52 >> 2] = $2;
  HEAP32[$8 + 48 >> 2] = $3;
  HEAP32[$8 + 44 >> 2] = $4;
  HEAP8[$8 + 43 | 0] = $5;
  HEAP32[$8 + 36 >> 2] = $6;
  HEAP32[$8 + 32 >> 2] = $7;
  HEAP32[$8 + 28 >> 2] = 0;
  HEAP32[$8 + 24 >> 2] = HEAPU8[HEAP32[$8 + 56 >> 2] + 5 | 0];
  HEAP32[$8 + 20 >> 2] = (1 << HEAP32[$8 + 24 >> 2]) - 1;
  HEAP32[$8 + 8 >> 2] = jsvStringIteratorGetCharAndNext(HEAP32[$8 + 60 >> 2] + 4 | 0) << 24 >> 24;
  HEAP32[$8 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$8 + 12 >> 2] < HEAPU8[HEAP32[$8 + 56 >> 2] + 1 | 0]) {
    HEAP32[$8 + 16 >> 2] = 0;
    while (1) {
     if (HEAP32[$8 + 16 >> 2] < HEAPU8[HEAP32[$8 + 56 >> 2]]) {
      HEAP32[$8 + 4 >> 2] = HEAP32[$8 + 8 >> 2] & HEAP32[$8 + 20 >> 2];
      if (HEAP8[$8 + 43 | 0] & 1 | HEAP32[$8 + 4 >> 2]) {
       graphicsFillRect(HEAP32[$8 + 52 >> 2], HEAP32[$8 + 48 >> 2] + Math_imul(HEAP32[$8 + 16 >> 2], HEAP32[$8 + 36 >> 2]) | 0, HEAP32[$8 + 44 >> 2] + Math_imul(HEAP32[$8 + 12 >> 2], HEAP32[$8 + 32 >> 2]) | 0, (HEAP32[$8 + 36 >> 2] + (HEAP32[$8 + 48 >> 2] + Math_imul(HEAP32[$8 + 16 >> 2], HEAP32[$8 + 36 >> 2]) | 0) | 0) - 1 | 0, (HEAP32[$8 + 32 >> 2] + (HEAP32[$8 + 44 >> 2] + Math_imul(HEAP32[$8 + 12 >> 2], HEAP32[$8 + 32 >> 2]) | 0) | 0) - 1 | 0, graphicsBlendGfxColor(HEAP32[$8 + 52 >> 2], (HEAP32[$8 + 4 >> 2] << 8) / HEAP32[$8 + 20 >> 2] | 0))
      }
      HEAP32[$8 + 28 >> 2] = HEAP32[$8 + 24 >> 2] + HEAP32[$8 + 28 >> 2];
      HEAP32[$8 + 8 >> 2] = HEAP32[$8 + 8 >> 2] >> HEAP32[$8 + 24 >> 2];
      if (HEAP32[$8 + 28 >> 2] >= 8) {
       HEAP32[$8 + 28 >> 2] = 0;
       HEAP32[$8 + 8 >> 2] = jsvStringIteratorGetCharAndNext(HEAP32[$8 + 60 >> 2] + 4 | 0) << 24 >> 24;
      }
      HEAP32[$8 + 16 >> 2] = HEAP32[$8 + 16 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$8 + 12 >> 2] = HEAP32[$8 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $8 - -64 | 0;
 }
 
 function graphicsFallbackSetPixel($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
 }
 
 function graphicsFallbackGetPixel($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = HEAP32[$3 + 12 >> 2];
  return HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
 }
 
 function graphicsFallbackFillRect($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  HEAP32[$6 >> 2] = HEAP32[$6 + 20 >> 2];
  while (1) {
   if (HEAP32[$6 >> 2] <= HEAP32[$6 + 12 >> 2]) {
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 24 >> 2];
    while (1) {
     if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 16 >> 2]) {
      graphicsSetPixelDevice(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 >> 2], HEAP32[$6 + 8 >> 2]);
      HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $6 + 32 | 0;
 }
 
 function graphicsSetPixelDevice($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = HEAP32[$4 + 12 >> 2];
  block : {
   if (HEAP32[$4 + 8 >> 2] < (HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8)) {
    break block
   }
   $0 = HEAP32[$4 + 12 >> 2];
   if (HEAP32[$4 + 4 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
    break block
   }
   $0 = HEAP32[$4 + 12 >> 2];
   if (HEAP32[$4 + 8 >> 2] > (HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8)) {
    break block
   }
   $0 = HEAP32[$4 + 12 >> 2];
   if (HEAP32[$4 + 4 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
    break block
   }
   $0 = HEAP32[$4 + 12 >> 2];
   if (HEAP32[$4 + 8 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$4 + 12 >> 2];
    $1 = HEAP32[$4 + 8 >> 2];
    HEAP8[$0 + 40 | 0] = $1;
    HEAP8[$0 + 41 | 0] = $1 >>> 8;
   }
   $0 = HEAP32[$4 + 12 >> 2];
   if (HEAP32[$4 + 8 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$4 + 12 >> 2];
    $1 = HEAP32[$4 + 8 >> 2];
    HEAP8[$0 + 44 | 0] = $1;
    HEAP8[$0 + 45 | 0] = $1 >>> 8;
   }
   $0 = HEAP32[$4 + 12 >> 2];
   if (HEAP32[$4 + 4 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$4 + 12 >> 2];
    $1 = HEAP32[$4 + 4 >> 2];
    HEAP8[$0 + 42 | 0] = $1;
    HEAP8[$0 + 43 | 0] = $1 >>> 8;
   }
   $0 = HEAP32[$4 + 12 >> 2];
   if (HEAP32[$4 + 4 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$4 + 12 >> 2];
    $1 = HEAP32[$4 + 4 >> 2];
    HEAP8[$0 + 46 | 0] = $1;
    HEAP8[$0 + 47 | 0] = $1 >>> 8;
   }
   $0 = HEAP32[$4 + 12 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24)](HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2] & (1 << HEAPU8[HEAP32[$4 + 12 >> 2] + 16 | 0]) - 1);
  }
  __stack_pointer = $4 + 16 | 0;
 }
 
 function graphicsFallbackBlit($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  var $7 = 0;
  $7 = __stack_pointer - 48 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 44 >> 2] = $0;
  HEAP32[$7 + 40 >> 2] = $1;
  HEAP32[$7 + 36 >> 2] = $2;
  HEAP32[$7 + 32 >> 2] = $3;
  HEAP32[$7 + 28 >> 2] = $4;
  HEAP32[$7 + 24 >> 2] = $5;
  HEAP32[$7 + 20 >> 2] = $6;
  HEAP32[$7 + 16 >> 2] = 0;
  while (1) {
   if (HEAP32[$7 + 16 >> 2] < HEAP32[$7 + 28 >> 2]) {
    HEAP32[$7 + 12 >> 2] = 0;
    while (1) {
     if (HEAP32[$7 + 12 >> 2] < HEAP32[$7 + 32 >> 2]) {
      $0 = HEAP32[$7 + 44 >> 2];
      $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
      $0 = HEAP32[$7 + 44 >> 2];
      FUNCTION_TABLE[$1 | 0](HEAP32[$7 + 44 >> 2], HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 24 >> 2] | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 20 >> 2] | 0, FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$7 + 44 >> 2], HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 40 >> 2] | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 36 >> 2] | 0) | 0);
      HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $7 + 48 | 0;
 }
 
 function graphicsFallbackScrollX($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  block : {
   if (HEAP32[$6 + 24 >> 2] <= 0) {
    HEAP32[$6 >> 2] = HEAP32[$6 + 8 >> 2] + HEAP32[$6 + 24 >> 2];
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 12 >> 2];
    while (1) {
     if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 >> 2]) {
      $0 = HEAP32[$6 + 28 >> 2];
      $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
      $0 = HEAP32[$6 + 28 >> 2];
      FUNCTION_TABLE[$1 | 0](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 16 >> 2], FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2] - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 20 >> 2]) | 0);
      HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
      continue;
     }
     break;
    };
    break block;
   }
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 8 >> 2] - HEAP32[$6 + 24 >> 2];
   while (1) {
    if (HEAP32[$6 + 4 >> 2] >= HEAP32[$6 + 12 >> 2]) {
     $0 = HEAP32[$6 + 28 >> 2];
     $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
     $0 = HEAP32[$6 + 28 >> 2];
     FUNCTION_TABLE[$1 | 0](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2] + HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 16 >> 2], FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 20 >> 2]) | 0);
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] - 1;
     continue;
    }
    break;
   };
  }
  __stack_pointer = $6 + 32 | 0;
 }
 
 function graphicsFallbackScroll($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  var $7 = 0;
  $7 = __stack_pointer - 48 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 44 >> 2] = $0;
  HEAP32[$7 + 40 >> 2] = $1;
  HEAP32[$7 + 36 >> 2] = $2;
  HEAP32[$7 + 32 >> 2] = $3;
  HEAP32[$7 + 28 >> 2] = $4;
  HEAP32[$7 + 24 >> 2] = $5;
  HEAP32[$7 + 20 >> 2] = $6;
  block1 : {
   if (!(HEAP32[$7 + 40 >> 2] | HEAP32[$7 + 36 >> 2])) {
    break block1
   }
   if (HEAP32[$7 + 36 >> 2] <= 0) {
    HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 20 >> 2] + HEAP32[$7 + 36 >> 2];
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 28 >> 2];
    while (1) {
     if (HEAP32[$7 + 16 >> 2] <= HEAP32[$7 + 12 >> 2]) {
      graphicsFallbackScrollX(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 16 >> 2] - HEAP32[$7 + 36 >> 2] | 0, HEAP32[$7 + 16 >> 2], HEAP32[$7 + 32 >> 2], HEAP32[$7 + 24 >> 2]);
      HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
      continue;
     }
     break;
    };
    break block1;
   }
   HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 20 >> 2] - HEAP32[$7 + 36 >> 2];
   while (1) {
    if (HEAP32[$7 + 16 >> 2] >= HEAP32[$7 + 28 >> 2]) {
     graphicsFallbackScrollX(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 16 >> 2], HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 36 >> 2] | 0, HEAP32[$7 + 32 >> 2], HEAP32[$7 + 24 >> 2]);
     HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] - 1;
     continue;
    }
    break;
   };
  }
  __stack_pointer = $7 + 48 | 0;
 }
 
 function graphicsStructResetState($0) {
  var $1 = 0, $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  block1 : {
   block : {
    $0 = HEAP32[$2 + 12 >> 2];
    if (!(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24))) {
     break block
    }
    $0 = HEAP32[$2 + 12 >> 2];
    if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 1) {
     break block
    }
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU8[416613] | HEAPU8[416614] << 8;
    HEAP8[$0 + 17 | 0] = $1;
    HEAP8[$0 + 18 | 0] = $1 >>> 8;
    HEAP8[$0 + 19 | 0] = $1 >>> 16;
    HEAP8[$0 + 20 | 0] = $1 >>> 24;
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU8[416615] | HEAPU8[416616] << 8;
    HEAP8[$0 + 21 | 0] = $1;
    HEAP8[$0 + 22 | 0] = $1 >>> 8;
    HEAP8[$0 + 23 | 0] = $1 >>> 16;
    HEAP8[$0 + 24 | 0] = $1 >>> 24;
    break block1;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU8[HEAP32[$2 + 12 >> 2] + 16 | 0] >= 32 ? -1 : (1 << HEAPU8[HEAP32[$2 + 12 >> 2] + 16 | 0]) - 1 | 0;
   HEAP8[$0 + 17 | 0] = $1;
   HEAP8[$0 + 18 | 0] = $1 >>> 8;
   HEAP8[$0 + 19 | 0] = $1 >>> 16;
   HEAP8[$0 + 20 | 0] = $1 >>> 24;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP8[$0 + 21 | 0] = 0;
   HEAP8[$0 + 22 | 0] = 0;
   HEAP8[$0 + 23 | 0] = 0;
   HEAP8[$0 + 24 | 0] = 0;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 25 | 0] = 1;
  HEAP8[$0 + 26 | 0] = 32;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] | 3;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] | 12;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] & -49;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 32 | 0] = 0;
  HEAP8[$0 + 33 | 0] = 0;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 34 | 0] = 0;
  HEAP8[$0 + 35 | 0] = 0;
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = HEAP32[$2 + 12 >> 2];
  $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) - 1 | 0;
  HEAP8[$0 + 36 | 0] = $1;
  HEAP8[$0 + 37 | 0] = $1 >>> 8;
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = HEAP32[$2 + 12 >> 2];
  $1 = (HEAPU8[$1 + 14 | 0] | HEAPU8[$1 + 15 | 0] << 8) - 1 | 0;
  HEAP8[$0 + 38 | 0] = $1;
  HEAP8[$0 + 39 | 0] = $1 >>> 8;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 27 | 0] = 0;
  HEAP8[$0 + 28 | 0] = 0;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 29 | 0] = 0;
  HEAP8[$0 + 30 | 0] = 0;
 }
 
 function graphicsStructInit($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP8[$0 + 8 | 0] = 0;
  HEAP8[$0 + 9 | 0] = 0;
  HEAP8[$0 + 10 | 0] = 0;
  HEAP8[$0 + 11 | 0] = 0;
  $0 = HEAP32[$4 + 12 >> 2];
  $1 = HEAP32[$4 + 8 >> 2];
  HEAP8[$0 + 12 | 0] = $1;
  HEAP8[$0 + 13 | 0] = $1 >>> 8;
  $0 = HEAP32[$4 + 12 >> 2];
  $1 = HEAP32[$4 + 4 >> 2];
  HEAP8[$0 + 14 | 0] = $1;
  HEAP8[$0 + 15 | 0] = $1 >>> 8;
  HEAP8[HEAP32[$4 + 12 >> 2] + 16 | 0] = HEAP32[$4 >> 2];
  graphicsStructResetState(HEAP32[$4 + 12 >> 2]);
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP8[$0 + 44 | 0] = 0;
  HEAP8[$0 + 45 | 0] = 128;
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP8[$0 + 46 | 0] = 0;
  HEAP8[$0 + 47 | 0] = 128;
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP8[$0 + 40 | 0] = 255;
  HEAP8[$0 + 41 | 0] = 127;
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP8[$0 + 42 | 0] = 255;
  HEAP8[$0 + 43 | 0] = 127;
  __stack_pointer = $4 + 16 | 0;
 }
 
 function graphicsSetCallbacks($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 + 52 | 0] = 79;
  HEAP8[$0 + 53 | 0] = 2;
  HEAP8[$0 + 54 | 0] = 0;
  HEAP8[$0 + 55 | 0] = 0;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 + 60 | 0] = 80;
  HEAP8[$0 + 61 | 0] = 2;
  HEAP8[$0 + 62 | 0] = 0;
  HEAP8[$0 + 63 | 0] = 0;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 + 56 | 0] = 81;
  HEAP8[$0 + 57 | 0] = 2;
  HEAP8[$0 + 58 | 0] = 0;
  HEAP8[$0 + 59 | 0] = 0;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 + 64 | 0] = 82;
  HEAP8[$0 + 65 | 0] = 2;
  HEAP8[$0 + 66 | 0] = 0;
  HEAP8[$0 + 67 | 0] = 0;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 + 68 | 0] = 83;
  HEAP8[$0 + 69 | 0] = 2;
  HEAP8[$0 + 70 | 0] = 0;
  HEAP8[$0 + 71 | 0] = 0;
  $0 = HEAP32[$1 + 8 >> 2];
  block3 : {
   block : {
    if (!(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24))) {
     lcdSetCallbacks_ArrayBuffer(HEAP32[$1 + 8 >> 2]);
     break block;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    block1 : {
     if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 1) {
      lcdSetCallbacks_JS(HEAP32[$1 + 8 >> 2]);
      break block1;
     }
     block2 : {
      $0 = HEAP32[$1 + 8 >> 2];
      if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 6) {
       lcdMemLCD_setCallbacks(HEAP32[$1 + 8 >> 2]);
       break block2;
      }
      HEAP8[$1 + 15 | 0] = 0;
      break block3;
     }
    }
   }
   HEAP8[$1 + 15 | 0] = 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function graphicsGetFromVar($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  $0 = HEAP32[$2 + 8 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  HEAP32[$2 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 4 >> 2], 3830);
  block : {
   if (!HEAP32[$2 >> 2]) {
    wasm2js_memory_copy(HEAP32[$2 + 8 >> 2], 416628, 72);
    HEAP8[$2 + 15 | 0] = 1;
    break block;
   }
   if (HEAP32[$2 >> 2]) {
    jsvGetStringChars(HEAP32[$2 >> 2], 0, HEAP32[$2 + 8 >> 2] + 4 | 0, 44);
    jsvUnLock(HEAP32[$2 >> 2]);
    HEAP8[$2 + 15 | 0] = graphicsSetCallbacks(HEAP32[$2 + 8 >> 2]) & 1;
    break block;
   }
   HEAP8[$2 + 15 | 0] = 0;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP8[$2 + 15 | 0] & 1;
 }
 
 function graphicsSetVarInitial($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = jsvFindOrAddChildFromString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 3830);
  HEAP32[$1 + 4 >> 2] = jsvSkipName(HEAP32[$1 + 8 >> 2]);
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 4 >> 2] = jsvNewStringOfLength(44, 0);
   jsvSetValueOfName(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  jsvSetString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2] + 4 | 0, 44);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function graphicsSetVar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 3830));
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    wasm2js_memory_copy(416628, HEAP32[$1 + 12 >> 2], 72);
    break block;
   }
   if (!HEAP32[$1 + 8 >> 2]) {
    break block
   }
   jsvSetString(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2] + 4 | 0, 44);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function graphicsGetMemoryRequired($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = HEAP32[$1 + 12 >> 2];
  return Math_imul(HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0], Math_imul(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8, HEAPU8[$2 + 14 | 0] | HEAPU8[$2 + 15 | 0] << 8)) + 7 >>> 3 | 0;
 }
 
 function graphicsToDeviceCoordinates($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
   HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
   HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
   HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
  }
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] + 1 | 0);
  }
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - (HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 1 | 0);
  }
 }
 
 function deviceToGraphicsCoordinates($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] + 1 | 0);
  }
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - (HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 1 | 0);
  }
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
   HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
   HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
   HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
  }
 }
 
 function graphicsToDeviceCoordinates16x($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
   HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
   HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
   HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
  }
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1 << 4) - HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
  }
  $0 = HEAP32[$3 + 12 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = ((HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - 1 << 4) - HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
  }
 }
 
 function graphicsGetWidth($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  block : {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
    $0 = HEAP32[$1 + 12 >> 2];
    $0 = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8;
    break block;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
  }
  return $0;
 }
 
 function graphicsGetHeight($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  block : {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
    $0 = HEAP32[$1 + 12 >> 2];
    $0 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
    break block;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8;
  }
  return $0;
 }
 
 function graphicsSetModifiedAndClip($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 48 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 44 >> 2] = $0;
  HEAP32[$6 + 40 >> 2] = $1;
  HEAP32[$6 + 36 >> 2] = $2;
  HEAP32[$6 + 32 >> 2] = $3;
  HEAP32[$6 + 28 >> 2] = $4;
  HEAP8[$6 + 27 | 0] = $5;
  HEAP8[$6 + 26 | 0] = 0;
  $0 = HEAP32[$6 + 44 >> 2];
  HEAP32[$6 + 20 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
  $0 = HEAP32[$6 + 44 >> 2];
  HEAP32[$6 + 16 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
  $0 = HEAP32[$6 + 44 >> 2];
  HEAP32[$6 + 12 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
  $0 = HEAP32[$6 + 44 >> 2];
  HEAP32[$6 + 8 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
  if (HEAP8[$6 + 27 | 0] & 1) {
   graphicsToDeviceCoordinates(HEAP32[$6 + 44 >> 2], $6 + 20 | 0, $6 + 16 | 0);
   graphicsToDeviceCoordinates(HEAP32[$6 + 44 >> 2], $6 + 12 | 0, $6 + 8 | 0);
   if (HEAP32[$6 + 12 >> 2] < HEAP32[$6 + 20 >> 2]) {
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
    HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 12 >> 2];
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 4 >> 2];
   }
   if (HEAP32[$6 + 8 >> 2] < HEAP32[$6 + 16 >> 2]) {
    HEAP32[$6 >> 2] = HEAP32[$6 + 16 >> 2];
    HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 8 >> 2];
    HEAP32[$6 + 8 >> 2] = HEAP32[$6 >> 2];
   }
  }
  if (HEAP32[HEAP32[$6 + 40 >> 2] >> 2] < HEAP32[$6 + 20 >> 2]) {
   HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$6 + 20 >> 2];
   HEAP8[$6 + 26 | 0] = 1;
  }
  if (HEAP32[HEAP32[$6 + 36 >> 2] >> 2] < HEAP32[$6 + 16 >> 2]) {
   HEAP32[HEAP32[$6 + 36 >> 2] >> 2] = HEAP32[$6 + 16 >> 2];
   HEAP8[$6 + 26 | 0] = 1;
  }
  if (HEAP32[HEAP32[$6 + 32 >> 2] >> 2] > HEAP32[$6 + 12 >> 2]) {
   HEAP32[HEAP32[$6 + 32 >> 2] >> 2] = HEAP32[$6 + 12 >> 2];
   HEAP8[$6 + 26 | 0] = 1;
  }
  if (HEAP32[HEAP32[$6 + 28 >> 2] >> 2] > HEAP32[$6 + 8 >> 2]) {
   HEAP32[HEAP32[$6 + 28 >> 2] >> 2] = HEAP32[$6 + 8 >> 2];
   HEAP8[$6 + 26 | 0] = 1;
  }
  $0 = HEAP32[$6 + 44 >> 2];
  if (HEAP32[HEAP32[$6 + 40 >> 2] >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 44 >> 2];
   $1 = HEAP32[HEAP32[$6 + 40 >> 2] >> 2];
   HEAP8[$0 + 40 | 0] = $1;
   HEAP8[$0 + 41 | 0] = $1 >>> 8;
   HEAP8[$6 + 26 | 0] = 1;
  }
  $0 = HEAP32[$6 + 44 >> 2];
  if (HEAP32[HEAP32[$6 + 32 >> 2] >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 44 >> 2];
   $1 = HEAP32[HEAP32[$6 + 32 >> 2] >> 2];
   HEAP8[$0 + 44 | 0] = $1;
   HEAP8[$0 + 45 | 0] = $1 >>> 8;
   HEAP8[$6 + 26 | 0] = 1;
  }
  $0 = HEAP32[$6 + 44 >> 2];
  if (HEAP32[HEAP32[$6 + 36 >> 2] >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 44 >> 2];
   $1 = HEAP32[HEAP32[$6 + 36 >> 2] >> 2];
   HEAP8[$0 + 42 | 0] = $1;
   HEAP8[$0 + 43 | 0] = $1 >>> 8;
   HEAP8[$6 + 26 | 0] = 1;
  }
  $0 = HEAP32[$6 + 44 >> 2];
  if (HEAP32[HEAP32[$6 + 28 >> 2] >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 44 >> 2];
   $1 = HEAP32[HEAP32[$6 + 28 >> 2] >> 2];
   HEAP8[$0 + 46 | 0] = $1;
   HEAP8[$0 + 47 | 0] = $1 >>> 8;
   HEAP8[$6 + 26 | 0] = 1;
  }
  __stack_pointer = $6 + 48 | 0;
  return HEAP8[$6 + 26 | 0] & 1;
 }
 
 function graphicsSetModified($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  HEAP32[$5 + 28 >> 2] = $0;
  HEAP32[$5 + 24 >> 2] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  $0 = HEAP32[$5 + 28 >> 2];
  if (HEAP32[$5 + 24 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$5 + 28 >> 2];
   $1 = HEAP32[$5 + 24 >> 2];
   HEAP8[$0 + 40 | 0] = $1;
   HEAP8[$0 + 41 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$5 + 28 >> 2];
  if (HEAP32[$5 + 16 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$5 + 28 >> 2];
   $1 = HEAP32[$5 + 16 >> 2];
   HEAP8[$0 + 44 | 0] = $1;
   HEAP8[$0 + 45 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$5 + 28 >> 2];
  if (HEAP32[$5 + 20 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$5 + 28 >> 2];
   $1 = HEAP32[$5 + 20 >> 2];
   HEAP8[$0 + 42 | 0] = $1;
   HEAP8[$0 + 43 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$5 + 28 >> 2];
  if (HEAP32[$5 + 12 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$5 + 28 >> 2];
   $1 = HEAP32[$5 + 12 >> 2];
   HEAP8[$0 + 46 | 0] = $1;
   HEAP8[$0 + 47 | 0] = $1 >>> 8;
  }
 }
 
 function graphicsGetSetPixelFn($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  $0 = HEAP32[$1 + 8 >> 2];
  block : {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 112) {
    HEAP32[$1 + 12 >> 2] = 596;
    break block;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function graphicsSetPixel($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  graphicsToDeviceCoordinates(HEAP32[$4 + 12 >> 2], $4 + 8 | 0, $4 + 4 | 0);
  graphicsSetPixelDevice(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function graphicsGetSetPixelUnclippedFn($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 24 >> 2] = $0;
  HEAP32[$6 + 20 >> 2] = $1;
  HEAP32[$6 + 16 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 8 >> 2] = $4;
  HEAP8[$6 + 7 | 0] = $5;
  block1 : {
   block : {
    $0 = HEAP32[$6 + 24 >> 2];
    if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 112)) {
     if (!(graphicsSetModifiedAndClip(HEAP32[$6 + 24 >> 2], $6 + 20 | 0, $6 + 16 | 0, $6 + 12 | 0, $6 + 8 | 0, HEAP8[$6 + 7 | 0] & 1) & 1)) {
      break block
     }
    }
    HEAP32[$6 + 28 >> 2] = 596;
    break block1;
   }
   $0 = HEAP32[$6 + 24 >> 2];
   HEAP32[$6 + 28 >> 2] = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
  }
  __stack_pointer = $6 + 32 | 0;
  return HEAP32[$6 + 28 >> 2];
 }
 
 function graphicsBlendColorRGB565($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  HEAP16[$3 + 46 >> 1] = $0;
  HEAP16[$3 + 44 >> 1] = $1;
  HEAP32[$3 + 40 >> 2] = $2;
  HEAP32[$3 + 36 >> 2] = HEAPU16[$3 + 44 >> 1] >>> 11;
  HEAP32[$3 + 32 >> 2] = HEAPU16[$3 + 44 >> 1] >>> 5 & 63;
  HEAP32[$3 + 28 >> 2] = HEAPU16[$3 + 44 >> 1] & 31;
  HEAP32[$3 + 24 >> 2] = HEAPU16[$3 + 46 >> 1] >>> 11;
  HEAP32[$3 + 20 >> 2] = HEAPU16[$3 + 46 >> 1] >>> 5 & 63;
  HEAP32[$3 + 16 >> 2] = HEAPU16[$3 + 46 >> 1] & 31;
  HEAP32[$3 + 12 >> 2] = Math_imul(HEAP32[$3 + 36 >> 2], 256 - HEAP32[$3 + 40 >> 2] | 0) + Math_imul(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 40 >> 2]) >>> 8;
  HEAP32[$3 + 8 >> 2] = Math_imul(HEAP32[$3 + 32 >> 2], 256 - HEAP32[$3 + 40 >> 2] | 0) + Math_imul(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 40 >> 2]) >>> 8;
  HEAP32[$3 + 4 >> 2] = Math_imul(HEAP32[$3 + 28 >> 2], 256 - HEAP32[$3 + 40 >> 2] | 0) + Math_imul(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 40 >> 2]) >>> 8;
  return (HEAP32[$3 + 4 >> 2] | HEAP32[$3 + 8 >> 2] << 5 | HEAP32[$3 + 12 >> 2] << 11) & 65535;
 }
 
 function graphicsBlendColor($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 80 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 72 >> 2] = $0;
  HEAP32[$4 + 68 >> 2] = $1;
  HEAP32[$4 + 64 >> 2] = $2;
  HEAP32[$4 + 60 >> 2] = $3;
  if (HEAP32[$4 + 60 >> 2] > 0) {
   $0 = HEAP32[$4 + 60 >> 2]
  } else {
   $0 = 0
  }
  HEAP32[$4 + 56 >> 2] = $0;
  if (HEAPU32[$4 + 56 >> 2] > 256) {
   HEAP32[$4 + 56 >> 2] = 256
  }
  block3 : {
   if (!(!(HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 2 | HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 4) & HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] != 8)) {
    HEAP32[$4 + 76 >> 2] = (Math_imul(HEAP32[$4 + 64 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 68 >> 2], HEAP32[$4 + 56 >> 2]) | 0) + 127 >>> 8;
    break block3;
   }
   if (HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 16) {
    HEAP32[$4 + 76 >> 2] = graphicsBlendColorRGB565(HEAP32[$4 + 68 >> 2] & 65535, HEAP32[$4 + 64 >> 2] & 65535, HEAP32[$4 + 60 >> 2]) & 65535;
    break block3;
   }
   if (HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 24) {
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 64 >> 2];
    HEAP32[$4 + 48 >> 2] = HEAP32[$4 + 52 >> 2] >>> 16 & 255;
    HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 52 >> 2] >>> 8 & 255;
    HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 52 >> 2] & 255;
    HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 68 >> 2];
    HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 36 >> 2] >>> 16 & 255;
    HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 36 >> 2] >>> 8 & 255;
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 36 >> 2] & 255;
    HEAP32[$4 + 20 >> 2] = Math_imul(HEAP32[$4 + 48 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 56 >> 2]) >>> 8;
    HEAP32[$4 + 16 >> 2] = Math_imul(HEAP32[$4 + 44 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 56 >> 2]) >>> 8;
    HEAP32[$4 + 12 >> 2] = Math_imul(HEAP32[$4 + 40 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 56 >> 2]) >>> 8;
    HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] << 8 | HEAP32[$4 + 20 >> 2] << 16;
    break block3;
   }
   if (HEAPU32[$4 + 56 >> 2] >= 128) {
    $0 = HEAP32[$4 + 68 >> 2]
   } else {
    $0 = HEAP32[$4 + 64 >> 2]
   }
   HEAP32[$4 + 76 >> 2] = $0;
  }
  __stack_pointer = $4 + 80 | 0;
  return HEAP32[$4 + 76 >> 2];
 }
 
 function graphicsBlendGfxColor($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = HEAP32[$2 + 12 >> 2];
  $0 = graphicsBlendColor(HEAP32[$2 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24), HEAPU8[$1 + 21 | 0] | HEAPU8[$1 + 22 | 0] << 8 | (HEAPU8[$1 + 23 | 0] << 16 | HEAPU8[$1 + 24 | 0] << 24), HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0;
 }
 
 function graphicsFillRectDevice($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  if (HEAP32[$6 + 24 >> 2] > HEAP32[$6 + 16 >> 2]) {
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 24 >> 2];
   HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 16 >> 2];
   HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 4 >> 2];
  }
  if (HEAP32[$6 + 20 >> 2] > HEAP32[$6 + 12 >> 2]) {
   HEAP32[$6 >> 2] = HEAP32[$6 + 20 >> 2];
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 12 >> 2];
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 >> 2];
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 24 >> 2] < (HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8)) {
   $0 = HEAP32[$6 + 28 >> 2];
   HEAP32[$6 + 24 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 20 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
   $0 = HEAP32[$6 + 28 >> 2];
   HEAP32[$6 + 20 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 16 >> 2] > (HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8)) {
   $0 = HEAP32[$6 + 28 >> 2];
   HEAP32[$6 + 16 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 12 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
   $0 = HEAP32[$6 + 28 >> 2];
   HEAP32[$6 + 12 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
  }
  block : {
   if (HEAP32[$6 + 16 >> 2] < HEAP32[$6 + 24 >> 2] | HEAP32[$6 + 12 >> 2] < HEAP32[$6 + 20 >> 2]) {
    break block
   }
   $0 = HEAP32[$6 + 28 >> 2];
   if (HEAP32[$6 + 24 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$6 + 28 >> 2];
    $1 = HEAP32[$6 + 24 >> 2];
    HEAP8[$0 + 40 | 0] = $1;
    HEAP8[$0 + 41 | 0] = $1 >>> 8;
   }
   $0 = HEAP32[$6 + 28 >> 2];
   if (HEAP32[$6 + 16 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$6 + 28 >> 2];
    $1 = HEAP32[$6 + 16 >> 2];
    HEAP8[$0 + 44 | 0] = $1;
    HEAP8[$0 + 45 | 0] = $1 >>> 8;
   }
   $0 = HEAP32[$6 + 28 >> 2];
   if (HEAP32[$6 + 20 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$6 + 28 >> 2];
    $1 = HEAP32[$6 + 20 >> 2];
    HEAP8[$0 + 42 | 0] = $1;
    HEAP8[$0 + 43 | 0] = $1 >>> 8;
   }
   $0 = HEAP32[$6 + 28 >> 2];
   if (HEAP32[$6 + 12 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
    $0 = HEAP32[$6 + 28 >> 2];
    $1 = HEAP32[$6 + 12 >> 2];
    HEAP8[$0 + 46 | 0] = $1;
    HEAP8[$0 + 47 | 0] = $1 >>> 8;
   }
   if (!(HEAP32[$6 + 24 >> 2] != HEAP32[$6 + 16 >> 2] | HEAP32[$6 + 20 >> 2] != HEAP32[$6 + 12 >> 2])) {
    $0 = HEAP32[$6 + 28 >> 2];
    FUNCTION_TABLE[HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 8 >> 2]);
    break block;
   }
   $0 = HEAP32[$6 + 28 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 56 | 0] | HEAPU8[$0 + 57 | 0] << 8 | (HEAPU8[$0 + 58 | 0] << 16 | HEAPU8[$0 + 59 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]);
  }
  __stack_pointer = $6 + 32 | 0;
 }
 
 function graphicsGetPixel($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  graphicsToDeviceCoordinates(HEAP32[$3 + 12 >> 2], $3 + 8 | 0, $3 + 4 | 0);
  $0 = graphicsGetPixelDevice(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0;
 }
 
 function graphicsGetPixelDevice($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 8 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 >> 2] = $2;
  block2 : {
   block1 : {
    block : {
     if ((HEAP32[$3 + 4 >> 2] | HEAP32[$3 >> 2]) < 0) {
      break block
     }
     $0 = HEAP32[$3 + 8 >> 2];
     if (HEAP32[$3 + 4 >> 2] >= (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8)) {
      break block
     }
     $0 = HEAP32[$3 + 8 >> 2];
     if (HEAP32[$3 >> 2] < (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) {
      break block1
     }
    }
    HEAP32[$3 + 12 >> 2] = 0;
    break block2;
   }
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 12 >> 2] = FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
  return HEAP32[$3 + 12 >> 2];
 }
 
 function graphicsFillRect($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], $6 + 24 | 0, $6 + 20 | 0);
  graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], $6 + 16 | 0, $6 + 12 | 0);
  graphicsFillRectDevice(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]);
  __stack_pointer = $6 + 32 | 0;
 }
 
 function graphicsClear($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = HEAP32[$1 + 12 >> 2];
  $3 = HEAP32[$1 + 12 >> 2];
  $0 = HEAP32[$1 + 12 >> 2];
  graphicsFillRectDevice(HEAP32[$1 + 12 >> 2], 0, 0, (HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8) - 1 | 0, (HEAPU8[$3 + 14 | 0] | HEAPU8[$3 + 15 | 0] << 8) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
  __stack_pointer = $1 + 16 | 0;
 }
 
 function graphicsDrawRect($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 28 >> 2] = $0;
  HEAP32[$5 + 24 >> 2] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  graphicsToDeviceCoordinates(HEAP32[$5 + 28 >> 2], $5 + 24 | 0, $5 + 20 | 0);
  graphicsToDeviceCoordinates(HEAP32[$5 + 28 >> 2], $5 + 16 | 0, $5 + 12 | 0);
  $0 = HEAP32[$5 + 28 >> 2];
  graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 20 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 28 >> 2];
  graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 28 >> 2];
  graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 28 >> 2];
  graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  __stack_pointer = $5 + 32 | 0;
 }
 
 function graphicsDrawEllipseInternal($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0;
  $7 = __stack_pointer + -64 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 60 >> 2] = $0;
  HEAP32[$7 + 56 >> 2] = $1;
  HEAP32[$7 + 52 >> 2] = $2;
  HEAP32[$7 + 48 >> 2] = $3;
  HEAP32[$7 + 44 >> 2] = $4;
  HEAP32[$7 + 40 >> 2] = $5;
  HEAP32[$7 + 36 >> 2] = $6;
  HEAP32[$7 + 32 >> 2] = 0;
  HEAP32[$7 + 28 >> 2] = HEAP32[$7 + 36 >> 2];
  HEAP32[$7 + 24 >> 2] = Math_imul(HEAP32[$7 + 40 >> 2], HEAP32[$7 + 40 >> 2]);
  HEAP32[$7 + 20 >> 2] = Math_imul(HEAP32[$7 + 36 >> 2], HEAP32[$7 + 36 >> 2]);
  HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 20 >> 2] - Math_imul(HEAP32[$7 + 24 >> 2], (HEAP32[$7 + 36 >> 2] << 1) - 1 | 0);
  HEAP8[$7 + 11 | 0] = 0;
  while (1) {
   HEAP8[$7 + 11 | 0] = 0;
   $0 = HEAP32[$7 + 60 >> 2];
   graphicsSetPixelDevice(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 48 >> 2] + HEAP32[$7 + 32 >> 2] | 0, HEAP32[$7 + 44 >> 2] + HEAP32[$7 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   $0 = HEAP32[$7 + 60 >> 2];
   graphicsSetPixelDevice(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 56 >> 2] - HEAP32[$7 + 32 >> 2] | 0, HEAP32[$7 + 44 >> 2] + HEAP32[$7 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   $0 = HEAP32[$7 + 60 >> 2];
   graphicsSetPixelDevice(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 48 >> 2] + HEAP32[$7 + 32 >> 2] | 0, HEAP32[$7 + 52 >> 2] - HEAP32[$7 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   $0 = HEAP32[$7 + 60 >> 2];
   graphicsSetPixelDevice(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 56 >> 2] - HEAP32[$7 + 32 >> 2] | 0, HEAP32[$7 + 52 >> 2] - HEAP32[$7 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 16 >> 2] << 1;
   if (HEAP32[$7 + 12 >> 2] < (Math_imul(HEAP32[$7 + 20 >> 2], (HEAP32[$7 + 32 >> 2] << 1) + 1 | 0) | 0)) {
    HEAP32[$7 + 32 >> 2] = HEAP32[$7 + 32 >> 2] + 1;
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + Math_imul(HEAP32[$7 + 20 >> 2], (HEAP32[$7 + 32 >> 2] << 1) + 1 | 0);
    HEAP8[$7 + 11 | 0] = 1;
   }
   if (HEAP32[$7 + 12 >> 2] > (Math_imul(HEAP32[$7 + 24 >> 2], 1 - (HEAP32[$7 + 28 >> 2] << 1) | 0) | 0)) {
    HEAP32[$7 + 28 >> 2] = HEAP32[$7 + 28 >> 2] - 1;
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] - Math_imul(HEAP32[$7 + 24 >> 2], (HEAP32[$7 + 28 >> 2] << 1) - 1 | 0);
    HEAP8[$7 + 11 | 0] = 1;
   }
   $0 = 0;
   $0 = HEAP8[$7 + 11 | 0] & 1 ? HEAP32[$7 + 28 >> 2] >= 0 : $0;
   if ($0) {
    continue
   }
   break;
  };
  while (1) {
   $0 = HEAP32[$7 + 32 >> 2];
   HEAP32[$7 + 32 >> 2] = $0 + 1;
   if (($0 | 0) < HEAP32[$7 + 40 >> 2]) {
    $0 = HEAP32[$7 + 60 >> 2];
    graphicsSetPixelDevice(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 48 >> 2] + HEAP32[$7 + 32 >> 2] | 0, HEAP32[$7 + 52 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
    $0 = HEAP32[$7 + 60 >> 2];
    graphicsSetPixelDevice(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 56 >> 2] - HEAP32[$7 + 32 >> 2] | 0, HEAP32[$7 + 52 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
    continue;
   }
   break;
  };
  __stack_pointer = $7 - -64 | 0;
 }
 
 function graphicsDrawEllipse($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 48 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 44 >> 2] = $0;
  HEAP32[$5 + 40 >> 2] = $1;
  HEAP32[$5 + 36 >> 2] = $2;
  HEAP32[$5 + 32 >> 2] = $3;
  HEAP32[$5 + 28 >> 2] = $4;
  graphicsToDeviceCoordinates(HEAP32[$5 + 44 >> 2], $5 + 40 | 0, $5 + 36 | 0);
  graphicsToDeviceCoordinates(HEAP32[$5 + 44 >> 2], $5 + 32 | 0, $5 + 28 | 0);
  if (HEAP32[$5 + 40 >> 2] > HEAP32[$5 + 32 >> 2]) {
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 32 >> 2];
   HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 24 >> 2];
  }
  if (HEAP32[$5 + 36 >> 2] > HEAP32[$5 + 28 >> 2]) {
   HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 36 >> 2];
   HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 28 >> 2];
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 20 >> 2];
  }
  HEAP32[$5 + 16 >> 2] = (HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 32 >> 2] | 0) / 2;
  HEAP32[$5 + 12 >> 2] = (HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 28 >> 2] | 0) / 2;
  HEAP32[$5 + 8 >> 2] = (HEAP32[$5 + 32 >> 2] - HEAP32[$5 + 40 >> 2] | 0) / 2;
  HEAP32[$5 + 4 >> 2] = (HEAP32[$5 + 28 >> 2] - HEAP32[$5 + 36 >> 2] | 0) / 2;
  graphicsDrawEllipseInternal(HEAP32[$5 + 44 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 4 >> 2]);
  __stack_pointer = $5 + 48 | 0;
 }
 
 function graphicsFillEllipse($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 80 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 76 >> 2] = $0;
  HEAP32[$5 + 72 >> 2] = $1;
  HEAP32[$5 + 68 >> 2] = $2;
  HEAP32[$5 + 64 >> 2] = $3;
  HEAP32[$5 + 60 >> 2] = $4;
  graphicsToDeviceCoordinates(HEAP32[$5 + 76 >> 2], $5 + 72 | 0, $5 + 68 | 0);
  graphicsToDeviceCoordinates(HEAP32[$5 + 76 >> 2], $5 - -64 | 0, $5 + 60 | 0);
  if (HEAP32[$5 + 72 >> 2] > HEAP32[$5 + 64 >> 2]) {
   HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 72 >> 2];
   HEAP32[$5 + 72 >> 2] = HEAP32[$5 + 64 >> 2];
   HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 56 >> 2];
  }
  if (HEAP32[$5 + 68 >> 2] > HEAP32[$5 + 60 >> 2]) {
   HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 68 >> 2];
   HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 60 >> 2];
   HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 52 >> 2];
  }
  HEAP32[$5 + 48 >> 2] = (HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 64 >> 2] | 0) / 2;
  HEAP32[$5 + 44 >> 2] = (HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 60 >> 2] | 0) / 2;
  HEAP32[$5 + 40 >> 2] = (HEAP32[$5 + 64 >> 2] - HEAP32[$5 + 72 >> 2] | 0) / 2;
  HEAP32[$5 + 36 >> 2] = (HEAP32[$5 + 60 >> 2] - HEAP32[$5 + 68 >> 2] | 0) / 2;
  HEAP32[$5 + 32 >> 2] = 0;
  HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 36 >> 2];
  HEAP32[$5 + 24 >> 2] = Math_imul(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 40 >> 2]);
  HEAP32[$5 + 20 >> 2] = Math_imul(HEAP32[$5 + 36 >> 2], HEAP32[$5 + 36 >> 2]);
  HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 20 >> 2] - Math_imul(HEAP32[$5 + 24 >> 2], (HEAP32[$5 + 36 >> 2] << 1) - 1 | 0);
  HEAP8[$5 + 11 | 0] = 0;
  while (1) {
   HEAP8[$5 + 11 | 0] = 0;
   HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 16 >> 2] << 1;
   if (HEAP32[$5 + 12 >> 2] < (Math_imul(HEAP32[$5 + 20 >> 2], (HEAP32[$5 + 32 >> 2] << 1) + 1 | 0) | 0)) {
    HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 32 >> 2] + 1;
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + Math_imul(HEAP32[$5 + 20 >> 2], (HEAP32[$5 + 32 >> 2] << 1) + 1 | 0);
    HEAP8[$5 + 11 | 0] = 1;
   }
   if (HEAP32[$5 + 12 >> 2] > (Math_imul(HEAP32[$5 + 24 >> 2], 1 - (HEAP32[$5 + 28 >> 2] << 1) | 0) | 0)) {
    $0 = HEAP32[$5 + 76 >> 2];
    graphicsFillRectDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 28 >> 2] | 0, HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
    $0 = HEAP32[$5 + 76 >> 2];
    graphicsFillRectDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 28 >> 2] | 0, HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
    HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] - 1;
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] - Math_imul(HEAP32[$5 + 24 >> 2], (HEAP32[$5 + 28 >> 2] << 1) - 1 | 0);
    HEAP8[$5 + 11 | 0] = 1;
   }
   $0 = 0;
   $0 = HEAP8[$5 + 11 | 0] & 1 ? HEAP32[$5 + 28 >> 2] >= 0 : $0;
   if ($0) {
    continue
   }
   break;
  };
  while (1) {
   $0 = HEAP32[$5 + 32 >> 2];
   HEAP32[$5 + 32 >> 2] = $0 + 1;
   if (($0 | 0) < HEAP32[$5 + 40 >> 2]) {
    $0 = HEAP32[$5 + 76 >> 2];
    graphicsFillRectDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
    continue;
   }
   break;
  };
  __stack_pointer = $5 + 80 | 0;
 }
 
 function graphicsDrawLine($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer + -64 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 60 >> 2] = $0;
  HEAP32[$5 + 56 >> 2] = $1;
  HEAP32[$5 + 52 >> 2] = $2;
  HEAP32[$5 + 48 >> 2] = $3;
  HEAP32[$5 + 44 >> 2] = $4;
  graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $5 + 56 | 0, $5 + 52 | 0);
  graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $5 + 48 | 0, $5 + 44 | 0);
  HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2];
  HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2];
  if (HEAP32[$5 + 40 >> 2] < 0) {
   HEAP32[$5 + 40 >> 2] = 0 - HEAP32[$5 + 40 >> 2]
  }
  if (HEAP32[$5 + 36 >> 2] < 0) {
   HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 36 >> 2]
  }
  block1 : {
   if (HEAP32[$5 + 40 >> 2] > HEAP32[$5 + 36 >> 2]) {
    block : {
     if (HEAP32[$5 + 56 >> 2] > HEAP32[$5 + 48 >> 2]) {
      HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 56 >> 2];
      HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 48 >> 2];
      HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 32 >> 2];
      HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 52 >> 2];
      HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 44 >> 2];
      HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 32 >> 2];
      break block;
     }
     if (!HEAP32[$5 + 40 >> 2]) {
      HEAP32[$5 + 40 >> 2] = 1
     }
    }
    HEAP32[$5 + 28 >> 2] = (HEAP32[$5 + 52 >> 2] << 8) + 128;
    HEAP32[$5 + 24 >> 2] = (HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2] << 8) / HEAP32[$5 + 40 >> 2];
    HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 56 >> 2];
    while (1) {
     if (HEAP32[$5 + 20 >> 2] <= HEAP32[$5 + 48 >> 2]) {
      $0 = HEAP32[$5 + 60 >> 2];
      graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 28 >> 2] >> 8, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
      HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 24 >> 2] + HEAP32[$5 + 28 >> 2];
      HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
      continue;
     }
     break;
    };
    break block1;
   }
   block2 : {
    if (HEAP32[$5 + 52 >> 2] > HEAP32[$5 + 44 >> 2]) {
     HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 56 >> 2];
     HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 48 >> 2];
     HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 16 >> 2];
     HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 52 >> 2];
     HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 44 >> 2];
     HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 16 >> 2];
     break block2;
    }
    if (!HEAP32[$5 + 36 >> 2]) {
     HEAP32[$5 + 36 >> 2] = 1
    }
   }
   HEAP32[$5 + 12 >> 2] = (HEAP32[$5 + 56 >> 2] << 8) + 128;
   HEAP32[$5 + 8 >> 2] = (HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2] << 8) / HEAP32[$5 + 36 >> 2];
   HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 52 >> 2];
   while (1) {
    if (HEAP32[$5 + 4 >> 2] <= HEAP32[$5 + 44 >> 2]) {
     $0 = HEAP32[$5 + 60 >> 2];
     graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 12 >> 2] >> 8, HEAP32[$5 + 4 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
     HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 8 >> 2] + HEAP32[$5 + 12 >> 2];
     HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
     continue;
    }
    break;
   };
  }
  __stack_pointer = $5 - -64 | 0;
 }
 
 function graphicsDrawLineAA($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 112 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 108 >> 2] = $0;
  HEAP32[$5 + 104 >> 2] = $1;
  HEAP32[$5 + 100 >> 2] = $2;
  HEAP32[$5 + 96 >> 2] = $3;
  HEAP32[$5 + 92 >> 2] = $4;
  graphicsToDeviceCoordinates16x(HEAP32[$5 + 108 >> 2], $5 + 104 | 0, $5 + 100 | 0);
  graphicsToDeviceCoordinates16x(HEAP32[$5 + 108 >> 2], $5 + 96 | 0, $5 + 92 | 0);
  HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 104 >> 2] << 4;
  HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 100 >> 2] << 4;
  HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 96 >> 2] << 4;
  HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 92 >> 2] << 4;
  $0 = HEAP32[$5 + 76 >> 2] - HEAP32[$5 + 84 >> 2] | 0;
  $1 = $0 >> 31;
  $2 = HEAP32[$5 + 80 >> 2] - HEAP32[$5 + 88 >> 2] | 0;
  $3 = $2 >> 31;
  HEAP8[$5 + 75 | 0] = (($1 ^ $0) - $1 | 0) > (($3 ^ $2) - $3 | 0);
  if (HEAP8[$5 + 75 | 0] & 1) {
   HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 88 >> 2];
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 84 >> 2];
   HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 68 >> 2];
   HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 80 >> 2];
   HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 76 >> 2];
   HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 68 >> 2];
  }
  if (HEAP32[$5 + 88 >> 2] > HEAP32[$5 + 80 >> 2]) {
   HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 88 >> 2];
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 80 >> 2];
   HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 64 >> 2];
   HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 84 >> 2];
   HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 76 >> 2];
   HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 64 >> 2];
  }
  HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 80 >> 2] - HEAP32[$5 + 88 >> 2];
  HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 76 >> 2] - HEAP32[$5 + 84 >> 2];
  if (HEAP32[$5 + 60 >> 2]) {
   $0 = (HEAP32[$5 + 56 >> 2] << 8) / HEAP32[$5 + 60 >> 2] | 0
  } else {
   $0 = 256
  }
  HEAP32[$5 + 52 >> 2] = $0;
  HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 88 >> 2] & -256;
  HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 84 >> 2] + (Math_imul(HEAP32[$5 + 52 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 88 >> 2] | 0) >> 8);
  HEAP32[$5 + 40 >> 2] = 255 - (HEAP32[$5 + 88 >> 2] & 255);
  HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 48 >> 2] >> 8;
  HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 44 >> 2] >> 8;
  HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 44 >> 2] & 255;
  graphicsDrawLineAAPixel(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2], HEAP8[$5 + 75 | 0] & 1, Math_imul(HEAP32[$5 + 40 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0) >> 8, Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 40 >> 2]) >> 8);
  HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 52 >> 2];
  HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 80 >> 2] + 256 & -256;
  HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 76 >> 2] + (Math_imul(HEAP32[$5 + 52 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 80 >> 2] | 0) >> 8);
  HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 80 >> 2] + 256 & 255;
  HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 48 >> 2] >> 8;
  HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2] >> 8;
  HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 44 >> 2] & 255;
  graphicsDrawLineAAPixel(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP8[$5 + 75 | 0] & 1, Math_imul(HEAP32[$5 + 40 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0) >> 8, Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 40 >> 2]) >> 8);
  HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 36 >> 2] + 1;
  while (1) {
   if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 20 >> 2]) {
    HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 24 >> 2] >> 8;
    HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 24 >> 2] & 255;
    graphicsDrawLineAAPixel(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 8 >> 2], HEAP8[$5 + 75 | 0] & 1, 256 - HEAP32[$5 + 28 >> 2] | 0, HEAP32[$5 + 28 >> 2]);
    HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 52 >> 2] + HEAP32[$5 + 24 >> 2];
    HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $5 + 112 | 0;
 }
 
 function graphicsDrawLineAAPixel($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP8[$6 + 19 | 0] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  block : {
   if (HEAP8[$6 + 19 | 0] & 1) {
    graphicsSetPixelDeviceBlended(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 12 >> 2]);
    graphicsSetPixelDeviceBlended(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 20 >> 2] + 1 | 0, HEAP32[$6 + 24 >> 2], HEAP32[$6 + 8 >> 2]);
    break block;
   }
   graphicsSetPixelDeviceBlended(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 12 >> 2]);
   graphicsSetPixelDeviceBlended(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2] + 1 | 0, HEAP32[$6 + 8 >> 2]);
  }
  __stack_pointer = $6 + 32 | 0;
 }
 
 function graphicsSetPixelDeviceBlended($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = graphicsGetPixelDevice(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 8 >> 2] = graphicsBlendColor(HEAP32[$4 + 28 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24), HEAP32[$4 + 12 >> 2], HEAP32[$4 + 16 >> 2]);
  graphicsSetPixelDevice(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 8 >> 2]);
  __stack_pointer = $4 + 32 | 0;
 }
 
 function graphicsDrawCircleAA($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP32[$4 + 32 >> 2] = $3;
  graphicsToDeviceCoordinates(HEAP32[$4 + 44 >> 2], $4 + 40 | 0, $4 + 36 | 0);
  HEAP32[$4 + 28 >> 2] = 0 - HEAP32[$4 + 32 >> 2];
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 20 >> 2] = 2 - (HEAP32[$4 + 32 >> 2] << 1);
  HEAP32[$4 + 32 >> 2] = 1 - HEAP32[$4 + 20 >> 2];
  while (1) {
   $0 = (HEAP32[$4 + 20 >> 2] - (HEAP32[$4 + 28 >> 2] + HEAP32[$4 + 24 >> 2] << 1) | 0) - 2 | 0;
   $1 = $0 >> 31;
   HEAP32[$4 + 16 >> 2] = 255 - ((Math_imul(($1 ^ $0) - $1 | 0, 255) | 0) / HEAP32[$4 + 32 >> 2] | 0);
   graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
   graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
   graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
   graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 20 >> 2];
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2];
   if ((HEAP32[$4 + 20 >> 2] + HEAP32[$4 + 24 >> 2] | 0) > 0) {
    HEAP32[$4 + 16 >> 2] = 255 - ((Math_imul((HEAP32[$4 + 20 >> 2] - (HEAP32[$4 + 28 >> 2] << 1) | 0) - 1 | 0, 255) | 0) / HEAP32[$4 + 32 >> 2] | 0);
    if (HEAP32[$4 + 16 >> 2] > 0) {
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 28 >> 2] | 0, (HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 24 >> 2] | 0) + 1 | 0, HEAP32[$4 + 16 >> 2]);
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 24 >> 2] | 0) - 1 | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 28 >> 2] | 0, (HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 24 >> 2] | 0) - 1 | 0, HEAP32[$4 + 16 >> 2]);
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 24 >> 2] | 0) + 1 | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
    }
    $0 = HEAP32[$4 + 28 >> 2] + 1 | 0;
    HEAP32[$4 + 28 >> 2] = $0;
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + (($0 << 1) + 1 | 0);
   }
   if ((HEAP32[$4 + 8 >> 2] + HEAP32[$4 + 12 >> 2] | 0) <= 0) {
    HEAP32[$4 + 16 >> 2] = 255 - ((Math_imul(((HEAP32[$4 + 24 >> 2] << 1) + 3 | 0) - HEAP32[$4 + 8 >> 2] | 0, 255) | 0) / HEAP32[$4 + 32 >> 2] | 0);
    if (HEAP32[$4 + 16 >> 2] > 0) {
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 12 >> 2] | 0) - 1 | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 24 >> 2] | 0, (HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 12 >> 2] | 0) - 1 | 0, HEAP32[$4 + 16 >> 2]);
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 12 >> 2] | 0) + 1 | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
     graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 24 >> 2] | 0, (HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 12 >> 2] | 0) + 1 | 0, HEAP32[$4 + 16 >> 2]);
    }
    $0 = HEAP32[$4 + 24 >> 2] + 1 | 0;
    HEAP32[$4 + 24 >> 2] = $0;
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + (($0 << 1) + 1 | 0);
   }
   if (HEAP32[$4 + 28 >> 2] < 0) {
    continue
   }
   break;
  };
  __stack_pointer = $4 + 48 | 0;
 }
 
 function graphicsFillPoly($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  $3 = $4;
  __stack_pointer = $3;
  HEAP32[$3 + 92 >> 2] = $0;
  HEAP32[$3 + 88 >> 2] = $1;
  HEAP32[$3 + 84 >> 2] = $2;
  HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 84 >> 2];
  $0 = HEAP32[$3 + 92 >> 2];
  HEAP32[$3 + 64 >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - 1;
  HEAP32[$3 + 60 >> 2] = 0;
  HEAP32[$3 + 76 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 76 >> 2] < HEAP32[$3 + 88 >> 2]) {
    HEAP32[$3 + 56 >> 2] = HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1] << 16 >> 16;
    HEAP32[$3 + 52 >> 2] = HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16;
    graphicsToDeviceCoordinates16x(HEAP32[$3 + 92 >> 2], $3 + 56 | 0, $3 + 52 | 0);
    HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1] = HEAP32[$3 + 56 >> 2];
    HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] = HEAP32[$3 + 52 >> 2];
    HEAP16[$3 + 50 >> 1] = HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16 >> 4;
    if (HEAP32[$3 + 64 >> 2] > HEAP16[$3 + 50 >> 1] << 16 >> 16) {
     HEAP32[$3 + 64 >> 2] = HEAP16[$3 + 50 >> 1] << 16 >> 16
    }
    if (HEAP32[$3 + 60 >> 2] < HEAP16[$3 + 50 >> 1] << 16 >> 16) {
     HEAP32[$3 + 60 >> 2] = HEAP16[$3 + 50 >> 1] << 16 >> 16
    }
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
    continue;
   }
   break;
  };
  $0 = HEAP32[$3 + 92 >> 2];
  if (HEAP32[$3 + 64 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
   $0 = HEAP32[$3 + 92 >> 2];
   HEAP32[$3 + 64 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
  }
  $0 = HEAP32[$3 + 92 >> 2];
  if (HEAP32[$3 + 60 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
   $0 = HEAP32[$3 + 92 >> 2];
   HEAP32[$3 + 60 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
  }
  HEAP32[$3 + 44 >> 2] = 64;
  HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 64 >> 2] << 4;
  while (1) {
   if (HEAP32[$3 + 68 >> 2] <= HEAP32[$3 + 60 >> 2] << 4) {
    HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 68 >> 2] >> 4;
    HEAP32[$3 + 36 >> 2] = $4;
    $4 = $4 - 128 | 0;
    __stack_pointer = $4;
    $0 = $4 + -64 | 0;
    __stack_pointer = $0;
    HEAP32[$3 + 32 >> 2] = 0;
    HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 88 >> 2] - 1;
    HEAP32[$3 + 76 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 76 >> 2] < HEAP32[$3 + 88 >> 2]) {
      block1 : {
       block : {
        if (HEAP32[$3 + 68 >> 2] >= HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16) {
         if (HEAP32[$3 + 68 >> 2] < HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16) {
          break block
         }
        }
        if (HEAP32[$3 + 68 >> 2] < HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16 | HEAP32[$3 + 68 >> 2] >= HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16) {
         break block1
        }
       }
       if (HEAP32[$3 + 32 >> 2] < 64) {
        HEAP32[$3 + 28 >> 2] = (HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16) - (HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16);
        if (HEAP32[$3 + 28 >> 2]) {
         HEAP16[(HEAP32[$3 + 32 >> 2] << 1) + $4 >> 1] = (HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1] << 16 >> 16) + ((Math_imul(HEAP32[$3 + 68 >> 2] - (HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] << 16 >> 16) | 0, (HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) >> 1] << 16 >> 16) - (HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1] << 16 >> 16) | 0) | 0) / HEAP32[$3 + 28 >> 2] | 0);
         HEAP8[HEAP32[$3 + 32 >> 2] + $0 | 0] = HEAP32[$3 + 28 >> 2] > 1;
         HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
        }
       }
      }
      HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 76 >> 2];
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$3 + 76 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 76 >> 2] < (HEAP32[$3 + 32 >> 2] - 1 | 0)) {
      if (HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1] << 16 >> 16 > HEAP16[(HEAP32[$3 + 76 >> 2] + 1 << 1) + $4 >> 1] << 16 >> 16) {
       HEAP16[$3 + 26 >> 1] = HEAPU16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1];
       HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1] = HEAPU16[(HEAP32[$3 + 76 >> 2] + 1 << 1) + $4 >> 1];
       HEAP16[(HEAP32[$3 + 76 >> 2] + 1 << 1) + $4 >> 1] = HEAPU16[$3 + 26 >> 1];
       HEAP8[$3 + 25 | 0] = HEAP8[HEAP32[$3 + 76 >> 2] + $0 | 0] & 1;
       HEAP8[HEAP32[$3 + 76 >> 2] + $0 | 0] = HEAP8[(HEAP32[$3 + 76 >> 2] + 1 | 0) + $0 | 0] & 1;
       HEAP8[(HEAP32[$3 + 76 >> 2] + 1 | 0) + $0 | 0] = HEAP8[$3 + 25 | 0] & 1;
       if (HEAP32[$3 + 76 >> 2]) {
        HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] - 1
       }
       continue;
      }
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$3 + 20 >> 2] = 0;
    HEAP32[$3 + 16 >> 2] = 0;
    HEAP32[$3 + 76 >> 2] = 0;
    while (1) {
     block2 : {
      if (HEAP32[$3 + 76 >> 2] >= HEAP32[$3 + 32 >> 2]) {
       break block2
      }
      if (!HEAP32[$3 + 16 >> 2]) {
       HEAP32[$3 + 20 >> 2] = HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1] << 16 >> 16
      }
      block3 : {
       if (HEAP8[HEAP32[$3 + 76 >> 2] + $0 | 0] & 1) {
        HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
        break block3;
       }
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - 1;
      }
      if (!(HEAP32[$3 + 76 >> 2] != (HEAP32[$3 + 32 >> 2] - 1 | 0) ? HEAP32[$3 + 16 >> 2] : 0)) {
       HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2] + 15 >> 4;
       HEAP32[$3 + 8 >> 2] = (HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1] << 16 >> 16) + 15 >> 4;
       if (HEAP32[$3 + 8 >> 2] > HEAP32[$3 + 12 >> 2]) {
        $1 = HEAP32[$3 + 92 >> 2];
        graphicsFillRectDevice(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 8 >> 2] - 1 | 0, HEAP32[$3 + 40 >> 2], HEAPU8[$1 + 17 | 0] | HEAPU8[$1 + 18 | 0] << 8 | (HEAPU8[$1 + 19 | 0] << 16 | HEAPU8[$1 + 20 | 0] << 24));
       }
      }
      if (jspIsInterrupted() & 1) {
       break block2
      }
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
      continue;
     }
     break;
    };
    $4 = HEAP32[$3 + 36 >> 2];
    HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 68 >> 2] + 16;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 96 | 0;
 }
 
 function graphicsScroll($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  HEAP32[$3 + 32 >> 2] = 0;
  HEAP32[$3 + 28 >> 2] = 0;
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 40 >> 2];
  HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 36 >> 2];
  graphicsToDeviceCoordinates(HEAP32[$3 + 44 >> 2], $3 + 32 | 0, $3 + 28 | 0);
  graphicsToDeviceCoordinates(HEAP32[$3 + 44 >> 2], $3 + 24 | 0, $3 + 20 | 0);
  HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 28 >> 2];
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 28 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 24 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 20 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
  HEAP8[$3 + 19 | 0] = 1;
  HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 24 >> 2] + 1 | 0) - HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 8 >> 2] = (HEAP32[$3 + 20 >> 2] + 1 | 0) - HEAP32[$3 + 28 >> 2];
  if (HEAP32[$3 + 40 >> 2] >= HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 12 >> 2];
   HEAP8[$3 + 19 | 0] = 0;
  }
  if (HEAP32[$3 + 40 >> 2] <= (0 - HEAP32[$3 + 12 >> 2] | 0)) {
   HEAP32[$3 + 40 >> 2] = 0 - HEAP32[$3 + 12 >> 2];
   HEAP8[$3 + 19 | 0] = 0;
  }
  if (HEAP32[$3 + 36 >> 2] >= HEAP32[$3 + 8 >> 2]) {
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 8 >> 2];
   HEAP8[$3 + 19 | 0] = 0;
  }
  if (HEAP32[$3 + 36 >> 2] <= (0 - HEAP32[$3 + 8 >> 2] | 0)) {
   HEAP32[$3 + 36 >> 2] = 0 - HEAP32[$3 + 8 >> 2];
   HEAP8[$3 + 19 | 0] = 0;
  }
  if (HEAP8[$3 + 19 | 0] & 1) {
   $0 = HEAP32[$3 + 44 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 68 | 0] | HEAPU8[$0 + 69 | 0] << 8 | (HEAPU8[$0 + 70 | 0] << 16 | HEAPU8[$0 + 71 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  }
  graphicsSetModified(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  block : {
   if (HEAP32[$3 + 40 >> 2] > 0) {
    $0 = HEAP32[$3 + 44 >> 2];
    $1 = HEAP32[$3 + 44 >> 2];
    FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], (HEAP32[$3 + 32 >> 2] + HEAP32[$3 + 40 >> 2] | 0) - 1 | 0, HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
    break block;
   }
   if (HEAP32[$3 + 40 >> 2] < 0) {
    $0 = HEAP32[$3 + 44 >> 2];
    $1 = HEAP32[$3 + 44 >> 2];
    FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2] + (HEAP32[$3 + 24 >> 2] + 1 | 0) | 0, HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   }
  }
  block1 : {
   if (HEAP32[$3 + 36 >> 2] > 0) {
    $0 = HEAP32[$3 + 44 >> 2];
    $1 = HEAP32[$3 + 44 >> 2];
    FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], (HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2] | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
    break block1;
   }
   if (HEAP32[$3 + 36 >> 2] < 0) {
    $0 = HEAP32[$3 + 44 >> 2];
    $1 = HEAP32[$3 + 44 >> 2];
    FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 36 >> 2] + (HEAP32[$3 + 20 >> 2] + 1 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   }
  }
  __stack_pointer = $3 + 48 | 0;
 }
 
 function graphicsIdle() {
  
 }
 
 function lcdGetPixelIndex_ArrayBuffer($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  $0 = HEAP32[$4 + 24 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1 & (HEAP32[$4 + 16 >> 2] & 1)) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 20 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[$4 + 20 >> 2] + HEAP32[$4 + 12 >> 2] | 0);
  }
  $0 = HEAP32[$4 + 24 >> 2];
  block : {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
    $0 = HEAP32[$4 + 24 >> 2];
    HEAP32[$4 + 8 >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) >>> 1;
    HEAP32[$4 + 4 >> 2] = 0;
    if (HEAP32[$4 + 16 >> 2] >= HEAP32[$4 + 8 >> 2]) {
     HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] - HEAP32[$4 + 8 >> 2];
     HEAP32[$4 + 4 >> 2] = HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0];
    }
    $0 = HEAP32[$4 + 24 >> 2];
    HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2] + Math_imul(HEAP32[$4 + 16 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0, HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0] << 1);
    break block;
   }
   $0 = HEAP32[$4 + 24 >> 2];
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
    $0 = HEAP32[$4 + 24 >> 2];
    HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 16 >> 2] & 7 | HEAP32[$4 + 20 >> 2] + Math_imul(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8, HEAP32[$4 + 16 >> 2] >> 3) << 3;
    break block;
   }
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 28 >> 2] = Math_imul(HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0], HEAP32[$4 + 20 >> 2] + Math_imul(HEAP32[$4 + 16 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0);
  }
  return HEAP32[$4 + 28 >> 2];
 }
 
 function lcdGetPixel_ArrayBuffer($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 112 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 108 >> 2] = $0;
  HEAP32[$3 + 104 >> 2] = $1;
  HEAP32[$3 + 100 >> 2] = $2;
  HEAP32[$3 + 96 >> 2] = 0;
  $0 = HEAP32[$3 + 108 >> 2];
  HEAP32[$3 + 92 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
  HEAP32[$3 + 88 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 1);
  jsvArrayBufferIteratorNew($3 + 28 | 0, HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2] >>> 3 | 0);
  block1 : {
   if (HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] & 7) {
    HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 88 >> 2] & 7;
    HEAP32[$3 + 24 >> 2] = (1 << HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0]) - 1;
    HEAP32[$3 + 20 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 28 | 0);
    $0 = HEAP32[$3 + 108 >> 2];
    if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
     $0 = 8 - (HEAP32[$3 + 88 >> 2] + HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] | 0) | 0
    } else {
     $0 = HEAP32[$3 + 88 >> 2]
    }
    HEAP32[$3 + 16 >> 2] = $0;
    HEAP32[$3 + 96 >> 2] = HEAP32[$3 + 24 >> 2] & HEAP32[$3 + 20 >> 2] >>> HEAP32[$3 + 16 >> 2];
    break block1;
   }
   $0 = HEAP32[$3 + 108 >> 2];
   block2 : {
    if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
     HEAP32[$3 + 12 >> 2] = HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] - 8;
     while (1) {
      if (HEAP32[$3 + 12 >> 2] >= 0) {
       HEAP32[$3 + 96 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 28 | 0) << HEAP32[$3 + 12 >> 2] | HEAP32[$3 + 96 >> 2];
       jsvArrayBufferIteratorNext($3 + 28 | 0);
       HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] - 8;
       continue;
      }
      break;
     };
     break block2;
    }
    HEAP32[$3 + 8 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 8 >> 2] < HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0]) {
      HEAP32[$3 + 96 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 28 | 0) << HEAP32[$3 + 8 >> 2] | HEAP32[$3 + 96 >> 2];
      jsvArrayBufferIteratorNext($3 + 28 | 0);
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 8;
      continue;
     }
     break;
    };
   }
  }
  jsvArrayBufferIteratorFree($3 + 28 | 0);
  __stack_pointer = $3 + 112 | 0;
  return HEAP32[$3 + 96 >> 2];
 }
 
 function lcdSetPixels_ArrayBuffer($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 128 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 124 >> 2] = $0;
  HEAP32[$5 + 120 >> 2] = $1;
  HEAP32[$5 + 116 >> 2] = $2;
  HEAP32[$5 + 112 >> 2] = $3;
  HEAP32[$5 + 108 >> 2] = $4;
  $0 = HEAP32[$5 + 124 >> 2];
  HEAP32[$5 + 104 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
  HEAP32[$5 + 100 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$5 + 124 >> 2], HEAP32[$5 + 120 >> 2], HEAP32[$5 + 116 >> 2], HEAP32[$5 + 112 >> 2]);
  jsvArrayBufferIteratorNew($5 + 40 | 0, HEAP32[$5 + 104 >> 2], HEAP32[$5 + 100 >> 2] >>> 3 | 0);
  HEAP32[$5 + 36 >> 2] = (1 << HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) - 1;
  block : {
   if (HEAP32[$5 + 108 >> 2]) {
    $0 = 0;
    if (HEAP32[$5 + 36 >> 2] != (HEAP32[$5 + 108 >> 2] & HEAP32[$5 + 36 >> 2])) {
     break block
    }
   }
   $0 = HEAP32[$5 + 124 >> 2];
   $0 = ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) != 0 ^ -1;
  }
  HEAP8[$5 + 35 | 0] = $0 & 1;
  HEAP32[$5 + 28 >> 2] = HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0];
  $0 = HEAP32[$5 + 124 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] << 1;
   HEAP8[$5 + 35 | 0] = 0;
  }
  while (1) {
   block1 : {
    $0 = HEAP32[$5 + 112 >> 2];
    HEAP32[$5 + 112 >> 2] = $0 - 1;
    if (!$0) {
     break block1
    }
    block5 : {
     if (HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] & 7) {
      HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 7;
      if (!(HEAP32[$5 + 100 >> 2] | !(HEAP8[$5 + 35 | 0] & 1))) {
       HEAP32[$5 + 24 >> 2] = Math_imul(HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0], HEAP32[$5 + 112 >> 2] + 1 | 0) >> 3;
       if (HEAP32[$5 + 24 >> 2]) {
        HEAP8[$5 + 23 | 0] = HEAP32[$5 + 108 >> 2] ? 255 : 0;
        HEAP32[$5 + 112 >> 2] = (HEAP32[$5 + 112 >> 2] + 1 | 0) - ((HEAP32[$5 + 24 >> 2] << 3) / HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] | 0);
        while (1) {
         $0 = HEAP32[$5 + 24 >> 2];
         HEAP32[$5 + 24 >> 2] = $0 - 1;
         if ($0) {
          jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, HEAP8[$5 + 23 | 0] << 24 >> 24);
          jsvArrayBufferIteratorNext($5 + 40 | 0);
          continue;
         }
         break;
        };
        continue;
       }
      }
      HEAP32[$5 + 16 >> 2] = (1 << HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) - 1;
      HEAP32[$5 + 12 >> 2] = jsvArrayBufferIteratorGetIntegerValue($5 + 40 | 0);
      $0 = HEAP32[$5 + 124 >> 2];
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
       $0 = 8 - (HEAP32[$5 + 100 >> 2] + HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] | 0) | 0
      } else {
       $0 = HEAP32[$5 + 100 >> 2]
      }
      HEAP32[$5 + 8 >> 2] = $0;
      jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, (HEAP32[$5 + 12 >> 2] & (HEAP32[$5 + 16 >> 2] << HEAP32[$5 + 8 >> 2] ^ -1) | (HEAP32[$5 + 108 >> 2] & HEAP32[$5 + 16 >> 2]) << HEAP32[$5 + 8 >> 2]) << 24 >> 24);
      $0 = HEAP32[$5 + 124 >> 2];
      block4 : {
       if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
        jsvArrayBufferIteratorNext($5 + 40 | 0);
        break block4;
       }
       HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 100 >> 2];
       if (HEAPU32[$5 + 100 >> 2] >= 8) {
        jsvArrayBufferIteratorNext($5 + 40 | 0)
       }
      }
      break block5;
     }
     $0 = HEAP32[$5 + 124 >> 2];
     block6 : {
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
       HEAP32[$5 + 4 >> 2] = HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] - 8;
       while (1) {
        if (HEAP32[$5 + 4 >> 2] >= 0) {
         jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, HEAP32[$5 + 108 >> 2] >>> HEAP32[$5 + 4 >> 2] << 24 >> 24);
         jsvArrayBufferIteratorNext($5 + 40 | 0);
         HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] - 8;
         continue;
        }
        break;
       };
       break block6;
      }
      HEAP32[$5 >> 2] = 0;
      while (1) {
       if (HEAP32[$5 >> 2] < HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) {
        jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, HEAP32[$5 + 108 >> 2] >>> HEAP32[$5 >> 2] << 24 >> 24);
        jsvArrayBufferIteratorNext($5 + 40 | 0);
        HEAP32[$5 >> 2] = HEAP32[$5 >> 2] + 8;
        continue;
       }
       break;
      };
     }
    }
    continue;
   }
   break;
  };
  jsvArrayBufferIteratorFree($5 + 40 | 0);
  __stack_pointer = $5 + 128 | 0;
 }
 
 function lcdSetPixel_ArrayBuffer($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  lcdSetPixels_ArrayBuffer(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], 1, HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function lcdFillRect_ArrayBuffer($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
  while (1) {
   if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 12 >> 2]) {
    lcdSetPixels_ArrayBuffer(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 4 >> 2], (HEAP32[$6 + 16 >> 2] + 1 | 0) - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 8 >> 2]);
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $6 + 32 | 0;
 }
 
 function lcdGetPixel_ArrayBuffer_flat($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  HEAP32[$3 + 32 >> 2] = 0;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 28 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
  HEAP32[$3 + 24 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2], 1);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 24 >> 2] >>> 3 | 0);
  block1 : {
   if (HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] & 7) {
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] & 7;
    HEAP32[$3 + 20 >> 2] = (1 << HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0]) - 1;
    HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 28 >> 2]];
    $0 = HEAP32[$3 + 44 >> 2];
    if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
     $0 = 8 - (HEAP32[$3 + 24 >> 2] + HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] | 0) | 0
    } else {
     $0 = HEAP32[$3 + 24 >> 2]
    }
    HEAP32[$3 + 12 >> 2] = $0;
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 20 >> 2] & HEAP32[$3 + 16 >> 2] >>> HEAP32[$3 + 12 >> 2];
    break block1;
   }
   $0 = HEAP32[$3 + 44 >> 2];
   block2 : {
    if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
     HEAP32[$3 + 8 >> 2] = HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] - 8;
     while (1) {
      if (HEAP32[$3 + 8 >> 2] >= 0) {
       HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | HEAPU8[HEAP32[$3 + 28 >> 2]] << HEAP32[$3 + 8 >> 2];
       HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
       HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] - 8;
       continue;
      }
      break;
     };
     break block2;
    }
    HEAP32[$3 + 4 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 4 >> 2] < HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0]) {
      HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | HEAPU8[HEAP32[$3 + 28 >> 2]] << HEAP32[$3 + 4 >> 2];
      HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
      HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 8;
      continue;
     }
     break;
    };
   }
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 32 >> 2];
 }
 
 function lcdSetPixels_ArrayBuffer_flat($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 80 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 76 >> 2] = $0;
  HEAP32[$5 + 72 >> 2] = $1;
  HEAP32[$5 + 68 >> 2] = $2;
  HEAP32[$5 + 64 >> 2] = $3;
  HEAP32[$5 + 60 >> 2] = $4;
  $0 = HEAP32[$5 + 76 >> 2];
  HEAP32[$5 + 56 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
  HEAP32[$5 + 52 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2], HEAP32[$5 + 68 >> 2], HEAP32[$5 + 64 >> 2]);
  HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + (HEAP32[$5 + 52 >> 2] >>> 3 | 0);
  HEAP32[$5 + 48 >> 2] = (1 << HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) - 1;
  block : {
   if (HEAP32[$5 + 60 >> 2]) {
    $0 = 0;
    if (HEAP32[$5 + 48 >> 2] != (HEAP32[$5 + 60 >> 2] & HEAP32[$5 + 48 >> 2])) {
     break block
    }
   }
   $0 = HEAP32[$5 + 76 >> 2];
   $0 = ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) != 0 ^ -1;
  }
  HEAP8[$5 + 47 | 0] = $0 & 1;
  HEAP32[$5 + 40 >> 2] = HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0];
  $0 = HEAP32[$5 + 76 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
   HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 40 >> 2] << 1;
   HEAP8[$5 + 47 | 0] = 0;
  }
  while (1) {
   block1 : {
    $0 = HEAP32[$5 + 64 >> 2];
    HEAP32[$5 + 64 >> 2] = $0 - 1;
    if (!$0) {
     break block1
    }
    block5 : {
     if (HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] & 7) {
      HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 52 >> 2] & 7;
      if (!(HEAP32[$5 + 52 >> 2] | !(HEAP8[$5 + 47 | 0] & 1))) {
       HEAP32[$5 + 36 >> 2] = Math_imul(HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0], HEAP32[$5 + 64 >> 2] + 1 | 0) >> 3;
       if (HEAP32[$5 + 36 >> 2]) {
        HEAP8[$5 + 35 | 0] = HEAP32[$5 + 60 >> 2] ? 255 : 0;
        HEAP32[$5 + 64 >> 2] = (HEAP32[$5 + 64 >> 2] + 1 | 0) - ((HEAP32[$5 + 36 >> 2] << 3) / HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] | 0);
        while (1) {
         $0 = HEAP32[$5 + 36 >> 2];
         HEAP32[$5 + 36 >> 2] = $0 - 1;
         if ($0) {
          HEAP8[HEAP32[$5 + 56 >> 2]] = HEAPU8[$5 + 35 | 0];
          HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
          continue;
         }
         break;
        };
        continue;
       }
      }
      HEAP32[$5 + 28 >> 2] = (1 << HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) - 1;
      HEAP32[$5 + 24 >> 2] = HEAPU8[HEAP32[$5 + 56 >> 2]];
      $0 = HEAP32[$5 + 76 >> 2];
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
       $0 = 8 - (HEAP32[$5 + 52 >> 2] + HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] | 0) | 0
      } else {
       $0 = HEAP32[$5 + 52 >> 2]
      }
      HEAP32[$5 + 20 >> 2] = $0;
      HEAP8[HEAP32[$5 + 56 >> 2]] = HEAP32[$5 + 24 >> 2] & (HEAP32[$5 + 28 >> 2] << HEAP32[$5 + 20 >> 2] ^ -1) | (HEAP32[$5 + 60 >> 2] & HEAP32[$5 + 28 >> 2]) << HEAP32[$5 + 20 >> 2];
      $0 = HEAP32[$5 + 76 >> 2];
      block4 : {
       if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
        HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
        break block4;
       }
       HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 52 >> 2];
       if (HEAPU32[$5 + 52 >> 2] >= 8) {
        HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1
       }
      }
      break block5;
     }
     $0 = HEAP32[$5 + 76 >> 2];
     block6 : {
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
       HEAP32[$5 + 16 >> 2] = HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] - 8;
       while (1) {
        if (HEAP32[$5 + 16 >> 2] >= 0) {
         $1 = HEAP32[$5 + 60 >> 2];
         $2 = HEAP32[$5 + 16 >> 2];
         $0 = HEAP32[$5 + 56 >> 2];
         HEAP32[$5 + 56 >> 2] = $0 + 1;
         HEAP8[$0 | 0] = $1 >>> $2;
         HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] - 8;
         continue;
        }
        break;
       };
       break block6;
      }
      HEAP32[$5 + 12 >> 2] = 0;
      while (1) {
       if (HEAP32[$5 + 12 >> 2] < HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) {
        $1 = HEAP32[$5 + 60 >> 2];
        $2 = HEAP32[$5 + 12 >> 2];
        $0 = HEAP32[$5 + 56 >> 2];
        HEAP32[$5 + 56 >> 2] = $0 + 1;
        HEAP8[$0 | 0] = $1 >>> $2;
        HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 8;
        continue;
       }
       break;
      };
     }
    }
    continue;
   }
   break;
  };
  __stack_pointer = $5 + 80 | 0;
 }
 
 function lcdSetPixel_ArrayBuffer_flat($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  lcdSetPixels_ArrayBuffer_flat(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], 1, HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function lcdFillRect_ArrayBuffer_flat($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
  while (1) {
   if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 12 >> 2]) {
    lcdSetPixels_ArrayBuffer_flat(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 4 >> 2], (HEAP32[$6 + 16 >> 2] + 1 | 0) - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 8 >> 2]);
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $6 + 32 | 0;
 }
 
 function lcdScroll_ArrayBuffer_flat($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  var $7 = 0;
  $7 = __stack_pointer + -64 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 60 >> 2] = $0;
  HEAP32[$7 + 56 >> 2] = $1;
  HEAP32[$7 + 52 >> 2] = $2;
  HEAP32[$7 + 48 >> 2] = $3;
  HEAP32[$7 + 44 >> 2] = $4;
  HEAP32[$7 + 40 >> 2] = $5;
  HEAP32[$7 + 36 >> 2] = $6;
  block4 : {
   block : {
    if (HEAP32[$7 + 48 >> 2]) {
     break block
    }
    $0 = HEAP32[$7 + 60 >> 2];
    if (HEAP32[$7 + 56 >> 2] | HEAP32[$7 + 40 >> 2] != ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1 | 0)) {
     break block
    }
    $0 = HEAP32[$7 + 60 >> 2];
    if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
     break block
    }
    $0 = HEAP32[$7 + 52 >> 2];
    $1 = $0 >> 31;
    HEAP32[$7 + 32 >> 2] = (HEAP32[$7 + 36 >> 2] + 1 | 0) - HEAP32[$7 + 44 >> 2] - (($1 ^ $0) - $1);
    HEAP32[$7 + 28 >> 2] = Math_imul(HEAP32[$7 + 32 >> 2], (HEAP32[$7 + 40 >> 2] + 1 | 0) - HEAP32[$7 + 48 >> 2] | 0);
    if (HEAP32[$7 + 52 >> 2] < 0) {
     $0 = 0 - HEAP32[$7 + 52 >> 2] | 0
    } else {
     $0 = 0
    }
    HEAP32[$7 + 24 >> 2] = $0 + HEAP32[$7 + 44 >> 2];
    if (HEAP32[$7 + 52 >> 2] > 0) {
     $0 = HEAP32[$7 + 52 >> 2]
    } else {
     $0 = 0
    }
    HEAP32[$7 + 20 >> 2] = $0 + HEAP32[$7 + 44 >> 2];
    HEAP32[$7 + 16 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 48 >> 2], HEAP32[$7 + 24 >> 2], HEAP32[$7 + 28 >> 2]);
    HEAP32[$7 + 12 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 48 >> 2], HEAP32[$7 + 20 >> 2], HEAP32[$7 + 28 >> 2]);
    HEAP32[$7 + 8 >> 2] = Math_imul(HEAP32[$7 + 28 >> 2], HEAPU8[HEAP32[$7 + 60 >> 2] + 16 | 0]);
    if (!(HEAP32[$7 + 8 >> 2] & 7 | (HEAP32[$7 + 16 >> 2] & 7 | HEAP32[$7 + 12 >> 2] & 7))) {
     $0 = HEAP32[$7 + 60 >> 2];
     HEAP32[$7 + 4 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
     $1 = HEAP32[$7 + 4 >> 2];
     $2 = HEAP32[$7 + 12 >> 2];
     $3 = HEAP32[$7 + 4 >> 2];
     $4 = HEAP32[$7 + 16 >> 2];
     $0 = HEAP32[$7 + 8 >> 2] >>> 3 | 0;
     if ($0) {
      wasm2js_memory_copy(($2 >>> 3 | 0) + $1 | 0, ($4 >>> 3 | 0) + $3 | 0, $0)
     }
     break block4;
    }
   }
   graphicsFallbackScroll(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 56 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2], HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2]);
  }
  __stack_pointer = $7 - -64 | 0;
 }
 
 function lcdSetPixel_ArrayBuffer_flat1($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 8 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 3);
  block : {
   if (HEAP32[$4 + 16 >> 2]) {
    $0 = HEAP32[$4 + 8 >> 2];
    HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 128 >> (HEAP32[$4 + 12 >> 2] & 7) & 255;
    break block;
   }
   $0 = HEAP32[$4 + 8 >> 2];
   HEAP8[$0 | 0] = HEAPU8[$0 | 0] & (65407 >> (HEAP32[$4 + 12 >> 2] & 7) & 255);
  }
 }
 
 function lcdGetPixel_ArrayBuffer_flat1($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 + 15 | 0] = HEAPU8[(HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] >> 3) | 0];
  return HEAPU8[$3 + 15 | 0] >> 7 - (HEAP32[$3 + 16 >> 2] & 7) & 1;
 }
 
 function lcdFillRect_ArrayBuffer_flat1($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 80 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 76 >> 2] = $0;
  HEAP32[$6 + 72 >> 2] = $1;
  HEAP32[$6 + 68 >> 2] = $2;
  HEAP32[$6 + 64 >> 2] = $3;
  HEAP32[$6 + 60 >> 2] = $4;
  HEAP32[$6 + 56 >> 2] = $5;
  block : {
   if ((HEAP32[$6 + 64 >> 2] - HEAP32[$6 + 72 >> 2] | 0) < 8) {
    lcdFillRect_ArrayBuffer_flat(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 72 >> 2], HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2]);
    break block;
   }
   $0 = HEAP32[$6 + 76 >> 2];
   HEAP32[$6 + 52 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
   HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 56 >> 2] & 1;
   HEAP8[$6 + 51 | 0] = HEAP32[$6 + 56 >> 2] & 255 | HEAP32[$6 + 56 >> 2] << 1 & 255;
   HEAP8[$6 + 51 | 0] = HEAPU8[$6 + 51 | 0] | HEAPU8[$6 + 51 | 0] << 2;
   HEAP8[$6 + 51 | 0] = HEAPU8[$6 + 51 | 0] | HEAPU8[$6 + 51 | 0] << 4;
   HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 68 >> 2];
   while (1) {
    if (HEAP32[$6 + 44 >> 2] > HEAP32[$6 + 60 >> 2]) {
     break block
    }
    $0 = HEAP32[$6 + 76 >> 2];
    HEAP32[$6 + 40 >> 2] = Math_imul(HEAP32[$6 + 44 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
    HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 72 >> 2] + HEAP32[$6 + 40 >> 2];
    HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 64 >> 2] + HEAP32[$6 + 40 >> 2];
    HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 52 >> 2] + (HEAP32[$6 + 36 >> 2] >> 3);
    if (HEAP32[$6 + 36 >> 2] & 7) {
     HEAP32[$6 + 24 >> 2] = 8 - (HEAP32[$6 + 36 >> 2] & 7);
     HEAP32[$6 + 20 >> 2] = 255 << HEAP32[$6 + 24 >> 2] ^ -1;
     HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 20 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 20 >> 2];
     HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
     HEAP32[$6 + 36 >> 2] = (HEAP32[$6 + 36 >> 2] & -8) + 8;
    }
    while (1) {
     if (HEAP32[$6 + 32 >> 2] >= (HEAP32[$6 + 36 >> 2] + 7 | 0)) {
      $1 = HEAPU8[$6 + 51 | 0];
      $0 = HEAP32[$6 + 28 >> 2];
      HEAP32[$6 + 28 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = $1;
      HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 8;
      continue;
     }
     break;
    };
    if (HEAP32[$6 + 36 >> 2] <= HEAP32[$6 + 32 >> 2]) {
     HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 32 >> 2] + 1 | 0) - HEAP32[$6 + 36 >> 2];
     HEAP32[$6 + 12 >> 2] = 255 >> HEAP32[$6 + 16 >> 2] ^ -1;
     HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 12 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 12 >> 2];
    }
    HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 44 >> 2] + 1;
    continue;
   };
  }
  __stack_pointer = $6 + 80 | 0;
 }
 
 function lcdSetPixel_ArrayBuffer_flat2($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  HEAP32[$4 + 8 >> 2] = (HEAP32[$4 + 12 >> 2] & 3) << 1;
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 4 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 2);
  HEAP8[HEAP32[$4 + 4 >> 2]] = HEAPU8[HEAP32[$4 + 4 >> 2]] & 65343 >> HEAP32[$4 + 8 >> 2] | (HEAP32[$4 + 16 >> 2] & 3) << 6 - HEAP32[$4 + 8 >> 2];
 }
 
 function lcdGetPixel_ArrayBuffer_flat2($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 16 >> 2] & 3) << 1;
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 8 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] >> 2);
  return HEAPU8[HEAP32[$3 + 8 >> 2]] >> 6 - HEAP32[$3 + 12 >> 2] & 3;
 }
 
 function lcdFillRect_ArrayBuffer_flat2($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 80 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 76 >> 2] = $0;
  HEAP32[$6 + 72 >> 2] = $1;
  HEAP32[$6 + 68 >> 2] = $2;
  HEAP32[$6 + 64 >> 2] = $3;
  HEAP32[$6 + 60 >> 2] = $4;
  HEAP32[$6 + 56 >> 2] = $5;
  block : {
   if ((HEAP32[$6 + 64 >> 2] - HEAP32[$6 + 72 >> 2] | 0) < 4) {
    lcdFillRect_ArrayBuffer_flat(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 72 >> 2], HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2]);
    break block;
   }
   $0 = HEAP32[$6 + 76 >> 2];
   HEAP32[$6 + 52 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
   HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 56 >> 2] & 3;
   HEAP8[$6 + 51 | 0] = HEAP32[$6 + 56 >> 2] & 255 | HEAP32[$6 + 56 >> 2] << 2 & 255;
   HEAP8[$6 + 51 | 0] = HEAPU8[$6 + 51 | 0] | HEAPU8[$6 + 51 | 0] << 4;
   HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 68 >> 2];
   while (1) {
    if (HEAP32[$6 + 44 >> 2] > HEAP32[$6 + 60 >> 2]) {
     break block
    }
    $0 = HEAP32[$6 + 76 >> 2];
    HEAP32[$6 + 40 >> 2] = Math_imul(HEAP32[$6 + 44 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
    HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 72 >> 2] + HEAP32[$6 + 40 >> 2];
    HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 64 >> 2] + HEAP32[$6 + 40 >> 2];
    HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 52 >> 2] + (HEAP32[$6 + 36 >> 2] >> 2);
    if (HEAP32[$6 + 36 >> 2] & 3) {
     HEAP32[$6 + 24 >> 2] = 4 - (HEAP32[$6 + 36 >> 2] & 3);
     HEAP32[$6 + 20 >> 2] = 255 << (HEAP32[$6 + 24 >> 2] << 1) ^ -1;
     HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 20 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 20 >> 2];
     HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
     HEAP32[$6 + 36 >> 2] = (HEAP32[$6 + 36 >> 2] & -4) + 4;
    }
    while (1) {
     if (HEAP32[$6 + 32 >> 2] >= (HEAP32[$6 + 36 >> 2] + 3 | 0)) {
      $1 = HEAPU8[$6 + 51 | 0];
      $0 = HEAP32[$6 + 28 >> 2];
      HEAP32[$6 + 28 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = $1;
      HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 4;
      continue;
     }
     break;
    };
    if (HEAP32[$6 + 36 >> 2] <= HEAP32[$6 + 32 >> 2]) {
     HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 32 >> 2] + 1 | 0) - HEAP32[$6 + 36 >> 2];
     HEAP32[$6 + 12 >> 2] = 255 >> (HEAP32[$6 + 16 >> 2] << 1) ^ -1;
     HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 12 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 12 >> 2];
    }
    HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 44 >> 2] + 1;
    continue;
   };
  }
  __stack_pointer = $6 + 80 | 0;
 }
 
 function lcdSetPixel_ArrayBuffer_flat4($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  HEAP32[$4 + 8 >> 2] = (HEAP32[$4 + 12 >> 2] & 1) << 2;
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 4 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 1);
  HEAP8[HEAP32[$4 + 4 >> 2]] = HEAPU8[HEAP32[$4 + 4 >> 2]] & 65295 >> HEAP32[$4 + 8 >> 2] | (HEAP32[$4 + 16 >> 2] & 15) << 4 - HEAP32[$4 + 8 >> 2];
 }
 
 function lcdGetPixel_ArrayBuffer_flat4($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 16 >> 2] & 1) << 2;
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 8 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] >> 1);
  return HEAPU8[HEAP32[$3 + 8 >> 2]] >> 4 - HEAP32[$3 + 12 >> 2] & 15;
 }
 
 function lcdFillRect_ArrayBuffer_flat4($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer + -64 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 60 >> 2] = $0;
  HEAP32[$6 + 56 >> 2] = $1;
  HEAP32[$6 + 52 >> 2] = $2;
  HEAP32[$6 + 48 >> 2] = $3;
  HEAP32[$6 + 44 >> 2] = $4;
  HEAP32[$6 + 40 >> 2] = $5;
  block : {
   if ((HEAP32[$6 + 48 >> 2] - HEAP32[$6 + 56 >> 2] | 0) < 2) {
    lcdFillRect_ArrayBuffer_flat(HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2], HEAP32[$6 + 52 >> 2], HEAP32[$6 + 48 >> 2], HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2]);
    break block;
   }
   $0 = HEAP32[$6 + 60 >> 2];
   HEAP32[$6 + 36 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
   HEAP32[$6 + 40 >> 2] = HEAP32[$6 + 40 >> 2] & 15;
   HEAP8[$6 + 35 | 0] = HEAP32[$6 + 40 >> 2] & 255 | HEAP32[$6 + 40 >> 2] << 4 & 255;
   HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 52 >> 2];
   while (1) {
    if (HEAP32[$6 + 28 >> 2] > HEAP32[$6 + 44 >> 2]) {
     break block
    }
    $0 = HEAP32[$6 + 60 >> 2];
    HEAP32[$6 + 24 >> 2] = Math_imul(HEAP32[$6 + 28 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
    HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 56 >> 2] + HEAP32[$6 + 24 >> 2];
    HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 48 >> 2] + HEAP32[$6 + 24 >> 2];
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 36 >> 2] + (HEAP32[$6 + 20 >> 2] >> 1);
    if (HEAP32[$6 + 20 >> 2] & 1) {
     HEAP8[HEAP32[$6 + 12 >> 2]] = HEAP32[$6 + 40 >> 2] | HEAPU8[HEAP32[$6 + 12 >> 2]] & 240;
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
     HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 1;
    }
    while (1) {
     if (HEAP32[$6 + 16 >> 2] >= (HEAP32[$6 + 20 >> 2] + 1 | 0)) {
      $1 = HEAPU8[$6 + 35 | 0];
      $0 = HEAP32[$6 + 12 >> 2];
      HEAP32[$6 + 12 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = $1;
      HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 2;
      continue;
     }
     break;
    };
    if (HEAP32[$6 + 20 >> 2] <= HEAP32[$6 + 16 >> 2]) {
     HEAP8[HEAP32[$6 + 12 >> 2]] = HEAPU8[HEAP32[$6 + 12 >> 2]] & 15 | HEAP32[$6 + 40 >> 2] << 4
    }
    HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
    continue;
   };
  }
  __stack_pointer = $6 - -64 | 0;
 }
 
 function lcdSetPixel_ArrayBuffer_flat8($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $1 = HEAP32[$4 + 12 >> 2];
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP8[(HEAP32[$4 + 8 >> 2] + Math_imul(HEAP32[$4 + 4 >> 2], HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0] = HEAP32[$4 >> 2];
 }
 
 function lcdGetPixel_ArrayBuffer_flat8($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $1 = HEAP32[$3 + 12 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  return HEAPU8[(HEAP32[$3 + 8 >> 2] + Math_imul(HEAP32[$3 + 4 >> 2], HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0];
 }
 
 function lcdFillRect_ArrayBuffer_flat8($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 48 | 0;
  HEAP32[$6 + 44 >> 2] = $0;
  HEAP32[$6 + 40 >> 2] = $1;
  HEAP32[$6 + 36 >> 2] = $2;
  HEAP32[$6 + 32 >> 2] = $3;
  HEAP32[$6 + 28 >> 2] = $4;
  HEAP32[$6 + 24 >> 2] = $5;
  HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 36 >> 2];
  while (1) {
   if (HEAP32[$6 + 20 >> 2] <= HEAP32[$6 + 28 >> 2]) {
    $1 = HEAP32[$6 + 44 >> 2];
    $0 = HEAP32[$6 + 44 >> 2];
    HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 40 >> 2] + Math_imul(HEAP32[$6 + 20 >> 2], HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24));
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 40 >> 2];
    while (1) {
     if (HEAP32[$6 + 12 >> 2] <= HEAP32[$6 + 32 >> 2]) {
      $1 = HEAP32[$6 + 24 >> 2];
      $0 = HEAP32[$6 + 16 >> 2];
      HEAP32[$6 + 16 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = $1;
      HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 1;
    continue;
   }
   break;
  };
 }
 
 function lcdScroll_ArrayBuffer_flat8($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  var $7 = 0;
  $7 = __stack_pointer - 48 | 0;
  HEAP32[$7 + 44 >> 2] = $0;
  HEAP32[$7 + 40 >> 2] = $1;
  HEAP32[$7 + 36 >> 2] = $2;
  HEAP32[$7 + 32 >> 2] = $3;
  HEAP32[$7 + 28 >> 2] = $4;
  HEAP32[$7 + 24 >> 2] = $5;
  HEAP32[$7 + 20 >> 2] = $6;
  HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 24 >> 2] - HEAP32[$7 + 32 >> 2];
  HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 20 >> 2] - HEAP32[$7 + 28 >> 2];
  HEAP32[$7 + 8 >> 2] = 0 - (HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 36 >> 2], HEAP32[$7 + 16 >> 2]) | 0);
  $0 = HEAP32[$7 + 44 >> 2];
  HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 32 >> 2] + Math_imul(HEAP32[$7 + 28 >> 2] - HEAP32[$7 + 36 >> 2] | 0, HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
  HEAP32[$7 >> 2] = 0;
  while (1) {
   if (HEAP32[$7 >> 2] < (HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 36 >> 2] | 0)) {
    block : {
     if (HEAP32[$7 + 8 >> 2] < 0) {
      $0 = HEAP32[$7 + 44 >> 2];
      $1 = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
      $2 = HEAP32[$7 + 4 >> 2];
      $3 = HEAP32[$7 + 8 >> 2];
      $0 = HEAP32[$7 + 44 >> 2];
      $4 = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
      $5 = HEAP32[$7 + 4 >> 2];
      $0 = HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 40 >> 2] | 0;
      if ($0) {
       wasm2js_memory_copy(($2 - $3 | 0) + $1 | 0, $4 + $5 | 0, $0)
      }
      break block;
     }
     $0 = HEAP32[$7 + 44 >> 2];
     $1 = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
     $2 = HEAP32[$7 + 4 >> 2];
     $0 = HEAP32[$7 + 44 >> 2];
     $3 = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
     $4 = HEAP32[$7 + 4 >> 2];
     $5 = HEAP32[$7 + 8 >> 2];
     $0 = HEAP32[$7 + 16 >> 2] - HEAP32[$7 + 40 >> 2] | 0;
     if ($0) {
      wasm2js_memory_copy($1 + $2 | 0, ($4 + $5 | 0) + $3 | 0, $0)
     }
    }
    $0 = HEAP32[$7 + 44 >> 2];
    HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
    HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + 1;
    continue;
   }
   break;
  };
 }
 
 function lcdInit_ArrayBuffer($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 8 >> 2]) {
    $0 = HEAP32[$2 + 12 >> 2];
    jsvUnLock(jsvAddNamedChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$2 + 8 >> 2], 8164));
    break block;
   }
   HEAP32[$2 + 4 >> 2] = jswrap_arraybuffer_constructor(graphicsGetMemoryRequired(HEAP32[$2 + 12 >> 2]));
   $0 = HEAP32[$2 + 12 >> 2];
   jsvAddNamedChildAndUnLock(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$2 + 4 >> 2], 8164);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function lcdSetCallbacks_ArrayBuffer($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 8164);
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 >> 2] = jsvGetDataPointer(HEAP32[$1 + 8 >> 2], $1 + 4 | 0);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  block9 : {
   block : {
    if (!HEAP32[$1 >> 2]) {
     break block
    }
    if (HEAPU32[$1 + 4 >> 2] < graphicsGetMemoryRequired(HEAP32[$1 + 12 >> 2]) >>> 0) {
     break block
    }
    $0 = HEAP32[$1 + 12 >> 2];
    if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1) {
     break block
    }
    $0 = HEAP32[$1 + 12 >> 2];
    $2 = HEAP32[$1 >> 2];
    HEAP8[$0 + 48 | 0] = $2;
    HEAP8[$0 + 49 | 0] = $2 >>> 8;
    HEAP8[$0 + 50 | 0] = $2 >>> 16;
    HEAP8[$0 + 51 | 0] = $2 >>> 24;
    block2 : {
     block1 : {
      if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 1) {
       break block1
      }
      $0 = HEAP32[$1 + 12 >> 2];
      if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4)) {
       break block1
      }
      $0 = HEAP32[$1 + 12 >> 2];
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
       break block1
      }
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 52 | 0] = 85;
      HEAP8[$0 + 53 | 0] = 2;
      HEAP8[$0 + 54 | 0] = 0;
      HEAP8[$0 + 55 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 60 | 0] = 86;
      HEAP8[$0 + 61 | 0] = 2;
      HEAP8[$0 + 62 | 0] = 0;
      HEAP8[$0 + 63 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 56 | 0] = 87;
      HEAP8[$0 + 57 | 0] = 2;
      HEAP8[$0 + 58 | 0] = 0;
      HEAP8[$0 + 59 | 0] = 0;
      break block2;
     }
     block4 : {
      block3 : {
       if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 2) {
        break block3
       }
       $0 = HEAP32[$1 + 12 >> 2];
       if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4)) {
        break block3
       }
       $0 = HEAP32[$1 + 12 >> 2];
       if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
        break block3
       }
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 52 | 0] = 88;
       HEAP8[$0 + 53 | 0] = 2;
       HEAP8[$0 + 54 | 0] = 0;
       HEAP8[$0 + 55 | 0] = 0;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 60 | 0] = 89;
       HEAP8[$0 + 61 | 0] = 2;
       HEAP8[$0 + 62 | 0] = 0;
       HEAP8[$0 + 63 | 0] = 0;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 56 | 0] = 90;
       HEAP8[$0 + 57 | 0] = 2;
       HEAP8[$0 + 58 | 0] = 0;
       HEAP8[$0 + 59 | 0] = 0;
       break block4;
      }
      block6 : {
       block5 : {
        if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 4) {
         break block5
        }
        $0 = HEAP32[$1 + 12 >> 2];
        if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4)) {
         break block5
        }
        $0 = HEAP32[$1 + 12 >> 2];
        if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
         break block5
        }
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 52 | 0] = 91;
        HEAP8[$0 + 53 | 0] = 2;
        HEAP8[$0 + 54 | 0] = 0;
        HEAP8[$0 + 55 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 60 | 0] = 92;
        HEAP8[$0 + 61 | 0] = 2;
        HEAP8[$0 + 62 | 0] = 0;
        HEAP8[$0 + 63 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 56 | 0] = 93;
        HEAP8[$0 + 57 | 0] = 2;
        HEAP8[$0 + 58 | 0] = 0;
        HEAP8[$0 + 59 | 0] = 0;
        break block6;
       }
       block8 : {
        block7 : {
         if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 8) {
          break block7
         }
         $0 = HEAP32[$1 + 12 >> 2];
         if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
          break block7
         }
         $0 = HEAP32[$1 + 12 >> 2];
         HEAP8[$0 + 52 | 0] = 94;
         HEAP8[$0 + 53 | 0] = 2;
         HEAP8[$0 + 54 | 0] = 0;
         HEAP8[$0 + 55 | 0] = 0;
         $0 = HEAP32[$1 + 12 >> 2];
         HEAP8[$0 + 60 | 0] = 95;
         HEAP8[$0 + 61 | 0] = 2;
         HEAP8[$0 + 62 | 0] = 0;
         HEAP8[$0 + 63 | 0] = 0;
         $0 = HEAP32[$1 + 12 >> 2];
         HEAP8[$0 + 56 | 0] = 96;
         HEAP8[$0 + 57 | 0] = 2;
         HEAP8[$0 + 58 | 0] = 0;
         HEAP8[$0 + 59 | 0] = 0;
         $0 = HEAP32[$1 + 12 >> 2];
         HEAP8[$0 + 68 | 0] = 97;
         HEAP8[$0 + 69 | 0] = 2;
         HEAP8[$0 + 70 | 0] = 0;
         HEAP8[$0 + 71 | 0] = 0;
         break block8;
        }
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 52 | 0] = 98;
        HEAP8[$0 + 53 | 0] = 2;
        HEAP8[$0 + 54 | 0] = 0;
        HEAP8[$0 + 55 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 60 | 0] = 99;
        HEAP8[$0 + 61 | 0] = 2;
        HEAP8[$0 + 62 | 0] = 0;
        HEAP8[$0 + 63 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 56 | 0] = 100;
        HEAP8[$0 + 57 | 0] = 2;
        HEAP8[$0 + 58 | 0] = 0;
        HEAP8[$0 + 59 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 68 | 0] = 101;
        HEAP8[$0 + 69 | 0] = 2;
        HEAP8[$0 + 70 | 0] = 0;
        HEAP8[$0 + 71 | 0] = 0;
       }
      }
     }
    }
    break block9;
   }
   if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
    $0 = HEAP32[$1 + 12 >> 2];
    $2 = HEAP32[$1 + 8 >> 2];
    HEAP8[$0 + 48 | 0] = $2;
    HEAP8[$0 + 49 | 0] = $2 >>> 8;
    HEAP8[$0 + 50 | 0] = $2 >>> 16;
    HEAP8[$0 + 51 | 0] = $2 >>> 24;
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP8[$0 + 52 | 0] = 102;
    HEAP8[$0 + 53 | 0] = 2;
    HEAP8[$0 + 54 | 0] = 0;
    HEAP8[$0 + 55 | 0] = 0;
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP8[$0 + 60 | 0] = 103;
    HEAP8[$0 + 61 | 0] = 2;
    HEAP8[$0 + 62 | 0] = 0;
    HEAP8[$0 + 63 | 0] = 0;
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP8[$0 + 56 | 0] = 104;
    HEAP8[$0 + 57 | 0] = 2;
    HEAP8[$0 + 58 | 0] = 0;
    HEAP8[$0 + 59 | 0] = 0;
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function lcdSetPixel_JS($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 15826);
  if (HEAP32[$4 + 12 >> 2]) {
   HEAP32[$4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 24 >> 2]);
   HEAP32[$4 + 4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 20 >> 2]);
   HEAP32[$4 + 8 >> 2] = jsvNewFromInteger(HEAP32[$4 + 16 >> 2]);
   $0 = HEAP32[$4 + 28 >> 2];
   jsvUnLock(jspExecuteFunction(HEAP32[$4 + 12 >> 2], HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 3, $4));
   jsvUnLockMany(3, $4);
   jsvUnLock(HEAP32[$4 + 12 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function lcdFillRect_JS($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 48 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 44 >> 2] = $0;
  HEAP32[$6 + 40 >> 2] = $1;
  HEAP32[$6 + 36 >> 2] = $2;
  HEAP32[$6 + 32 >> 2] = $3;
  HEAP32[$6 + 28 >> 2] = $4;
  HEAP32[$6 + 24 >> 2] = $5;
  $0 = HEAP32[$6 + 44 >> 2];
  HEAP32[$6 + 20 >> 2] = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 5021);
  block : {
   if (HEAP32[$6 + 20 >> 2]) {
    HEAP32[$6 >> 2] = jsvNewFromInteger(HEAP32[$6 + 40 >> 2]);
    HEAP32[$6 + 4 >> 2] = jsvNewFromInteger(HEAP32[$6 + 36 >> 2]);
    HEAP32[$6 + 8 >> 2] = jsvNewFromInteger(HEAP32[$6 + 32 >> 2]);
    HEAP32[$6 + 12 >> 2] = jsvNewFromInteger(HEAP32[$6 + 28 >> 2]);
    HEAP32[$6 + 16 >> 2] = jsvNewFromInteger(HEAP32[$6 + 24 >> 2]);
    $0 = HEAP32[$6 + 44 >> 2];
    jsvUnLock(jspExecuteFunction(HEAP32[$6 + 20 >> 2], HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 5, $6));
    jsvUnLockMany(5, $6);
    jsvUnLock(HEAP32[$6 + 20 >> 2]);
    break block;
   }
   graphicsFallbackFillRect(HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAP32[$6 + 32 >> 2], HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2]);
  }
  __stack_pointer = $6 + 48 | 0;
 }
 
 function lcdInit_JS($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = HEAP32[$3 + 12 >> 2];
  jsvObjectSetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 15826, HEAP32[$3 + 8 >> 2]);
  $0 = HEAP32[$3 + 12 >> 2];
  jsvObjectSetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 5021, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function lcdSetCallbacks_JS($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 52 | 0] = 105;
  HEAP8[$0 + 53 | 0] = 2;
  HEAP8[$0 + 54 | 0] = 0;
  HEAP8[$0 + 55 | 0] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 56 | 0] = 106;
  HEAP8[$0 + 57 | 0] = 2;
  HEAP8[$0 + 58 | 0] = 0;
  HEAP8[$0 + 59 | 0] = 0;
 }
 
 function jsGfxChanged() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  HEAP8[$0 + 15 | 0] = HEAP8[416700] & 1;
  HEAP8[416700] = 0;
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function jsGfxGetPtr($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   if (!(HEAP32[$1 + 8 >> 2] < 176 & HEAP32[$1 + 8 >> 2] >= 0)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = Math_imul(HEAP32[$1 + 8 >> 2], 68) + 416706;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function lcdMemLCD_getRowPtr($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return Math_imul(HEAP32[$1 + 12 >> 2], 68) + 428674 | 0;
 }
 
 function lcdMemLCD_getPixel($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 16 >> 2] = (Math_imul(HEAP32[$3 + 24 >> 2], 3) + 16 | 0) + Math_imul(HEAP32[$3 + 20 >> 2], 544);
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2] & 7;
  $0 = HEAP32[$3 + 16 >> 2] >> 3;
  HEAP16[$3 + 10 >> 1] = HEAPU8[$0 + 428672 | 0] | HEAPU8[$0 + 428673 | 0] << 8;
  HEAP32[$3 + 4 >> 2] = HEAPU16[$3 + 10 >> 1] >> HEAP32[$3 + 12 >> 2] & 7;
  return (HEAP32[$3 + 4 >> 2] & 1 ? 63488 : 0) | (HEAP32[$3 + 4 >> 2] & 2 ? 2016 : 0) | (HEAP32[$3 + 4 >> 2] & 4 ? 31 : 0);
 }
 
 function lcdMemLCD_setPixel($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
  lcdMemLCD_waitForSendComplete();
  HEAP32[$4 + 12 >> 2] = (Math_imul(HEAP32[$4 + 24 >> 2], 3) + 16 | 0) + Math_imul(HEAP32[$4 + 20 >> 2], 544);
  HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 12 >> 2] & 7;
  $0 = HEAP32[$4 + 12 >> 2] >> 3;
  HEAP16[$4 + 6 >> 1] = HEAPU8[$0 + 428672 | 0] | HEAPU8[$0 + 428673 | 0] << 8;
  $0 = HEAP32[$4 + 12 >> 2] >> 3;
  $1 = HEAPU16[$4 + 6 >> 1] & (7 << HEAP32[$4 + 8 >> 2] ^ -1) | HEAP32[$4 + 16 >> 2] << HEAP32[$4 + 8 >> 2];
  HEAP8[$0 + 428672 | 0] = $1;
  HEAP8[$0 + 428673 | 0] = $1 >>> 8;
  __stack_pointer = $4 + 32 | 0;
 }
 
 function lcdMemLCD_convert16toLCD($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = HEAPU16[(((HEAP32[$3 + 4 >> 2] & 1) << 2) + 173360 | 0) + ((HEAP32[$3 + 8 >> 2] & 1) << 1) >> 1] + (HEAP32[$3 + 12 >> 2] & 59164);
  return !!(HEAP32[$3 + 12 >> 2] & 65536) | (HEAP32[$3 + 12 >> 2] & 2048 ? 2 : 0) | (HEAP32[$3 + 12 >> 2] & 32 ? 4 : 0);
 }
 
 function lcdMemLCD_waitForSendComplete() {
  var $0 = 0, $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = 1e6;
  while (1) {
   $0 = 0;
   if (HEAP8[440776] & 1) {
    $0 = HEAP32[$1 + 12 >> 2] - 1 | 0;
    HEAP32[$1 + 12 >> 2] = $0;
    $0 = ($0 | 0) != 0;
   }
   if ($0) {
    continue
   }
   break;
  };
  if (HEAP8[440776] & 1) {
   HEAP8[440776] = 0
  }
 }
 
 function lcdMemLCD_fillRect($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0;
  $6 = __stack_pointer - 80 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 76 >> 2] = $0;
  HEAP32[$6 + 72 >> 2] = $1;
  HEAP32[$6 + 68 >> 2] = $2;
  HEAP32[$6 + 64 >> 2] = $3;
  HEAP32[$6 + 60 >> 2] = $4;
  HEAP32[$6 + 56 >> 2] = $5;
  lcdMemLCD_waitForSendComplete();
  block1 : {
   if (!(HEAP32[$6 + 72 >> 2] | HEAP32[$6 + 64 >> 2] != 175 | (HEAP32[$6 + 56 >> 2] != 65535 ? HEAP32[$6 + 56 >> 2] : 0))) {
    HEAP32[$6 + 52 >> 2] = Math_imul(HEAP32[$6 + 68 >> 2], 68) + 2;
    HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 68 >> 2];
    while (1) {
     if (HEAP32[$6 + 48 >> 2] <= HEAP32[$6 + 60 >> 2]) {
      wasm2js_memory_fill(HEAP32[$6 + 52 >> 2] + 428672 | 0, HEAP32[$6 + 56 >> 2] ? 255 : 0, 66);
      HEAP32[$6 + 52 >> 2] = HEAP32[$6 + 52 >> 2] + 68;
      HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 48 >> 2] + 1;
      continue;
     }
     break;
    };
    break block1;
   }
   HEAP32[$6 + 32 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 0, 0);
   HEAP32[$6 + 36 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 1, 0);
   HEAP32[$6 + 40 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 0, 1);
   HEAP32[$6 + 44 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 1, 1);
   HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 68 >> 2];
   while (1) {
    if (HEAP32[$6 + 28 >> 2] <= HEAP32[$6 + 60 >> 2]) {
     HEAP32[$6 + 24 >> 2] = ($6 + 32 | 0) + ((HEAP32[$6 + 28 >> 2] & 1) << 3);
     HEAP32[$6 + 20 >> 2] = (Math_imul(HEAP32[$6 + 72 >> 2], 3) + 16 | 0) + Math_imul(HEAP32[$6 + 28 >> 2], 544);
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 72 >> 2];
     while (1) {
      if (HEAP32[$6 + 16 >> 2] <= HEAP32[$6 + 64 >> 2]) {
       HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 20 >> 2] & 7;
       $0 = HEAP32[$6 + 20 >> 2] >> 3;
       HEAP16[$6 + 10 >> 1] = HEAPU8[$0 + 428672 | 0] | HEAPU8[$0 + 428673 | 0] << 8;
       $0 = HEAP32[$6 + 20 >> 2] >> 3;
       $1 = HEAPU16[$6 + 10 >> 1] & (7 << HEAP32[$6 + 12 >> 2] ^ -1) | HEAP32[HEAP32[$6 + 24 >> 2] + ((HEAP32[$6 + 16 >> 2] & 1) << 2) >> 2] << HEAP32[$6 + 12 >> 2];
       HEAP8[$0 + 428672 | 0] = $1;
       HEAP8[$0 + 428673 | 0] = $1 >>> 8;
       HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 3;
       HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
     continue;
    }
    break;
   };
  }
  __stack_pointer = $6 + 80 | 0;
 }
 
 function lcdMemLCD_scroll($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  var $7 = 0;
  $7 = __stack_pointer - 128 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 124 >> 2] = $0;
  HEAP32[$7 + 120 >> 2] = $1;
  HEAP32[$7 + 116 >> 2] = $2;
  HEAP32[$7 + 112 >> 2] = $3;
  HEAP32[$7 + 108 >> 2] = $4;
  HEAP32[$7 + 104 >> 2] = $5;
  HEAP32[$7 + 100 >> 2] = $6;
  lcdMemLCD_waitForSendComplete();
  block1 : {
   if (!(!HEAP32[$7 + 112 >> 2] & HEAP32[$7 + 104 >> 2] == 175)) {
    graphicsFallbackScroll(HEAP32[$7 + 124 >> 2], HEAP32[$7 + 120 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 112 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2], HEAP32[$7 + 100 >> 2]);
    break block1;
   }
   if (HEAP32[$7 + 116 >> 2] <= 0) {
    HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 108 >> 2];
    while (1) {
     if (HEAP32[$7 + 12 >> 2] <= (HEAP32[$7 + 100 >> 2] + HEAP32[$7 + 116 >> 2] | 0)) {
      HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 12 >> 2] - HEAP32[$7 + 116 >> 2];
      lcdMemLCD_scrollX(HEAP32[$7 + 124 >> 2], $7 + 16 | 0, Math_imul(HEAP32[$7 + 8 >> 2], 68) + 428672 | 0, HEAP32[$7 + 120 >> 2]);
      wasm2js_memory_copy(Math_imul(HEAP32[$7 + 12 >> 2], 68) + 428674 | 0, $7 + 18 | 0, 66);
      HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] + 1;
      continue;
     }
     break;
    };
    break block1;
   }
   if (HEAP32[$7 + 116 >> 2] > 0) {
    HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 100 >> 2] - HEAP32[$7 + 116 >> 2];
    while (1) {
     if (HEAP32[$7 + 4 >> 2] >= HEAP32[$7 + 108 >> 2]) {
      HEAP32[$7 >> 2] = HEAP32[$7 + 4 >> 2] + HEAP32[$7 + 116 >> 2];
      lcdMemLCD_scrollX(HEAP32[$7 + 124 >> 2], $7 + 16 | 0, Math_imul(HEAP32[$7 + 4 >> 2], 68) + 428672 | 0, HEAP32[$7 + 120 >> 2]);
      wasm2js_memory_copy(Math_imul(HEAP32[$7 >> 2], 68) + 428674 | 0, $7 + 18 | 0, 66);
      HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] - 1;
      continue;
     }
     break;
    };
   }
  }
  __stack_pointer = $7 + 128 | 0;
 }
 
 function lcdMemLCD_scrollX($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP32[$4 + 48 >> 2] = $3;
  HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 56 >> 2] + 2;
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 52 >> 2] + 2;
  block : {
   if (!HEAP32[$4 + 48 >> 2]) {
    wasm2js_memory_copy(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], 68);
    break block;
   }
   block1 : {
    if (HEAP32[$4 + 48 >> 2] < 0) {
     HEAP32[$4 + 36 >> 2] = Math_imul(HEAP32[$4 + 48 >> 2], -3);
     HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 36 >> 2] >> 5;
     HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 36 >> 2] & 31;
     HEAP32[$4 + 28 >> 2] = 528 - HEAP32[$4 + 36 >> 2] >> 5;
     HEAP32[$4 + 24 >> 2] = 0;
     while (1) {
      if (HEAP32[$4 + 24 >> 2] <= HEAP32[$4 + 28 >> 2]) {
       HEAP32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 24 >> 2] << 2) >> 2] = HEAP32[HEAP32[$4 + 40 >> 2] + ((HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 32 >> 2] | 0) + 1 << 2) >> 2] << 32 - HEAP32[$4 + 36 >> 2] | HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 32 >> 2] << 2) >> 2] >>> HEAP32[$4 + 36 >> 2];
       HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
       continue;
      }
      break;
     };
     break block1;
    }
    HEAP32[$4 + 20 >> 2] = Math_imul(HEAP32[$4 + 48 >> 2], 3);
    HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 20 >> 2] >> 5;
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] & 31;
    HEAP32[$4 + 12 >> 2] = 543 - HEAP32[$4 + 20 >> 2] >> 5;
    HEAP32[$4 + 8 >> 2] = 0;
    while (1) {
     if (HEAP32[$4 + 8 >> 2] <= HEAP32[$4 + 12 >> 2]) {
      HEAP32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 8 >> 2] << 2) >> 2] = HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 8 >> 2] - HEAP32[$4 + 16 >> 2] << 2) >> 2] << HEAP32[$4 + 20 >> 2] | HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 8 >> 2] - (HEAP32[$4 + 16 >> 2] + 1 | 0) << 2) >> 2] >>> 32 - HEAP32[$4 + 20 >> 2];
      HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
      continue;
     }
     break;
    };
   }
  }
 }
 
 function lcdMemLCD_flip($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 192 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 188 >> 2] = $0;
  $0 = HEAP32[$1 + 188 >> 2];
  $2 = HEAP32[$1 + 188 >> 2];
  if ((HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16 <= (HEAPU8[$2 + 46 | 0] | HEAPU8[$2 + 47 | 0] << 8) << 16 >> 16) {
   HEAP8[416700] = 1;
   lcdMemLCD_waitForSendComplete();
   $0 = HEAP32[$1 + 188 >> 2];
   HEAP32[$1 + 184 >> 2] = (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16;
   $0 = HEAP32[$1 + 188 >> 2];
   HEAP32[$1 + 180 >> 2] = (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16;
   HEAP32[$1 + 176 >> 2] = (HEAP32[$1 + 180 >> 2] + 1 | 0) - HEAP32[$1 + 184 >> 2];
   HEAP8[$1 + 175 | 0] = 0;
   if (HEAP32[110195]) {
    $0 = HEAP32[$1 + 188 >> 2];
    HEAP32[$1 + 84 >> 2] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
    $0 = HEAP32[$1 + 188 >> 2];
    HEAP32[$1 + 80 >> 2] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
    $0 = HEAP32[$1 + 188 >> 2];
    $2 = HEAPU8[416613] | HEAPU8[416614] << 8;
    HEAP8[$0 + 17 | 0] = $2;
    HEAP8[$0 + 18 | 0] = $2 >>> 8;
    HEAP8[$0 + 19 | 0] = $2 >>> 16;
    HEAP8[$0 + 20 | 0] = $2 >>> 24;
    $0 = HEAP32[$1 + 188 >> 2];
    $2 = HEAPU8[416615] | HEAPU8[416616] << 8;
    HEAP8[$0 + 21 | 0] = $2;
    HEAP8[$0 + 22 | 0] = $2 >>> 8;
    HEAP8[$0 + 23 | 0] = $2 >>> 16;
    HEAP8[$0 + 24 | 0] = $2 >>> 24;
    HEAP8[$1 + 175 | 0] = _jswrap_graphics_parseImage(HEAP32[$1 + 188 >> 2], HEAP32[110195], 0, $1 + 88 | 0) & 1;
    $0 = HEAP32[$1 + 188 >> 2];
    $2 = HEAP32[$1 + 84 >> 2];
    HEAP8[$0 + 17 | 0] = $2;
    HEAP8[$0 + 18 | 0] = $2 >>> 8;
    HEAP8[$0 + 19 | 0] = $2 >>> 16;
    HEAP8[$0 + 20 | 0] = $2 >>> 24;
    $0 = HEAP32[$1 + 188 >> 2];
    $2 = HEAP32[$1 + 80 >> 2];
    HEAP8[$0 + 21 | 0] = $2;
    HEAP8[$0 + 22 | 0] = $2 >>> 8;
    HEAP8[$0 + 23 | 0] = $2 >>> 16;
    HEAP8[$0 + 24 | 0] = $2 >>> 24;
   }
   jshPinSetValue(5, 1);
   block3 : {
    if (HEAP8[$1 + 175 | 0] & 1) {
     HEAP8[$1 + 79 | 0] = ((HEAPU8[416636] | HEAPU8[416637] << 8 | (HEAPU8[416638] << 16 | HEAPU8[416639] << 24)) & 112) == 96;
     HEAP32[$1 + 72 >> 2] = HEAP16[220392] << 16 >> 16;
     HEAP32[$1 + 68 >> 2] = 1;
     HEAP32[$1 + 64 >> 2] = 619;
     if (HEAP32[$1 + 72 >> 2] < HEAP32[$1 + 184 >> 2]) {
      $0 = Math_imul(HEAP32[$1 + 88 >> 2], Math_imul(HEAP32[$1 + 96 >> 2], HEAP32[$1 + 72 >> 2] - HEAP32[$1 + 184 >> 2] | 0))
     } else {
      $0 = 0
     }
     HEAP32[$1 + 60 >> 2] = $0;
     block1 : {
      if (HEAP8[$1 + 79 | 0] & 1) {
       HEAP32[$1 + 68 >> 2] = -1;
       HEAP32[$1 + 52 >> 2] = HEAP32[$1 + 184 >> 2];
       HEAP32[$1 + 184 >> 2] = HEAP32[$1 + 180 >> 2];
       HEAP32[$1 + 180 >> 2] = HEAP32[$1 + 52 >> 2] - 1;
       HEAP32[$1 + 72 >> 2] = 176 - (HEAP32[$1 + 92 >> 2] + (HEAP16[220392] << 16 >> 16) | 0);
       HEAP32[$1 + 64 >> 2] = 620;
       break block1;
      }
      HEAP32[$1 + 180 >> 2] = HEAP32[$1 + 180 >> 2] + 1;
     }
     jsvStringIteratorNew($1 + 12 | 0, HEAP32[$1 + 108 >> 2], HEAP32[$1 + 112 >> 2]);
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 184 >> 2];
     while (1) {
      if (HEAP32[$1 + 8 >> 2] != HEAP32[$1 + 180 >> 2]) {
       HEAP32[$1 + 4 >> 2] = (HEAP32[$1 + 8 >> 2] & 1) + 176;
       HEAP32[$1 >> 2] = Math_imul(HEAP32[$1 + 4 >> 2], 68) + 428672;
       wasm2js_memory_copy(HEAP32[$1 >> 2], Math_imul(HEAP32[$1 + 8 >> 2], 68) + 428672 | 0, 68);
       if (!(HEAP32[$1 + 8 >> 2] < HEAP32[$1 + 72 >> 2] | HEAP32[$1 + 8 >> 2] >= (HEAP32[$1 + 72 >> 2] + HEAP32[$1 + 92 >> 2] | 0))) {
        _jswrap_drawImageSimpleRow(HEAP32[$1 + 188 >> 2], HEAP16[220393] << 16 >> 16, HEAP32[$1 + 4 >> 2], $1 + 88 | 0, $1 + 12 | 0, HEAP32[$1 + 64 >> 2], $1 + 60 | 0, $1 + 56 | 0)
       }
       wasm2js_memory_copy(Math_imul(HEAP32[$1 + 8 >> 2], 68) + 416704 | 0, HEAP32[$1 >> 2], 68);
       HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 68 >> 2] + HEAP32[$1 + 8 >> 2];
       continue;
      }
      break;
     };
     jsvStringIteratorFree_1174($1 + 12 | 0);
     _jswrap_graphics_freeImageInfo($1 + 88 | 0);
     break block3;
    }
    wasm2js_memory_copy(416704, 428672, 11968);
   }
   $0 = HEAP32[$1 + 188 >> 2];
   HEAP8[$0 + 44 | 0] = 0;
   HEAP8[$0 + 45 | 0] = 128;
   $0 = HEAP32[$1 + 188 >> 2];
   HEAP8[$0 + 46 | 0] = 0;
   HEAP8[$0 + 47 | 0] = 128;
   $0 = HEAP32[$1 + 188 >> 2];
   HEAP8[$0 + 40 | 0] = 255;
   HEAP8[$0 + 41 | 0] = 127;
   $0 = HEAP32[$1 + 188 >> 2];
   HEAP8[$0 + 42 | 0] = 255;
   HEAP8[$0 + 43 | 0] = 127;
  }
  __stack_pointer = $1 + 192 | 0;
 }
 
 function _lcdMemLCD_setPixel_mirrored($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  lcdMemLCD_setPixel(HEAP32[$4 + 12 >> 2], 175 - HEAP32[$4 + 8 >> 2] | 0, HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function jsvStringIteratorFree_1174($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function lcdMemLCD_init($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  $0 = HEAP32[$1 + 28 >> 2];
  HEAP8[$0 + 12 | 0] = 176;
  HEAP8[$0 + 13 | 0] = 0;
  $0 = HEAP32[$1 + 28 >> 2];
  HEAP8[$0 + 14 | 0] = 176;
  HEAP8[$0 + 15 | 0] = 0;
  HEAP8[HEAP32[$1 + 28 >> 2] + 16 | 0] = 16;
  wasm2js_memory_fill(428672, 0, 12104);
  HEAP32[$1 + 24 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 24 >> 2] < 176) {
    $0 = jswrap_espruino_reverseByte(128);
    HEAP8[Math_imul(HEAP32[$1 + 24 >> 2], 68) + 428672 | 0] = $0;
    $0 = jswrap_espruino_reverseByte(HEAP32[$1 + 24 >> 2] + 1 | 0);
    HEAP8[(Math_imul(HEAP32[$1 + 24 >> 2], 68) + 1 | 0) + 428672 | 0] = $0;
    HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] + 1;
    continue;
   }
   break;
  };
  jshPinOutput(5, 0);
  jshPinOutput(26, 1);
  jshPinOutput(27, 1);
  jshPinOutput(7, 1);
  jshPinOutput(6, 1);
  jshSPIInitInfo($1 + 10 | 0);
  HEAP8[$1 + 10 | 0] = 0;
  HEAP8[$1 + 11 | 0] = 9;
  HEAP8[$1 + 12 | 0] = 61;
  HEAP8[$1 + 13 | 0] = 0;
  HEAP8[$1 + 17 | 0] = 27;
  HEAP8[$1 + 15 | 0] = 26;
  HEAP8[$1 + 19 | 0] = 0;
  jshSPISetup(27, $1 + 10 | 0);
  __stack_pointer = $1 + 32 | 0;
 }
 
 function lcdMemLCD_extcominBacklight($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP8[440788] = HEAP8[$1 + 15 | 0] & 1;
  block : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    jshPinAnalogOutput(6, .0003, 120.0, 0);
    break block;
   }
   jshPinOutput(6, 0);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function lcdMemLCD_setOverlay($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  if (HEAP32[110195]) {
   lcdMemLCD_setOverlayModified(416628);
   jsvUnLock(HEAP32[110195]);
  }
  block : {
   if (HEAP32[$3 + 12 >> 2]) {
    HEAP32[110195] = jsvLockAgain(HEAP32[$3 + 12 >> 2]);
    HEAP16[220393] = HEAP32[$3 + 8 >> 2];
    HEAP16[220392] = HEAP32[$3 + 4 >> 2];
    lcdMemLCD_setOverlayModified(416628);
    break block;
   }
   HEAP32[110195] = 0;
   HEAP16[220393] = 0;
   HEAP16[220392] = 0;
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function lcdMemLCD_setOverlayModified($0) {
  var $1 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 108 >> 2] = $0;
  block : {
   if (HEAP32[110195]) {
    if (_jswrap_graphics_parseImage(HEAP32[$1 + 108 >> 2], HEAP32[110195], 0, $1 + 24 | 0) & 1) {
     HEAP32[$1 + 20 >> 2] = HEAP16[220393] << 16 >> 16 >= 0 ? HEAP16[220393] << 16 >> 16 : 0;
     HEAP32[$1 + 16 >> 2] = HEAP16[220392] << 16 >> 16 >= 0 ? HEAP16[220392] << 16 >> 16 : 0;
     HEAP32[$1 + 12 >> 2] = (HEAP32[$1 + 24 >> 2] + (HEAP16[220393] << 16 >> 16) | 0) - 1;
     if (HEAP32[$1 + 12 >> 2] > 175) {
      HEAP32[$1 + 12 >> 2] = 175
     }
     HEAP32[$1 + 8 >> 2] = (HEAP32[$1 + 28 >> 2] + (HEAP16[220392] << 16 >> 16) | 0) - 1;
     if (HEAP32[$1 + 8 >> 2] > 175) {
      HEAP32[$1 + 8 >> 2] = 175
     }
     graphicsSetModified(HEAP32[$1 + 108 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
     _jswrap_graphics_freeImageInfo($1 + 24 | 0);
    }
    break block;
   }
   HEAP8[416668] = 0;
   HEAP8[416669] = 0;
   HEAP8[416670] = 0;
   HEAP8[416671] = 0;
   HEAP8[416672] = 175;
   HEAP8[416673] = 0;
   HEAP8[416674] = 175;
   HEAP8[416675] = 0;
  }
  __stack_pointer = $1 + 112 | 0;
 }
 
 function lcdMemLCD_setCallbacks($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 52 | 0] = 107;
  HEAP8[$0 + 53 | 0] = 2;
  HEAP8[$0 + 54 | 0] = 0;
  HEAP8[$0 + 55 | 0] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 56 | 0] = 109;
  HEAP8[$0 + 57 | 0] = 2;
  HEAP8[$0 + 58 | 0] = 0;
  HEAP8[$0 + 59 | 0] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 60 | 0] = 110;
  HEAP8[$0 + 61 | 0] = 2;
  HEAP8[$0 + 62 | 0] = 0;
  HEAP8[$0 + 63 | 0] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 68 | 0] = 111;
  HEAP8[$0 + 69 | 0] = 2;
  HEAP8[$0 + 70 | 0] = 0;
  HEAP8[$0 + 71 | 0] = 0;
 }
 
 function mbedtls_sha1_init($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  wasm2js_memory_fill(HEAP32[$1 + 12 >> 2], 0, 92);
 }
 
 function mbedtls_sha1_free($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   mbedtls_zeroize(HEAP32[$1 + 12 >> 2], 92)
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function mbedtls_zeroize($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  while (1) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 - 1;
   if ($0) {
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$2 + 4 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 0;
    continue;
   }
   break;
  };
 }
 
 function mbedtls_sha1_starts($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] = 1732584193;
  HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = -271733879;
  HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = -1732584194;
  HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] = 271733878;
  HEAP32[HEAP32[$1 + 12 >> 2] + 24 >> 2] = -1009589776;
 }
 
 function mbedtls_sha1_processR($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] & 15) << 2) >> 2] ^ (HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 14 & 15) << 2) >> 2] ^ (HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 3 & 15) << 2) >> 2] ^ HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 8 & 15) << 2) >> 2]));
  $0 = HEAP32[$2 + 4 >> 2] << 1 | HEAP32[$2 + 4 >> 2] >>> 31;
  HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] & 15) << 2) >> 2] = $0;
  return $0;
 }
 
 function mbedtls_sha1_process($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 160 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 156 >> 2] = $0;
  HEAP32[$2 + 152 >> 2] = $1;
  HEAP32[$2 + 64 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 3 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2]] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 1 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 2 | 0] << 8);
  HEAP32[$2 + 68 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 7 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 4 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 5 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 6 | 0] << 8);
  HEAP32[$2 + 72 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 11 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 8 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 9 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 10 | 0] << 8);
  HEAP32[$2 + 76 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 15 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 12 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 13 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 14 | 0] << 8);
  HEAP32[$2 + 80 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 19 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 16 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 17 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 18 | 0] << 8);
  HEAP32[$2 + 84 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 23 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 20 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 21 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 22 | 0] << 8);
  HEAP32[$2 + 88 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 27 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 24 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 25 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 26 | 0] << 8);
  HEAP32[$2 + 92 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 31 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 28 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 29 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 30 | 0] << 8);
  HEAP32[$2 + 96 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 35 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 32 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 33 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 34 | 0] << 8);
  HEAP32[$2 + 100 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 39 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 36 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 37 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 38 | 0] << 8);
  HEAP32[$2 + 104 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 43 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 40 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 41 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 42 | 0] << 8);
  HEAP32[$2 + 108 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 47 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 44 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 45 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 46 | 0] << 8);
  HEAP32[$2 + 112 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 51 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 48 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 49 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 50 | 0] << 8);
  HEAP32[$2 + 116 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 55 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 52 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 53 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 54 | 0] << 8);
  HEAP32[$2 + 120 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 59 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 56 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 57 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 58 | 0] << 8);
  HEAP32[$2 + 124 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 63 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 60 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 61 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 62 | 0] << 8);
  HEAP32[$2 + 148 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 148 >> 2] < 5) {
    HEAP32[($2 + 32 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$2 + 156 >> 2] + 8 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2];
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$2 + 148 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 148 >> 2] < 20) {
    HEAP32[$2 + 28 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
    block : {
     if (HEAPU32[$2 + 148 >> 2] < 16) {
      HEAP32[$2 + 24 >> 2] = HEAP32[($2 - -64 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2];
      break block;
     }
     HEAP32[$2 + 24 >> 2] = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
    }
    $0 = ((0 - HEAP32[$2 + 28 >> 2] << 2) + $2 | 0) + 48 | 0;
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + (HEAP32[$2 + 24 >> 2] + (((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] & (HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + 1518500249 | 0) | 0);
    HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$2 + 148 >> 2] = 20;
  while (1) {
   if (HEAPU32[$2 + 148 >> 2] < 40) {
    HEAP32[$2 + 20 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
    $1 = ((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] ^ (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + 1859775393 | 0;
    $3 = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
    $0 = ((0 - HEAP32[$2 + 20 >> 2] << 2) + $2 | 0) + 48 | 0;
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + ($1 + $3 | 0);
    HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$2 + 148 >> 2] = 40;
  while (1) {
   if (HEAPU32[$2 + 148 >> 2] < 60) {
    HEAP32[$2 + 16 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
    $1 = ((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] & HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] | HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] & (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] | HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) - 1894007588 | 0;
    $3 = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
    $0 = ((0 - HEAP32[$2 + 16 >> 2] << 2) + $2 | 0) + 48 | 0;
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + ($1 + $3 | 0);
    HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$2 + 148 >> 2] = 60;
  while (1) {
   if (HEAPU32[$2 + 148 >> 2] < 80) {
    HEAP32[$2 + 12 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
    $1 = ((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] ^ (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) - 899497514 | 0;
    $3 = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
    $0 = ((0 - HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 48 | 0;
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + ($1 + $3 | 0);
    HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$2 + 148 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 148 >> 2] < 5) {
    $0 = (HEAP32[$2 + 156 >> 2] + 8 | 0) + (HEAP32[$2 + 148 >> 2] << 2) | 0;
    HEAP32[$0 >> 2] = HEAP32[($2 + 32 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2] + HEAP32[$0 >> 2];
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 160 | 0;
 }
 
 function mbedtls_sha1_update($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (!HEAP32[$3 + 20 >> 2]) {
    break block
   }
   HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] >> 2] & 63;
   HEAP32[$3 + 16 >> 2] = 64 - HEAP32[$3 + 12 >> 2];
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2];
   if (HEAPU32[HEAP32[$3 + 28 >> 2] >> 2] < HEAPU32[$3 + 20 >> 2]) {
    $0 = HEAP32[$3 + 28 >> 2];
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
   }
   if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
    $1 = HEAP32[$3 + 28 >> 2];
    $2 = HEAP32[$3 + 12 >> 2];
    $4 = HEAP32[$3 + 24 >> 2];
    $0 = HEAP32[$3 + 16 >> 2];
    if ($0) {
     wasm2js_memory_copy(($1 + 28 | 0) + $2 | 0, $4, $0)
    }
    mbedtls_sha1_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 28 | 0);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
    HEAP32[$3 + 12 >> 2] = 0;
   }
   while (1) {
    if (HEAPU32[$3 + 20 >> 2] >= 64) {
     mbedtls_sha1_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - -64;
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + -64;
     continue;
    }
    break;
   };
   if (!HEAP32[$3 + 20 >> 2]) {
    break block
   }
   $1 = HEAP32[$3 + 28 >> 2];
   $2 = HEAP32[$3 + 12 >> 2];
   $4 = HEAP32[$3 + 24 >> 2];
   $0 = HEAP32[$3 + 20 >> 2];
   if ($0) {
    wasm2js_memory_copy(($1 + 28 | 0) + $2 | 0, $4, $0)
   }
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function mbedtls_sha1_finish($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 92 >> 2] = $0;
  HEAP32[$2 + 88 >> 2] = $1;
  HEAP32[$2 + 76 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] + 4 >> 2] << 3 | HEAP32[HEAP32[$2 + 92 >> 2] >> 2] >>> 29;
  HEAP32[$2 + 72 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] >> 2] << 3;
  HEAP8[$2 + 64 | 0] = HEAP32[$2 + 76 >> 2] >>> 24;
  HEAP8[$2 + 65 | 0] = HEAP32[$2 + 76 >> 2] >>> 16;
  HEAP8[$2 + 66 | 0] = HEAP32[$2 + 76 >> 2] >>> 8;
  HEAP8[$2 + 67 | 0] = HEAP32[$2 + 76 >> 2];
  HEAP8[$2 + 68 | 0] = HEAP32[$2 + 72 >> 2] >>> 24;
  HEAP8[$2 + 69 | 0] = HEAP32[$2 + 72 >> 2] >>> 16;
  HEAP8[$2 + 70 | 0] = HEAP32[$2 + 72 >> 2] >>> 8;
  HEAP8[$2 + 71 | 0] = HEAP32[$2 + 72 >> 2];
  HEAP32[$2 + 84 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] >> 2] & 63;
  if (HEAPU32[$2 + 84 >> 2] < 56) {
   $0 = 56 - HEAP32[$2 + 84 >> 2] | 0
  } else {
   $0 = 120 - HEAP32[$2 + 84 >> 2] | 0
  }
  HEAP32[$2 + 80 >> 2] = $0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 + 56 >> 2] = 0;
  HEAP32[$2 + 60 >> 2] = 0;
  HEAP32[$2 + 48 >> 2] = 0;
  HEAP32[$2 + 52 >> 2] = 0;
  HEAP32[$2 + 40 >> 2] = 0;
  HEAP32[$2 + 44 >> 2] = 0;
  HEAP32[$2 + 32 >> 2] = 0;
  HEAP32[$2 + 36 >> 2] = 0;
  HEAP32[$2 + 24 >> 2] = 0;
  HEAP32[$2 + 28 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP8[$2 | 0] = 128;
  mbedtls_sha1_update(HEAP32[$2 + 92 >> 2], $2, HEAP32[$2 + 80 >> 2]);
  mbedtls_sha1_update(HEAP32[$2 + 92 >> 2], $2 - -64 | 0, 8);
  HEAP8[HEAP32[$2 + 88 >> 2]] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 88 >> 2] + 1 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 88 >> 2] + 2 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 88 >> 2] + 3 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2];
  HEAP8[HEAP32[$2 + 88 >> 2] + 4 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 88 >> 2] + 5 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 88 >> 2] + 6 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 88 >> 2] + 7 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2];
  HEAP8[HEAP32[$2 + 88 >> 2] + 8 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 88 >> 2] + 9 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 88 >> 2] + 10 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 88 >> 2] + 11 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2];
  HEAP8[HEAP32[$2 + 88 >> 2] + 12 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 88 >> 2] + 13 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 88 >> 2] + 14 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 88 >> 2] + 15 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2];
  HEAP8[HEAP32[$2 + 88 >> 2] + 16 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 88 >> 2] + 17 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 88 >> 2] + 18 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 88 >> 2] + 19 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2];
  __stack_pointer = $2 + 96 | 0;
 }
 
 function mbedtls_sha1($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 112 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 108 >> 2] = $0;
  HEAP32[$3 + 104 >> 2] = $1;
  HEAP32[$3 + 100 >> 2] = $2;
  mbedtls_sha1_init($3 + 8 | 0);
  mbedtls_sha1_starts($3 + 8 | 0);
  mbedtls_sha1_update($3 + 8 | 0, HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2]);
  mbedtls_sha1_finish($3 + 8 | 0, HEAP32[$3 + 100 >> 2]);
  mbedtls_sha1_free($3 + 8 | 0);
  __stack_pointer = $3 + 112 | 0;
 }
 
 function mbedtls_sha256_init($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  wasm2js_memory_fill(HEAP32[$1 + 12 >> 2], 0, 108);
 }
 
 function mbedtls_sha256_free($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   mbedtls_zeroize_1191(HEAP32[$1 + 12 >> 2], 108)
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function mbedtls_zeroize_1191($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  while (1) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 - 1;
   if ($0) {
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$2 + 4 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 0;
    continue;
   }
   break;
  };
 }
 
 function mbedtls_sha256_starts($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
  HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = 0;
  block : {
   if (!HEAP32[$2 + 8 >> 2]) {
    HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = 1779033703;
    HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = -1150833019;
    HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 1013904242;
    HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] = -1521486534;
    HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2] = 1359893119;
    HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = -1694144372;
    HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = 528734635;
    HEAP32[HEAP32[$2 + 12 >> 2] + 36 >> 2] = 1541459225;
    break block;
   }
   HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = -1056596264;
   HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = 914150663;
   HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 812702999;
   HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] = -150054599;
   HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2] = -4191439;
   HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = 1750603025;
   HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = 1694076839;
   HEAP32[HEAP32[$2 + 12 >> 2] + 36 >> 2] = -1090891868;
  }
  HEAP32[HEAP32[$2 + 12 >> 2] + 104 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 
 function mbedtls_sha256_process($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 320 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 316 >> 2] = $0;
  HEAP32[$2 + 312 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 12 >> 2] < 8) {
    HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$2 + 316 >> 2] + 8 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2];
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 12 >> 2] < 64) {
    block : {
     if (HEAPU32[$2 + 12 >> 2] < 16) {
      HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 3 | 0) | 0] | (HEAPU8[HEAP32[$2 + 312 >> 2] + (HEAP32[$2 + 12 >> 2] << 2) | 0] << 24 | HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 1 | 0) | 0] << 16 | HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 2 | 0) | 0] << 8);
      break block;
     }
     HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 16 >> 2] + ((HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 20 >> 2] + ((HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] << 15 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] >>> 17) ^ (HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] << 13 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] >>> 19) ^ HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] >>> 10) | 0) + ((HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] << 25 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] >>> 7) ^ (HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] << 14 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] >>> 18) ^ HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] >>> 3) | 0);
    }
    HEAP32[$2 + 308 >> 2] = HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] + (HEAP32[(HEAP32[$2 + 12 >> 2] << 2) + 173376 >> 2] + ((HEAP32[$2 + 44 >> 2] + ((HEAP32[$2 + 32 >> 2] << 7 | HEAP32[$2 + 32 >> 2] >>> 25) ^ ((HEAP32[$2 + 32 >> 2] << 26 | HEAP32[$2 + 32 >> 2] >>> 6) ^ (HEAP32[$2 + 32 >> 2] << 21 | HEAP32[$2 + 32 >> 2] >>> 11))) | 0) + (HEAP32[$2 + 40 >> 2] ^ HEAP32[$2 + 32 >> 2] & (HEAP32[$2 + 36 >> 2] ^ HEAP32[$2 + 40 >> 2])) | 0) | 0);
    HEAP32[$2 + 304 >> 2] = (HEAP32[$2 + 16 >> 2] & HEAP32[$2 + 20 >> 2] | HEAP32[$2 + 24 >> 2] & (HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 20 >> 2])) + ((HEAP32[$2 + 16 >> 2] << 10 | HEAP32[$2 + 16 >> 2] >>> 22) ^ ((HEAP32[$2 + 16 >> 2] << 30 | HEAP32[$2 + 16 >> 2] >>> 2) ^ (HEAP32[$2 + 16 >> 2] << 19 | HEAP32[$2 + 16 >> 2] >>> 13)));
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 308 >> 2] + HEAP32[$2 + 28 >> 2];
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 308 >> 2] + HEAP32[$2 + 304 >> 2];
    HEAP32[$2 + 308 >> 2] = HEAP32[$2 + 44 >> 2];
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 40 >> 2];
    HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 36 >> 2];
    HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 32 >> 2];
    HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 28 >> 2];
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 20 >> 2];
    HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 16 >> 2];
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 308 >> 2];
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 12 >> 2] < 8) {
    $0 = (HEAP32[$2 + 316 >> 2] + 8 | 0) + (HEAP32[$2 + 12 >> 2] << 2) | 0;
    HEAP32[$0 >> 2] = HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] + HEAP32[$0 >> 2];
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 320 | 0;
 }
 
 function mbedtls_sha256_update($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (!HEAP32[$3 + 20 >> 2]) {
    break block
   }
   HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] >> 2] & 63;
   HEAP32[$3 + 16 >> 2] = 64 - HEAP32[$3 + 12 >> 2];
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2];
   if (HEAPU32[HEAP32[$3 + 28 >> 2] >> 2] < HEAPU32[$3 + 20 >> 2]) {
    $0 = HEAP32[$3 + 28 >> 2];
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
   }
   if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
    $1 = HEAP32[$3 + 28 >> 2];
    $2 = HEAP32[$3 + 12 >> 2];
    $4 = HEAP32[$3 + 24 >> 2];
    $0 = HEAP32[$3 + 16 >> 2];
    if ($0) {
     wasm2js_memory_copy(($1 + 40 | 0) + $2 | 0, $4, $0)
    }
    mbedtls_sha256_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 40 | 0);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
    HEAP32[$3 + 12 >> 2] = 0;
   }
   while (1) {
    if (HEAPU32[$3 + 20 >> 2] >= 64) {
     mbedtls_sha256_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - -64;
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + -64;
     continue;
    }
    break;
   };
   if (!HEAP32[$3 + 20 >> 2]) {
    break block
   }
   $1 = HEAP32[$3 + 28 >> 2];
   $2 = HEAP32[$3 + 12 >> 2];
   $4 = HEAP32[$3 + 24 >> 2];
   $0 = HEAP32[$3 + 20 >> 2];
   if ($0) {
    wasm2js_memory_copy(($1 + 40 | 0) + $2 | 0, $4, $0)
   }
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function mbedtls_sha256_finish($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] + 4 >> 2] << 3 | HEAP32[HEAP32[$2 + 28 >> 2] >> 2] >>> 29;
  HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] >> 2] << 3;
  HEAP8[$2 | 0] = HEAP32[$2 + 12 >> 2] >>> 24;
  HEAP8[$2 + 1 | 0] = HEAP32[$2 + 12 >> 2] >>> 16;
  HEAP8[$2 + 2 | 0] = HEAP32[$2 + 12 >> 2] >>> 8;
  HEAP8[$2 + 3 | 0] = HEAP32[$2 + 12 >> 2];
  HEAP8[$2 + 4 | 0] = HEAP32[$2 + 8 >> 2] >>> 24;
  HEAP8[$2 + 5 | 0] = HEAP32[$2 + 8 >> 2] >>> 16;
  HEAP8[$2 + 6 | 0] = HEAP32[$2 + 8 >> 2] >>> 8;
  HEAP8[$2 + 7 | 0] = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 20 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] >> 2] & 63;
  if (HEAPU32[$2 + 20 >> 2] < 56) {
   $0 = 56 - HEAP32[$2 + 20 >> 2] | 0
  } else {
   $0 = 120 - HEAP32[$2 + 20 >> 2] | 0
  }
  HEAP32[$2 + 16 >> 2] = $0;
  mbedtls_sha256_update(HEAP32[$2 + 28 >> 2], 173632, HEAP32[$2 + 16 >> 2]);
  mbedtls_sha256_update(HEAP32[$2 + 28 >> 2], $2, 8);
  HEAP8[HEAP32[$2 + 24 >> 2]] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 1 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 2 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 3 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
  HEAP8[HEAP32[$2 + 24 >> 2] + 4 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 5 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 6 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 7 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2];
  HEAP8[HEAP32[$2 + 24 >> 2] + 8 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 9 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 10 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 11 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2];
  HEAP8[HEAP32[$2 + 24 >> 2] + 12 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 13 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 14 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 15 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2];
  HEAP8[HEAP32[$2 + 24 >> 2] + 16 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 17 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 18 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 19 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2];
  HEAP8[HEAP32[$2 + 24 >> 2] + 20 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 21 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 22 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 23 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2];
  HEAP8[HEAP32[$2 + 24 >> 2] + 24 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 25 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 26 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 27 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2];
  if (!HEAP32[HEAP32[$2 + 28 >> 2] + 104 >> 2]) {
   HEAP8[HEAP32[$2 + 24 >> 2] + 28 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 24;
   HEAP8[HEAP32[$2 + 24 >> 2] + 29 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 16;
   HEAP8[HEAP32[$2 + 24 >> 2] + 30 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 8;
   HEAP8[HEAP32[$2 + 24 >> 2] + 31 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function mbedtls_sha256($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 128 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 124 >> 2] = $0;
  HEAP32[$4 + 120 >> 2] = $1;
  HEAP32[$4 + 116 >> 2] = $2;
  HEAP32[$4 + 112 >> 2] = $3;
  mbedtls_sha256_init($4 + 4 | 0);
  mbedtls_sha256_starts($4 + 4 | 0, HEAP32[$4 + 112 >> 2]);
  mbedtls_sha256_update($4 + 4 | 0, HEAP32[$4 + 124 >> 2], HEAP32[$4 + 120 >> 2]);
  mbedtls_sha256_finish($4 + 4 | 0, HEAP32[$4 + 116 >> 2]);
  mbedtls_sha256_free($4 + 4 | 0);
  __stack_pointer = $4 + 128 | 0;
 }
 
 function mbedtls_sha512_init($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  wasm2js_memory_fill(HEAP32[$1 + 12 >> 2], 0, 216);
 }
 
 function mbedtls_sha512_free($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   mbedtls_zeroize_1199(HEAP32[$1 + 12 >> 2], 216)
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function mbedtls_zeroize_1199($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  while (1) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 - 1;
   if ($0) {
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$2 + 4 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 0;
    continue;
   }
   break;
  };
 }
 
 function mbedtls_sha512_starts($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  block : {
   if (!HEAP32[$2 + 8 >> 2]) {
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 16 >> 2] = -205731576;
    HEAP32[$0 + 20 >> 2] = 1779033703;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 24 >> 2] = -2067093701;
    HEAP32[$0 + 28 >> 2] = -1150833019;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 32 >> 2] = -23791573;
    HEAP32[$0 + 36 >> 2] = 1013904242;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 40 >> 2] = 1595750129;
    HEAP32[$0 + 44 >> 2] = -1521486534;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 48 >> 2] = -1377402159;
    HEAP32[$0 + 52 >> 2] = 1359893119;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 56 >> 2] = 725511199;
    HEAP32[$0 + 60 >> 2] = -1694144372;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 64 >> 2] = -79577749;
    HEAP32[$0 + 68 >> 2] = 528734635;
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$0 + 72 >> 2] = 327033209;
    HEAP32[$0 + 76 >> 2] = 1541459225;
    break block;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 16 >> 2] = -1056596264;
   HEAP32[$0 + 20 >> 2] = -876896931;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 24 >> 2] = 914150663;
   HEAP32[$0 + 28 >> 2] = 1654270250;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 32 >> 2] = 812702999;
   HEAP32[$0 + 36 >> 2] = -1856437926;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 40 >> 2] = -150054599;
   HEAP32[$0 + 44 >> 2] = 355462360;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 48 >> 2] = -4191439;
   HEAP32[$0 + 52 >> 2] = 1731405415;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 56 >> 2] = 1750603025;
   HEAP32[$0 + 60 >> 2] = -1900787065;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 64 >> 2] = 1694076839;
   HEAP32[$0 + 68 >> 2] = -619958771;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 72 >> 2] = -1090891868;
   HEAP32[$0 + 76 >> 2] = 1203062813;
  }
  HEAP32[HEAP32[$2 + 12 >> 2] + 208 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 
 function mbedtls_sha512_process($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
  $3 = __stack_pointer - 736 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 732 >> 2] = $0;
  HEAP32[$3 + 728 >> 2] = $1;
  HEAP32[$3 + 724 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 724 >> 2] < 16) {
    $4 = HEAP32[$3 + 728 >> 2] + ((HEAP32[$3 + 724 >> 2] << 3) + 7 | 0) | 0;
    $1 = HEAPU8[$4 | 0];
    $5 = $1;
    $4 = HEAP32[$3 + 728 >> 2] + (HEAP32[$3 + 724 >> 2] << 3) | 0;
    $0 = HEAPU8[$4 | 0];
    $0 = $0 << 24;
    $2 = $0;
    $1 = HEAP32[$3 + 728 >> 2] + ((HEAP32[$3 + 724 >> 2] << 3) + 1 | 0) | 0;
    $0 = HEAPU8[$1 | 0];
    $0 = $0 << 16;
    $1 = $0;
    $0 = $2;
    $1 = $1 | $0;
    $2 = $1;
    $0 = HEAP32[$3 + 728 >> 2] + ((HEAP32[$3 + 724 >> 2] << 3) + 2 | 0) | 0;
    $1 = HEAPU8[$0 | 0];
    $0 = $1;
    $1 = $0 << 8;
    $0 = $1;
    $1 = $2;
    $0 = $1 | $0;
    $2 = $0;
    $1 = HEAP32[$3 + 728 >> 2] + ((HEAP32[$3 + 724 >> 2] << 3) + 3 | 0) | 0;
    $0 = HEAPU8[$1 | 0];
    $1 = $0;
    $0 = $2;
    $1 = $1 | $0;
    $2 = $1;
    $0 = HEAP32[$3 + 728 >> 2] + ((HEAP32[$3 + 724 >> 2] << 3) + 4 | 0) | 0;
    $1 = HEAPU8[$0 | 0];
    $0 = $1;
    $7 = $0 << 24;
    $1 = $0 >>> 8 | 0;
    $0 = $1;
    $1 = $2;
    $0 = $1 | $0;
    $2 = $0;
    $4 = 0;
    $6 = 0;
    $4 = $4 | $6;
    $4 = $4 | 0;
    $4 = $4 | 0;
    $6 = $7;
    $4 = $4 | $6;
    $1 = HEAP32[$3 + 728 >> 2] + ((HEAP32[$3 + 724 >> 2] << 3) + 5 | 0) | 0;
    $0 = HEAPU8[$1 | 0];
    $6 = $0 << 16;
    $0 = $0 >>> 16 | 0;
    $1 = $0;
    $0 = $2;
    $1 = $1 | $0;
    $2 = $1;
    $0 = HEAP32[$3 + 728 >> 2] + ((HEAP32[$3 + 724 >> 2] << 3) + 6 | 0) | 0;
    $1 = HEAPU8[$0 | 0];
    $0 = $1;
    $7 = $0 << 8;
    $1 = $0 >>> 24 | 0;
    $0 = $1;
    $1 = $2;
    $0 = $1 | $0;
    $1 = $5;
    $4 = $4 | $6;
    $6 = $7;
    $6 = $4 | $6;
    $2 = $1 | $6;
    $1 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
    HEAP32[$1 >> 2] = $2;
    $4 = $0;
    HEAP32[$1 + 4 >> 2] = $4;
    HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
    continue;
   }
   break;
  };
  while (1) {
   if (HEAP32[$3 + 724 >> 2] < 80) {
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) + -64 | 0;
    $4 = HEAP32[$0 >> 2];
    $10 = $4;
    $1 = HEAP32[$0 + 4 >> 2];
    $9 = $1;
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) + 8 | 0;
    $1 = HEAP32[$0 >> 2];
    $8 = $1;
    $4 = HEAP32[$0 + 4 >> 2];
    $7 = $4;
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) + 48 | 0;
    $4 = HEAP32[$0 >> 2];
    $0 = $4;
    $4 = $0 << 13;
    $2 = $4;
    $1 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) + 48 | 0;
    $4 = HEAP32[$1 >> 2];
    $0 = HEAP32[$1 + 4 >> 2];
    $1 = $4;
    $4 = $0 >>> 19 | 0;
    $6 = ($0 & 524287) << 13 | $1 >>> 19;
    $0 = 0;
    $13 = $0 | $6;
    $1 = $4;
    $4 = $2;
    $1 = $1 | $4;
    $5 = $1;
    $4 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) + 48 | 0;
    $1 = HEAP32[$4 >> 2];
    $0 = HEAP32[$4 + 4 >> 2];
    $12 = $1 << 3;
    $1 = $0 << 3 | $1 >>> 29;
    $2 = $1;
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) + 48 | 0;
    $1 = HEAP32[$0 >> 2];
    $4 = HEAP32[$0 + 4 >> 2];
    $6 = $4 >>> 29 | 0;
    $1 = $2;
    $0 = $11;
    $0 = $1 | $0;
    $2 = $0;
    $1 = $13;
    $4 = $12;
    $6 = $4 | $6;
    $12 = $1 ^ $6;
    $0 = $5;
    $4 = $2;
    $4 = $0 ^ $4;
    $2 = $4;
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) + 48 | 0;
    $4 = HEAP32[$0 >> 2];
    $1 = HEAP32[$0 + 4 >> 2];
    $0 = $4;
    $6 = ($1 & 63) << 26 | $0 >>> 6;
    $4 = $1 >>> 6 | 0;
    $0 = $4;
    $4 = $2;
    $0 = $0 ^ $4;
    $4 = $8;
    $1 = $12;
    $6 = $1 ^ $6;
    $2 = $4 + $6 | 0;
    $1 = $0;
    $0 = $7;
    $5 = $1 + $0 | 0;
    $5 = $2 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
    $8 = $5;
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) - 56 | 0;
    $5 = HEAP32[$0 >> 2];
    $0 = $5;
    $5 = $0 << 31;
    $1 = $5;
    $4 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) - 56 | 0;
    $5 = HEAP32[$4 >> 2];
    $0 = HEAP32[$4 + 4 >> 2];
    $4 = $5;
    $5 = $0 >>> 1 | 0;
    $6 = ($0 & 1) << 31 | $4 >>> 1;
    $0 = 0;
    $12 = $0 | $6;
    $4 = $5;
    $5 = $1;
    $4 = $4 | $5;
    $7 = $4;
    $5 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) - 56 | 0;
    $4 = HEAP32[$5 >> 2];
    $4 = $4 << 24;
    $1 = $4;
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) - 56 | 0;
    $4 = HEAP32[$0 >> 2];
    $5 = HEAP32[$0 + 4 >> 2];
    $0 = $4;
    $6 = ($5 & 255) << 24 | $0 >>> 8;
    $4 = $5 >>> 8 | 0;
    $0 = $4;
    $4 = $1;
    $0 = $0 | $4;
    $1 = $0;
    $4 = $12;
    $5 = 0;
    $6 = $6 | $5;
    $12 = $4 ^ $6;
    $0 = $7;
    $5 = $1;
    $5 = $0 ^ $5;
    $1 = $5;
    $0 = ((HEAP32[$3 + 724 >> 2] << 3) + $3 | 0) - 56 | 0;
    $5 = HEAP32[$0 >> 2];
    $4 = HEAP32[$0 + 4 >> 2];
    $0 = $5;
    $6 = ($4 & 127) << 25 | $0 >>> 7;
    $5 = $4 >>> 7 | 0;
    $0 = $5;
    $5 = $1;
    $0 = $0 ^ $5;
    $5 = $0;
    $4 = $12;
    $6 = $4 ^ $6;
    $1 = $6 + $2 | 0;
    $0 = $8;
    $4 = $5;
    $2 = $0 + $4 | 0;
    $2 = $1 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
    $5 = $2;
    $6 = $1;
    $0 = $10;
    $4 = $0 + $1 | 0;
    $2 = $9;
    $1 = $2 + $5 | 0;
    $0 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
    HEAP32[$0 >> 2] = $4;
    $1 = $4 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
    HEAP32[$0 + 4 >> 2] = $1;
    HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
    continue;
   }
   break;
  };
  $2 = HEAP32[$3 + 732 >> 2];
  $1 = HEAP32[$2 + 16 >> 2];
  $0 = HEAP32[$2 + 20 >> 2];
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 60 >> 2] = $0;
  $2 = HEAP32[$3 + 732 >> 2];
  $0 = HEAP32[$2 + 24 >> 2];
  $1 = HEAP32[$2 + 28 >> 2];
  HEAP32[$3 + 48 >> 2] = $0;
  HEAP32[$3 + 52 >> 2] = $1;
  $2 = HEAP32[$3 + 732 >> 2];
  $1 = HEAP32[$2 + 32 >> 2];
  $0 = HEAP32[$2 + 36 >> 2];
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 44 >> 2] = $0;
  $2 = HEAP32[$3 + 732 >> 2];
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = HEAP32[$2 + 44 >> 2];
  HEAP32[$3 + 32 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  $2 = HEAP32[$3 + 732 >> 2];
  $1 = HEAP32[$2 + 48 >> 2];
  $0 = HEAP32[$2 + 52 >> 2];
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 28 >> 2] = $0;
  $2 = HEAP32[$3 + 732 >> 2];
  $0 = HEAP32[$2 + 56 >> 2];
  $1 = HEAP32[$2 + 60 >> 2];
  HEAP32[$3 + 16 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  $2 = HEAP32[$3 + 732 >> 2];
  $1 = HEAP32[$2 + 64 >> 2];
  $0 = HEAP32[$2 + 68 >> 2];
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 12 >> 2] = $0;
  $2 = HEAP32[$3 + 732 >> 2];
  $0 = HEAP32[$2 + 72 >> 2];
  $1 = HEAP32[$2 + 76 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 724 >> 2] = 0;
  while (1) {
   $2 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $1 = HEAP32[$2 >> 2];
   $14 = $1;
   $0 = HEAP32[$2 + 4 >> 2];
   $15 = $0;
   $2 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $0 = HEAP32[$2 >> 2];
   $13 = $0;
   $1 = HEAP32[$2 + 4 >> 2];
   $12 = $1;
   $1 = HEAP32[$3 >> 2];
   $9 = $1;
   $0 = HEAP32[$3 + 4 >> 2];
   $8 = $0;
   $0 = HEAP32[$3 + 24 >> 2];
   $5 = $0 << 23;
   $1 = HEAP32[$3 + 28 >> 2];
   $0 = $1 << 23 | $0 >>> 9;
   $4 = $0;
   $0 = HEAP32[$3 + 24 >> 2];
   $2 = HEAP32[$3 + 28 >> 2];
   $6 = $2 >>> 9 | 0;
   $2 = $5;
   $11 = $6 | $2;
   $0 = 0;
   $1 = $0;
   $0 = $4;
   $1 = $1 | $0;
   $7 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $0 = $1;
   $1 = $0 << 18;
   $4 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $2 = $1;
   $0 = HEAP32[$3 + 28 >> 2];
   $1 = $0 >>> 14 | 0;
   $6 = ($0 & 16383) << 18 | $2 >>> 14;
   $2 = $1;
   $0 = 0;
   $10 = $0 | $6;
   $1 = $4;
   $2 = $1 | $2;
   $5 = $2;
   $2 = HEAP32[$3 + 24 >> 2];
   $1 = $2;
   $2 = $1 << 14;
   $4 = $2;
   $2 = HEAP32[$3 + 24 >> 2];
   $0 = $2;
   $1 = HEAP32[$3 + 28 >> 2];
   $2 = $1 >>> 18 | 0;
   $6 = ($1 & 262143) << 14 | $0 >>> 18;
   $0 = $2;
   $2 = $4;
   $0 = $0 | $2;
   $1 = 0;
   $6 = $1 | $6;
   $2 = $10;
   $6 = $6 ^ $2;
   $1 = $0;
   $0 = $5;
   $1 = $1 ^ $0;
   $2 = $1;
   $1 = $7;
   $2 = $1 ^ $2;
   $1 = $9;
   $0 = $11;
   $6 = $0 ^ $6;
   $5 = $1 + $6 | 0;
   $0 = $2;
   $2 = $8;
   $4 = $0 + $2 | 0;
   $4 = $5 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   $11 = $4;
   $4 = HEAP32[$3 + 8 >> 2];
   $10 = $4;
   $1 = HEAP32[$3 + 12 >> 2];
   $9 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $8 = $1;
   $4 = HEAP32[$3 + 28 >> 2];
   $7 = $4;
   $4 = HEAP32[$3 + 16 >> 2];
   $2 = $4;
   $1 = HEAP32[$3 + 20 >> 2];
   $0 = $1;
   $1 = HEAP32[$3 + 8 >> 2];
   $6 = $1;
   $4 = HEAP32[$3 + 12 >> 2];
   $1 = $4;
   $4 = $0;
   $1 = $1 ^ $4;
   $0 = $1;
   $4 = $8;
   $6 = $6 ^ $2;
   $6 = $4 & $6;
   $1 = $7;
   $2 = $0;
   $2 = $1 & $2;
   $4 = $2;
   $2 = $9;
   $4 = $4 ^ $2;
   $1 = $10;
   $6 = $1 ^ $6;
   $2 = $5;
   $0 = $6 + $2 | 0;
   $1 = $4;
   $4 = $11;
   $5 = $1 + $4 | 0;
   $5 = $0 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $6 = $0;
   $4 = $13;
   $1 = $4 + $0 | 0;
   $2 = $5;
   $5 = $12;
   $0 = $2 + $5 | 0;
   $0 = $1 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   $4 = $0;
   $6 = $1;
   $5 = $14;
   $2 = $5 + $1 | 0;
   $0 = $15;
   $1 = $0 + $4 | 0;
   HEAP32[$3 + 712 >> 2] = $2;
   $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   HEAP32[$3 + 716 >> 2] = $1;
   $1 = HEAP32[$3 + 56 >> 2];
   $0 = $1;
   $5 = HEAP32[$3 + 60 >> 2];
   $4 = $5;
   $1 = HEAP32[$3 + 52 >> 2];
   $2 = $1;
   $5 = HEAP32[$3 + 48 >> 2];
   $9 = $0 & $5;
   $1 = $4;
   $5 = $2;
   $5 = $1 & $5;
   $8 = $5;
   $5 = HEAP32[$3 + 40 >> 2];
   $7 = $5;
   $0 = HEAP32[$3 + 44 >> 2];
   $4 = $0;
   $0 = HEAP32[$3 + 56 >> 2];
   $2 = $0;
   $5 = HEAP32[$3 + 60 >> 2];
   $1 = $5;
   $5 = HEAP32[$3 + 48 >> 2];
   $6 = $5;
   $0 = HEAP32[$3 + 52 >> 2];
   $5 = $0;
   $0 = $1;
   $5 = $0 | $5;
   $0 = $7;
   $1 = $2;
   $6 = $1 | $6;
   $1 = $5;
   $5 = $4;
   $1 = $1 & $5;
   $2 = $1;
   $6 = $0 & $6;
   $5 = $9;
   $11 = $6 | $5;
   $1 = $8;
   $0 = $2;
   $0 = $1 | $0;
   $8 = $0;
   $0 = HEAP32[$3 + 56 >> 2];
   $4 = $0 << 25;
   $5 = HEAP32[$3 + 60 >> 2];
   $0 = $5 << 25 | $0 >>> 7;
   $2 = $0;
   $0 = HEAP32[$3 + 56 >> 2];
   $1 = HEAP32[$3 + 60 >> 2];
   $6 = $1 >>> 7 | 0;
   $1 = $4;
   $10 = $1 | $6;
   $0 = $2;
   $5 = $16;
   $5 = $0 | $5;
   $7 = $5;
   $5 = HEAP32[$3 + 56 >> 2];
   $0 = $5;
   $5 = $0 << 4;
   $2 = $5;
   $5 = HEAP32[$3 + 56 >> 2];
   $1 = $5;
   $0 = HEAP32[$3 + 60 >> 2];
   $5 = $0 >>> 28 | 0;
   $6 = ($0 & 268435455) << 4 | $1 >>> 28;
   $0 = 0;
   $6 = $0 | $6;
   $1 = $5;
   $5 = $2;
   $1 = $1 | $5;
   $4 = $1;
   $1 = HEAP32[$3 + 56 >> 2];
   $9 = $1 << 30;
   $0 = HEAP32[$3 + 60 >> 2];
   $1 = $0 << 30 | $1 >>> 2;
   $0 = $1;
   $1 = HEAP32[$3 + 56 >> 2];
   $5 = HEAP32[$3 + 60 >> 2];
   $1 = $0;
   $0 = $16;
   $0 = $1 | $0;
   $2 = $0;
   $1 = $6;
   $6 = $5 >>> 2 | 0;
   $5 = $9;
   $6 = $6 | $5;
   $6 = $1 ^ $6;
   $0 = $4;
   $5 = $2;
   $5 = $0 ^ $5;
   $1 = $5;
   $5 = $7;
   $1 = $1 ^ $5;
   $2 = $1;
   $0 = $10;
   $6 = $0 ^ $6;
   $5 = $11;
   $4 = $6 + $5 | 0;
   $1 = $8;
   $0 = $2;
   $2 = $1 + $0 | 0;
   HEAP32[$3 + 704 >> 2] = $4;
   $2 = $4 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$3 + 708 >> 2] = $2;
   $2 = HEAP32[$3 + 712 >> 2];
   $1 = $2;
   $5 = HEAP32[$3 + 716 >> 2];
   $0 = $5;
   $5 = HEAP32[$3 + 32 >> 2];
   $6 = $5;
   $2 = HEAP32[$3 + 36 >> 2];
   $5 = $2;
   $2 = $0;
   $4 = $2 + $5 | 0;
   $0 = $1 + $6 | 0;
   $4 = $0 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   HEAP32[$3 + 32 >> 2] = $0;
   HEAP32[$3 + 36 >> 2] = $4;
   $1 = HEAP32[$3 + 716 >> 2];
   $0 = $1;
   $1 = HEAP32[$3 + 704 >> 2];
   $6 = $1;
   $4 = HEAP32[$3 + 712 >> 2];
   $2 = $4;
   $5 = $1 + $2 | 0;
   $4 = HEAP32[$3 + 708 >> 2];
   $1 = $4;
   $4 = $0;
   $0 = $1 + $4 | 0;
   HEAP32[$3 >> 2] = $5;
   $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   HEAP32[$3 + 4 >> 2] = $0;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   $4 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $0 = HEAP32[$4 >> 2];
   $14 = $0;
   $2 = HEAP32[$4 + 4 >> 2];
   $15 = $2;
   $4 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $2 = HEAP32[$4 >> 2];
   $13 = $2;
   $0 = HEAP32[$4 + 4 >> 2];
   $12 = $0;
   $0 = HEAP32[$3 + 8 >> 2];
   $9 = $0;
   $2 = HEAP32[$3 + 12 >> 2];
   $8 = $2;
   $2 = HEAP32[$3 + 32 >> 2];
   $5 = $2 << 23;
   $0 = HEAP32[$3 + 36 >> 2];
   $2 = $0 << 23 | $2 >>> 9;
   $1 = $2;
   $2 = HEAP32[$3 + 32 >> 2];
   $4 = HEAP32[$3 + 36 >> 2];
   $6 = $4 >>> 9 | 0;
   $4 = $5;
   $11 = $4 | $6;
   $2 = 0;
   $0 = $2;
   $2 = $1;
   $0 = $0 | $2;
   $7 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $0 = $0 << 18;
   $5 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $4 = $0;
   $2 = HEAP32[$3 + 36 >> 2];
   $0 = $2 >>> 14 | 0;
   $1 = $0;
   $6 = ($2 & 16383) << 18 | $4 >>> 14;
   $2 = 0;
   $10 = $6 | $2;
   $0 = $5;
   $4 = $1;
   $4 = $0 | $4;
   $5 = $4;
   $4 = HEAP32[$3 + 32 >> 2];
   $0 = $4;
   $4 = $0 << 14;
   $1 = $4;
   $4 = HEAP32[$3 + 32 >> 2];
   $2 = $4;
   $0 = HEAP32[$3 + 36 >> 2];
   $4 = $0 >>> 18 | 0;
   $6 = ($0 & 262143) << 14 | $2 >>> 18;
   $2 = $4;
   $4 = $1;
   $2 = $4 | $2;
   $4 = $10;
   $0 = 0;
   $6 = $0 | $6;
   $6 = $4 ^ $6;
   $0 = $2;
   $2 = $5;
   $0 = $0 ^ $2;
   $4 = $0;
   $0 = $7;
   $4 = $0 ^ $4;
   $5 = $4;
   $0 = $9;
   $2 = $11;
   $6 = $6 ^ $2;
   $1 = $0 + $6 | 0;
   $4 = $8;
   $2 = $5;
   $5 = $4 + $2 | 0;
   $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $11 = $5;
   $5 = HEAP32[$3 + 16 >> 2];
   $10 = $5;
   $0 = HEAP32[$3 + 20 >> 2];
   $9 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $8 = $0;
   $5 = HEAP32[$3 + 36 >> 2];
   $7 = $5;
   $5 = HEAP32[$3 + 24 >> 2];
   $4 = $5;
   $0 = HEAP32[$3 + 28 >> 2];
   $2 = $0;
   $0 = HEAP32[$3 + 16 >> 2];
   $6 = $0;
   $5 = HEAP32[$3 + 20 >> 2];
   $0 = $5;
   $5 = $2;
   $0 = $0 ^ $5;
   $2 = $0;
   $6 = $4 ^ $6;
   $5 = $8;
   $6 = $6 & $5;
   $0 = $7;
   $4 = $2;
   $4 = $0 & $4;
   $5 = $4;
   $4 = $9;
   $5 = $4 ^ $5;
   $0 = $10;
   $6 = $0 ^ $6;
   $2 = $6 + $1 | 0;
   $0 = $5;
   $5 = $11;
   $1 = $0 + $5 | 0;
   $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   $4 = $1;
   $6 = $2;
   $5 = $13;
   $0 = $5 + $2 | 0;
   $1 = $12;
   $2 = $1 + $4 | 0;
   $2 = $0 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   $5 = $2;
   $6 = $0;
   $1 = $14;
   $4 = $0 + $1 | 0;
   $2 = $15;
   $0 = $2 + $5 | 0;
   HEAP32[$3 + 712 >> 2] = $4;
   $0 = $4 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   HEAP32[$3 + 716 >> 2] = $0;
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = $1;
   $1 = HEAP32[$3 + 56 >> 2];
   $0 = HEAP32[$3 >> 2];
   $10 = $1 & $0;
   $0 = HEAP32[$3 + 60 >> 2];
   $1 = $0;
   $0 = $2;
   $1 = $1 & $0;
   $9 = $1;
   $1 = HEAP32[$3 + 48 >> 2];
   $8 = $1;
   $2 = HEAP32[$3 + 52 >> 2];
   $7 = $2;
   $2 = HEAP32[$3 >> 2];
   $5 = $2;
   $1 = HEAP32[$3 + 4 >> 2];
   $0 = $1;
   $1 = HEAP32[$3 + 56 >> 2];
   $6 = $1;
   $2 = HEAP32[$3 + 60 >> 2];
   $1 = $2;
   $2 = $0;
   $1 = $1 | $2;
   $4 = $1;
   $0 = $5;
   $6 = $0 | $6;
   $2 = $8;
   $1 = $7;
   $0 = $4;
   $0 = $1 & $0;
   $4 = $0;
   $1 = $10;
   $6 = $6 & $2;
   $11 = $1 | $6;
   $0 = $9;
   $2 = $4;
   $2 = $0 | $2;
   $8 = $2;
   $2 = HEAP32[$3 >> 2];
   $0 = $2;
   $5 = $0 << 25;
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = $1 << 25 | $0 >>> 7;
   $4 = $2;
   $2 = HEAP32[$3 >> 2];
   $0 = HEAP32[$3 + 4 >> 2];
   $6 = $0 >>> 7 | 0;
   $0 = $5;
   $10 = $0 | $6;
   $2 = 0;
   $1 = $2;
   $2 = $4;
   $1 = $1 | $2;
   $7 = $1;
   $1 = HEAP32[$3 >> 2];
   $1 = $1 << 4;
   $5 = $1;
   $1 = HEAP32[$3 >> 2];
   $0 = $1;
   $2 = HEAP32[$3 + 4 >> 2];
   $1 = $2 >>> 28 | 0;
   $4 = $1;
   $6 = ($2 & 268435455) << 4 | $0 >>> 28;
   $2 = 0;
   $9 = $6 | $2;
   $1 = $5;
   $0 = $4;
   $0 = $1 | $0;
   $4 = $0;
   $0 = HEAP32[$3 >> 2];
   $5 = $0 << 30;
   $2 = HEAP32[$3 + 4 >> 2];
   $0 = $2 << 30 | $0 >>> 2;
   $2 = $0;
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $6 = $1 >>> 2 | 0;
   $0 = $2;
   $2 = $16;
   $2 = $0 | $2;
   $0 = $9;
   $1 = $5;
   $6 = $1 | $6;
   $6 = $0 ^ $6;
   $1 = $2;
   $2 = $4;
   $1 = $1 ^ $2;
   $0 = $1;
   $1 = $7;
   $0 = $1 ^ $0;
   $4 = $0;
   $1 = $11;
   $2 = $10;
   $6 = $6 ^ $2;
   $5 = $1 + $6 | 0;
   $0 = $8;
   $2 = $4;
   $4 = $0 + $2 | 0;
   HEAP32[$3 + 704 >> 2] = $5;
   $4 = $5 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   HEAP32[$3 + 708 >> 2] = $4;
   $1 = HEAP32[$3 + 716 >> 2];
   $5 = $1;
   $4 = HEAP32[$3 + 712 >> 2];
   $0 = $4;
   $1 = HEAP32[$3 + 40 >> 2];
   $6 = $1;
   $2 = $0 + $1 | 0;
   $4 = HEAP32[$3 + 44 >> 2];
   $1 = $4;
   $4 = $5;
   $5 = $1 + $4 | 0;
   HEAP32[$3 + 40 >> 2] = $2;
   $5 = $2 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   HEAP32[$3 + 44 >> 2] = $5;
   $5 = HEAP32[$3 + 712 >> 2];
   $4 = $5;
   $0 = HEAP32[$3 + 716 >> 2];
   $1 = $0;
   $0 = HEAP32[$3 + 704 >> 2];
   $6 = $0;
   $5 = HEAP32[$3 + 708 >> 2];
   $0 = $5;
   $5 = $1;
   $2 = $0 + $5 | 0;
   $1 = $4 + $6 | 0;
   $2 = $1 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$3 + 8 >> 2] = $1;
   HEAP32[$3 + 12 >> 2] = $2;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   $5 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $2 = HEAP32[$5 >> 2];
   $14 = $2;
   $4 = HEAP32[$5 + 4 >> 2];
   $15 = $4;
   $5 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $4 = HEAP32[$5 >> 2];
   $13 = $4;
   $2 = HEAP32[$5 + 4 >> 2];
   $12 = $2;
   $2 = HEAP32[$3 + 16 >> 2];
   $9 = $2;
   $4 = HEAP32[$3 + 20 >> 2];
   $8 = $4;
   $4 = HEAP32[$3 + 40 >> 2];
   $1 = $4 << 23;
   $2 = HEAP32[$3 + 44 >> 2];
   $4 = $2 << 23 | $4 >>> 9;
   $0 = $4;
   $4 = HEAP32[$3 + 40 >> 2];
   $5 = HEAP32[$3 + 44 >> 2];
   $6 = $5 >>> 9 | 0;
   $5 = $1;
   $11 = $6 | $5;
   $4 = $0;
   $2 = $16;
   $2 = $4 | $2;
   $7 = $2;
   $2 = HEAP32[$3 + 40 >> 2];
   $2 = $2 << 18;
   $0 = $2;
   $2 = HEAP32[$3 + 40 >> 2];
   $5 = $2;
   $4 = HEAP32[$3 + 44 >> 2];
   $2 = $4 >>> 14 | 0;
   $6 = ($4 & 16383) << 18 | $5 >>> 14;
   $5 = $2;
   $4 = 0;
   $10 = $4 | $6;
   $2 = $0;
   $5 = $2 | $5;
   $1 = $5;
   $5 = HEAP32[$3 + 40 >> 2];
   $2 = $5;
   $5 = $2 << 14;
   $0 = $5;
   $5 = HEAP32[$3 + 40 >> 2];
   $4 = $5;
   $2 = HEAP32[$3 + 44 >> 2];
   $5 = $2 >>> 18 | 0;
   $6 = ($2 & 262143) << 14 | $4 >>> 18;
   $4 = $5;
   $5 = $0;
   $4 = $4 | $5;
   $0 = $4;
   $2 = 0;
   $6 = $6 | $2;
   $5 = $10;
   $6 = $6 ^ $5;
   $4 = $1;
   $2 = $0;
   $2 = $4 ^ $2;
   $5 = $2;
   $2 = $7;
   $5 = $2 ^ $5;
   $4 = $11;
   $6 = $4 ^ $6;
   $2 = $9;
   $0 = $6 + $2 | 0;
   $4 = $5;
   $5 = $8;
   $1 = $4 + $5 | 0;
   $1 = $0 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   $11 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $10 = $1;
   $2 = HEAP32[$3 + 28 >> 2];
   $9 = $2;
   $2 = HEAP32[$3 + 40 >> 2];
   $8 = $2;
   $1 = HEAP32[$3 + 44 >> 2];
   $7 = $1;
   $1 = HEAP32[$3 + 32 >> 2];
   $5 = $1;
   $2 = HEAP32[$3 + 36 >> 2];
   $4 = $2;
   $2 = HEAP32[$3 + 24 >> 2];
   $6 = $2;
   $1 = HEAP32[$3 + 28 >> 2];
   $2 = $1;
   $1 = $4;
   $2 = $1 ^ $2;
   $4 = $2;
   $1 = $8;
   $6 = $6 ^ $5;
   $6 = $1 & $6;
   $2 = $7;
   $5 = $4;
   $5 = $2 & $5;
   $1 = $5;
   $5 = $9;
   $1 = $1 ^ $5;
   $5 = $1;
   $2 = $10;
   $6 = $6 ^ $2;
   $4 = $6 + $0 | 0;
   $1 = $11;
   $2 = $5;
   $0 = $1 + $2 | 0;
   $0 = $4 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   $5 = $0;
   $6 = $4;
   $1 = $13;
   $2 = $4 + $1 | 0;
   $0 = $12;
   $4 = $0 + $5 | 0;
   $4 = $2 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   $6 = $2;
   $0 = $14;
   $5 = $2 + $0 | 0;
   $1 = $4;
   $4 = $15;
   $2 = $1 + $4 | 0;
   HEAP32[$3 + 712 >> 2] = $5;
   $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$3 + 716 >> 2] = $2;
   $0 = HEAP32[$3 + 12 >> 2];
   $1 = $0;
   $2 = HEAP32[$3 + 8 >> 2];
   $0 = HEAP32[$3 >> 2];
   $9 = $2 & $0;
   $2 = HEAP32[$3 + 4 >> 2];
   $0 = $2;
   $2 = $1;
   $0 = $0 & $2;
   $8 = $0;
   $0 = HEAP32[$3 + 56 >> 2];
   $7 = $0;
   $4 = HEAP32[$3 + 60 >> 2];
   $5 = $4;
   $4 = HEAP32[$3 + 8 >> 2];
   $2 = $4;
   $0 = HEAP32[$3 + 12 >> 2];
   $1 = $0;
   $0 = HEAP32[$3 >> 2];
   $6 = $0;
   $4 = HEAP32[$3 + 4 >> 2];
   $0 = $4;
   $4 = $1;
   $0 = $0 | $4;
   $1 = $0;
   $4 = $7;
   $6 = $6 | $2;
   $0 = $5;
   $2 = $1;
   $2 = $0 & $2;
   $0 = $9;
   $6 = $4 & $6;
   $12 = $0 | $6;
   $4 = $2;
   $2 = $8;
   $4 = $4 | $2;
   $8 = $4;
   $4 = HEAP32[$3 + 8 >> 2];
   $2 = $4;
   $5 = $2 << 25;
   $0 = HEAP32[$3 + 12 >> 2];
   $4 = $0 << 25 | $2 >>> 7;
   $1 = $4;
   $4 = HEAP32[$3 + 8 >> 2];
   $2 = HEAP32[$3 + 12 >> 2];
   $6 = $2 >>> 7 | 0;
   $2 = $5;
   $11 = $6 | $2;
   $4 = 0;
   $0 = $4;
   $4 = $1;
   $0 = $0 | $4;
   $7 = $0;
   $0 = HEAP32[$3 + 8 >> 2];
   $0 = $0 << 4;
   $1 = $0;
   $0 = HEAP32[$3 + 8 >> 2];
   $2 = $0;
   $4 = HEAP32[$3 + 12 >> 2];
   $0 = $4 >>> 28 | 0;
   $6 = ($4 & 268435455) << 4 | $2 >>> 28;
   $2 = $0;
   $4 = 0;
   $10 = $4 | $6;
   $0 = $1;
   $2 = $0 | $2;
   $5 = $2;
   $2 = HEAP32[$3 + 8 >> 2];
   $0 = $2;
   $9 = $0 << 30;
   $4 = HEAP32[$3 + 12 >> 2];
   $2 = $4 << 30 | $0 >>> 2;
   $1 = $2;
   $2 = HEAP32[$3 + 8 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   $6 = $0 >>> 2 | 0;
   $2 = 0;
   $4 = $2;
   $2 = $1;
   $4 = $4 | $2;
   $0 = $9;
   $6 = $0 | $6;
   $2 = $10;
   $6 = $6 ^ $2;
   $0 = $4;
   $4 = $5;
   $0 = $0 ^ $4;
   $2 = $0;
   $0 = $7;
   $2 = $0 ^ $2;
   $0 = $12;
   $4 = $11;
   $6 = $4 ^ $6;
   $1 = $0 + $6 | 0;
   $4 = $2;
   $2 = $8;
   $5 = $4 + $2 | 0;
   HEAP32[$3 + 704 >> 2] = $1;
   $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   HEAP32[$3 + 708 >> 2] = $5;
   $0 = HEAP32[$3 + 716 >> 2];
   $1 = $0;
   $0 = HEAP32[$3 + 48 >> 2];
   $6 = $0;
   $5 = HEAP32[$3 + 712 >> 2];
   $2 = $5;
   $4 = $0 + $2 | 0;
   $5 = HEAP32[$3 + 52 >> 2];
   $0 = $5;
   $5 = $1;
   $1 = $0 + $5 | 0;
   HEAP32[$3 + 48 >> 2] = $4;
   $1 = $4 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   HEAP32[$3 + 52 >> 2] = $1;
   $1 = HEAP32[$3 + 712 >> 2];
   $5 = $1;
   $2 = HEAP32[$3 + 716 >> 2];
   $7 = $2;
   $1 = HEAP32[$3 + 708 >> 2];
   $4 = $1;
   $2 = HEAP32[$3 + 704 >> 2];
   $6 = $2;
   $0 = $2 + $5 | 0;
   $1 = $7;
   $2 = $4;
   $4 = $1 + $2 | 0;
   HEAP32[$3 + 16 >> 2] = $0;
   $4 = $0 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   HEAP32[$3 + 20 >> 2] = $4;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   $1 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $4 = HEAP32[$1 >> 2];
   $14 = $4;
   $5 = HEAP32[$1 + 4 >> 2];
   $15 = $5;
   $1 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $5 = HEAP32[$1 >> 2];
   $13 = $5;
   $4 = HEAP32[$1 + 4 >> 2];
   $12 = $4;
   $4 = HEAP32[$3 + 24 >> 2];
   $9 = $4;
   $5 = HEAP32[$3 + 28 >> 2];
   $8 = $5;
   $5 = HEAP32[$3 + 48 >> 2];
   $1 = $5;
   $2 = $1 << 23;
   $4 = HEAP32[$3 + 52 >> 2];
   $5 = $4 << 23 | $1 >>> 9;
   $0 = $5;
   $5 = HEAP32[$3 + 48 >> 2];
   $1 = HEAP32[$3 + 52 >> 2];
   $6 = $1 >>> 9 | 0;
   $1 = $2;
   $11 = $1 | $6;
   $5 = 0;
   $4 = $5;
   $5 = $0;
   $4 = $4 | $5;
   $7 = $4;
   $4 = HEAP32[$3 + 48 >> 2];
   $4 = $4 << 18;
   $0 = $4;
   $4 = HEAP32[$3 + 48 >> 2];
   $1 = $4;
   $5 = HEAP32[$3 + 52 >> 2];
   $4 = $5 >>> 14 | 0;
   $6 = ($5 & 16383) << 18 | $1 >>> 14;
   $5 = 0;
   $10 = $6 | $5;
   $1 = $4;
   $4 = $0;
   $1 = $1 | $4;
   $2 = $1;
   $1 = HEAP32[$3 + 48 >> 2];
   $1 = $1 << 14;
   $0 = $1;
   $1 = HEAP32[$3 + 48 >> 2];
   $5 = $1;
   $4 = HEAP32[$3 + 52 >> 2];
   $1 = $4 >>> 18 | 0;
   $6 = ($4 & 262143) << 14 | $5 >>> 18;
   $5 = $1;
   $1 = $0;
   $5 = $1 | $5;
   $1 = $10;
   $4 = 0;
   $6 = $4 | $6;
   $6 = $1 ^ $6;
   $4 = $5;
   $5 = $2;
   $4 = $4 ^ $5;
   $1 = $4;
   $4 = $7;
   $1 = $1 ^ $4;
   $0 = $1;
   $4 = $9;
   $5 = $11;
   $6 = $6 ^ $5;
   $2 = $4 + $6 | 0;
   $1 = $8;
   $5 = $0;
   $0 = $1 + $5 | 0;
   $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   $11 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $10 = $0;
   $4 = HEAP32[$3 + 36 >> 2];
   $9 = $4;
   $4 = HEAP32[$3 + 48 >> 2];
   $8 = $4;
   $0 = HEAP32[$3 + 52 >> 2];
   $7 = $0;
   $0 = HEAP32[$3 + 40 >> 2];
   $5 = $0;
   $4 = HEAP32[$3 + 44 >> 2];
   $1 = $4;
   $4 = HEAP32[$3 + 32 >> 2];
   $6 = $4;
   $0 = HEAP32[$3 + 36 >> 2];
   $4 = $0;
   $0 = $1;
   $4 = $0 ^ $4;
   $0 = $8;
   $1 = $5;
   $6 = $1 ^ $6;
   $6 = $0 & $6;
   $1 = $4;
   $4 = $7;
   $1 = $1 & $4;
   $0 = $1;
   $1 = $9;
   $0 = $1 ^ $0;
   $7 = $0;
   $1 = $2;
   $4 = $10;
   $6 = $4 ^ $6;
   $5 = $1 + $6 | 0;
   $0 = $11;
   $4 = $7;
   $2 = $0 + $4 | 0;
   $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   $6 = $5;
   $0 = $13;
   $4 = $5 + $0 | 0;
   $1 = $2;
   $2 = $12;
   $5 = $1 + $2 | 0;
   $5 = $4 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $6 = $4;
   $2 = $14;
   $1 = $2 + $4 | 0;
   $0 = $5;
   $5 = $15;
   $4 = $0 + $5 | 0;
   HEAP32[$3 + 712 >> 2] = $1;
   $4 = $1 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   HEAP32[$3 + 716 >> 2] = $4;
   $4 = HEAP32[$3 + 16 >> 2];
   $5 = $4;
   $2 = HEAP32[$3 + 20 >> 2];
   $1 = $2;
   $4 = HEAP32[$3 + 12 >> 2];
   $0 = $4;
   $2 = HEAP32[$3 + 8 >> 2];
   $9 = $2 & $5;
   $4 = $1;
   $2 = $0;
   $2 = $4 & $2;
   $8 = $2;
   $2 = HEAP32[$3 >> 2];
   $7 = $2;
   $5 = HEAP32[$3 + 4 >> 2];
   $1 = $5;
   $5 = HEAP32[$3 + 16 >> 2];
   $4 = $5;
   $2 = HEAP32[$3 + 20 >> 2];
   $0 = $2;
   $2 = HEAP32[$3 + 8 >> 2];
   $6 = $2;
   $5 = HEAP32[$3 + 12 >> 2];
   $2 = $5;
   $5 = $0;
   $2 = $2 | $5;
   $6 = $4 | $6;
   $5 = $7;
   $4 = $2;
   $2 = $1;
   $4 = $4 & $2;
   $0 = $4;
   $6 = $6 & $5;
   $2 = $9;
   $11 = $6 | $2;
   $4 = $8;
   $5 = $0;
   $5 = $4 | $5;
   $8 = $5;
   $5 = HEAP32[$3 + 16 >> 2];
   $4 = $5;
   $1 = $4 << 25;
   $2 = HEAP32[$3 + 20 >> 2];
   $5 = $2 << 25 | $4 >>> 7;
   $0 = $5;
   $5 = HEAP32[$3 + 16 >> 2];
   $4 = HEAP32[$3 + 20 >> 2];
   $6 = $4 >>> 7 | 0;
   $4 = $1;
   $10 = $4 | $6;
   $5 = 0;
   $2 = $5;
   $5 = $0;
   $2 = $2 | $5;
   $7 = $2;
   $2 = HEAP32[$3 + 16 >> 2];
   $2 = $2 << 4;
   $0 = $2;
   $2 = HEAP32[$3 + 16 >> 2];
   $4 = $2;
   $5 = HEAP32[$3 + 20 >> 2];
   $2 = $5 >>> 28 | 0;
   $6 = ($5 & 268435455) << 4 | $4 >>> 28;
   $5 = 0;
   $6 = $6 | $5;
   $4 = $2;
   $2 = $0;
   $4 = $4 | $2;
   $1 = $4;
   $4 = HEAP32[$3 + 16 >> 2];
   $2 = $4;
   $9 = $2 << 30;
   $5 = HEAP32[$3 + 20 >> 2];
   $4 = $5 << 30 | $2 >>> 2;
   $0 = $4;
   $4 = HEAP32[$3 + 16 >> 2];
   $2 = HEAP32[$3 + 20 >> 2];
   $4 = $0;
   $5 = $16;
   $5 = $4 | $5;
   $4 = $6;
   $6 = $2 >>> 2 | 0;
   $2 = $9;
   $6 = $6 | $2;
   $6 = $4 ^ $6;
   $2 = $5;
   $5 = $1;
   $2 = $2 ^ $5;
   $4 = $2;
   $2 = $7;
   $4 = $4 ^ $2;
   $1 = $4;
   $5 = $10;
   $6 = $6 ^ $5;
   $2 = $11;
   $0 = $6 + $2 | 0;
   $4 = $8;
   $5 = $1;
   $1 = $4 + $5 | 0;
   HEAP32[$3 + 704 >> 2] = $0;
   $1 = $0 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   HEAP32[$3 + 708 >> 2] = $1;
   $1 = HEAP32[$3 + 712 >> 2];
   $4 = $1;
   $2 = HEAP32[$3 + 716 >> 2];
   $7 = $2;
   $1 = HEAP32[$3 + 60 >> 2];
   $0 = $1;
   $2 = HEAP32[$3 + 56 >> 2];
   $6 = $2;
   $5 = $4 + $2 | 0;
   $1 = $7;
   $2 = $0;
   $0 = $1 + $2 | 0;
   HEAP32[$3 + 56 >> 2] = $5;
   $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   HEAP32[$3 + 60 >> 2] = $0;
   $0 = HEAP32[$3 + 712 >> 2];
   $1 = $0;
   $4 = HEAP32[$3 + 716 >> 2];
   $7 = $4;
   $0 = HEAP32[$3 + 708 >> 2];
   $5 = $0;
   $4 = HEAP32[$3 + 704 >> 2];
   $6 = $4;
   $2 = $1 + $4 | 0;
   $0 = $7;
   $4 = $5;
   $5 = $0 + $4 | 0;
   HEAP32[$3 + 24 >> 2] = $2;
   $5 = $2 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   HEAP32[$3 + 28 >> 2] = $5;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   $0 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $5 = HEAP32[$0 >> 2];
   $14 = $5;
   $1 = HEAP32[$0 + 4 >> 2];
   $15 = $1;
   $0 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $1 = HEAP32[$0 >> 2];
   $13 = $1;
   $5 = HEAP32[$0 + 4 >> 2];
   $12 = $5;
   $5 = HEAP32[$3 + 32 >> 2];
   $9 = $5;
   $1 = HEAP32[$3 + 36 >> 2];
   $8 = $1;
   $1 = HEAP32[$3 + 56 >> 2];
   $0 = $1;
   $4 = $0 << 23;
   $5 = HEAP32[$3 + 60 >> 2];
   $1 = $5 << 23 | $0 >>> 9;
   $2 = $1;
   $1 = HEAP32[$3 + 56 >> 2];
   $0 = HEAP32[$3 + 60 >> 2];
   $6 = $0 >>> 9 | 0;
   $0 = $4;
   $11 = $0 | $6;
   $1 = $2;
   $5 = $16;
   $5 = $1 | $5;
   $7 = $5;
   $5 = HEAP32[$3 + 56 >> 2];
   $1 = $5;
   $5 = $1 << 18;
   $2 = $5;
   $5 = HEAP32[$3 + 56 >> 2];
   $0 = $5;
   $1 = HEAP32[$3 + 60 >> 2];
   $5 = $1 >>> 14 | 0;
   $6 = ($1 & 16383) << 18 | $0 >>> 14;
   $1 = 0;
   $10 = $1 | $6;
   $0 = $5;
   $5 = $2;
   $0 = $0 | $5;
   $4 = $0;
   $0 = HEAP32[$3 + 56 >> 2];
   $0 = $0 << 14;
   $2 = $0;
   $0 = HEAP32[$3 + 56 >> 2];
   $1 = $0;
   $5 = HEAP32[$3 + 60 >> 2];
   $0 = $5 >>> 18 | 0;
   $6 = ($5 & 262143) << 14 | $1 >>> 18;
   $1 = $0;
   $0 = $2;
   $1 = $1 | $0;
   $2 = $1;
   $0 = $10;
   $5 = 0;
   $6 = $6 | $5;
   $6 = $0 ^ $6;
   $1 = $4;
   $5 = $2;
   $5 = $1 ^ $5;
   $0 = $5;
   $5 = $7;
   $0 = $0 ^ $5;
   $1 = $11;
   $6 = $1 ^ $6;
   $5 = $9;
   $4 = $6 + $5 | 0;
   $1 = $0;
   $0 = $8;
   $2 = $1 + $0 | 0;
   $2 = $4 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   $11 = $2;
   $2 = HEAP32[$3 + 40 >> 2];
   $10 = $2;
   $5 = HEAP32[$3 + 44 >> 2];
   $9 = $5;
   $5 = HEAP32[$3 + 56 >> 2];
   $8 = $5;
   $2 = HEAP32[$3 + 60 >> 2];
   $7 = $2;
   $2 = HEAP32[$3 + 48 >> 2];
   $1 = $2;
   $5 = HEAP32[$3 + 52 >> 2];
   $0 = $5;
   $5 = HEAP32[$3 + 40 >> 2];
   $6 = $5;
   $2 = HEAP32[$3 + 44 >> 2];
   $5 = $2;
   $2 = $0;
   $5 = $2 ^ $5;
   $0 = $1;
   $6 = $0 ^ $6;
   $2 = $8;
   $6 = $6 & $2;
   $0 = $5;
   $5 = $7;
   $0 = $0 & $5;
   $2 = $0;
   $0 = $9;
   $2 = $0 ^ $2;
   $7 = $2;
   $0 = $4;
   $5 = $10;
   $6 = $6 ^ $5;
   $1 = $0 + $6 | 0;
   $2 = $11;
   $5 = $7;
   $4 = $2 + $5 | 0;
   $4 = $1 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   $6 = $1;
   $2 = $13;
   $5 = $2 + $1 | 0;
   $0 = $4;
   $4 = $12;
   $1 = $0 + $4 | 0;
   $1 = $5 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   $2 = $1;
   $6 = $5;
   $4 = $14;
   $0 = $5 + $4 | 0;
   $1 = $15;
   $5 = $1 + $2 | 0;
   HEAP32[$3 + 712 >> 2] = $0;
   $5 = $0 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   HEAP32[$3 + 716 >> 2] = $5;
   $4 = HEAP32[$3 + 28 >> 2];
   $0 = $4;
   $5 = HEAP32[$3 + 24 >> 2];
   $1 = $5;
   $4 = HEAP32[$3 + 16 >> 2];
   $9 = $1 & $4;
   $5 = HEAP32[$3 + 20 >> 2];
   $4 = $5;
   $5 = $0;
   $4 = $4 & $5;
   $8 = $4;
   $4 = HEAP32[$3 + 8 >> 2];
   $7 = $4;
   $1 = HEAP32[$3 + 12 >> 2];
   $2 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $5 = $1;
   $4 = HEAP32[$3 + 28 >> 2];
   $0 = $4;
   $4 = HEAP32[$3 + 16 >> 2];
   $6 = $4;
   $1 = HEAP32[$3 + 20 >> 2];
   $4 = $1;
   $1 = $0;
   $4 = $1 | $4;
   $0 = $4;
   $1 = $7;
   $6 = $6 | $5;
   $4 = $2;
   $5 = $0;
   $5 = $4 & $5;
   $4 = $9;
   $6 = $1 & $6;
   $12 = $4 | $6;
   $1 = $5;
   $5 = $8;
   $1 = $1 | $5;
   $8 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $2 = $1 << 25;
   $4 = HEAP32[$3 + 28 >> 2];
   $1 = $4 << 25 | $1 >>> 7;
   $0 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $5 = HEAP32[$3 + 28 >> 2];
   $6 = $5 >>> 7 | 0;
   $5 = $2;
   $11 = $6 | $5;
   $1 = $0;
   $4 = $16;
   $4 = $1 | $4;
   $7 = $4;
   $4 = HEAP32[$3 + 24 >> 2];
   $1 = $4;
   $4 = $1 << 4;
   $0 = $4;
   $4 = HEAP32[$3 + 24 >> 2];
   $5 = $4;
   $1 = HEAP32[$3 + 28 >> 2];
   $4 = $1 >>> 28 | 0;
   $6 = ($1 & 268435455) << 4 | $5 >>> 28;
   $5 = $4;
   $1 = 0;
   $10 = $1 | $6;
   $4 = $0;
   $5 = $4 | $5;
   $2 = $5;
   $5 = HEAP32[$3 + 24 >> 2];
   $4 = $5;
   $9 = $4 << 30;
   $1 = HEAP32[$3 + 28 >> 2];
   $5 = $1 << 30 | $4 >>> 2;
   $0 = $5;
   $5 = HEAP32[$3 + 24 >> 2];
   $4 = HEAP32[$3 + 28 >> 2];
   $6 = $4 >>> 2 | 0;
   $5 = 0;
   $1 = $5;
   $5 = $0;
   $1 = $1 | $5;
   $0 = $1;
   $4 = $9;
   $6 = $4 | $6;
   $5 = $10;
   $6 = $6 ^ $5;
   $1 = $2;
   $4 = $0;
   $4 = $1 ^ $4;
   $5 = $4;
   $4 = $7;
   $5 = $4 ^ $5;
   $4 = $12;
   $1 = $11;
   $6 = $1 ^ $6;
   $2 = $4 + $6 | 0;
   $1 = $5;
   $5 = $8;
   $0 = $1 + $5 | 0;
   HEAP32[$3 + 704 >> 2] = $2;
   $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   HEAP32[$3 + 708 >> 2] = $0;
   $0 = HEAP32[$3 + 712 >> 2];
   $5 = $0;
   $4 = HEAP32[$3 + 716 >> 2];
   $7 = $4;
   $0 = HEAP32[$3 + 4 >> 2];
   $2 = $0;
   $4 = HEAP32[$3 >> 2];
   $6 = $4;
   $1 = $4 + $5 | 0;
   $0 = $7;
   $4 = $2;
   $2 = $0 + $4 | 0;
   HEAP32[$3 >> 2] = $1;
   $2 = $1 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$3 + 4 >> 2] = $2;
   $2 = HEAP32[$3 + 712 >> 2];
   $4 = $2;
   $5 = HEAP32[$3 + 716 >> 2];
   $0 = $5;
   $5 = HEAP32[$3 + 704 >> 2];
   $6 = $5;
   $2 = HEAP32[$3 + 708 >> 2];
   $5 = $2;
   $2 = $0;
   $1 = $2 + $5 | 0;
   $0 = $4;
   $4 = $0 + $6 | 0;
   $1 = $4 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   HEAP32[$3 + 32 >> 2] = $4;
   HEAP32[$3 + 36 >> 2] = $1;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   $2 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $1 = HEAP32[$2 >> 2];
   $14 = $1;
   $0 = HEAP32[$2 + 4 >> 2];
   $15 = $0;
   $2 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $0 = HEAP32[$2 >> 2];
   $13 = $0;
   $1 = HEAP32[$2 + 4 >> 2];
   $12 = $1;
   $1 = HEAP32[$3 + 40 >> 2];
   $9 = $1;
   $0 = HEAP32[$3 + 44 >> 2];
   $8 = $0;
   $0 = HEAP32[$3 >> 2];
   $5 = $0 << 23;
   $1 = HEAP32[$3 + 4 >> 2];
   $0 = $1 << 23 | $0 >>> 9;
   $4 = $0;
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 4 >> 2];
   $6 = $2 >>> 9 | 0;
   $2 = $5;
   $11 = $6 | $2;
   $0 = 0;
   $1 = $0;
   $0 = $4;
   $1 = $1 | $0;
   $7 = $1;
   $1 = HEAP32[$3 >> 2];
   $0 = $1;
   $1 = $0 << 18;
   $4 = $1;
   $1 = HEAP32[$3 >> 2];
   $2 = $1;
   $0 = HEAP32[$3 + 4 >> 2];
   $1 = $0 >>> 14 | 0;
   $6 = ($0 & 16383) << 18 | $2 >>> 14;
   $2 = $1;
   $0 = 0;
   $10 = $0 | $6;
   $1 = $4;
   $2 = $1 | $2;
   $5 = $2;
   $2 = HEAP32[$3 >> 2];
   $1 = $2;
   $2 = $1 << 14;
   $4 = $2;
   $2 = HEAP32[$3 >> 2];
   $0 = $2;
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = $1 >>> 18 | 0;
   $6 = ($1 & 262143) << 14 | $0 >>> 18;
   $0 = $2;
   $2 = $4;
   $0 = $0 | $2;
   $1 = 0;
   $6 = $1 | $6;
   $2 = $10;
   $6 = $6 ^ $2;
   $1 = $0;
   $0 = $5;
   $1 = $1 ^ $0;
   $2 = $1;
   $1 = $7;
   $2 = $1 ^ $2;
   $1 = $9;
   $0 = $11;
   $6 = $0 ^ $6;
   $5 = $1 + $6 | 0;
   $0 = $2;
   $2 = $8;
   $4 = $0 + $2 | 0;
   $4 = $5 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   $11 = $4;
   $4 = HEAP32[$3 + 48 >> 2];
   $10 = $4;
   $1 = HEAP32[$3 + 52 >> 2];
   $9 = $1;
   $1 = HEAP32[$3 >> 2];
   $8 = $1;
   $4 = HEAP32[$3 + 4 >> 2];
   $7 = $4;
   $4 = HEAP32[$3 + 56 >> 2];
   $2 = $4;
   $1 = HEAP32[$3 + 60 >> 2];
   $0 = $1;
   $1 = HEAP32[$3 + 48 >> 2];
   $6 = $1;
   $4 = HEAP32[$3 + 52 >> 2];
   $1 = $4;
   $4 = $0;
   $1 = $1 ^ $4;
   $0 = $1;
   $4 = $8;
   $6 = $6 ^ $2;
   $6 = $4 & $6;
   $1 = $7;
   $2 = $0;
   $2 = $1 & $2;
   $4 = $2;
   $2 = $9;
   $4 = $4 ^ $2;
   $1 = $10;
   $6 = $1 ^ $6;
   $2 = $5;
   $0 = $6 + $2 | 0;
   $1 = $4;
   $4 = $11;
   $5 = $1 + $4 | 0;
   $5 = $0 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $6 = $0;
   $4 = $13;
   $1 = $4 + $0 | 0;
   $2 = $5;
   $5 = $12;
   $0 = $2 + $5 | 0;
   $0 = $1 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   $4 = $0;
   $6 = $1;
   $5 = $14;
   $2 = $5 + $1 | 0;
   $0 = $15;
   $1 = $0 + $4 | 0;
   HEAP32[$3 + 712 >> 2] = $2;
   $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   HEAP32[$3 + 716 >> 2] = $1;
   $1 = HEAP32[$3 + 32 >> 2];
   $0 = $1;
   $5 = HEAP32[$3 + 36 >> 2];
   $4 = $5;
   $1 = HEAP32[$3 + 28 >> 2];
   $2 = $1;
   $5 = HEAP32[$3 + 24 >> 2];
   $9 = $0 & $5;
   $1 = $4;
   $5 = $2;
   $5 = $1 & $5;
   $8 = $5;
   $5 = HEAP32[$3 + 16 >> 2];
   $7 = $5;
   $0 = HEAP32[$3 + 20 >> 2];
   $4 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $2 = $0;
   $5 = HEAP32[$3 + 36 >> 2];
   $1 = $5;
   $5 = HEAP32[$3 + 24 >> 2];
   $6 = $5;
   $0 = HEAP32[$3 + 28 >> 2];
   $5 = $0;
   $0 = $1;
   $5 = $0 | $5;
   $0 = $7;
   $1 = $2;
   $6 = $1 | $6;
   $1 = $5;
   $5 = $4;
   $1 = $1 & $5;
   $2 = $1;
   $6 = $0 & $6;
   $5 = $9;
   $11 = $6 | $5;
   $1 = $8;
   $0 = $2;
   $0 = $1 | $0;
   $8 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $4 = $0 << 25;
   $5 = HEAP32[$3 + 36 >> 2];
   $0 = $5 << 25 | $0 >>> 7;
   $2 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $1 = HEAP32[$3 + 36 >> 2];
   $6 = $1 >>> 7 | 0;
   $1 = $4;
   $10 = $1 | $6;
   $0 = $2;
   $5 = $16;
   $5 = $0 | $5;
   $7 = $5;
   $5 = HEAP32[$3 + 32 >> 2];
   $0 = $5;
   $5 = $0 << 4;
   $2 = $5;
   $5 = HEAP32[$3 + 32 >> 2];
   $1 = $5;
   $0 = HEAP32[$3 + 36 >> 2];
   $5 = $0 >>> 28 | 0;
   $6 = ($0 & 268435455) << 4 | $1 >>> 28;
   $0 = 0;
   $6 = $0 | $6;
   $1 = $5;
   $5 = $2;
   $1 = $1 | $5;
   $4 = $1;
   $1 = HEAP32[$3 + 32 >> 2];
   $9 = $1 << 30;
   $0 = HEAP32[$3 + 36 >> 2];
   $1 = $0 << 30 | $1 >>> 2;
   $0 = $1;
   $1 = HEAP32[$3 + 32 >> 2];
   $5 = HEAP32[$3 + 36 >> 2];
   $1 = $0;
   $0 = $16;
   $0 = $1 | $0;
   $2 = $0;
   $1 = $6;
   $6 = $5 >>> 2 | 0;
   $5 = $9;
   $6 = $6 | $5;
   $6 = $1 ^ $6;
   $0 = $4;
   $5 = $2;
   $5 = $0 ^ $5;
   $1 = $5;
   $5 = $7;
   $1 = $1 ^ $5;
   $2 = $1;
   $0 = $10;
   $6 = $0 ^ $6;
   $5 = $11;
   $4 = $6 + $5 | 0;
   $1 = $8;
   $0 = $2;
   $2 = $1 + $0 | 0;
   HEAP32[$3 + 704 >> 2] = $4;
   $2 = $4 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$3 + 708 >> 2] = $2;
   $2 = HEAP32[$3 + 712 >> 2];
   $1 = $2;
   $5 = HEAP32[$3 + 716 >> 2];
   $0 = $5;
   $5 = HEAP32[$3 + 8 >> 2];
   $6 = $5;
   $2 = HEAP32[$3 + 12 >> 2];
   $5 = $2;
   $2 = $0;
   $4 = $2 + $5 | 0;
   $0 = $1 + $6 | 0;
   $4 = $0 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   HEAP32[$3 + 8 >> 2] = $0;
   HEAP32[$3 + 12 >> 2] = $4;
   $1 = HEAP32[$3 + 716 >> 2];
   $0 = $1;
   $1 = HEAP32[$3 + 704 >> 2];
   $6 = $1;
   $4 = HEAP32[$3 + 712 >> 2];
   $2 = $4;
   $5 = $1 + $2 | 0;
   $4 = HEAP32[$3 + 708 >> 2];
   $1 = $4;
   $4 = $0;
   $0 = $1 + $4 | 0;
   HEAP32[$3 + 40 >> 2] = $5;
   $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   HEAP32[$3 + 44 >> 2] = $0;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   $4 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $0 = HEAP32[$4 >> 2];
   $14 = $0;
   $2 = HEAP32[$4 + 4 >> 2];
   $15 = $2;
   $4 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $2 = HEAP32[$4 >> 2];
   $13 = $2;
   $0 = HEAP32[$4 + 4 >> 2];
   $12 = $0;
   $0 = HEAP32[$3 + 48 >> 2];
   $9 = $0;
   $2 = HEAP32[$3 + 52 >> 2];
   $8 = $2;
   $2 = HEAP32[$3 + 8 >> 2];
   $5 = $2 << 23;
   $0 = HEAP32[$3 + 12 >> 2];
   $2 = $0 << 23 | $2 >>> 9;
   $1 = $2;
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $6 = $4 >>> 9 | 0;
   $4 = $5;
   $11 = $4 | $6;
   $2 = 0;
   $0 = $2;
   $2 = $1;
   $0 = $0 | $2;
   $7 = $0;
   $0 = HEAP32[$3 + 8 >> 2];
   $0 = $0 << 18;
   $5 = $0;
   $0 = HEAP32[$3 + 8 >> 2];
   $4 = $0;
   $2 = HEAP32[$3 + 12 >> 2];
   $0 = $2 >>> 14 | 0;
   $1 = $0;
   $6 = ($2 & 16383) << 18 | $4 >>> 14;
   $2 = 0;
   $10 = $6 | $2;
   $0 = $5;
   $4 = $1;
   $4 = $0 | $4;
   $5 = $4;
   $4 = HEAP32[$3 + 8 >> 2];
   $0 = $4;
   $4 = $0 << 14;
   $1 = $4;
   $4 = HEAP32[$3 + 8 >> 2];
   $2 = $4;
   $0 = HEAP32[$3 + 12 >> 2];
   $4 = $0 >>> 18 | 0;
   $6 = ($0 & 262143) << 14 | $2 >>> 18;
   $2 = $4;
   $4 = $1;
   $2 = $4 | $2;
   $4 = $10;
   $0 = 0;
   $6 = $0 | $6;
   $6 = $4 ^ $6;
   $0 = $2;
   $2 = $5;
   $0 = $0 ^ $2;
   $4 = $0;
   $0 = $7;
   $4 = $0 ^ $4;
   $5 = $4;
   $0 = $9;
   $2 = $11;
   $6 = $6 ^ $2;
   $1 = $0 + $6 | 0;
   $4 = $8;
   $2 = $5;
   $5 = $4 + $2 | 0;
   $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $11 = $5;
   $5 = HEAP32[$3 + 56 >> 2];
   $10 = $5;
   $0 = HEAP32[$3 + 60 >> 2];
   $9 = $0;
   $0 = HEAP32[$3 + 8 >> 2];
   $8 = $0;
   $5 = HEAP32[$3 + 12 >> 2];
   $7 = $5;
   $5 = HEAP32[$3 >> 2];
   $4 = $5;
   $0 = HEAP32[$3 + 4 >> 2];
   $2 = $0;
   $0 = HEAP32[$3 + 56 >> 2];
   $6 = $0;
   $5 = HEAP32[$3 + 60 >> 2];
   $0 = $5;
   $5 = $2;
   $0 = $0 ^ $5;
   $2 = $0;
   $6 = $4 ^ $6;
   $5 = $8;
   $6 = $6 & $5;
   $0 = $7;
   $4 = $2;
   $4 = $0 & $4;
   $5 = $4;
   $4 = $9;
   $5 = $4 ^ $5;
   $0 = $10;
   $6 = $0 ^ $6;
   $2 = $6 + $1 | 0;
   $0 = $5;
   $5 = $11;
   $1 = $0 + $5 | 0;
   $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   $4 = $1;
   $6 = $2;
   $5 = $13;
   $0 = $5 + $2 | 0;
   $1 = $12;
   $2 = $1 + $4 | 0;
   $2 = $0 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   $5 = $2;
   $6 = $0;
   $1 = $14;
   $4 = $0 + $1 | 0;
   $2 = $15;
   $0 = $2 + $5 | 0;
   HEAP32[$3 + 712 >> 2] = $4;
   $0 = $4 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   HEAP32[$3 + 716 >> 2] = $0;
   $1 = HEAP32[$3 + 44 >> 2];
   $2 = $1;
   $1 = HEAP32[$3 + 32 >> 2];
   $0 = HEAP32[$3 + 40 >> 2];
   $10 = $1 & $0;
   $0 = HEAP32[$3 + 36 >> 2];
   $1 = $0;
   $0 = $2;
   $1 = $1 & $0;
   $9 = $1;
   $1 = HEAP32[$3 + 24 >> 2];
   $8 = $1;
   $2 = HEAP32[$3 + 28 >> 2];
   $7 = $2;
   $2 = HEAP32[$3 + 40 >> 2];
   $5 = $2;
   $1 = HEAP32[$3 + 44 >> 2];
   $0 = $1;
   $1 = HEAP32[$3 + 32 >> 2];
   $6 = $1;
   $2 = HEAP32[$3 + 36 >> 2];
   $1 = $2;
   $2 = $0;
   $1 = $1 | $2;
   $4 = $1;
   $0 = $5;
   $6 = $0 | $6;
   $2 = $8;
   $1 = $7;
   $0 = $4;
   $0 = $1 & $0;
   $4 = $0;
   $1 = $10;
   $6 = $6 & $2;
   $11 = $1 | $6;
   $0 = $9;
   $2 = $4;
   $2 = $0 | $2;
   $8 = $2;
   $2 = HEAP32[$3 + 40 >> 2];
   $0 = $2;
   $5 = $0 << 25;
   $1 = HEAP32[$3 + 44 >> 2];
   $2 = $1 << 25 | $0 >>> 7;
   $4 = $2;
   $2 = HEAP32[$3 + 40 >> 2];
   $0 = HEAP32[$3 + 44 >> 2];
   $6 = $0 >>> 7 | 0;
   $0 = $5;
   $10 = $0 | $6;
   $2 = 0;
   $1 = $2;
   $2 = $4;
   $1 = $1 | $2;
   $7 = $1;
   $1 = HEAP32[$3 + 40 >> 2];
   $1 = $1 << 4;
   $5 = $1;
   $1 = HEAP32[$3 + 40 >> 2];
   $0 = $1;
   $2 = HEAP32[$3 + 44 >> 2];
   $1 = $2 >>> 28 | 0;
   $4 = $1;
   $6 = ($2 & 268435455) << 4 | $0 >>> 28;
   $2 = 0;
   $9 = $6 | $2;
   $1 = $5;
   $0 = $4;
   $0 = $1 | $0;
   $4 = $0;
   $0 = HEAP32[$3 + 40 >> 2];
   $5 = $0 << 30;
   $2 = HEAP32[$3 + 44 >> 2];
   $0 = $2 << 30 | $0 >>> 2;
   $2 = $0;
   $0 = HEAP32[$3 + 40 >> 2];
   $1 = HEAP32[$3 + 44 >> 2];
   $6 = $1 >>> 2 | 0;
   $0 = $2;
   $2 = $16;
   $2 = $0 | $2;
   $0 = $9;
   $1 = $5;
   $6 = $1 | $6;
   $6 = $0 ^ $6;
   $1 = $2;
   $2 = $4;
   $1 = $1 ^ $2;
   $0 = $1;
   $1 = $7;
   $0 = $1 ^ $0;
   $4 = $0;
   $1 = $11;
   $2 = $10;
   $6 = $6 ^ $2;
   $5 = $1 + $6 | 0;
   $0 = $8;
   $2 = $4;
   $4 = $0 + $2 | 0;
   HEAP32[$3 + 704 >> 2] = $5;
   $4 = $5 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   HEAP32[$3 + 708 >> 2] = $4;
   $1 = HEAP32[$3 + 716 >> 2];
   $5 = $1;
   $4 = HEAP32[$3 + 712 >> 2];
   $0 = $4;
   $1 = HEAP32[$3 + 16 >> 2];
   $6 = $1;
   $2 = $0 + $1 | 0;
   $4 = HEAP32[$3 + 20 >> 2];
   $1 = $4;
   $4 = $5;
   $5 = $1 + $4 | 0;
   HEAP32[$3 + 16 >> 2] = $2;
   $5 = $2 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   HEAP32[$3 + 20 >> 2] = $5;
   $5 = HEAP32[$3 + 712 >> 2];
   $4 = $5;
   $0 = HEAP32[$3 + 716 >> 2];
   $1 = $0;
   $0 = HEAP32[$3 + 704 >> 2];
   $6 = $0;
   $5 = HEAP32[$3 + 708 >> 2];
   $0 = $5;
   $5 = $1;
   $2 = $0 + $5 | 0;
   $1 = $4 + $6 | 0;
   $2 = $1 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$3 + 48 >> 2] = $1;
   HEAP32[$3 + 52 >> 2] = $2;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   $5 = ($3 - -64 | 0) + (HEAP32[$3 + 724 >> 2] << 3) | 0;
   $2 = HEAP32[$5 >> 2];
   $14 = $2;
   $4 = HEAP32[$5 + 4 >> 2];
   $15 = $4;
   $5 = (HEAP32[$3 + 724 >> 2] << 3) + 173696 | 0;
   $4 = HEAP32[$5 >> 2];
   $13 = $4;
   $2 = HEAP32[$5 + 4 >> 2];
   $12 = $2;
   $2 = HEAP32[$3 + 56 >> 2];
   $9 = $2;
   $4 = HEAP32[$3 + 60 >> 2];
   $8 = $4;
   $4 = HEAP32[$3 + 16 >> 2];
   $1 = $4 << 23;
   $2 = HEAP32[$3 + 20 >> 2];
   $4 = $2 << 23 | $4 >>> 9;
   $0 = $4;
   $4 = HEAP32[$3 + 16 >> 2];
   $5 = HEAP32[$3 + 20 >> 2];
   $6 = $5 >>> 9 | 0;
   $5 = $1;
   $11 = $6 | $5;
   $4 = $0;
   $2 = $16;
   $2 = $4 | $2;
   $7 = $2;
   $2 = HEAP32[$3 + 16 >> 2];
   $2 = $2 << 18;
   $0 = $2;
   $2 = HEAP32[$3 + 16 >> 2];
   $5 = $2;
   $4 = HEAP32[$3 + 20 >> 2];
   $2 = $4 >>> 14 | 0;
   $6 = ($4 & 16383) << 18 | $5 >>> 14;
   $5 = $2;
   $4 = 0;
   $10 = $4 | $6;
   $2 = $0;
   $5 = $2 | $5;
   $1 = $5;
   $5 = HEAP32[$3 + 16 >> 2];
   $2 = $5;
   $5 = $2 << 14;
   $0 = $5;
   $5 = HEAP32[$3 + 16 >> 2];
   $4 = $5;
   $2 = HEAP32[$3 + 20 >> 2];
   $5 = $2 >>> 18 | 0;
   $6 = ($2 & 262143) << 14 | $4 >>> 18;
   $4 = $5;
   $5 = $0;
   $4 = $4 | $5;
   $0 = $4;
   $2 = 0;
   $6 = $6 | $2;
   $5 = $10;
   $6 = $6 ^ $5;
   $4 = $1;
   $2 = $0;
   $2 = $4 ^ $2;
   $5 = $2;
   $2 = $7;
   $5 = $2 ^ $5;
   $4 = $11;
   $6 = $4 ^ $6;
   $2 = $9;
   $0 = $6 + $2 | 0;
   $4 = $5;
   $5 = $8;
   $1 = $4 + $5 | 0;
   $1 = $0 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   $11 = $1;
   $1 = HEAP32[$3 >> 2];
   $10 = $1;
   $2 = HEAP32[$3 + 4 >> 2];
   $9 = $2;
   $2 = HEAP32[$3 + 16 >> 2];
   $8 = $2;
   $1 = HEAP32[$3 + 20 >> 2];
   $7 = $1;
   $1 = HEAP32[$3 + 8 >> 2];
   $5 = $1;
   $2 = HEAP32[$3 + 12 >> 2];
   $4 = $2;
   $2 = HEAP32[$3 >> 2];
   $6 = $2;
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = $1;
   $1 = $4;
   $2 = $1 ^ $2;
   $4 = $2;
   $1 = $8;
   $6 = $6 ^ $5;
   $6 = $1 & $6;
   $2 = $7;
   $5 = $4;
   $5 = $2 & $5;
   $1 = $5;
   $5 = $9;
   $1 = $1 ^ $5;
   $5 = $1;
   $2 = $10;
   $6 = $6 ^ $2;
   $4 = $6 + $0 | 0;
   $1 = $11;
   $2 = $5;
   $0 = $1 + $2 | 0;
   $0 = $4 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
   $5 = $0;
   $6 = $4;
   $1 = $13;
   $2 = $4 + $1 | 0;
   $0 = $12;
   $4 = $0 + $5 | 0;
   $4 = $2 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   $6 = $2;
   $0 = $14;
   $5 = $2 + $0 | 0;
   $1 = $4;
   $4 = $15;
   $2 = $1 + $4 | 0;
   HEAP32[$3 + 712 >> 2] = $5;
   $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$3 + 716 >> 2] = $2;
   $0 = HEAP32[$3 + 52 >> 2];
   $1 = $0;
   $2 = HEAP32[$3 + 48 >> 2];
   $0 = HEAP32[$3 + 40 >> 2];
   $9 = $2 & $0;
   $2 = HEAP32[$3 + 44 >> 2];
   $0 = $2;
   $2 = $1;
   $0 = $0 & $2;
   $8 = $0;
   $0 = HEAP32[$3 + 32 >> 2];
   $7 = $0;
   $4 = HEAP32[$3 + 36 >> 2];
   $5 = $4;
   $4 = HEAP32[$3 + 48 >> 2];
   $2 = $4;
   $0 = HEAP32[$3 + 52 >> 2];
   $1 = $0;
   $0 = HEAP32[$3 + 40 >> 2];
   $6 = $0;
   $4 = HEAP32[$3 + 44 >> 2];
   $0 = $4;
   $4 = $1;
   $0 = $0 | $4;
   $1 = $0;
   $4 = $7;
   $6 = $6 | $2;
   $0 = $5;
   $2 = $1;
   $2 = $0 & $2;
   $0 = $9;
   $6 = $4 & $6;
   $12 = $0 | $6;
   $4 = $2;
   $2 = $8;
   $4 = $4 | $2;
   $8 = $4;
   $4 = HEAP32[$3 + 48 >> 2];
   $2 = $4;
   $5 = $2 << 25;
   $0 = HEAP32[$3 + 52 >> 2];
   $4 = $0 << 25 | $2 >>> 7;
   $1 = $4;
   $4 = HEAP32[$3 + 48 >> 2];
   $2 = HEAP32[$3 + 52 >> 2];
   $6 = $2 >>> 7 | 0;
   $2 = $5;
   $11 = $6 | $2;
   $4 = 0;
   $0 = $4;
   $4 = $1;
   $0 = $0 | $4;
   $7 = $0;
   $0 = HEAP32[$3 + 48 >> 2];
   $0 = $0 << 4;
   $1 = $0;
   $0 = HEAP32[$3 + 48 >> 2];
   $2 = $0;
   $4 = HEAP32[$3 + 52 >> 2];
   $0 = $4 >>> 28 | 0;
   $6 = ($4 & 268435455) << 4 | $2 >>> 28;
   $2 = $0;
   $4 = 0;
   $10 = $4 | $6;
   $0 = $1;
   $2 = $0 | $2;
   $5 = $2;
   $2 = HEAP32[$3 + 48 >> 2];
   $0 = $2;
   $9 = $0 << 30;
   $4 = HEAP32[$3 + 52 >> 2];
   $2 = $4 << 30 | $0 >>> 2;
   $1 = $2;
   $2 = HEAP32[$3 + 48 >> 2];
   $0 = HEAP32[$3 + 52 >> 2];
   $6 = $0 >>> 2 | 0;
   $2 = 0;
   $4 = $2;
   $2 = $1;
   $4 = $4 | $2;
   $0 = $9;
   $6 = $0 | $6;
   $2 = $10;
   $6 = $6 ^ $2;
   $0 = $4;
   $4 = $5;
   $0 = $0 ^ $4;
   $2 = $0;
   $0 = $7;
   $2 = $0 ^ $2;
   $0 = $12;
   $4 = $11;
   $6 = $4 ^ $6;
   $1 = $0 + $6 | 0;
   $4 = $2;
   $2 = $8;
   $5 = $4 + $2 | 0;
   HEAP32[$3 + 704 >> 2] = $1;
   $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   HEAP32[$3 + 708 >> 2] = $5;
   $0 = HEAP32[$3 + 716 >> 2];
   $1 = $0;
   $0 = HEAP32[$3 + 24 >> 2];
   $6 = $0;
   $5 = HEAP32[$3 + 712 >> 2];
   $2 = $5;
   $4 = $0 + $2 | 0;
   $5 = HEAP32[$3 + 28 >> 2];
   $0 = $5;
   $5 = $1;
   $1 = $0 + $5 | 0;
   HEAP32[$3 + 24 >> 2] = $4;
   $1 = $4 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   HEAP32[$3 + 28 >> 2] = $1;
   $1 = HEAP32[$3 + 712 >> 2];
   $5 = $1;
   $2 = HEAP32[$3 + 716 >> 2];
   $7 = $2;
   $1 = HEAP32[$3 + 708 >> 2];
   $4 = $1;
   $2 = HEAP32[$3 + 704 >> 2];
   $6 = $2;
   $0 = $2 + $5 | 0;
   $1 = $7;
   $2 = $4;
   $4 = $1 + $2 | 0;
   HEAP32[$3 + 56 >> 2] = $0;
   $4 = $0 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
   HEAP32[$3 + 60 >> 2] = $4;
   HEAP32[$3 + 724 >> 2] = HEAP32[$3 + 724 >> 2] + 1;
   if (HEAP32[$3 + 724 >> 2] < 80) {
    continue
   }
   break;
  };
  $8 = HEAP32[$3 + 732 >> 2];
  $4 = HEAP32[$3 + 56 >> 2];
  $2 = $4;
  $5 = HEAP32[$3 + 60 >> 2];
  $7 = $5;
  $1 = $8;
  $5 = HEAP32[$1 + 16 >> 2];
  $4 = HEAP32[$1 + 20 >> 2];
  $0 = $4;
  $1 = $2;
  $6 = $5;
  $2 = $1 + $5 | 0;
  $4 = $7;
  $5 = $0;
  $0 = $4 + $5 | 0;
  $1 = $8;
  HEAP32[$1 + 16 >> 2] = $2;
  $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$1 + 20 >> 2] = $0;
  $7 = HEAP32[$3 + 732 >> 2];
  $0 = HEAP32[$3 + 48 >> 2];
  $5 = $0;
  $1 = HEAP32[$3 + 52 >> 2];
  $2 = $1;
  $4 = $7;
  $1 = HEAP32[$4 + 24 >> 2];
  $0 = HEAP32[$4 + 28 >> 2];
  $4 = $5;
  $6 = $1;
  $5 = $4 + $1 | 0;
  $1 = $0;
  $0 = $2;
  $2 = $1 + $0 | 0;
  $4 = $7;
  HEAP32[$4 + 24 >> 2] = $5;
  $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 28 >> 2] = $2;
  $8 = HEAP32[$3 + 732 >> 2];
  $2 = HEAP32[$3 + 40 >> 2];
  $7 = $2;
  $4 = HEAP32[$3 + 44 >> 2];
  $1 = $4;
  $0 = $8;
  $4 = HEAP32[$0 + 32 >> 2];
  $6 = $4;
  $2 = HEAP32[$0 + 36 >> 2];
  $4 = $2;
  $2 = $1;
  $5 = $4 + $2 | 0;
  $0 = $7;
  $1 = $0 + $6 | 0;
  $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $0 = $8;
  HEAP32[$0 + 32 >> 2] = $1;
  HEAP32[$0 + 36 >> 2] = $5;
  $7 = HEAP32[$3 + 732 >> 2];
  $5 = HEAP32[$3 + 32 >> 2];
  $4 = $5;
  $0 = HEAP32[$3 + 36 >> 2];
  $1 = $0;
  $2 = $7;
  $0 = HEAP32[$2 + 40 >> 2];
  $6 = $0;
  $5 = HEAP32[$2 + 44 >> 2];
  $0 = $5;
  $5 = $1;
  $1 = $0 + $5 | 0;
  $2 = $4;
  $4 = $6 + $2 | 0;
  $1 = $4 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  $2 = $7;
  HEAP32[$2 + 40 >> 2] = $4;
  HEAP32[$2 + 44 >> 2] = $1;
  $8 = HEAP32[$3 + 732 >> 2];
  $1 = HEAP32[$3 + 24 >> 2];
  $7 = $1;
  $2 = HEAP32[$3 + 28 >> 2];
  $0 = $2;
  $5 = $8;
  $2 = HEAP32[$5 + 48 >> 2];
  $6 = $2;
  $1 = HEAP32[$5 + 52 >> 2];
  $2 = $1;
  $1 = $0;
  $4 = $1 + $2 | 0;
  $5 = $7;
  $0 = $6 + $5 | 0;
  $4 = $0 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
  $5 = $8;
  HEAP32[$5 + 48 >> 2] = $0;
  HEAP32[$5 + 52 >> 2] = $4;
  $8 = HEAP32[$3 + 732 >> 2];
  $4 = HEAP32[$3 + 16 >> 2];
  $2 = $4;
  $5 = HEAP32[$3 + 20 >> 2];
  $7 = $5;
  $1 = $8;
  $5 = HEAP32[$1 + 56 >> 2];
  $4 = HEAP32[$1 + 60 >> 2];
  $0 = $4;
  $1 = $2;
  $6 = $5;
  $2 = $1 + $5 | 0;
  $4 = $7;
  $5 = $0;
  $0 = $4 + $5 | 0;
  $1 = $8;
  HEAP32[$1 + 56 >> 2] = $2;
  $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$1 + 60 >> 2] = $0;
  $7 = HEAP32[$3 + 732 >> 2];
  $0 = HEAP32[$3 + 8 >> 2];
  $5 = $0;
  $1 = HEAP32[$3 + 12 >> 2];
  $2 = $1;
  $4 = $7;
  $1 = HEAP32[$4 + 64 >> 2];
  $0 = HEAP32[$4 + 68 >> 2];
  $4 = $5;
  $6 = $1;
  $5 = $4 + $1 | 0;
  $1 = $0;
  $0 = $2;
  $2 = $1 + $0 | 0;
  $4 = $7;
  HEAP32[$4 + 64 >> 2] = $5;
  $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 68 >> 2] = $2;
  $8 = HEAP32[$3 + 732 >> 2];
  $2 = HEAP32[$3 >> 2];
  $7 = $2;
  $4 = HEAP32[$3 + 4 >> 2];
  $1 = $4;
  $0 = $8;
  $4 = HEAP32[$0 + 72 >> 2];
  $6 = $4;
  $2 = HEAP32[$0 + 76 >> 2];
  $4 = $2;
  $2 = $1;
  $5 = $4 + $2 | 0;
  $0 = $7;
  $1 = $0 + $6 | 0;
  $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $0 = $8;
  HEAP32[$0 + 72 >> 2] = $1;
  HEAP32[$0 + 76 >> 2] = $5;
  __stack_pointer = $3 + 736 | 0;
 }
 
 function mbedtls_sha512_update($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (!HEAP32[$3 + 20 >> 2]) {
    break block
   }
   $2 = HEAP32[$3 + 28 >> 2];
   $0 = HEAP32[$2 >> 2];
   $2 = $0;
   HEAP32[$3 + 12 >> 2] = $2 & 127;
   HEAP32[$3 + 16 >> 2] = 128 - HEAP32[$3 + 12 >> 2];
   $4 = HEAP32[$3 + 28 >> 2];
   $0 = HEAP32[$3 + 20 >> 2];
   $1 = $0;
   $0 = $4;
   $2 = HEAP32[$0 >> 2];
   $0 = HEAP32[$0 + 4 >> 2];
   $6 = $0;
   $0 = $1;
   $1 = $2;
   $5 = $0 + $2 | 0;
   $2 = $6;
   $0 = $4;
   HEAP32[$0 >> 2] = $5;
   $2 = $1 >>> 0 > $5 >>> 0 ? $2 + 1 | 0 : $2;
   HEAP32[$0 + 4 >> 2] = $2;
   $0 = HEAP32[$3 + 28 >> 2];
   $2 = HEAP32[$0 >> 2];
   $1 = $2;
   $0 = HEAP32[$0 + 4 >> 2];
   $2 = $0;
   $0 = HEAP32[$3 + 20 >> 2];
   $4 = $0;
   $0 = $1;
   $1 = $4;
   if (!$2 & $0 >>> 0 < $1 >>> 0) {
    $4 = HEAP32[$3 + 28 >> 2];
    $1 = $4;
    $0 = HEAP32[$1 + 8 >> 2];
    $2 = HEAP32[$1 + 12 >> 2];
    $1 = $0;
    $5 = $2;
    $2 = $1 + 1 | 0;
    $5 = $2 ? $5 : $5 + 1 | 0;
    $1 = $4;
    HEAP32[$1 + 8 >> 2] = $2;
    HEAP32[$1 + 12 >> 2] = $5;
   }
   if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
    $1 = HEAP32[$3 + 28 >> 2];
    $2 = HEAP32[$3 + 12 >> 2];
    $4 = HEAP32[$3 + 24 >> 2];
    $0 = HEAP32[$3 + 16 >> 2];
    if ($0) {
     wasm2js_memory_copy(($1 + 80 | 0) + $2 | 0, $4, $0)
    }
    mbedtls_sha512_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 80 | 0);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
    HEAP32[$3 + 12 >> 2] = 0;
   }
   while (1) {
    if (HEAPU32[$3 + 20 >> 2] >= 128) {
     mbedtls_sha512_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 128;
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - 128;
     continue;
    }
    break;
   };
   if (!HEAP32[$3 + 20 >> 2]) {
    break block
   }
   $1 = HEAP32[$3 + 28 >> 2];
   $2 = HEAP32[$3 + 12 >> 2];
   $4 = HEAP32[$3 + 24 >> 2];
   $0 = HEAP32[$3 + 20 >> 2];
   if ($0) {
    wasm2js_memory_copy(($1 + 80 | 0) + $2 | 0, $4, $0)
   }
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function mbedtls_sha512_finish($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 8 >> 2];
  $2 = HEAP32[$1 + 12 >> 2];
  $4 = $0 << 3;
  $0 = $2 << 3 | $0 >>> 29;
  $5 = $0;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  $0 = $1 >>> 29 | 0;
  $1 = $4;
  $0 = $0 | $1;
  HEAP32[$3 + 24 >> 2] = $0;
  $0 = $5;
  $2 = $6;
  $2 = $0 | $2;
  HEAP32[$3 + 28 >> 2] = $2;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 >> 2];
  $1 = HEAP32[$0 + 4 >> 2];
  $0 = $2;
  $2 = $1 << 3 | $2 >>> 29;
  $0 = $0 << 3;
  HEAP32[$3 + 16 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $2;
  $2 = HEAP32[$3 + 24 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 | 0] = $0 >>> 24;
  $2 = HEAP32[$3 + 24 >> 2];
  $1 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 + 1 | 0] = $1 >>> 16;
  $2 = HEAP32[$3 + 24 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 + 2 | 0] = $0 >>> 8;
  $2 = HEAP32[$3 + 24 >> 2];
  $1 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 + 3 | 0] = $1;
  $2 = HEAP32[$3 + 24 >> 2];
  $1 = $2;
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 + 4 | 0] = ($0 & 16777215) << 8 | $1 >>> 24;
  $2 = HEAP32[$3 + 24 >> 2];
  $0 = $2;
  $1 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 + 5 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
  $2 = HEAP32[$3 + 24 >> 2];
  $1 = $2;
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP8[$3 + 6 | 0] = ($0 & 255) << 24 | $1 >>> 8;
  $2 = HEAP32[$3 + 24 >> 2];
  HEAP8[$3 + 7 | 0] = $2;
  $1 = HEAP32[$3 + 16 >> 2];
  $2 = HEAP32[$3 + 20 >> 2];
  HEAP8[$3 + 8 | 0] = $2 >>> 24;
  $1 = HEAP32[$3 + 16 >> 2];
  $0 = HEAP32[$3 + 20 >> 2];
  HEAP8[$3 + 9 | 0] = $0 >>> 16;
  $1 = HEAP32[$3 + 16 >> 2];
  $2 = HEAP32[$3 + 20 >> 2];
  HEAP8[$3 + 10 | 0] = $2 >>> 8;
  $1 = HEAP32[$3 + 16 >> 2];
  $0 = HEAP32[$3 + 20 >> 2];
  HEAP8[$3 + 11 | 0] = $0;
  $1 = HEAP32[$3 + 16 >> 2];
  $0 = $1;
  $2 = HEAP32[$3 + 20 >> 2];
  HEAP8[$3 + 12 | 0] = ($2 & 16777215) << 8 | $0 >>> 24;
  $1 = HEAP32[$3 + 16 >> 2];
  $2 = $1;
  $0 = HEAP32[$3 + 20 >> 2];
  HEAP8[$3 + 13 | 0] = ($0 & 65535) << 16 | $2 >>> 16;
  $1 = HEAP32[$3 + 16 >> 2];
  $0 = $1;
  $2 = HEAP32[$3 + 20 >> 2];
  HEAP8[$3 + 14 | 0] = ($2 & 255) << 24 | $0 >>> 8;
  $1 = HEAP32[$3 + 16 >> 2];
  HEAP8[$3 + 15 | 0] = $1;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 >> 2];
  $2 = $0;
  HEAP32[$3 + 36 >> 2] = $2 & 127;
  if (HEAPU32[$3 + 36 >> 2] < 112) {
   $0 = 112 - HEAP32[$3 + 36 >> 2] | 0
  } else {
   $0 = 240 - HEAP32[$3 + 36 >> 2] | 0
  }
  HEAP32[$3 + 32 >> 2] = $0;
  mbedtls_sha512_update(HEAP32[$3 + 44 >> 2], 174336, HEAP32[$3 + 32 >> 2]);
  mbedtls_sha512_update(HEAP32[$3 + 44 >> 2], $3, 16);
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2]] = $2 >>> 24;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 16 >> 2];
  $1 = HEAP32[$2 + 20 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 1 | 0] = $1 >>> 16;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 2 | 0] = $2 >>> 8;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 16 >> 2];
  $1 = HEAP32[$2 + 20 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 3 | 0] = $1;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  $1 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 4 | 0] = ($2 & 16777215) << 8 | $1 >>> 24;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 16 >> 2];
  $1 = HEAP32[$2 + 20 >> 2];
  $2 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 5 | 0] = ($1 & 65535) << 16 | $2 >>> 16;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  $1 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 6 | 0] = ($2 & 255) << 24 | $1 >>> 8;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 16 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 7 | 0] = $0;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 24 >> 2];
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 8 | 0] = $0 >>> 24;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$0 + 28 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 9 | 0] = $2 >>> 16;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 24 >> 2];
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 10 | 0] = $0 >>> 8;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$0 + 28 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 11 | 0] = $2;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 24 >> 2];
  $0 = HEAP32[$2 + 28 >> 2];
  $2 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = ($0 & 16777215) << 8 | $2 >>> 24;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$0 + 28 >> 2];
  $0 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 13 | 0] = ($2 & 65535) << 16 | $0 >>> 16;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 24 >> 2];
  $0 = HEAP32[$2 + 28 >> 2];
  $2 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 14 | 0] = ($0 & 255) << 24 | $2 >>> 8;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 24 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 15 | 0] = $1;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 32 >> 2];
  $1 = HEAP32[$0 + 36 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 16 | 0] = $1 >>> 24;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 32 >> 2];
  $0 = HEAP32[$1 + 36 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 17 | 0] = $0 >>> 16;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 32 >> 2];
  $1 = HEAP32[$0 + 36 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 18 | 0] = $1 >>> 8;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 32 >> 2];
  $0 = HEAP32[$1 + 36 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 19 | 0] = $0;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 32 >> 2];
  $1 = HEAP32[$0 + 36 >> 2];
  $0 = $2;
  HEAP8[HEAP32[$3 + 40 >> 2] + 20 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 32 >> 2];
  $0 = HEAP32[$1 + 36 >> 2];
  $1 = $2;
  HEAP8[HEAP32[$3 + 40 >> 2] + 21 | 0] = ($0 & 65535) << 16 | $1 >>> 16;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 32 >> 2];
  $1 = HEAP32[$0 + 36 >> 2];
  $0 = $2;
  HEAP8[HEAP32[$3 + 40 >> 2] + 22 | 0] = ($1 & 255) << 24 | $0 >>> 8;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 32 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 23 | 0] = $2;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 40 >> 2];
  $2 = HEAP32[$1 + 44 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 24 | 0] = $2 >>> 24;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = HEAP32[$2 + 44 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 25 | 0] = $1 >>> 16;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 40 >> 2];
  $2 = HEAP32[$1 + 44 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 26 | 0] = $2 >>> 8;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = HEAP32[$2 + 44 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 27 | 0] = $1;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 40 >> 2];
  $2 = HEAP32[$1 + 44 >> 2];
  $1 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 28 | 0] = ($2 & 16777215) << 8 | $1 >>> 24;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = HEAP32[$2 + 44 >> 2];
  $2 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 29 | 0] = ($1 & 65535) << 16 | $2 >>> 16;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 40 >> 2];
  $2 = HEAP32[$1 + 44 >> 2];
  $1 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 30 | 0] = ($2 & 255) << 24 | $1 >>> 8;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 40 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 31 | 0] = $0;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 48 >> 2];
  $0 = HEAP32[$2 + 52 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 32 | 0] = $0 >>> 24;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 48 >> 2];
  $2 = HEAP32[$0 + 52 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 33 | 0] = $2 >>> 16;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 48 >> 2];
  $0 = HEAP32[$2 + 52 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 34 | 0] = $0 >>> 8;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 48 >> 2];
  $2 = HEAP32[$0 + 52 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 35 | 0] = $2;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 48 >> 2];
  $0 = HEAP32[$2 + 52 >> 2];
  $2 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 36 | 0] = ($0 & 16777215) << 8 | $2 >>> 24;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 48 >> 2];
  $2 = HEAP32[$0 + 52 >> 2];
  $0 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 37 | 0] = ($2 & 65535) << 16 | $0 >>> 16;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 48 >> 2];
  $0 = HEAP32[$2 + 52 >> 2];
  $2 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 38 | 0] = ($0 & 255) << 24 | $2 >>> 8;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 48 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 39 | 0] = $1;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 56 >> 2];
  $1 = HEAP32[$0 + 60 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 40 | 0] = $1 >>> 24;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 56 >> 2];
  $0 = HEAP32[$1 + 60 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 41 | 0] = $0 >>> 16;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 56 >> 2];
  $1 = HEAP32[$0 + 60 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 42 | 0] = $1 >>> 8;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 56 >> 2];
  $0 = HEAP32[$1 + 60 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 43 | 0] = $0;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 56 >> 2];
  $1 = HEAP32[$0 + 60 >> 2];
  $0 = $2;
  HEAP8[HEAP32[$3 + 40 >> 2] + 44 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 56 >> 2];
  $0 = HEAP32[$1 + 60 >> 2];
  $1 = $2;
  HEAP8[HEAP32[$3 + 40 >> 2] + 45 | 0] = ($0 & 65535) << 16 | $1 >>> 16;
  $0 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$0 + 56 >> 2];
  $1 = HEAP32[$0 + 60 >> 2];
  $0 = $2;
  HEAP8[HEAP32[$3 + 40 >> 2] + 46 | 0] = ($1 & 255) << 24 | $0 >>> 8;
  $1 = HEAP32[$3 + 44 >> 2];
  $2 = HEAP32[$1 + 56 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 47 | 0] = $2;
  if (!HEAP32[HEAP32[$3 + 44 >> 2] + 208 >> 2]) {
   $1 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$1 + 64 >> 2];
   $2 = HEAP32[$1 + 68 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 48 | 0] = $2 >>> 24;
   $2 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$2 + 64 >> 2];
   $1 = HEAP32[$2 + 68 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 49 | 0] = $1 >>> 16;
   $1 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$1 + 64 >> 2];
   $2 = HEAP32[$1 + 68 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 50 | 0] = $2 >>> 8;
   $2 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$2 + 64 >> 2];
   $1 = HEAP32[$2 + 68 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 51 | 0] = $1;
   $1 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$1 + 64 >> 2];
   $2 = HEAP32[$1 + 68 >> 2];
   $1 = $0;
   HEAP8[HEAP32[$3 + 40 >> 2] + 52 | 0] = ($2 & 16777215) << 8 | $1 >>> 24;
   $2 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$2 + 64 >> 2];
   $1 = HEAP32[$2 + 68 >> 2];
   $2 = $0;
   HEAP8[HEAP32[$3 + 40 >> 2] + 53 | 0] = ($1 & 65535) << 16 | $2 >>> 16;
   $1 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$1 + 64 >> 2];
   $2 = HEAP32[$1 + 68 >> 2];
   $1 = $0;
   HEAP8[HEAP32[$3 + 40 >> 2] + 54 | 0] = ($2 & 255) << 24 | $1 >>> 8;
   $2 = HEAP32[$3 + 44 >> 2];
   $0 = HEAP32[$2 + 64 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 55 | 0] = $0;
   $2 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$2 + 72 >> 2];
   $0 = HEAP32[$2 + 76 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 56 | 0] = $0 >>> 24;
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$0 + 72 >> 2];
   $2 = HEAP32[$0 + 76 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 57 | 0] = $2 >>> 16;
   $2 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$2 + 72 >> 2];
   $0 = HEAP32[$2 + 76 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 58 | 0] = $0 >>> 8;
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$0 + 72 >> 2];
   $2 = HEAP32[$0 + 76 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 59 | 0] = $2;
   $2 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$2 + 72 >> 2];
   $0 = HEAP32[$2 + 76 >> 2];
   $2 = $1;
   HEAP8[HEAP32[$3 + 40 >> 2] + 60 | 0] = ($0 & 16777215) << 8 | $2 >>> 24;
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$0 + 72 >> 2];
   $2 = HEAP32[$0 + 76 >> 2];
   $0 = $1;
   HEAP8[HEAP32[$3 + 40 >> 2] + 61 | 0] = ($2 & 65535) << 16 | $0 >>> 16;
   $2 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$2 + 72 >> 2];
   $0 = HEAP32[$2 + 76 >> 2];
   $2 = $1;
   HEAP8[HEAP32[$3 + 40 >> 2] + 62 | 0] = ($0 & 255) << 24 | $2 >>> 8;
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$0 + 72 >> 2];
   HEAP8[HEAP32[$3 + 40 >> 2] + 63 | 0] = $1;
  }
  __stack_pointer = $3 + 48 | 0;
 }
 
 function mbedtls_sha512($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 240 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 236 >> 2] = $0;
  HEAP32[$4 + 232 >> 2] = $1;
  HEAP32[$4 + 228 >> 2] = $2;
  HEAP32[$4 + 224 >> 2] = $3;
  mbedtls_sha512_init($4 + 8 | 0);
  mbedtls_sha512_starts($4 + 8 | 0, HEAP32[$4 + 224 >> 2]);
  mbedtls_sha512_update($4 + 8 | 0, HEAP32[$4 + 236 >> 2], HEAP32[$4 + 232 >> 2]);
  mbedtls_sha512_finish($4 + 8 | 0, HEAP32[$4 + 228 >> 2]);
  mbedtls_sha512_free($4 + 8 | 0);
  __stack_pointer = $4 + 240 | 0;
 }
 
 function mbedtls_ccm_init($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP32[$0 + 48 >> 2] = 0;
  HEAP32[$0 + 52 >> 2] = 0;
  HEAP32[$0 + 40 >> 2] = 0;
  HEAP32[$0 + 44 >> 2] = 0;
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 36 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
 }
 
 function mbedtls_ccm_setkey($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 4 >> 2] = mbedtls_cipher_info_from_values(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 12 >> 2], 1);
  block : {
   if (!HEAP32[$4 + 4 >> 2]) {
    HEAP32[$4 + 28 >> 2] = -13;
    break block;
   }
   if (HEAP32[HEAP32[$4 + 4 >> 2] + 24 >> 2] != 16) {
    HEAP32[$4 + 28 >> 2] = -13;
    break block;
   }
   mbedtls_cipher_free(HEAP32[$4 + 24 >> 2]);
   $0 = mbedtls_cipher_setup(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 4 >> 2]);
   HEAP32[$4 + 8 >> 2] = $0;
   if ($0) {
    HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 8 >> 2];
    break block;
   }
   $0 = mbedtls_cipher_setkey(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2], 1);
   HEAP32[$4 + 8 >> 2] = $0;
   if ($0) {
    HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 8 >> 2];
    break block;
   }
   HEAP32[$4 + 28 >> 2] = 0;
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 28 >> 2];
 }
 
 function mbedtls_ccm_free($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  mbedtls_cipher_free(HEAP32[$1 + 12 >> 2]);
  mbedtls_zeroize_1208(HEAP32[$1 + 12 >> 2], 56);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function mbedtls_zeroize_1208($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  while (1) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 - 1;
   if ($0) {
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$2 + 4 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 0;
    continue;
   }
   break;
  };
 }
 
 function mbedtls_ccm_encrypt_and_tag($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
  var $10 = 0;
  $10 = __stack_pointer - 48 | 0;
  __stack_pointer = $10;
  HEAP32[$10 + 44 >> 2] = $0;
  HEAP32[$10 + 40 >> 2] = $1;
  HEAP32[$10 + 36 >> 2] = $2;
  HEAP32[$10 + 32 >> 2] = $3;
  HEAP32[$10 + 28 >> 2] = $4;
  HEAP32[$10 + 24 >> 2] = $5;
  HEAP32[$10 + 20 >> 2] = $6;
  HEAP32[$10 + 16 >> 2] = $7;
  HEAP32[$10 + 12 >> 2] = $8;
  HEAP32[$10 + 8 >> 2] = $9;
  $0 = ccm_auth_crypt(HEAP32[$10 + 44 >> 2], 0, HEAP32[$10 + 40 >> 2], HEAP32[$10 + 36 >> 2], HEAP32[$10 + 32 >> 2], HEAP32[$10 + 28 >> 2], HEAP32[$10 + 24 >> 2], HEAP32[$10 + 20 >> 2], HEAP32[$10 + 16 >> 2], HEAP32[$10 + 12 >> 2], HEAP32[$10 + 8 >> 2]);
  __stack_pointer = $10 + 48 | 0;
  return $0;
 }
 
 function ccm_auth_crypt($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
  var $11 = 0;
  $11 = __stack_pointer - 128 | 0;
  __stack_pointer = $11;
  HEAP32[$11 + 120 >> 2] = $0;
  HEAP32[$11 + 116 >> 2] = $1;
  HEAP32[$11 + 112 >> 2] = $2;
  HEAP32[$11 + 108 >> 2] = $3;
  HEAP32[$11 + 104 >> 2] = $4;
  HEAP32[$11 + 100 >> 2] = $5;
  HEAP32[$11 + 96 >> 2] = $6;
  HEAP32[$11 + 92 >> 2] = $7;
  HEAP32[$11 + 88 >> 2] = $8;
  HEAP32[$11 + 84 >> 2] = $9;
  HEAP32[$11 + 80 >> 2] = $10;
  block2 : {
   if (HEAP32[$11 + 80 >> 2] & 1 | (HEAPU32[$11 + 80 >> 2] < 4 | HEAPU32[$11 + 80 >> 2] > 16)) {
    HEAP32[$11 + 124 >> 2] = -13;
    break block2;
   }
   if (!(HEAPU32[$11 + 104 >> 2] <= 13 & HEAPU32[$11 + 104 >> 2] >= 7)) {
    HEAP32[$11 + 124 >> 2] = -13;
    break block2;
   }
   if (HEAPU32[$11 + 96 >> 2] > 65280) {
    HEAP32[$11 + 124 >> 2] = -13;
    break block2;
   }
   HEAP8[$11 + 74 | 0] = 15 - (HEAP32[$11 + 104 >> 2] & 255);
   HEAP8[$11 + 48 | 0] = 0;
   HEAP8[$11 + 48 | 0] = HEAPU8[$11 + 48 | 0] | (HEAP32[$11 + 96 >> 2] != 0) << 6;
   HEAP8[$11 + 48 | 0] = HEAPU8[$11 + 48 | 0] | HEAP32[$11 + 80 >> 2] - 2 >>> 1 << 3;
   HEAP8[$11 + 48 | 0] = HEAPU8[$11 + 48 | 0] | HEAPU8[$11 + 74 | 0] - 1;
   $1 = HEAP32[$11 + 108 >> 2];
   $0 = HEAP32[$11 + 104 >> 2];
   if ($0) {
    wasm2js_memory_copy($11 + 49 | 0, $1, $0)
   }
   HEAP8[$11 + 75 | 0] = 0;
   HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 112 >> 2];
   while (1) {
    if (HEAPU8[$11 + 75 | 0] < HEAPU8[$11 + 74 | 0]) {
     HEAP8[($11 - HEAPU8[$11 + 75 | 0] | 0) + 63 | 0] = HEAP32[$11 + 68 >> 2];
     HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
     HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] >>> 8;
     continue;
    }
    break;
   };
   if (HEAP32[$11 + 68 >> 2]) {
    HEAP32[$11 + 124 >> 2] = -13;
    break block2;
   }
   $0 = $11 + 32 | 0;
   HEAP32[$0 >> 2] = 0;
   HEAP32[$0 + 4 >> 2] = 0;
   HEAP32[$0 + 8 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = 0;
   HEAP8[$11 + 75 | 0] = 0;
   while (1) {
    if (HEAPU8[$11 + 75 | 0] < 16) {
     $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
     HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
     HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
     continue;
    }
    break;
   };
   $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
   HEAP32[$11 + 76 >> 2] = $0;
   if ($0) {
    HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
    break block2;
   }
   if (HEAP32[$11 + 96 >> 2]) {
    HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 96 >> 2];
    HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 100 >> 2];
    $0 = $11 + 48 | 0;
    HEAP32[$0 >> 2] = 0;
    HEAP32[$0 + 4 >> 2] = 0;
    HEAP32[$0 + 8 >> 2] = 0;
    HEAP32[$0 + 12 >> 2] = 0;
    HEAP8[$11 + 48 | 0] = HEAP32[$11 + 96 >> 2] >>> 8;
    HEAP8[$11 + 49 | 0] = HEAP32[$11 + 96 >> 2];
    if (HEAPU32[$11 + 68 >> 2] < 14) {
     $0 = HEAP32[$11 + 68 >> 2]
    } else {
     $0 = 14
    }
    HEAP32[$11 + 4 >> 2] = $0;
    $1 = HEAP32[$11 + 12 >> 2];
    $0 = HEAP32[$11 + 4 >> 2];
    if ($0) {
     wasm2js_memory_copy($11 + 50 | 0, $1, $0)
    }
    HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] - HEAP32[$11 + 4 >> 2];
    HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 4 >> 2] + HEAP32[$11 + 12 >> 2];
    HEAP8[$11 + 75 | 0] = 0;
    while (1) {
     if (HEAPU8[$11 + 75 | 0] < 16) {
      $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
      HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
      HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
      continue;
     }
     break;
    };
    $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
    HEAP32[$11 + 76 >> 2] = $0;
    if ($0) {
     HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
     break block2;
    }
    while (1) {
     if (HEAP32[$11 + 68 >> 2]) {
      HEAP32[$11 + 4 >> 2] = HEAPU32[$11 + 68 >> 2] > 16 ? 16 : HEAP32[$11 + 68 >> 2];
      $0 = $11 + 48 | 0;
      HEAP32[$0 >> 2] = 0;
      HEAP32[$0 + 4 >> 2] = 0;
      HEAP32[$0 + 8 >> 2] = 0;
      HEAP32[$0 + 12 >> 2] = 0;
      $1 = HEAP32[$11 + 12 >> 2];
      $0 = HEAP32[$11 + 4 >> 2];
      if ($0) {
       wasm2js_memory_copy($11 + 48 | 0, $1, $0)
      }
      HEAP8[$11 + 75 | 0] = 0;
      while (1) {
       if (HEAPU8[$11 + 75 | 0] < 16) {
        $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
        HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
        HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
        continue;
       }
       break;
      };
      $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
      HEAP32[$11 + 76 >> 2] = $0;
      if ($0) {
       HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
       break block2;
      } else {
       HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] - HEAP32[$11 + 4 >> 2];
       HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 4 >> 2] + HEAP32[$11 + 12 >> 2];
       continue;
      }
     }
     break;
    };
   }
   HEAP8[$11 + 16 | 0] = HEAPU8[$11 + 74 | 0] - 1;
   $1 = HEAP32[$11 + 108 >> 2];
   $0 = HEAP32[$11 + 104 >> 2];
   if ($0) {
    wasm2js_memory_copy($11 + 17 | 0, $1, $0)
   }
   $1 = HEAP32[$11 + 104 >> 2];
   $0 = HEAPU8[$11 + 74 | 0];
   if ($0) {
    wasm2js_memory_fill(($11 + 17 | 0) + $1 | 0, 0, $0)
   }
   HEAP8[$11 + 31 | 0] = 1;
   HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 112 >> 2];
   HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 92 >> 2];
   HEAP32[$11 + 8 >> 2] = HEAP32[$11 + 88 >> 2];
   while (1) {
    if (HEAP32[$11 + 68 >> 2]) {
     HEAP32[$11 >> 2] = HEAPU32[$11 + 68 >> 2] > 16 ? 16 : HEAP32[$11 + 68 >> 2];
     if (!HEAP32[$11 + 116 >> 2]) {
      $0 = $11 + 48 | 0;
      HEAP32[$0 >> 2] = 0;
      HEAP32[$0 + 4 >> 2] = 0;
      HEAP32[$0 + 8 >> 2] = 0;
      HEAP32[$0 + 12 >> 2] = 0;
      $1 = HEAP32[$11 + 12 >> 2];
      $0 = HEAP32[$11 >> 2];
      if ($0) {
       wasm2js_memory_copy($11 + 48 | 0, $1, $0)
      }
      HEAP8[$11 + 75 | 0] = 0;
      while (1) {
       if (HEAPU8[$11 + 75 | 0] < 16) {
        $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
        HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
        HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
        continue;
       }
       break;
      };
      $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
      HEAP32[$11 + 76 >> 2] = $0;
      if ($0) {
       HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
       break block2;
      }
     }
     $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 16 | 0, 16, $11 + 48 | 0, $11 - -64 | 0);
     HEAP32[$11 + 76 >> 2] = $0;
     if ($0) {
      HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
      break block2;
     }
     HEAP8[$11 + 75 | 0] = 0;
     while (1) {
      if (HEAPU8[$11 + 75 | 0] < HEAPU32[$11 >> 2]) {
       HEAP8[HEAP32[$11 + 8 >> 2] + HEAPU8[$11 + 75 | 0] | 0] = HEAPU8[HEAP32[$11 + 12 >> 2] + HEAPU8[$11 + 75 | 0] | 0] ^ HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0];
       HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
       continue;
      }
      break;
     };
     if (HEAP32[$11 + 116 >> 2] == 1) {
      $0 = $11 + 48 | 0;
      HEAP32[$0 >> 2] = 0;
      HEAP32[$0 + 4 >> 2] = 0;
      HEAP32[$0 + 8 >> 2] = 0;
      HEAP32[$0 + 12 >> 2] = 0;
      $1 = HEAP32[$11 + 8 >> 2];
      $0 = HEAP32[$11 >> 2];
      if ($0) {
       wasm2js_memory_copy($11 + 48 | 0, $1, $0)
      }
      HEAP8[$11 + 75 | 0] = 0;
      while (1) {
       if (HEAPU8[$11 + 75 | 0] < 16) {
        $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
        HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
        HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
        continue;
       }
       break;
      };
      $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
      HEAP32[$11 + 76 >> 2] = $0;
      if ($0) {
       HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
       break block2;
      }
     }
     HEAP32[$11 + 8 >> 2] = HEAP32[$11 >> 2] + HEAP32[$11 + 8 >> 2];
     HEAP32[$11 + 12 >> 2] = HEAP32[$11 >> 2] + HEAP32[$11 + 12 >> 2];
     HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] - HEAP32[$11 >> 2];
     HEAP8[$11 + 75 | 0] = 0;
     while (1) {
      block5 : {
       if (HEAPU8[$11 + 75 | 0] >= HEAPU8[$11 + 74 | 0]) {
        break block5
       }
       $0 = ($11 - HEAPU8[$11 + 75 | 0] | 0) + 31 | 0;
       $1 = HEAPU8[$0 | 0] + 1 | 0;
       HEAP8[$0 | 0] = $1;
       if ($1 & 255) {
        break block5
       }
       HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
       continue;
      }
      break;
     };
     continue;
    }
    break;
   };
   HEAP8[$11 + 75 | 0] = 0;
   while (1) {
    if (HEAPU8[$11 + 75 | 0] < HEAPU8[$11 + 74 | 0]) {
     HEAP8[($11 - HEAPU8[$11 + 75 | 0] | 0) + 31 | 0] = 0;
     HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
     continue;
    }
    break;
   };
   $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 16 | 0, 16, $11 + 48 | 0, $11 - -64 | 0);
   HEAP32[$11 + 76 >> 2] = $0;
   if ($0) {
    HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
    break block2;
   }
   HEAP8[$11 + 75 | 0] = 0;
   while (1) {
    if (HEAPU8[$11 + 75 | 0] < 16) {
     HEAP8[HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0] ^ HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0];
     HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
     continue;
    }
    break;
   };
   $1 = HEAP32[$11 + 84 >> 2];
   $0 = HEAP32[$11 + 80 >> 2];
   if ($0) {
    wasm2js_memory_copy($1, $11 + 32 | 0, $0)
   }
   HEAP32[$11 + 124 >> 2] = 0;
  }
  __stack_pointer = $11 + 128 | 0;
  return HEAP32[$11 + 124 >> 2];
 }
 
 function mbedtls_ccm_auth_decrypt($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
  var $10 = 0;
  $10 = __stack_pointer - 80 | 0;
  __stack_pointer = $10;
  HEAP32[$10 + 72 >> 2] = $0;
  HEAP32[$10 + 68 >> 2] = $1;
  HEAP32[$10 + 64 >> 2] = $2;
  HEAP32[$10 + 60 >> 2] = $3;
  HEAP32[$10 + 56 >> 2] = $4;
  HEAP32[$10 + 52 >> 2] = $5;
  HEAP32[$10 + 48 >> 2] = $6;
  HEAP32[$10 + 44 >> 2] = $7;
  HEAP32[$10 + 40 >> 2] = $8;
  HEAP32[$10 + 36 >> 2] = $9;
  $0 = ccm_auth_crypt(HEAP32[$10 + 72 >> 2], 1, HEAP32[$10 + 68 >> 2], HEAP32[$10 + 64 >> 2], HEAP32[$10 + 60 >> 2], HEAP32[$10 + 56 >> 2], HEAP32[$10 + 52 >> 2], HEAP32[$10 + 48 >> 2], HEAP32[$10 + 44 >> 2], $10 + 16 | 0, HEAP32[$10 + 36 >> 2]);
  HEAP32[$10 + 32 >> 2] = $0;
  block : {
   if ($0) {
    HEAP32[$10 + 76 >> 2] = HEAP32[$10 + 32 >> 2];
    break block;
   }
   HEAP32[$10 + 8 >> 2] = 0;
   HEAP8[$10 + 15 | 0] = 0;
   while (1) {
    if (HEAPU8[$10 + 15 | 0] < HEAPU32[$10 + 36 >> 2]) {
     HEAP32[$10 + 8 >> 2] = HEAP32[$10 + 8 >> 2] | HEAPU8[HEAP32[$10 + 40 >> 2] + HEAPU8[$10 + 15 | 0] | 0] ^ HEAPU8[HEAPU8[$10 + 15 | 0] + ($10 + 16 | 0) | 0];
     HEAP8[$10 + 15 | 0] = HEAPU8[$10 + 15 | 0] + 1;
     continue;
    }
    break;
   };
   if (HEAP32[$10 + 8 >> 2]) {
    mbedtls_zeroize_1208(HEAP32[$10 + 44 >> 2], HEAP32[$10 + 68 >> 2]);
    HEAP32[$10 + 76 >> 2] = -15;
    break block;
   }
   HEAP32[$10 + 76 >> 2] = 0;
  }
  __stack_pointer = $10 + 80 | 0;
  return HEAP32[$10 + 76 >> 2];
 }
 
 function mbedtls_aes_init($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  wasm2js_memory_fill(HEAP32[$1 + 12 >> 2], 0, 280);
 }
 
 function mbedtls_aes_free($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   mbedtls_zeroize_1214(HEAP32[$1 + 12 >> 2], 280)
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function mbedtls_zeroize_1214($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  while (1) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 - 1;
   if ($0) {
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$2 + 4 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 0;
    continue;
   }
   break;
  };
 }
 
 function mbedtls_aes_setkey_enc($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block4 : {
   block3 : {
    block2 : {
     block1 : {
      block : {
       $0 = HEAP32[$3 + 16 >> 2];
       if (($0 | 0) != 128) {
        if (($0 | 0) == 192) {
         break block
        }
        if (($0 | 0) == 256) {
         break block1
        }
        break block2;
       }
       HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 10;
       break block3;
      }
      HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 12;
      break block3;
     }
     HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 14;
     break block3;
    }
    HEAP32[$3 + 28 >> 2] = -32;
    break block4;
   }
   $0 = HEAP32[$3 + 24 >> 2] + 8 | 0;
   HEAP32[$3 + 8 >> 2] = $0;
   HEAP32[HEAP32[$3 + 24 >> 2] + 4 >> 2] = $0;
   HEAP32[$3 + 12 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 12 >> 2] < HEAP32[$3 + 16 >> 2] >>> 5 >>> 0) {
     HEAP32[HEAP32[$3 + 8 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2] = HEAPU8[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) | 0] | HEAPU8[HEAP32[$3 + 20 >> 2] + ((HEAP32[$3 + 12 >> 2] << 2) + 1 | 0) | 0] << 8 | HEAPU8[HEAP32[$3 + 20 >> 2] + ((HEAP32[$3 + 12 >> 2] << 2) + 2 | 0) | 0] << 16 | HEAPU8[HEAP32[$3 + 20 >> 2] + ((HEAP32[$3 + 12 >> 2] << 2) + 3 | 0) | 0] << 24;
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   block6 : {
    block8 : {
     switch (HEAP32[HEAP32[$3 + 24 >> 2] >> 2] - 10 | 0) {
     case 0:
      HEAP32[$3 + 12 >> 2] = 0;
      while (1) {
       if (HEAPU32[$3 + 12 >> 2] < 10) {
        HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2] = HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] >>> 8 & 255) + 174512 | 0] ^ (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ^ HEAP32[(HEAP32[$3 + 12 >> 2] << 2) + 174464 >> 2]) ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] >>> 16 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] >>> 24 | 0) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] & 255) + 174512 | 0] << 24;
        HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 4 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2];
        HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2];
        HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2];
        HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
        HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 16;
        continue;
       }
       break;
      };
      break block6;
     case 2:
      HEAP32[$3 + 12 >> 2] = 0;
      while (1) {
       if (HEAPU32[$3 + 12 >> 2] < 8) {
        HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2] = HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] >>> 8 & 255) + 174512 | 0] ^ (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ^ HEAP32[(HEAP32[$3 + 12 >> 2] << 2) + 174464 >> 2]) ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] >>> 16 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] >>> 24 | 0) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] & 255) + 174512 | 0] << 24;
        HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 4 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2];
        HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2];
        HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2];
        HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2];
        HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2];
        HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
        HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 24;
        continue;
       }
       break;
      };
      break block6;
     case 4:
      break block8;
     default:
      break block6;
     };
    }
    HEAP32[$3 + 12 >> 2] = 0;
    while (1) {
     if (HEAPU32[$3 + 12 >> 2] < 7) {
      HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2] = HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] >>> 8 & 255) + 174512 | 0] ^ (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ^ HEAP32[(HEAP32[$3 + 12 >> 2] << 2) + 174464 >> 2]) ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] >>> 16 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] >>> 24 | 0) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] & 255) + 174512 | 0] << 24;
      HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 4 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2];
      HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2];
      HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2];
      HEAP32[HEAP32[$3 + 8 >> 2] + 48 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2] ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] & 255) + 174512 | 0] ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] >>> 8 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] >>> 16 & 255) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] >>> 24 | 0) + 174512 | 0] << 24;
      HEAP32[HEAP32[$3 + 8 >> 2] + 52 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 48 >> 2];
      HEAP32[HEAP32[$3 + 8 >> 2] + 56 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 52 >> 2];
      HEAP32[HEAP32[$3 + 8 >> 2] + 60 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 56 >> 2];
      HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 32;
      continue;
     }
     break;
    };
   }
   HEAP32[$3 + 28 >> 2] = 0;
  }
  return HEAP32[$3 + 28 >> 2];
 }
 
 function mbedtls_aes_setkey_dec($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 320 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 316 >> 2] = $0;
  HEAP32[$3 + 312 >> 2] = $1;
  HEAP32[$3 + 308 >> 2] = $2;
  mbedtls_aes_init($3 + 16 | 0);
  $0 = HEAP32[$3 + 316 >> 2] + 8 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[HEAP32[$3 + 316 >> 2] + 4 >> 2] = $0;
  $0 = mbedtls_aes_setkey_enc($3 + 16 | 0, HEAP32[$3 + 312 >> 2], HEAP32[$3 + 308 >> 2]);
  HEAP32[$3 + 296 >> 2] = $0;
  if (!$0) {
   HEAP32[HEAP32[$3 + 316 >> 2] >> 2] = HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 16 >> 2] << 4);
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
   HEAP32[$3 + 304 >> 2] = HEAP32[HEAP32[$3 + 316 >> 2] >> 2] - 1;
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] - 32;
   while (1) {
    if (HEAP32[$3 + 304 >> 2] > 0) {
     HEAP32[$3 + 300 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 300 >> 2] < 4) {
       $1 = HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] >>> 24 | 0) + 174512 | 0] << 2) + 177840 >> 2];
       $2 = HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] >>> 16 & 255) + 174512 | 0] << 2) + 176816 >> 2] ^ (HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] & 255) + 174512 | 0] << 2) + 174768 >> 2] ^ HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] >>> 8 & 255) + 174512 | 0] << 2) + 175792 >> 2]);
       $0 = HEAP32[$3 + 12 >> 2];
       HEAP32[$3 + 12 >> 2] = $0 + 4;
       HEAP32[$0 >> 2] = $1 ^ $2;
       HEAP32[$3 + 300 >> 2] = HEAP32[$3 + 300 >> 2] + 1;
       HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 4;
       continue;
      }
      break;
     };
     HEAP32[$3 + 304 >> 2] = HEAP32[$3 + 304 >> 2] - 1;
     HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] - 32;
     continue;
    }
    break;
   };
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 + 4;
   $1 = HEAP32[$0 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 4;
   HEAP32[$0 >> 2] = $1;
  }
  mbedtls_aes_free($3 + 16 | 0);
  __stack_pointer = $3 + 320 | 0;
  return HEAP32[$3 + 296 >> 2];
 }
 
 function mbedtls_aes_encrypt($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  HEAP32[$3 + 44 >> 2] = HEAP32[HEAP32[$3 + 60 >> 2] + 4 >> 2];
  HEAP32[$3 + 40 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2]] | HEAPU8[HEAP32[$3 + 56 >> 2] + 1 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 2 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 3 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 40 >> 2];
  HEAP32[$3 + 36 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 4 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 5 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 6 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 7 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 8 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 9 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 10 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 11 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 28 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 12 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 13 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 14 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 15 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 48 >> 2] = (HEAP32[HEAP32[$3 + 60 >> 2] >> 2] >> 1) - 1;
  while (1) {
   if (HEAP32[$3 + 48 >> 2] > 0) {
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 178864 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 178864 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 178864 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 178864 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 40 >> 2] = HEAP32[(HEAP32[$3 + 12 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 24 >> 2] & 255) << 2) + 178864 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 36 >> 2] = HEAP32[(HEAP32[$3 + 24 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 20 >> 2] & 255) << 2) + 178864 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 32 >> 2] = HEAP32[(HEAP32[$3 + 20 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 16 >> 2] & 255) << 2) + 178864 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 28 >> 2] = HEAP32[(HEAP32[$3 + 16 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 12 >> 2] & 255) << 2) + 178864 >> 2])));
    HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] - 1;
    continue;
   }
   break;
  };
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 178864 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 178864 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 178864 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 181936 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 180912 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 179888 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 178864 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] & 255) + 174512 | 0] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 8 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 16 & 255) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 24 | 0) + 174512 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] & 255) + 174512 | 0] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 8 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 16 & 255) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 24 | 0) + 174512 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] & 255) + 174512 | 0] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 8 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 16 & 255) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 24 | 0) + 174512 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] & 255) + 174512 | 0] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 8 & 255) + 174512 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 16 & 255) + 174512 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 24 | 0) + 174512 | 0] << 24;
  HEAP8[HEAP32[$3 + 52 >> 2]] = HEAP32[$3 + 40 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 1 | 0] = HEAP32[$3 + 40 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 2 | 0] = HEAP32[$3 + 40 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 3 | 0] = HEAP32[$3 + 40 >> 2] >>> 24;
  HEAP8[HEAP32[$3 + 52 >> 2] + 4 | 0] = HEAP32[$3 + 36 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 5 | 0] = HEAP32[$3 + 36 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 6 | 0] = HEAP32[$3 + 36 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 7 | 0] = HEAP32[$3 + 36 >> 2] >>> 24;
  HEAP8[HEAP32[$3 + 52 >> 2] + 8 | 0] = HEAP32[$3 + 32 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 9 | 0] = HEAP32[$3 + 32 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 10 | 0] = HEAP32[$3 + 32 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 11 | 0] = HEAP32[$3 + 32 >> 2] >>> 24;
  HEAP8[HEAP32[$3 + 52 >> 2] + 12 | 0] = HEAP32[$3 + 28 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 13 | 0] = HEAP32[$3 + 28 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 14 | 0] = HEAP32[$3 + 28 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 15 | 0] = HEAP32[$3 + 28 >> 2] >>> 24;
 }
 
 function mbedtls_aes_decrypt($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  HEAP32[$3 + 44 >> 2] = HEAP32[HEAP32[$3 + 60 >> 2] + 4 >> 2];
  HEAP32[$3 + 40 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2]] | HEAPU8[HEAP32[$3 + 56 >> 2] + 1 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 2 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 3 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 40 >> 2];
  HEAP32[$3 + 36 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 4 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 5 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 6 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 7 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 8 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 9 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 10 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 11 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 28 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 12 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 13 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 14 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 15 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 48 >> 2] = (HEAP32[HEAP32[$3 + 60 >> 2] >> 2] >> 1) - 1;
  while (1) {
   if (HEAP32[$3 + 48 >> 2] > 0) {
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 174768 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 174768 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 174768 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 174768 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 40 >> 2] = HEAP32[(HEAP32[$3 + 20 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 24 >> 2] & 255) << 2) + 174768 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 36 >> 2] = HEAP32[(HEAP32[$3 + 16 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 20 >> 2] & 255) << 2) + 174768 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 32 >> 2] = HEAP32[(HEAP32[$3 + 12 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 16 >> 2] & 255) << 2) + 174768 >> 2])));
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 44 >> 2] = $0 + 4;
    HEAP32[$3 + 28 >> 2] = HEAP32[(HEAP32[$3 + 24 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 12 >> 2] & 255) << 2) + 174768 >> 2])));
    HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] - 1;
    continue;
   }
   break;
  };
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 174768 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 174768 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 174768 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 177840 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 176816 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 175792 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 174768 >> 2])));
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] & 255) + 182960 | 0] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 8 & 255) + 182960 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 16 & 255) + 182960 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 24 | 0) + 182960 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] & 255) + 182960 | 0] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 8 & 255) + 182960 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 16 & 255) + 182960 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 24 | 0) + 182960 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] & 255) + 182960 | 0] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 8 & 255) + 182960 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 16 & 255) + 182960 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 24 | 0) + 182960 | 0] << 24;
  $0 = HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 44 >> 2] = $0 + 4;
  HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] & 255) + 182960 | 0] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 8 & 255) + 182960 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 16 & 255) + 182960 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 24 | 0) + 182960 | 0] << 24;
  HEAP8[HEAP32[$3 + 52 >> 2]] = HEAP32[$3 + 40 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 1 | 0] = HEAP32[$3 + 40 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 2 | 0] = HEAP32[$3 + 40 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 3 | 0] = HEAP32[$3 + 40 >> 2] >>> 24;
  HEAP8[HEAP32[$3 + 52 >> 2] + 4 | 0] = HEAP32[$3 + 36 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 5 | 0] = HEAP32[$3 + 36 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 6 | 0] = HEAP32[$3 + 36 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 7 | 0] = HEAP32[$3 + 36 >> 2] >>> 24;
  HEAP8[HEAP32[$3 + 52 >> 2] + 8 | 0] = HEAP32[$3 + 32 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 9 | 0] = HEAP32[$3 + 32 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 10 | 0] = HEAP32[$3 + 32 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 11 | 0] = HEAP32[$3 + 32 >> 2] >>> 24;
  HEAP8[HEAP32[$3 + 52 >> 2] + 12 | 0] = HEAP32[$3 + 28 >> 2];
  HEAP8[HEAP32[$3 + 52 >> 2] + 13 | 0] = HEAP32[$3 + 28 >> 2] >>> 8;
  HEAP8[HEAP32[$3 + 52 >> 2] + 14 | 0] = HEAP32[$3 + 28 >> 2] >>> 16;
  HEAP8[HEAP32[$3 + 52 >> 2] + 15 | 0] = HEAP32[$3 + 28 >> 2] >>> 24;
 }
 
 function mbedtls_aes_crypt_ecb($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  block : {
   if (HEAP32[$4 + 8 >> 2] == 1) {
    mbedtls_aes_encrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
    break block;
   }
   mbedtls_aes_decrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
  }
  __stack_pointer = $4 + 16 | 0;
  return 0;
 }
 
 function mbedtls_cipher_info_from_values($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = 183408;
  block1 : {
   while (1) {
    if (HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2]) {
     if (!(HEAP32[HEAP32[HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] + 28 >> 2] >> 2] != HEAP32[$3 + 24 >> 2] | HEAP32[HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] + 8 >> 2] != HEAP32[$3 + 20 >> 2] | HEAP32[HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] + 4 >> 2] != HEAP32[$3 + 16 >> 2])) {
      HEAP32[$3 + 28 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2];
      break block1;
     }
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 8;
     continue;
    }
    break;
   };
   HEAP32[$3 + 28 >> 2] = 0;
  }
  return HEAP32[$3 + 28 >> 2];
 }
 
 function mbedtls_cipher_free($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 52 >> 2]) {
    FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + 28 >> 2] + 20 >> 2]](HEAP32[HEAP32[$1 + 12 >> 2] + 52 >> 2])
   }
   mbedtls_zeroize_1222(HEAP32[$1 + 12 >> 2], 56);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function mbedtls_zeroize_1222($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  while (1) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 - 1;
   if ($0) {
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$2 + 4 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = 0;
    continue;
   }
   break;
  };
 }
 
 function mbedtls_cipher_setup($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block1 : {
   if (!(HEAP32[$2 + 8 >> 2] ? HEAP32[$2 + 4 >> 2] : 0)) {
    HEAP32[$2 + 12 >> 2] = -24832;
    break block1;
   }
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$0 >> 2] = 0;
   HEAP32[$0 + 4 >> 2] = 0;
   HEAP32[$0 + 48 >> 2] = 0;
   HEAP32[$0 + 52 >> 2] = 0;
   HEAP32[$0 + 40 >> 2] = 0;
   HEAP32[$0 + 44 >> 2] = 0;
   HEAP32[$0 + 32 >> 2] = 0;
   HEAP32[$0 + 36 >> 2] = 0;
   HEAP32[$0 + 24 >> 2] = 0;
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 + 8 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = 0;
   $0 = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 28 >> 2] + 16 >> 2]]() | 0;
   HEAP32[HEAP32[$2 + 8 >> 2] + 52 >> 2] = $0;
   if (!$0) {
    HEAP32[$2 + 12 >> 2] = -24960;
    break block1;
   }
   HEAP32[HEAP32[$2 + 8 >> 2] >> 2] = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 12 >> 2] = 0;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function mbedtls_cipher_setkey($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  block1 : {
   if (!(HEAP32[HEAP32[$4 + 24 >> 2] >> 2] ? HEAP32[$4 + 24 >> 2] : 0)) {
    HEAP32[$4 + 28 >> 2] = -24832;
    break block1;
   }
   if (!(HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 20 >> 2] & 2 | HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 8 >> 2] == HEAP32[$4 + 16 >> 2])) {
    HEAP32[$4 + 28 >> 2] = -24832;
    break block1;
   }
   HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2] = HEAP32[$4 + 16 >> 2];
   HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] = HEAP32[$4 + 12 >> 2];
   if (!(!(HEAP32[$4 + 12 >> 2] == 1 | HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 4 >> 2] == 3) & HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 4 >> 2] != 5)) {
    HEAP32[$4 + 28 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 28 >> 2] + 8 >> 2]](HEAP32[HEAP32[$4 + 24 >> 2] + 52 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2]);
    break block1;
   }
   if (!HEAP32[$4 + 12 >> 2]) {
    HEAP32[$4 + 28 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 28 >> 2] + 12 >> 2]](HEAP32[HEAP32[$4 + 24 >> 2] + 52 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2]);
    break block1;
   }
   HEAP32[$4 + 28 >> 2] = -24832;
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 28 >> 2];
 }
 
 function mbedtls_cipher_update($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 24 >> 2] = $0;
  HEAP32[$5 + 20 >> 2] = $1;
  HEAP32[$5 + 16 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 8 >> 2] = $4;
  block2 : {
   if (HEAP32[$5 + 8 >> 2] ? !HEAP32[$5 + 24 >> 2] | !HEAP32[HEAP32[$5 + 24 >> 2] >> 2] : 1) {
    HEAP32[$5 + 28 >> 2] = -24832;
    break block2;
   }
   HEAP32[HEAP32[$5 + 8 >> 2] >> 2] = 0;
   if (HEAP32[HEAP32[HEAP32[$5 + 24 >> 2] >> 2] + 4 >> 2] == 1) {
    if (HEAP32[$5 + 16 >> 2] != (mbedtls_cipher_get_block_size(HEAP32[$5 + 24 >> 2]) | 0)) {
     HEAP32[$5 + 28 >> 2] = -25216;
     break block2;
    }
    HEAP32[HEAP32[$5 + 8 >> 2] >> 2] = HEAP32[$5 + 16 >> 2];
    $0 = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$5 + 24 >> 2] >> 2] + 28 >> 2] + 4 >> 2]](HEAP32[HEAP32[$5 + 24 >> 2] + 52 >> 2], HEAP32[HEAP32[$5 + 24 >> 2] + 8 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 12 >> 2]) | 0;
    HEAP32[$5 + 4 >> 2] = $0;
    if ($0) {
     HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 4 >> 2];
     break block2;
    }
    HEAP32[$5 + 28 >> 2] = 0;
    break block2;
   }
   block3 : {
    if (HEAP32[$5 + 20 >> 2] != HEAP32[$5 + 12 >> 2]) {
     break block3
    }
    if (!HEAP32[HEAP32[$5 + 24 >> 2] + 28 >> 2]) {
     if (!(HEAPU32[$5 + 16 >> 2] % (mbedtls_cipher_get_block_size(HEAP32[$5 + 24 >> 2]) >>> 0) | 0)) {
      break block3
     }
    }
    HEAP32[$5 + 28 >> 2] = -24832;
    break block2;
   }
   HEAP32[$5 + 28 >> 2] = -24704;
  }
  __stack_pointer = $5 + 32 | 0;
  return HEAP32[$5 + 28 >> 2];
 }
 
 function mbedtls_cipher_get_block_size($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   if (!(HEAP32[HEAP32[$1 + 8 >> 2] >> 2] ? HEAP32[$1 + 8 >> 2] : 0)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[HEAP32[$1 + 8 >> 2] >> 2] + 24 >> 2];
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function aes_crypt_ecb_wrap($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = mbedtls_aes_crypt_ecb(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
  return $0 | 0;
 }
 
 function aes_setkey_enc_wrap($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = mbedtls_aes_setkey_enc(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function aes_setkey_dec_wrap($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = mbedtls_aes_setkey_dec(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function aes_ctx_alloc() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = jsvMalloc(280);
  block : {
   if (!HEAP32[$0 + 8 >> 2]) {
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   mbedtls_aes_init(HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function aes_ctx_free($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  mbedtls_aes_free(HEAP32[$1 + 12 >> 2]);
  jsvFree(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function ccm_aes_setkey_wrap($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = mbedtls_ccm_setkey(HEAP32[$3 + 12 >> 2], 2, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function ccm_ctx_alloc() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jsvMalloc(56);
  if (HEAP32[$0 + 12 >> 2]) {
   mbedtls_ccm_init(HEAP32[$0 + 12 >> 2])
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function ccm_ctx_free($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  mbedtls_ccm_free(HEAP32[$1 + 12 >> 2]);
  jsvFree(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsInit() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[110198] = $0 + 12;
  jshInit();
  jswHWInit();
  jsvInit(12e3);
  jsiInit(1);
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jsIdle() {
  HEAP32[61110] = -1;
  jsiLoop();
  return HEAP32[61110];
 }
 
 function jsSendPinWatchEvent($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jshGetEventFlagsForPin(HEAP32[$1 + 12 >> 2] & 255);
  if (HEAPU8[$1 + 11 | 0]) {
   jshPushIOWatchEvent(HEAPU8[$1 + 11 | 0])
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsSendTouchEvent($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  touchHandlerInternal(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
  __stack_pointer = $4 + 16 | 0;
 }
 
 function jsKill() {
  jsiKill();
  jsvKill();
  jshKill();
 }
 
 function jshInit() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$0 + 12 >> 2] < 16) {
    HEAP8[HEAP32[$0 + 12 >> 2] + 440800 | 0] = 255;
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  jshInitDevices();
  HEAP8[244444] = 1;
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jshReset() {
  jshResetDevices();
 }
 
 function jshKill() {
  
 }
 
 function jshIdle() {
  if (HEAP8[244444] & 1) {
   jsiOneSecondAfterStartup()
  }
  HEAP8[244444] = 0;
 }
 
 function jshBusyIdle() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 244706;
  $1 = HEAP32[$0 + 12 >> 2];
  HEAP8[$0 + 11 | 0] = 0;
  emscripten_asm_const_int($1 | 0, $0 + 11 | 0, 0) | 0;
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jshGetSerialNumber($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 32 | 0;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = -559030611;
  HEAP32[$2 + 12 >> 2] = -559030611;
  $1 = HEAP32[$2 + 28 >> 2];
  $0 = HEAP32[$2 + 20 >> 2];
  HEAP8[$1 | 0] = $0;
  HEAP8[$1 + 1 | 0] = $0 >>> 8;
  HEAP8[$1 + 2 | 0] = $0 >>> 16;
  HEAP8[$1 + 3 | 0] = $0 >>> 24;
  $1 = HEAP32[$2 + 12 >> 2];
  $3 = HEAP32[$2 + 8 >> 2];
  $0 = $3;
  $3 = HEAP32[$2 + 28 >> 2];
  HEAP8[$3 + 4 | 0] = $0;
  HEAP8[$3 + 5 | 0] = $0 >>> 8;
  HEAP8[$3 + 6 | 0] = $0 >>> 16;
  HEAP8[$3 + 7 | 0] = $0 >>> 24;
  HEAP8[$3 + 8 | 0] = $1;
  HEAP8[$3 + 9 | 0] = $1 >>> 8;
  HEAP8[$3 + 10 | 0] = $1 >>> 16;
  HEAP8[$3 + 11 | 0] = $1 >>> 24;
  return 12;
 }
 
 function jshInterruptOff() {
  
 }
 
 function jshInterruptOn() {
  
 }
 
 function jshIsInInterrupt() {
  return 0;
 }
 
 function jshDelayMicroseconds($0) {
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 }
 
 function jshPinSetState($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
 }
 
 function jshPinGetState($0) {
  HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
  return 0;
 }
 
 function jshPinSetValue($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 31 | 0] = $0;
  HEAP8[$2 + 30 | 0] = $1;
  if (HEAPU8[Math_imul(HEAPU8[$2 + 31 | 0], 3) + 183520 | 0] & 16) {
   HEAP8[$2 + 30 | 0] = (HEAPU8[$2 + 30 | 0] ^ -1) & 1
  }
  HEAP32[$2 + 24 >> 2] = 244724;
  $0 = HEAP32[$2 + 24 >> 2];
  HEAP8[$2 + 21 | 0] = 105;
  HEAP8[$2 + 22 | 0] = 112;
  HEAP8[$2 + 23 | 0] = 0;
  $1 = HEAPU8[$2 + 31 | 0];
  HEAP32[$2 + 4 >> 2] = HEAP8[$2 + 30 | 0] & 1;
  HEAP32[$2 >> 2] = $1;
  emscripten_asm_const_int($0 | 0, $2 + 21 | 0, $2 | 0) | 0;
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jshPinGetValue($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP32[$1 + 8 >> 2] = 244749;
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 6 | 0] = 105;
  HEAP8[$1 + 7 | 0] = 0;
  HEAP32[$1 >> 2] = HEAPU8[$1 + 15 | 0];
  HEAP8[$1 + 14 | 0] = (emscripten_asm_const_int($0 | 0, $1 + 6 | 0, $1 | 0) | 0) != 0;
  if (HEAPU8[Math_imul(HEAPU8[$1 + 15 | 0], 3) + 183520 | 0] & 16) {
   HEAP8[$1 + 14 | 0] = (HEAPU8[$1 + 14 | 0] ^ -1) & 1
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 14 | 0] & 1;
 }
 
 function jshIsDeviceInitialised($0) {
  HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
  return 1;
 }
 
 function jshIsUSBSERIALConnected() {
  return 1;
 }
 
 function jshGetTimeFromMilliseconds($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = HEAPF64[$1 + 8 >> 3] * 1.0e3;
  if (Math_abs($0) < 9223372036854775808.0) {
   if (Math_abs($0) >= 1.0) {
    $1 = ~~($0 > 0.0 ? Math_min(Math_floor($0 * 2.3283064365386963e-10), 4294967295.0) : Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0
   } else {
    $1 = 0
   }
   $2 = ~~$0 >>> 0;
  } else {
   $1 = -2147483648
  }
  i64toi32_i32$HIGH_BITS = $1;
  return $2;
 }
 
 function jshGetMillisecondsFromTime($0, $1) {
  var $2 = 0, $3 = 0.0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 12 >> 2] = $1;
  $3 = +HEAPU32[$2 + 8 >> 2];
  $2 = HEAP32[$2 + 12 >> 2];
  return ($3 + +($2 | 0) * 4294967296.0) / 1.0e3;
 }
 
 function jshGetSystemTime() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 244778;
  $1 = HEAP32[$0 + 12 >> 2];
  HEAP8[$0 + 11 | 0] = 0;
  $1 = jshGetTimeFromMilliseconds(+emscripten_asm_const_double($1 | 0, $0 + 11 | 0, 0));
  __stack_pointer = $0 + 16 | 0;
  return $1;
 }
 
 function jshSetSystemTime($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 12 >> 2] = $1;
 }
 
 function jshPinAnalog($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  HEAPF64[$1 >> 3] = 0;
  return +HEAPF64[$1 >> 3];
 }
 
 function jshPinAnalogOutput($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  HEAP8[$4 + 31 | 0] = $0;
  HEAPF64[$4 + 16 >> 3] = $1;
  HEAPF64[$4 + 8 >> 3] = $2;
  HEAP32[$4 + 4 >> 2] = $3;
  return 0;
 }
 
 function jshCanWatch($0) {
  HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
  return 1;
 }
 
 function jshGetEventFlagsForPin($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 14 | 0] = $0;
  HEAP32[$1 + 8 >> 2] = 0;
  block : {
   while (1) {
    if (HEAP32[$1 + 8 >> 2] < 16) {
     if (HEAPU8[HEAP32[$1 + 8 >> 2] + 440800 | 0] == HEAPU8[$1 + 14 | 0]) {
      HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 1;
      break block;
     } else {
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
      continue;
     }
    }
    break;
   };
   HEAP8[$1 + 15 | 0] = 0;
  }
  return HEAPU8[$1 + 15 | 0];
 }
 
 function jshPinWatch($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP8[$3 + 14 | 0] = $0;
  HEAP8[$3 + 13 | 0] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  block : {
   if (HEAP8[$3 + 13 | 0] & 1) {
    HEAP32[$3 + 4 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 4 >> 2] < 16) {
      if (HEAPU8[HEAP32[$3 + 4 >> 2] + 440800 | 0] == 255) {
       HEAP8[HEAP32[$3 + 4 >> 2] + 440800 | 0] = HEAPU8[$3 + 14 | 0];
       HEAP8[$3 + 15 | 0] = HEAP32[$3 + 4 >> 2] + 1;
       break block;
      } else {
       HEAP32[$3 >> 2] = 0;
       while (1) {
        if (HEAP32[$3 >> 2] < 16) {
         if (HEAPU8[HEAP32[$3 >> 2] + 440800 | 0] == HEAPU8[$3 + 14 | 0]) {
          HEAP8[HEAP32[$3 >> 2] + 440800 | 0] = 255
         }
         HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + 1;
         continue;
        }
        break;
       };
       HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
       continue;
      }
     }
     break;
    };
   }
   HEAP8[$3 + 15 | 0] = 0;
  }
  return HEAPU8[$3 + 15 | 0];
 }
 
 function jshGetWatchedPinState($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = jshPinGetValue(HEAPU8[(HEAPU8[$1 + 15 | 0] - 1 | 0) + 440800 | 0]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jshIsEventForPin($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  $0 = HEAPU8[$2 + 15 | 0] & 31;
  $1 = jshGetEventFlagsForPin(HEAPU8[$2 + 14 | 0]) & 255;
  __stack_pointer = $2 + 16 | 0;
  return ($0 | 0) == ($1 | 0);
 }
 
 function jshUSARTSetup($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jshUSARTKick($0) {
  HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
 }
 
 function jshSPISetup($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jshSPISend($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 11 | 0] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jshSPISend16($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jshSPISet16($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
 }
 
 function jshSPISetReceive($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
 }
 
 function jshSPIWait($0) {
  HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
 }
 
 function jshI2CSetup($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jshI2CWrite($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 16 | 0;
  HEAP8[$5 + 15 | 0] = $0;
  HEAP8[$5 + 14 | 0] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 4 >> 2] = $3;
  HEAP8[$5 + 3 | 0] = $4;
 }
 
 function jshI2CRead($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 16 | 0;
  HEAP8[$5 + 15 | 0] = $0;
  HEAP8[$5 + 14 | 0] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 4 >> 2] = $3;
  HEAP8[$5 + 3 | 0] = $4;
 }
 
 function jshSleep($0, $1) {
  var $2 = 0, $3 = 0.0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 12 >> 2] = $1;
  HEAPF64[$2 >> 3] = jshGetMillisecondsFromTime(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
  if (HEAPF64[$2 >> 3] > 2147483647.0) {
   HEAPF64[$2 >> 3] = 2147483647
  }
  $3 = HEAPF64[$2 >> 3];
  if (Math_abs($3) < 2147483647.0) {
   $0 = ~~$3
  } else {
   $0 = -2147483648
  }
  HEAP32[61110] = $0;
  __stack_pointer = $2 + 16 | 0;
  return 0;
 }
 
 function jshUtilTimerDisable() {
  
 }
 
 function jshUtilTimerStart($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 12 >> 2] = $1;
 }
 
 function jshEnableWatchDog($0) {
  HEAPF64[(__stack_pointer - 16 | 0) + 8 >> 3] = $0;
 }
 
 function jshKickWatchDog() {
  
 }
 
 function jshReadTemperature() {
  return NaN;
 }
 
 function jshReadVRef() {
  return NaN;
 }
 
 function jshGetRandomNumber() {
  return rand() | 0;
 }
 
 function jshFlashGetPage($0, $1, $2) {
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 8 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 >> 2] = $2;
  block : {
   if (HEAPU32[$3 + 8 >> 2] < 134217728) {
    HEAP8[$3 + 15 | 0] = 0;
    break block;
   }
   $1 = HEAP32[$3 + 4 >> 2];
   $4 = +(HEAP32[$3 + 8 >> 2] >>> 12 >>> 0) * 4096.0;
   if ($4 < 4294967295.0 & $4 >= 0.0) {
    $0 = ~~$4 >>> 0
   } else {
    $0 = 0
   }
   HEAP32[$1 >> 2] = $0;
   HEAP32[HEAP32[$3 >> 2] >> 2] = 4096;
   HEAP8[$3 + 15 | 0] = 1;
  }
  return HEAP8[$3 + 15 | 0] & 1;
 }
 
 function jshFlashGetFree() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jsvNewEmptyArray();
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jshFlashErasePage($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 4144 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 4140 >> 2] = $0;
  if (jshFlashGetPage(HEAP32[$1 + 4140 >> 2], $1 + 4136 | 0, $1 + 4132 | 0) & 1) {
   wasm2js_memory_fill($1 + 32 | 0, 255, 4096);
   HEAP32[$1 + 28 >> 2] = 244801;
   $0 = HEAP32[$1 + 28 >> 2];
   HEAP8[$1 + 24 | 0] = 105;
   HEAP8[$1 + 25 | 0] = 112;
   HEAP8[$1 + 26 | 0] = 105;
   HEAP8[$1 + 27 | 0] = 0;
   $2 = HEAP32[$1 + 4136 >> 2];
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 4132 >> 2];
   HEAP32[$1 + 4 >> 2] = $1 + 32;
   HEAP32[$1 >> 2] = $2 + -134217728;
   emscripten_asm_const_int($0 | 0, $1 + 24 | 0, $1 | 0) | 0;
  }
  __stack_pointer = $1 + 4144 | 0;
 }
 
 function jshFlashRead($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (HEAPU32[$3 + 24 >> 2] < 134217728) {
    break block
   }
   HEAP32[$3 + 16 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 16 >> 2] >= HEAPU32[$3 + 20 >> 2]) {
     break block
    }
    HEAP32[$3 + 12 >> 2] = 244832;
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP8[$3 + 10 | 0] = 105;
    HEAP8[$3 + 11 | 0] = 0;
    HEAP32[$3 >> 2] = (HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 16 >> 2] | 0) + -134217728;
    $0 = emscripten_asm_const_int($0 | 0, $3 + 10 | 0, $3 | 0) | 0;
    HEAP8[HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 16 >> 2] | 0] = $0;
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
    continue;
   };
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jshFlashWrite($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  if (HEAPU32[$3 + 24 >> 2] >= 134217728) {
   HEAP32[$3 + 16 >> 2] = 244859;
   $0 = HEAP32[$3 + 16 >> 2];
   HEAP8[$3 + 12 | 0] = 105;
   HEAP8[$3 + 13 | 0] = 112;
   HEAP8[$3 + 14 | 0] = 105;
   HEAP8[$3 + 15 | 0] = 0;
   $1 = HEAP32[$3 + 24 >> 2];
   $2 = HEAP32[$3 + 28 >> 2];
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 20 >> 2];
   HEAP32[$3 + 4 >> 2] = $2;
   HEAP32[$3 >> 2] = $1 + -134217728;
   emscripten_asm_const_int($0 | 0, $3 + 12 | 0, $3 | 0) | 0;
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jshFlashGetMemMapAddress($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   if (!(HEAPU32[$1 + 8 >> 2] < 134217728 | HEAPU32[$1 + 8 >> 2] >= 142606336)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jshSetSystemClock($0) {
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
  return 0;
 }
 
 function jswrap_banglejs_pwrBacklight($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jshPinOutput(8, HEAP8[$1 + 15 | 0] & 1);
  lcdMemLCD_extcominBacklight(HEAP8[$1 + 15 | 0] & 1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function graphicsInternalFlip() {
  lcdMemLCD_flip(416628);
 }
 
 function lcd_flip($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 8 >> 2] == 2) {
    lcdMemLCD_setOverlayModified(416628);
    break block;
   }
   if (HEAP32[$2 + 8 >> 2]) {
    HEAP8[416668] = 0;
    HEAP8[416669] = 0;
    HEAP8[416670] = 0;
    HEAP8[416671] = 0;
    HEAP8[416672] = 175;
    HEAP8[416673] = 0;
    HEAP8[416674] = 175;
    HEAP8[416675] = 0;
   }
  }
  graphicsInternalFlip();
  __stack_pointer = $2 + 16 | 0;
 }
 
 function wakeUpBangle($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = 0;
  if (!(!HEAP32[110208] | HEAP32[110206] & 65536)) {
   HEAP8[$1 + 11 | 0] = 1;
   HEAP32[110209] = HEAP32[110209] | 2;
  }
  if (!(!HEAP32[110210] | HEAP32[110206] & 131072)) {
   HEAP8[$1 + 11 | 0] = 1;
   HEAP32[110209] = HEAP32[110209] | 8;
  }
  if (!(!HEAP32[110211] | !(HEAP32[110206] & 262144))) {
   HEAP8[$1 + 11 | 0] = 1;
   HEAP32[110207] = HEAP32[$1 + 12 >> 2];
   HEAP32[110209] = HEAP32[110209] | 64;
  }
  if (HEAP8[$1 + 11 | 0] & 1) {
   HEAP16[220424] = 0;
   jshHadEvent();
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 11 | 0] & 1;
 }
 
 function jswrap_banglejs_setPollInterval_internal($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP16[$1 + 14 >> 1] = $0;
  HEAP16[220425] = HEAPU16[$1 + 14 >> 1];
 }
 
 function jswrap_banglejs_kickPollWatchdog() {
  HEAP16[220426] = 0;
 }
 
 function btnHandlerCommon($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP8[$3 + 11 | 0] = $1;
  HEAP8[$3 + 10 | 0] = $2;
  block4 : {
   if (HEAP32[110208] | HEAP32[110210] | HEAP32[110211]) {
    block3 : {
     if (!((HEAP32[$3 + 12 >> 2] == 1 ? HEAP32[110206] & 2 : 0) | (HEAP32[$3 + 12 >> 2] == 2 ? HEAP32[110206] & 4 : 0))) {
      if (!(HEAP32[110206] & 8) | HEAP32[$3 + 12 >> 2] != 3) {
       break block3
      }
     }
     if (HEAP8[$3 + 11 | 0] & 1) {
      HEAP8[$3 + 9 | 0] = wakeUpBangle(15158) & 1;
      if (HEAP8[$3 + 9 | 0] & 1) {
       HEAP16[220424] = 0;
       HEAP8[440854] = HEAP32[$3 + 12 >> 2];
       $4 = jshGetSystemTime();
       $2 = i64toi32_i32$HIGH_BITS;
       $0 = $2;
       $2 = jshGetTimeFromMilliseconds(100.0);
       $1 = $2;
       $4 = $2 + $4 | 0;
       $2 = i64toi32_i32$HIGH_BITS;
       $0 = $2 + $0 | 0;
       HEAP32[110214] = $4;
       $0 = $4 >>> 0 < $1 >>> 0 ? $0 + 1 | 0 : $0;
       HEAP32[110215] = $0;
       break block4;
      }
     }
    }
   }
   HEAP8[$3 + 8 | 0] = 1;
   block5 : {
    if (HEAP32[110206] & 262144) {
     HEAP8[$3 + 8 | 0] = 0;
     break block5;
    }
    HEAP16[220424] = 0;
   }
   if (HEAP32[$3 + 12 >> 2] == 1) {
    HEAP16[220432] = 0
   }
   $0 = jshGetSystemTime();
   HEAP32[$3 >> 2] = $0;
   HEAP32[$3 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
   if (HEAP32[$3 + 12 >> 2] == HEAP8[440854] << 24 >> 24) {
    $0 = HEAP32[$3 + 4 >> 2];
    $2 = $0;
    $0 = HEAP32[110214];
    $1 = $0;
    $0 = HEAP32[110215];
    block7 : {
     if (!(HEAP8[$3 + 11 | 0] & 1 & (($0 | 0) <= ($2 | 0) & $1 >>> 0 <= HEAPU32[$3 >> 2] | ($0 | 0) < ($2 | 0)))) {
      $1 = HEAP32[$3 >> 2];
      $2 = HEAP32[$3 + 4 >> 2];
      $0 = jshGetTimeFromMilliseconds(100.0);
      $4 = i64toi32_i32$HIGH_BITS + $2 | 0;
      $2 = $1 + $0 | 0;
      $4 = $2 >>> 0 < $0 >>> 0 ? $4 + 1 | 0 : $4;
      HEAP32[110214] = $2;
      HEAP32[110215] = $4;
      HEAP8[$3 + 10 | 0] = HEAPU8[$3 + 10 | 0] | 64;
      $1 = 440856;
      break block7;
     }
     HEAP8[440854] = 0;
     HEAP32[110214] = 0;
     HEAP32[110215] = 0;
     $1 = 440856;
    }
   }
   if (!(HEAP8[$3 + 8 | 0] & 1)) {
    break block4
   }
   $4 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   jshPushIOEvent((HEAPU8[$3 + 10 | 0] | (HEAP8[$3 + 11 | 0] & 1 ? 32 : 0)) & 255, $4, $1);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function btn1Handler($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP8[$2 + 14 | 0] = $1;
  if (!(HEAP32[110206] & 4194304)) {
   btnHandlerCommon(1, HEAP8[$2 + 15 | 0] & 1, HEAPU8[$2 + 14 | 0])
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function touchSwipeRotate($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if ((HEAPU8[416636] | HEAPU8[416637] << 8 | (HEAPU8[416638] << 16 | HEAPU8[416639] << 24)) & 32) {
   block : {
    if (HEAP32[$1 + 12 >> 2] == 1) {
     HEAP32[$1 + 12 >> 2] = 2;
     break block;
    }
    if (HEAP32[$1 + 12 >> 2] == 2) {
     HEAP32[$1 + 12 >> 2] = 1
    }
   }
  }
  if ((HEAPU8[416636] | HEAPU8[416637] << 8 | (HEAPU8[416638] << 16 | HEAPU8[416639] << 24)) & 64) {
   block1 : {
    if (HEAP32[$1 + 12 >> 2] == 3) {
     HEAP32[$1 + 12 >> 2] = 4;
     break block1;
    }
    if (HEAP32[$1 + 12 >> 2] == 4) {
     HEAP32[$1 + 12 >> 2] = 3
    }
   }
  }
  if ((HEAPU8[416636] | HEAPU8[416637] << 8 | (HEAPU8[416638] << 16 | HEAPU8[416639] << 24)) & 16) {
   block2 : {
    if (HEAP32[$1 + 12 >> 2] == 1) {
     HEAP32[$1 + 12 >> 2] = 3;
     break block2;
    }
    block3 : {
     if (HEAP32[$1 + 12 >> 2] == 2) {
      HEAP32[$1 + 12 >> 2] = 4;
      break block3;
     }
     block4 : {
      if (HEAP32[$1 + 12 >> 2] == 3) {
       HEAP32[$1 + 12 >> 2] = 1;
       break block4;
      }
      if (HEAP32[$1 + 12 >> 2] == 4) {
       HEAP32[$1 + 12 >> 2] = 2
      }
     }
    }
   }
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function touchHandlerInternal($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  if (!(HEAP32[110206] & 262144)) {
   deviceToGraphicsCoordinates(416628, $4 + 28 | 0, $4 + 24 | 0);
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] - (HEAP16[220433] << 16 >> 16);
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2] - (HEAP16[220434] << 16 >> 16);
   HEAP16[220433] = HEAP32[$4 + 28 >> 2];
   HEAP16[220434] = HEAP32[$4 + 24 >> 2];
   HEAP8[440870] = HEAP32[$4 + 20 >> 2] != 0;
   HEAP32[$4 + 4 >> 2] = HEAP32[110209];
   if (HEAP32[$4 + 16 >> 2] != HEAP32[110218]) {
    block5 : {
     block7 : {
      switch (HEAP32[$4 + 16 >> 2] - 1 | 0) {
      case 0:
       HEAP32[110219] = touchSwipeRotate(4);
       HEAP32[110209] = HEAP32[110209] | 524288;
       break block5;
      case 1:
       HEAP32[110219] = touchSwipeRotate(3);
       HEAP32[110209] = HEAP32[110209] | 524288;
       break block5;
      case 2:
       HEAP32[110219] = touchSwipeRotate(1);
       HEAP32[110209] = HEAP32[110209] | 524288;
       break block5;
      case 3:
       HEAP32[110219] = touchSwipeRotate(2);
       HEAP32[110209] = HEAP32[110209] | 524288;
       break block5;
      case 4:
       block8 : {
        if (HEAP16[220433] << 16 >> 16 < 80) {
         HEAP32[110209] = HEAP32[110209] | 1048576;
         break block8;
        }
        HEAP32[110209] = HEAP32[110209] | 2097152;
       }
       HEAP8[440880] = 0;
       break block5;
      case 10:
       block9 : {
        if (HEAP16[220433] << 16 >> 16 < 80) {
         HEAP32[110209] = HEAP32[110209] | 1048576;
         break block9;
        }
        HEAP32[110209] = HEAP32[110209] | 2097152;
       }
       HEAP8[440880] = 1;
       break block5;
      case 11:
       break block7;
      default:
       break block5;
      };
     }
     block10 : {
      if (HEAP16[220433] << 16 >> 16 < 80) {
       HEAP32[110209] = HEAP32[110209] | 1048576;
       break block10;
      }
      HEAP32[110209] = HEAP32[110209] | 2097152;
     }
     HEAP8[440880] = 2;
    }
   }
   if (!(!((HEAP8[440870] & 1) != (HEAP8[440881] & 1) | HEAPU16[220441] != HEAPU16[220433]) & HEAPU16[220442] == HEAPU16[220434])) {
    HEAP32[110209] = HEAP32[110209] | 4194304;
    if (unistroke_touch(HEAP16[220433] << 16 >> 16, HEAP16[220434] << 16 >> 16, HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP8[440870] & 1) & 1) {
     HEAP32[110209] = HEAP32[110209] | 8388608
    }
   }
   if (HEAP32[$4 + 4 >> 2] != HEAP32[110209]) {
    jshHadEvent();
    HEAP16[220424] = 0;
   }
   HEAP32[110218] = HEAP32[$4 + 16 >> 2];
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jswrap_banglejs_setLCDPowerBacklight($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  if ((HEAP8[$1 + 15 | 0] & 1) != ((HEAP32[110206] & 131072) != 0 | 0)) {
   HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 17919);
   if (HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 4 >> 2] = jsvNewFromBool(HEAP8[$1 + 15 | 0] & 1);
    jsiQueueObjectCallbacks(HEAP32[$1 + 8 >> 2], 4820, $1 + 4 | 0, 1);
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
  block : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    if (HEAP32[110210] > 0) {
     HEAP16[220424] = 0
    }
    HEAP32[110206] = HEAP32[110206] | 131072;
    break block;
   }
   if (!(HEAP32[110211] <= 0 | HEAP32[110211] > HEAP32[110210])) {
    _jswrap_banglejs_setLocked(1, 4837)
   }
   HEAP32[110206] = HEAP32[110206] & -131073;
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jswrap_banglejs_setLocked($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 31 | 0] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  if ((HEAP32[110206] & 262144) != (HEAP8[$2 + 31 | 0] & 1)) {
   HEAP32[$2 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 17919);
   if (HEAP32[$2 + 20 >> 2]) {
    HEAP32[$2 + 12 >> 2] = jsvNewFromBool(HEAP8[$2 + 31 | 0] & 1);
    $1 = $2 + 12 | 0;
    block : {
     if (HEAP32[$2 + 24 >> 2]) {
      $0 = jsvNewFromString(HEAP32[$2 + 24 >> 2]);
      break block;
     }
     $0 = 0;
    }
    HEAP32[$1 + 4 >> 2] = $0;
    jsiQueueObjectCallbacks(HEAP32[$2 + 20 >> 2], 15975, $2 + 12 | 0, 2);
    jsvUnLockMany(2, $2 + 12 | 0);
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
  }
  block1 : {
   if (HEAP8[$2 + 31 | 0] & 1) {
    HEAP32[110206] = HEAP32[110206] | 262144;
    break block1;
   }
   HEAP16[220424] = 0;
   HEAP32[110206] = HEAP32[110206] & -262145;
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_banglejs_setLCDPower($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jswrap_banglejs_setLCDPowerController(HEAP8[$1 + 15 | 0] & 1);
  jswrap_banglejs_setLCDPowerBacklight(HEAP8[$1 + 15 | 0] & 1);
  if ((HEAP8[$1 + 15 | 0] & 1) != ((HEAP32[110206] & 65536) != 0 | 0)) {
   HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 17919);
   if (HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 4 >> 2] = jsvNewFromBool(HEAP8[$1 + 15 | 0] & 1);
    jsiQueueObjectCallbacks(HEAP32[$1 + 8 >> 2], 7908, $1 + 4 | 0, 1);
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
  block1 : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    if (!(HEAP32[110208] <= 0 & HEAP32[110210] <= 0)) {
     HEAP16[220424] = 0
    }
    HEAP32[110206] = HEAP32[110206] | 65536;
    break block1;
   }
   HEAP32[110206] = HEAP32[110206] & -65537;
   if (!(HEAP32[110211] <= 0 | HEAP32[110211] > HEAP32[110208])) {
    _jswrap_banglejs_setLocked(1, 19278)
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_banglejs_setLCDPowerController($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jshPinOutput(6, 0);
  jshPinOutput(7, HEAP8[$1 + 15 | 0] & 1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_banglejs_setLCDBrightness($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = HEAPF64[$1 + 8 >> 3] * 256.0 + .5;
  if (Math_abs($0) < 2147483647.0) {
   $2 = ~~$0
  } else {
   $2 = -2147483648
  }
  HEAP32[$1 + 4 >> 2] = $2;
  if (HEAP32[$1 + 4 >> 2] < 0) {
   HEAP32[$1 + 4 >> 2] = 0
  }
  if (HEAP32[$1 + 4 >> 2] > 255) {
   HEAP32[$1 + 4 >> 2] = 255
  }
  HEAP8[440886] = HEAP32[$1 + 4 >> 2];
  if (HEAP32[110206] & 131072) {
   jswrap_banglejs_setLCDPowerBacklight(1)
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_banglejs_setLCDMode($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsExceptionHere(1, 18297, 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_banglejs_getLCDMode() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = 0;
  block : {
   if (!HEAP32[$0 + 8 >> 2]) {
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 12 >> 2] = jsvNewFromString(HEAP32[$0 + 8 >> 2]);
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_banglejs_setLCDOffset($0) {
  $0 = $0 | 0;
  HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 }
 
 function jswrap_banglejs_setLCDOverlay($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP32[$4 + 32 >> 2] = $3;
  HEAP8[$4 + 31 | 0] = jsvIsUndefined(HEAP32[$4 + 44 >> 2]) & 1;
  HEAP32[$4 + 24 >> 2] = jsvGetInteger(HEAP32[$4 + 40 >> 2]);
  if (HEAP8[$4 + 31 | 0] & 1) {
   HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 40 >> 2]
  }
  HEAP32[$4 + 20 >> 2] = 0;
  if (jsvIsObject(HEAP32[$4 + 32 >> 2]) & 1) {
   HEAP32[$4 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 32 >> 2], 18704)
  }
  HEAP32[$4 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 19575);
  HEAP8[$4 + 15 | 0] = (jsvIsEqual(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]) ^ -1) & 1;
  jsvUnLock(HEAP32[$4 + 16 >> 2]);
  block1 : {
   if (!(!(HEAP8[$4 + 15 | 0] & 1) | (!(HEAP8[$4 + 31 | 0] & 1) | !HEAP32[$4 + 20 >> 2]))) {
    jsvUnLock(HEAP32[$4 + 20 >> 2]);
    break block1;
   }
   if (HEAP8[$4 + 15 | 0] & 1) {
    HEAP32[$4 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 20526);
    if (HEAP32[$4 + 8 >> 2]) {
     jsiQueueEvents(0, HEAP32[$4 + 8 >> 2], 0, 0);
     jsvUnLock(HEAP32[$4 + 8 >> 2]);
    }
   }
   block3 : {
    if (HEAP32[$4 + 44 >> 2]) {
     jsvObjectSetOrRemoveChild(HEAP32[103308], 19575, HEAP32[$4 + 20 >> 2]);
     block2 : {
      if (jsvIsObject(HEAP32[$4 + 32 >> 2]) & 1) {
       $0 = jsvObjectGetChildIfExists(HEAP32[$4 + 32 >> 2], 17255);
       break block2;
      }
      $0 = 0;
     }
     HEAP32[$4 + 4 >> 2] = $0;
     jsvObjectSetOrRemoveChild(HEAP32[103308], 20526, HEAP32[$4 + 4 >> 2]);
     jsvUnLock(HEAP32[$4 + 4 >> 2]);
     break block3;
    }
    jsvObjectRemoveChild(HEAP32[103308], 19575);
    jsvObjectRemoveChild(HEAP32[103308], 20526);
   }
   jsvUnLock(HEAP32[$4 + 20 >> 2]);
   lcdMemLCD_setOverlay(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 36 >> 2]);
  }
  __stack_pointer = $4 + 48 | 0;
 }
 
 function jswrap_banglejs_setLCDTimeout($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 24 >> 3] = $0;
  __DOUBLE_BITS_1314(HEAPF64[$1 + 24 >> 3]);
  $2 = i64toi32_i32$HIGH_BITS & 2147483647;
  block : {
   if (($2 | 0) == 2146435072 | $2 >>> 0 > 2146435072) {
    HEAPF64[$1 + 24 >> 3] = 0;
    break block;
   }
   if (HEAPF64[$1 + 24 >> 3] < 0.0) {
    HEAPF64[$1 + 24 >> 3] = 0
   }
  }
  $0 = HEAPF64[$1 + 24 >> 3] * 1.0e3;
  if (Math_abs($0) < 2147483647.0) {
   $2 = ~~$0
  } else {
   $2 = -2147483648
  }
  HEAP32[110210] = $2;
  $0 = HEAPF64[$1 + 24 >> 3] * 1.0e3;
  if (Math_abs($0) < 2147483647.0) {
   $2 = ~~$0
  } else {
   $2 = -2147483648
  }
  HEAP32[110211] = $2;
  __stack_pointer = $1 + 32 | 0;
 }
 
 function __DOUBLE_BITS_1314($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_banglejs_setPollInterval($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 24 >> 3] = $0;
  __DOUBLE_BITS_1314(HEAPF64[$1 + 24 >> 3]);
  block2 : {
   block1 : {
    $2 = i64toi32_i32$HIGH_BITS & 2147483647;
    if (!(($2 | 0) == 2146435072 | $2 >>> 0 > 2146435072 | HEAPF64[$1 + 24 >> 3] < 10.0)) {
     if (!(HEAPF64[$1 + 24 >> 3] > 4.0e3)) {
      break block1
     }
    }
    jsExceptionHere(1, 15862, 0);
    break block2;
   }
   HEAP32[110206] = HEAP32[110206] & -2049;
   $0 = HEAPF64[$1 + 24 >> 3];
   if ($0 < 4294967295.0 & $0 >= 0.0) {
    $2 = ~~$0 >>> 0
   } else {
    $2 = 0
   }
   jswrap_banglejs_setPollInterval_internal($2 & 65535);
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function _jswrap_banglejs_setOptions($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 432 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 424 >> 2] = $0;
  HEAP8[$2 + 423 | 0] = $1;
  HEAP8[$2 + 422 | 0] = (HEAP32[110206] & 2) != 0;
  HEAP8[$2 + 421 | 0] = (HEAP32[110206] & 4) != 0;
  HEAP8[$2 + 420 | 0] = (HEAP32[110206] & 8) != 0;
  HEAP8[$2 + 419 | 0] = HEAP32[110206] & 1;
  HEAP8[$2 + 418 | 0] = (HEAP32[110206] & 16) != 0;
  HEAP8[$2 + 417 | 0] = (HEAP32[110206] & 32) != 0;
  HEAP8[$2 + 416 | 0] = (HEAP32[110206] & 64) != 0;
  HEAP8[$2 + 415 | 0] = (HEAP32[110206] & 2048) != 0;
  HEAP8[$2 + 414 | 0] = (HEAP32[110206] & 2097152) != 0;
  HEAP8[$2 + 413 | 0] = (HEAP32[110206] & 4194304) != 0;
  HEAP32[$2 + 400 >> 2] = Math_imul(HEAPU16[122228], HEAPU16[122228]);
  HEAP32[$2 + 396 >> 2] = Math_imul(HEAPU16[122229], HEAPU16[122229]);
  HEAP32[$2 + 392 >> 2] = HEAP16[220408] << 16 >> 16;
  HEAP32[$2 + 388 >> 2] = HEAP16[220409] << 16 >> 16;
  HEAP32[$2 + 384 >> 2] = HEAP16[122223] << 16 >> 16;
  HEAP32[$2 + 380 >> 2] = HEAP16[122224] << 16 >> 16;
  HEAP32[$2 + 376 >> 2] = lcdMemLCD_getRowPtr(0);
  HEAP8[$2 + 375 | 0] = (HEAP32[110206] & 1048576) != 0;
  HEAP32[$2 >> 2] = 16263;
  HEAP16[$2 + 4 >> 1] = 10;
  HEAP16[$2 + 6 >> 1] = 0;
  HEAP32[$2 + 8 >> 2] = $2 + 400;
  HEAP32[$2 + 12 >> 2] = 16282;
  HEAP16[$2 + 16 >> 1] = 10;
  HEAP16[$2 + 18 >> 1] = 0;
  HEAP32[$2 + 20 >> 2] = $2 + 396;
  HEAP32[$2 + 24 >> 2] = 4522;
  HEAP16[$2 + 28 >> 1] = 10;
  HEAP16[$2 + 30 >> 1] = 0;
  HEAP32[$2 + 32 >> 2] = 244460;
  HEAP32[$2 + 36 >> 2] = 16219;
  HEAP16[$2 + 40 >> 1] = 10;
  HEAP16[$2 + 42 >> 1] = 0;
  HEAP32[$2 + 44 >> 2] = 244464;
  HEAP32[$2 + 48 >> 2] = 3993;
  HEAP16[$2 + 52 >> 1] = 10;
  HEAP16[$2 + 54 >> 1] = 0;
  HEAP32[$2 + 56 >> 2] = $2 + 408;
  HEAP32[$2 + 60 >> 2] = 16330;
  HEAP16[$2 + 64 >> 1] = 10;
  HEAP16[$2 + 66 >> 1] = 0;
  HEAP32[$2 + 68 >> 2] = $2 + 404;
  HEAP32[$2 + 72 >> 2] = 19212;
  HEAP16[$2 + 76 >> 1] = 12;
  HEAP16[$2 + 78 >> 1] = 0;
  HEAP32[$2 + 80 >> 2] = 440820;
  HEAP32[$2 + 84 >> 2] = 18688;
  HEAP16[$2 + 88 >> 1] = 10;
  HEAP16[$2 + 90 >> 1] = 0;
  HEAP32[$2 + 92 >> 2] = 244468;
  HEAP32[$2 + 96 >> 2] = 4376;
  HEAP16[$2 + 100 >> 1] = 10;
  HEAP16[$2 + 102 >> 1] = 0;
  HEAP32[$2 + 104 >> 2] = 244476;
  HEAP32[$2 + 108 >> 2] = 20802;
  HEAP16[$2 + 112 >> 1] = 10;
  HEAP16[$2 + 114 >> 1] = 0;
  HEAP32[$2 + 116 >> 2] = 244472;
  HEAP32[$2 + 120 >> 2] = 22468;
  HEAP16[$2 + 124 >> 1] = 12;
  HEAP16[$2 + 126 >> 1] = 0;
  HEAP32[$2 + 128 >> 2] = $2 + 422;
  HEAP32[$2 + 132 >> 2] = 22396;
  HEAP16[$2 + 136 >> 1] = 12;
  HEAP16[$2 + 138 >> 1] = 0;
  HEAP32[$2 + 140 >> 2] = $2 + 421;
  HEAP32[$2 + 144 >> 2] = 22342;
  HEAP16[$2 + 148 >> 1] = 12;
  HEAP16[$2 + 150 >> 1] = 0;
  HEAP32[$2 + 152 >> 2] = $2 + 420;
  HEAP32[$2 + 156 >> 2] = 15079;
  HEAP16[$2 + 160 >> 1] = 12;
  HEAP16[$2 + 162 >> 1] = 0;
  HEAP32[$2 + 164 >> 2] = $2 + 419;
  HEAP32[$2 + 168 >> 2] = 16374;
  HEAP16[$2 + 172 >> 1] = 12;
  HEAP16[$2 + 174 >> 1] = 0;
  HEAP32[$2 + 176 >> 2] = $2 + 418;
  HEAP32[$2 + 180 >> 2] = 15053;
  HEAP16[$2 + 184 >> 1] = 12;
  HEAP16[$2 + 186 >> 1] = 0;
  HEAP32[$2 + 188 >> 2] = $2 + 417;
  HEAP32[$2 + 192 >> 2] = 4472;
  HEAP16[$2 + 196 >> 1] = 12;
  HEAP16[$2 + 198 >> 1] = 0;
  HEAP32[$2 + 200 >> 2] = $2 + 416;
  HEAP32[$2 + 204 >> 2] = 17274;
  HEAP16[$2 + 208 >> 1] = 12;
  HEAP16[$2 + 210 >> 1] = 0;
  HEAP32[$2 + 212 >> 2] = $2 + 415;
  HEAP32[$2 + 216 >> 2] = 16570;
  HEAP16[$2 + 220 >> 1] = 12;
  HEAP16[$2 + 222 >> 1] = 0;
  HEAP32[$2 + 224 >> 2] = $2 + 414;
  HEAP32[$2 + 228 >> 2] = 3813;
  HEAP16[$2 + 232 >> 1] = 12;
  HEAP16[$2 + 234 >> 1] = 0;
  HEAP32[$2 + 236 >> 2] = $2 + 413;
  HEAP32[$2 + 240 >> 2] = 4422;
  HEAP16[$2 + 244 >> 1] = 10;
  HEAP16[$2 + 246 >> 1] = 0;
  HEAP32[$2 + 248 >> 2] = 440844;
  HEAP32[$2 + 252 >> 2] = 4406;
  HEAP16[$2 + 256 >> 1] = 10;
  HEAP16[$2 + 258 >> 1] = 0;
  HEAP32[$2 + 260 >> 2] = 440832;
  HEAP32[$2 + 264 >> 2] = 4389;
  HEAP16[$2 + 268 >> 1] = 10;
  HEAP16[$2 + 270 >> 1] = 0;
  HEAP32[$2 + 272 >> 2] = 440840;
  HEAP32[$2 + 276 >> 2] = 4434;
  HEAP16[$2 + 280 >> 1] = 10;
  HEAP16[$2 + 282 >> 1] = 0;
  HEAP32[$2 + 284 >> 2] = 440888;
  HEAP32[$2 + 288 >> 2] = 22460;
  HEAP16[$2 + 292 >> 1] = 10;
  HEAP16[$2 + 294 >> 1] = 0;
  HEAP32[$2 + 296 >> 2] = $2 + 392;
  HEAP32[$2 + 300 >> 2] = 22452;
  HEAP16[$2 + 304 >> 1] = 10;
  HEAP16[$2 + 306 >> 1] = 0;
  HEAP32[$2 + 308 >> 2] = $2 + 388;
  HEAP32[$2 + 312 >> 2] = 22388;
  HEAP16[$2 + 316 >> 1] = 10;
  HEAP16[$2 + 318 >> 1] = 0;
  HEAP32[$2 + 320 >> 2] = $2 + 384;
  HEAP32[$2 + 324 >> 2] = 22380;
  HEAP16[$2 + 328 >> 1] = 10;
  HEAP16[$2 + 330 >> 1] = 0;
  HEAP32[$2 + 332 >> 2] = $2 + 380;
  HEAP32[$2 + 336 >> 2] = 7692;
  HEAP16[$2 + 340 >> 1] = 10;
  HEAP16[$2 + 342 >> 1] = 0;
  HEAP32[$2 + 344 >> 2] = $2 + 376;
  HEAP32[$2 + 348 >> 2] = 16299;
  HEAP16[$2 + 352 >> 1] = 12;
  HEAP16[$2 + 354 >> 1] = 0;
  HEAP32[$2 + 356 >> 2] = $2 + 375;
  block : {
   if (HEAP8[$2 + 423 | 0] & 1) {
    HEAP32[$2 + 428 >> 2] = jsvCreateConfigObject($2, 30);
    break block;
   }
   if (jsvReadConfigObject(HEAP32[$2 + 424 >> 2], $2, 30) & 1) {
    HEAP32[110206] = HEAP32[110206] & -3 | (HEAP8[$2 + 422 | 0] & 1 ? 2 : 0);
    HEAP32[110206] = HEAP32[110206] & -5 | (HEAP8[$2 + 421 | 0] & 1 ? 4 : 0);
    HEAP32[110206] = HEAP32[110206] & -9 | (HEAP8[$2 + 420 | 0] & 1 ? 8 : 0);
    HEAP32[110206] = HEAP32[110206] & -2 | HEAP8[$2 + 419 | 0] & 1;
    HEAP32[110206] = HEAP32[110206] & -17 | (HEAP8[$2 + 418 | 0] & 1 ? 16 : 0);
    HEAP32[110206] = HEAP32[110206] & -33 | (HEAP8[$2 + 417 | 0] & 1 ? 32 : 0);
    HEAP32[110206] = HEAP32[110206] & -65 | (HEAP8[$2 + 416 | 0] & 1 ? 64 : 0);
    HEAP32[110206] = HEAP32[110206] & -2049 | (HEAP8[$2 + 415 | 0] & 1 ? 2048 : 0);
    HEAP32[110206] = HEAP32[110206] & -2097153 | (HEAP8[$2 + 414 | 0] & 1 ? 2097152 : 0);
    HEAP32[110206] = HEAP32[110206] & -4194305 | (HEAP8[$2 + 413 | 0] & 1 ? 4194304 : 0);
    if (HEAP32[110211] < 0) {
     HEAP32[110211] = 0
    }
    if (HEAP32[110208] < 0) {
     HEAP32[110208] = 0
    }
    if (HEAP32[110210] < 0) {
     HEAP32[110210] = 0
    }
    HEAP16[122228] = int_sqrt32(HEAP32[$2 + 400 >> 2]);
    HEAP16[122229] = int_sqrt32(HEAP32[$2 + 396 >> 2]);
    HEAP16[220408] = HEAP32[$2 + 392 >> 2];
    HEAP16[220409] = HEAP32[$2 + 388 >> 2];
    HEAP16[122223] = HEAP32[$2 + 384 >> 2];
    HEAP16[122224] = HEAP32[$2 + 380 >> 2];
    HEAP32[110206] = HEAP32[110206] & -1048577 | (HEAP8[$2 + 375 | 0] & 1 ? 1048576 : 0);
   }
   HEAP32[$2 + 428 >> 2] = 0;
  }
  __stack_pointer = $2 + 432 | 0;
  return HEAP32[$2 + 428 >> 2];
 }
 
 function jswrap_banglejs_setOptions($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  _jswrap_banglejs_setOptions(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_banglejs_getOptions() {
  return _jswrap_banglejs_setOptions(0, 1) | 0;
 }
 
 function jswrap_banglejs_isLCDOn() {
  return (HEAP32[110206] & 65536) != 0 | 0;
 }
 
 function jswrap_banglejs_isBacklightOn() {
  return (HEAP32[110206] & 131072) != 0 | 0;
 }
 
 function jswrap_banglejs_setLocked($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  _jswrap_banglejs_setLocked(HEAP8[$1 + 15 | 0] & 1, 7204);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_banglejs_isLocked() {
  return (HEAP32[110206] & 262144) != 0 | 0;
 }
 
 function jswrap_banglejs_isCharging() {
  return (jshPinGetValue(23) ^ -1) & 1;
 }
 
 function jswrap_banglejs_getBattery() {
  return 50;
 }
 
 function jswrap_banglejs_lcdWr($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  $2 = $3;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 >> 2] = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
  if (!(HEAP32[$2 >> 2] | !HEAP32[$2 + 8 >> 2])) {
   HEAP32[$2 + 4 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 8 >> 2]);
   block1 : {
    if (HEAP32[$2 + 4 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 20608, 0);
     break block1;
    }
    $3 = $3 - (HEAP32[$2 + 4 >> 2] + 15 & -16) | 0;
    __stack_pointer = $3;
    HEAP32[$2 >> 2] = $3;
    jsvIterateCallbackToBytes(HEAP32[$2 + 8 >> 2], HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
   }
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_banglejs_setHRMPower($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_isHRMOn() {
  return (HEAP32[110206] & 4096) != 0 | 0;
 }
 
 function jswrap_banglejs_setGPSPower($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_isGPSOn() {
  return (HEAP32[110206] & 8192) != 0 | 0;
 }
 
 function jswrap_banglejs_getGPSFix() {
  return 0;
 }
 
 function jswrap_banglejs_setCompassPower($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_isCompassOn() {
  return (HEAP32[110206] & 16384) != 0 | 0;
 }
 
 function jswrap_banglejs_resetCompass() {
  
 }
 
 function jswrap_banglejs_setBarometerPower($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_isBarometerOn() {
  return (HEAP32[110206] & 32768) != 0 | 0;
 }
 
 function jswrap_banglejs_getStepCount() {
  return HEAP32[110223];
 }
 
 function jswrap_banglejs_setStepCount($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[110223] = HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_banglejs_getCompass() {
  return 0;
 }
 
 function jswrap_banglejs_getAccel() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jsvNewObject();
  if (HEAP32[$0 + 12 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 3934, jsvNewFromFloat(+HEAP16[220448] * .0001220703125));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 3805, jsvNewFromFloat(+HEAP16[220449] * .0001220703125));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 3502, jsvNewFromFloat(+HEAP16[220450] * .0001220703125));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 17053, jsvNewFromFloat(Math_sqrt(+HEAP32[110226]) * .0001220703125));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 17120, jsvNewFromFloat(+HEAPU32[110227] * .0001220703125));
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_banglejs_getHealthStatus($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block1 : {
   block : {
    if (!(jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1)) {
     if (!(jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 15513) & 1)) {
      break block
     }
    }
    HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(440912);
    break block1;
   }
   if (jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 4488) & 1) {
    HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(440931);
    break block1;
   }
   if (jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 3803) & 1) {
    HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(440950);
    break block1;
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
   jsExceptionHere(1, 14766, $1);
   HEAP32[$1 + 12 >> 2] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function _jswrap_banglejs_getHealthStatusObject($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP32[$1 + 24 >> 2] = jsvNewObject();
  if (HEAP32[$1 + 24 >> 2]) {
   $0 = HEAP32[$1 + 28 >> 2];
   $2 = HEAP32[$1 + 28 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 4707, jsvNewFromInteger(((HEAPU8[$0 + 1 | 0] | HEAPU8[$0 + 2 | 0] << 8 | (HEAPU8[$0 + 3 | 0] << 16 | HEAPU8[$0 + 4 | 0] << 24)) >>> 0) / ((HEAPU8[$2 + 5 | 0] | HEAPU8[$2 + 6 | 0] << 8) >>> 0) | 0));
   $0 = HEAP32[$1 + 28 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 7132, jsvNewFromInteger(HEAPU8[$0 + 7 | 0] | HEAPU8[$0 + 8 | 0] << 8));
   $0 = HEAP32[46039];
   $2 = HEAP32[46038];
   HEAP32[$1 + 8 >> 2] = $2;
   HEAP32[$1 + 12 >> 2] = $0;
   $2 = HEAP32[46037];
   $0 = HEAP32[46036];
   HEAP32[$1 >> 2] = $0;
   HEAP32[$1 + 4 >> 2] = $2;
   if (HEAPU8[HEAP32[$1 + 28 >> 2] + 18 | 0] < 4) {
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 3507, jsvNewFromString(HEAP32[(HEAPU8[HEAP32[$1 + 28 >> 2] + 18 | 0] << 2) + $1 >> 2]))
   }
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 24 >> 2];
 }
 
 function jswrap_banglejs_postInit() {
  
 }
 
 function jswrap_banglejs_setTheme() {
  HEAP8[416613] = 0;
  HEAP8[416614] = 0;
  HEAP8[416615] = 255;
  HEAP8[416616] = 255;
  HEAP8[416617] = 0;
  HEAP8[416618] = 0;
  HEAP8[416619] = 255;
  HEAP8[416620] = 191;
  HEAP8[416621] = 0;
  HEAP8[416622] = 0;
  HEAP8[416623] = 255;
  HEAP8[416624] = 7;
  HEAP8[416625] = 0;
 }
 
 function jswrap_banglejs_hwinit() {
  graphicsStructInit(416628, 176, 176, 3);
  HEAP8[416632] = 6;
  HEAP8[416633] = 0;
  HEAP8[416634] = 0;
  HEAP8[416635] = 0;
  HEAP8[416644] = 16;
  HEAP8[416636] = 0;
  HEAP8[416637] = 0;
  HEAP8[416638] = 0;
  HEAP8[416639] = 0;
  HEAP8[416653] = 1;
  HEAP8[416654] = 64;
  lcdMemLCD_init(416628);
  jswrap_banglejs_pwrBacklight(1);
  graphicsSetCallbacks(416628);
  jswrap_banglejs_setTheme();
  graphicsFillRect(416628, 0, 0, 175, 175, HEAPU8[416615] | HEAPU8[416616] << 8);
 }
 
 function jswrap_banglejs_init() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 176 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 174 | 0] = (HEAPU16[207230] & 4096) != 0;
  HEAP8[$0 + 173 | 0] = 0;
  if (HEAP8[$0 + 174 | 0] & 1) {
   HEAP32[110206] = 196686;
   HEAP8[440886] = 255;
   HEAP32[110227] = 0;
   healthStateClear(440912);
   healthStateClear(440931);
   healthStateClear(440950);
   if (jshPinGetValue(17) & 1) {
    HEAP8[$0 + 173 | 0] = 1
   }
  }
  HEAP32[110206] = HEAP32[110206] | 2048;
  HEAP16[220424] = 0;
  HEAP32[110222] = 1500;
  HEAP32[110208] = 0;
  HEAP32[110210] = 3e3;
  HEAP32[110211] = 5e3;
  HEAP8[440854] = 0;
  if (jshPinGetValue(17) & 1) {
   HEAP8[440854] = 1
  }
  HEAP8[440969] = 0;
  HEAP16[220485] = 0;
  if (!(HEAP8[$0 + 173 | 0] & 1)) {
   HEAP32[$0 + 168 >> 2] = jsvNewFromString(15165);
   HEAP32[$0 + 164 >> 2] = jswrap_storage_readJSON(HEAP32[$0 + 168 >> 2], 1);
   jsvUnLock(HEAP32[$0 + 168 >> 2]);
   block : {
    if (jsvIsObject(HEAP32[$0 + 164 >> 2]) & 1) {
     $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 164 >> 2], 15022);
     break block;
    }
    $1 = 0;
   }
   HEAP32[$0 + 160 >> 2] = $1;
   block2 : {
    block1 : {
     if (!HEAP32[$0 + 160 >> 2]) {
      break block1
     }
     if (jsvGetBool(HEAP32[$0 + 160 >> 2]) & 1) {
      break block1
     }
     HEAP32[110206] = HEAP32[110206] & -257;
     break block2;
    }
    HEAP32[110206] = HEAP32[110206] | 256;
    HEAP32[110206] = HEAP32[110206] | 128;
   }
   jsvUnLock(HEAP32[$0 + 160 >> 2]);
   block3 : {
    if (jsvIsObject(HEAP32[$0 + 164 >> 2]) & 1) {
     $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 164 >> 2], 17589);
     break block3;
    }
    $1 = 0;
   }
   HEAP32[$0 + 160 >> 2] = $1;
   block5 : {
    block4 : {
     if (!HEAP32[$0 + 160 >> 2]) {
      break block4
     }
     if (jsvGetBool(HEAP32[$0 + 160 >> 2]) & 1) {
      break block4
     }
     HEAP32[110206] = HEAP32[110206] & -513;
     break block5;
    }
    HEAP32[110206] = HEAP32[110206] | 512;
   }
   jsvUnLock(HEAP32[$0 + 160 >> 2]);
   HEAPF32[61113] = .31439998745918274;
   block6 : {
    if (jsvIsObject(HEAP32[$0 + 164 >> 2]) & 1) {
     $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 164 >> 2], 18087);
     break block6;
    }
    $1 = 0;
   }
   HEAP32[$0 + 160 >> 2] = $1;
   if (jsvIsNumeric(HEAP32[$0 + 160 >> 2]) & 1) {
    HEAPF32[61113] = jsvGetFloatAndUnLock(HEAP32[$0 + 160 >> 2])
   }
   jswrap_banglejs_setTheme();
   block7 : {
    if (jsvIsObject(HEAP32[$0 + 164 >> 2]) & 1) {
     $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 164 >> 2], 17818);
     break block7;
    }
    $1 = 0;
   }
   HEAP32[$0 + 160 >> 2] = $1;
   if (jsvIsObject(HEAP32[$0 + 160 >> 2]) & 1) {
    $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 17024);
    HEAP8[416613] = $1;
    HEAP8[416614] = $1 >>> 8;
    $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 17028);
    HEAP8[416615] = $1;
    HEAP8[416616] = $1 >>> 8;
    $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 22372);
    HEAP8[416617] = $1;
    HEAP8[416618] = $1 >>> 8;
    $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 22376);
    HEAP8[416619] = $1;
    HEAP8[416620] = $1 >>> 8;
    $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 21470);
    HEAP8[416621] = $1;
    HEAP8[416622] = $1 >>> 8;
    $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 21474);
    HEAP8[416623] = $1;
    HEAP8[416624] = $1 >>> 8;
    HEAP8[416625] = jsvObjectGetBoolChild(HEAP32[$0 + 160 >> 2], 15945) & 1;
   }
   jsvUnLock(HEAP32[$0 + 160 >> 2]);
   block8 : {
    if (jsvIsObject(HEAP32[$0 + 164 >> 2]) & 1) {
     $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 164 >> 2], 16368);
     break block8;
    }
    $1 = 0;
   }
   HEAP32[$0 + 160 >> 2] = $1;
   if (jsvIsObject(HEAP32[$0 + 160 >> 2]) & 1) {
    HEAP16[220408] = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 22436);
    HEAP16[220409] = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 22433);
    HEAP16[122223] = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 22356);
    HEAP16[122224] = jsvObjectGetIntegerChild(HEAP32[$0 + 160 >> 2], 22353);
   }
   jsvUnLock(HEAP32[$0 + 160 >> 2]);
   jsvUnLock(HEAP32[$0 + 164 >> 2]);
  }
  jswrap_banglejs_setLCDOffset(0);
  graphicsStructResetState(416628);
  HEAP32[$0 + 156 >> 2] = jspNewObject(0, 7540);
  block9 : {
   if (!HEAP32[$0 + 156 >> 2]) {
    break block9
   }
   jsvObjectSetChild(HEAP32[103307], 17068, HEAP32[$0 + 156 >> 2]);
   jsvObjectSetChild(HEAP32[103308], 3831, HEAP32[$0 + 156 >> 2]);
   $1 = HEAP32[$0 + 156 >> 2];
   HEAP8[416628] = $1;
   HEAP8[416629] = $1 >>> 8;
   HEAP8[416630] = $1 >>> 16;
   HEAP8[416631] = $1 >>> 24;
   HEAP32[$0 + 152 >> 2] = jsvNewNativeFunction(632, 32800);
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 156 >> 2], 15009, HEAP32[$0 + 152 >> 2]);
   block10 : {
    if (HEAP8[$0 + 174 | 0] & 1) {
     break block10
    }
   }
   HEAP8[$0 + 151 | 0] = 1;
   if (HEAPU16[207230] & 64) {
    HEAP8[$0 + 151 | 0] = 0;
    if (!(HEAP8[$0 + 174 | 0] & 1 | HEAP8[$0 + 173 | 0] & 1)) {
     jswrap_banglejs_showLoadingScreen()
    }
   }
   if (HEAP8[$0 + 173 | 0] & 1) {
    HEAP8[$0 + 151 | 0] = 0
   }
   if (HEAP8[$0 + 151 | 0] & 1) {
    HEAP8[416653] = 1;
    HEAP8[416654] = 64;
    graphicsClear(416628);
    HEAP8[$0 + 150 | 0] = 0;
    jsfNameFromString($0 + 116 | 0, 16316);
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 140 >> 2];
    $2 = HEAP32[$0 + 136 >> 2];
    $1 = HEAP32[$0 + 132 >> 2];
    HEAP32[$0 + 24 >> 2] = $1;
    HEAP32[$0 + 28 >> 2] = $2;
    $1 = HEAP32[$0 + 128 >> 2];
    $2 = HEAP32[$0 + 124 >> 2];
    HEAP32[$0 + 16 >> 2] = $2;
    HEAP32[$0 + 20 >> 2] = $1;
    $2 = HEAP32[$0 + 120 >> 2];
    $1 = HEAP32[$0 + 116 >> 2];
    HEAP32[$0 + 8 >> 2] = $1;
    HEAP32[$0 + 12 >> 2] = $2;
    HEAP32[$0 + 144 >> 2] = jsfReadFile($0 + 8 | 0, 0, 0);
    block12 : {
     if (jsvIsString(HEAP32[$0 + 144 >> 2]) & 1) {
      if (!(jsvIsEmptyString(HEAP32[$0 + 144 >> 2]) & 1)) {
       break block12
      }
     }
     jsvUnLock(HEAP32[$0 + 144 >> 2]);
     HEAP8[$0 + 150 | 0] = 1;
     HEAP32[$0 + 144 >> 2] = jswrap_banglejs_getLogo();
    }
    HEAP32[$0 + 112 >> 2] = jsvGetCharInString(HEAP32[$0 + 144 >> 2], 0) & 255;
    HEAP32[$0 + 108 >> 2] = jsvGetCharInString(HEAP32[$0 + 144 >> 2], 1) & 255;
    HEAP32[$0 + 76 >> 2] = jsvNewFromString(18918);
    jsvGetString(HEAP32[$0 + 76 >> 2], $0 + 80 | 0, 20);
    jsvUnLock(HEAP32[$0 + 76 >> 2]);
    HEAP32[$0 + 72 >> 2] = (176 - HEAP32[$0 + 108 >> 2] | 0) / 2;
    jsvUnLock2(jswrap_graphics_drawImage(HEAP32[$0 + 156 >> 2], HEAP32[$0 + 144 >> 2], (176 - HEAP32[$0 + 112 >> 2] | 0) / 2 | 0, HEAP32[$0 + 72 >> 2], 0), HEAP32[$0 + 144 >> 2]);
    if (HEAP8[$0 + 150 | 0] & 1) {
     block13 : {
      if (HEAP32[$0 + 108 >> 2] > 56) {
       HEAP32[$0 + 72 >> 2] = HEAP32[$0 + 72 >> 2] + (HEAP32[$0 + 108 >> 2] - 28 | 0);
       break block13;
      }
      HEAP32[$0 + 72 >> 2] = HEAP32[$0 + 72 >> 2] + (HEAP32[$0 + 108 >> 2] - 15 | 0);
     }
     HEAP32[$0 + 44 >> 2] = jsvNewFromString(18918);
     jsvGetString(HEAP32[$0 + 44 >> 2], $0 + 48 | 0, 20);
     jsvUnLock(HEAP32[$0 + 44 >> 2]);
     jswrap_graphics_drawCString(416628, 8, HEAP32[$0 + 72 >> 2], 22253);
     jswrap_graphics_drawCString(416628, 8, HEAP32[$0 + 72 >> 2] + 10 | 0, $0 + 48 | 0);
     jswrap_graphics_drawCString(416628, 8, HEAP32[$0 + 72 >> 2] + 20 | 0, 7178);
    }
   }
   graphicsInternalFlip();
   graphicsStructResetState(416628);
   if (HEAP8[$0 + 174 | 0] & 1) {
    stepcount_init();
    HEAP32[110223] = 0;
    unistroke_init();
   }
   HEAP8[440972] = 0;
   jshPinSetState(23, 5);
   HEAP32[110244] = 0;
   HEAP32[110245] = 0;
   HEAP32[110246] = 0;
   jshSetPinShouldStayWatched(17, 1);
   HEAP8[$0 + 175 | 0] = jshPinWatch(17, 1, 0);
   if (HEAPU8[$0 + 175 | 0]) {
    jshSetEventCallback(HEAPU8[$0 + 175 | 0], 633)
   }
   if (!(HEAP8[$0 + 174 | 0] & 1)) {
    jsvUnLock(jsiSetTimeout(634, 500.0))
   }
   if (!(HEAP8[$0 + 173 | 0] & 1)) {
    break block9
   }
   jsvUnLock(jspEvaluate(25984, 1));
  }
  __stack_pointer = $0 + 176 | 0;
 }
 
 function healthStateClear($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 | 0] = 0;
  HEAP8[$0 + 1 | 0] = 0;
  HEAP8[$0 + 2 | 0] = 0;
  HEAP8[$0 + 3 | 0] = 0;
  HEAP8[$0 + 4 | 0] = 0;
  HEAP8[$0 + 5 | 0] = 0;
  HEAP8[$0 + 6 | 0] = 0;
  HEAP8[$0 + 7 | 0] = 0;
  HEAP8[$0 + 15 | 0] = 0;
  HEAP8[$0 + 16 | 0] = 0;
  HEAP8[$0 + 17 | 0] = 0;
  HEAP8[$0 + 18 | 0] = 0;
  HEAP8[$0 + 8 | 0] = 0;
  HEAP8[$0 + 9 | 0] = 0;
  HEAP8[$0 + 10 | 0] = 0;
  HEAP8[$0 + 11 | 0] = 0;
  HEAP8[$0 + 12 | 0] = 0;
  HEAP8[$0 + 13 | 0] = 0;
  HEAP8[$0 + 14 | 0] = 0;
  HEAP8[$0 + 15 | 0] = 0;
 }
 
 function jswrap_banglejs_showLoadingScreen() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 80 | 0;
  __stack_pointer = $0;
  jsfNameFromString($0 + 48 | 0, 17015);
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 72 >> 2];
  $2 = HEAP32[$0 + 68 >> 2];
  $1 = HEAP32[$0 + 64 >> 2];
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $2;
  $1 = HEAP32[$0 + 60 >> 2];
  $2 = HEAP32[$0 + 56 >> 2];
  HEAP32[$0 + 8 >> 2] = $2;
  HEAP32[$0 + 12 >> 2] = $1;
  $2 = HEAP32[$0 + 52 >> 2];
  $1 = HEAP32[$0 + 48 >> 2];
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 76 >> 2] = jsfReadFile($0, 0, 0);
  block : {
   if (jsvIsString(HEAP32[$0 + 76 >> 2]) & 1) {
    if (jsvGetStringLength(HEAP32[$0 + 76 >> 2]) >>> 0 > 3) {
     HEAP32[$0 + 44 >> 2] = jsvGetCharInString(HEAP32[$0 + 76 >> 2], 0) & 255;
     HEAP32[$0 + 40 >> 2] = jsvGetCharInString(HEAP32[$0 + 76 >> 2], 1) & 255;
     jsvUnLock2(jswrap_graphics_drawImage(HEAPU8[416628] | HEAPU8[416629] << 8 | (HEAPU8[416630] << 16 | HEAPU8[416631] << 24), HEAP32[$0 + 76 >> 2], (176 - HEAP32[$0 + 44 >> 2] | 0) / 2 | 0, (176 - HEAP32[$0 + 40 >> 2] | 0) / 2 | 0, 0), HEAP32[$0 + 76 >> 2]);
    }
    break block;
   }
   HEAP32[$0 + 36 >> 2] = 88;
   HEAP32[$0 + 32 >> 2] = 88;
   graphicsFillRect(416628, HEAP32[$0 + 36 >> 2] - 49 | 0, HEAP32[$0 + 32 >> 2] - 19 | 0, HEAP32[$0 + 36 >> 2] + 49 | 0, HEAP32[$0 + 32 >> 2] + 19 | 0, HEAPU8[416615] | HEAPU8[416616] << 8);
   $1 = HEAPU8[416613] | HEAPU8[416614] << 8;
   HEAP8[416645] = $1;
   HEAP8[416646] = $1 >>> 8;
   HEAP8[416647] = $1 >>> 16;
   HEAP8[416648] = $1 >>> 24;
   graphicsDrawRect(416628, HEAP32[$0 + 36 >> 2] - 50 | 0, HEAP32[$0 + 32 >> 2] - 20 | 0, HEAP32[$0 + 36 >> 2] + 50 | 0, HEAP32[$0 + 32 >> 2] + 20 | 0);
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] - 4;
   HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] - 24;
   HEAP32[$0 + 28 >> 2] = 22768;
   while (1) {
    if (HEAPU8[HEAP32[$0 + 28 >> 2]]) {
     graphicsDrawChar6x8(416628, HEAP32[$0 + 36 >> 2], HEAP32[$0 + 32 >> 2], HEAP8[HEAP32[$0 + 28 >> 2]] << 24 >> 24, 1, 1, 0);
     HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 6;
     HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1;
     continue;
    }
    break;
   };
  }
  graphicsInternalFlip();
  __stack_pointer = $0 + 80 | 0;
 }
 
 function jswrap_banglejs_getLogo() {
  var $0 = 0;
  $0 = __stack_pointer - 496 | 0;
  __stack_pointer = $0;
  wasm2js_memory_copy($0 + 16 | 0, 183664, 467);
  HEAP32[$0 + 12 >> 2] = jsvNewNativeString($0 + 16 | 0, 467);
  HEAP32[$0 + 8 >> 2] = jswrap_heatshrink_decompress(HEAP32[$0 + 12 >> 2]);
  HEAP32[$0 + 4 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$0 + 8 >> 2], 0);
  jsvUnLock2(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2]);
  __stack_pointer = $0 + 496 | 0;
  return HEAP32[$0 + 4 >> 2];
 }
 
 function jswrap_banglejs_kill() {
  jsvUnLock(HEAP32[110247]);
  HEAP32[110247] = 0;
  jsvUnLock(HEAP32[110248]);
  HEAP32[110248] = 0;
  if (HEAPU16[220485]) {
   jswrap_banglejs_beep_callback()
  }
  if (HEAPU8[440969]) {
   jswrap_banglejs_buzz_callback()
  }
  jshPinWatch(17, 0, 0);
  jshSetPinShouldStayWatched(17, 0);
  lcdMemLCD_setOverlay(0, 0, 0);
  jsvUnLock(HEAPU8[416628] | HEAPU8[416629] << 8 | (HEAPU8[416630] << 16 | HEAPU8[416631] << 24));
  HEAP8[416628] = 0;
  HEAP8[416629] = 0;
  HEAP8[416630] = 0;
  HEAP8[416631] = 0;
 }
 
 function jswrap_banglejs_beep_callback() {
  HEAP16[220485] = 0;
  if (HEAP32[110206] & 128) {
   _jswrap_banglejs_setVibration()
  }
  jshHadEvent();
 }
 
 function jswrap_banglejs_buzz_callback() {
  HEAP8[440969] = 0;
  _jswrap_banglejs_setVibration();
  jshHadEvent();
 }
 
 function jswrap_banglejs_idle() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = __stack_pointer - 144 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 140 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 17919);
  block : {
   if (jsiObjectHasCallbacks(HEAP32[$0 + 140 >> 2], 15844) & 1) {
    HEAP32[110206] = HEAP32[110206] | 1024;
    break block;
   }
   HEAP32[110206] = HEAP32[110206] & -1025;
  }
  if (!HEAP32[$0 + 140 >> 2]) {
   HEAP32[110209] = 0
  }
  if (HEAP32[110209]) {
   if (HEAP32[110209] & 4) {
    jswrap_banglejs_setLCDPower(0)
   }
   if (HEAP32[110209] & 2) {
    jswrap_banglejs_setLCDPower(1)
   }
   if (HEAP32[110209] & 16) {
    jswrap_banglejs_setLCDPowerBacklight(0)
   }
   if (HEAP32[110209] & 8) {
    jswrap_banglejs_setLCDPowerBacklight(1)
   }
   if (HEAP32[110209] & 32) {
    _jswrap_banglejs_setLocked(1, HEAP32[110207]);
    HEAP32[110207] = 0;
   }
   if (HEAP32[110209] & 64) {
    _jswrap_banglejs_setLocked(0, HEAP32[110207]);
    HEAP32[110207] = 0;
   }
   if (HEAP32[110209] & 1) {
    HEAP16[207230] = HEAPU16[207230] | 64
   }
   if (HEAP32[110209] & 67108864) {
    jswrap_banglejs_setPollInterval_internal(80)
   }
   if (HEAP32[110209] & 134217728) {
    jswrap_banglejs_setPollInterval_internal(800)
   }
   if (HEAP32[110209] & 128) {
    HEAP32[$0 + 136 >> 2] = jswrap_banglejs_getAccel();
    if (HEAP32[$0 + 136 >> 2]) {
     jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 15844, $0 + 136 | 0, 1);
     jsvUnLock(HEAP32[$0 + 136 >> 2]);
    }
   }
   if (HEAP32[110209] & 256) {
    HEAP32[$0 + 132 >> 2] = jsvNewObject();
    if (HEAP32[$0 + 132 >> 2]) {
     HEAP32[$0 + 128 >> 2] = 28753;
     if (HEAPU8[440996] & 2) {
      HEAP32[$0 + 128 >> 2] = 4593
     }
     if (HEAP8[440996] & 1) {
      HEAP32[$0 + 128 >> 2] = 15993
     }
     if (HEAPU8[440996] & 8) {
      HEAP32[$0 + 128 >> 2] = 15686
     }
     if (HEAPU8[440996] & 4) {
      HEAP32[$0 + 128 >> 2] = 14904
     }
     if (HEAPU8[440996] & 16) {
      HEAP32[$0 + 128 >> 2] = 4802
     }
     if (HEAPU8[440996] & 32) {
      HEAP32[$0 + 128 >> 2] = 4884
     }
     HEAP32[$0 + 124 >> 2] = HEAPU8[440996] & 128 ? 2 : 1;
     jsvObjectSetChildAndUnLock(HEAP32[$0 + 132 >> 2], 7900, jsvNewFromString(HEAP32[$0 + 128 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$0 + 132 >> 2], 17926, jsvNewFromBool((HEAPU8[440996] & 128) != 0));
     $2 = HEAP32[$0 + 132 >> 2];
     if (HEAPU8[440996] & 16) {
      $1 = 0 - HEAP32[$0 + 124 >> 2] | 0
     } else {
      if (HEAPU8[440996] & 32) {
       $1 = HEAP32[$0 + 124 >> 2]
      } else {
       $1 = 0
      }
     }
     jsvObjectSetChildAndUnLock($2, 3934, jsvNewFromInteger($1));
     $2 = HEAP32[$0 + 132 >> 2];
     if (HEAPU8[440996] & 4) {
      $1 = 0 - HEAP32[$0 + 124 >> 2] | 0
     } else {
      if (HEAPU8[440996] & 8) {
       $1 = HEAP32[$0 + 124 >> 2]
      } else {
       $1 = 0
      }
     }
     jsvObjectSetChildAndUnLock($2, 3805, jsvNewFromInteger($1));
     $2 = HEAP32[$0 + 132 >> 2];
     if (HEAP8[440996] & 1) {
      $1 = 0 - HEAP32[$0 + 124 >> 2] | 0
     } else {
      if (HEAPU8[440996] & 2) {
       $1 = HEAP32[$0 + 124 >> 2]
      } else {
       $1 = 0
      }
     }
     jsvObjectSetChildAndUnLock($2, 3502, jsvNewFromInteger($1));
     jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 15027, $0 + 132 | 0, 1);
     jsvUnLock(HEAP32[$0 + 132 >> 2]);
    }
   }
   if (HEAP32[110209] & 16384) {
    block7 : {
     if (!HEAP32[$0 + 140 >> 2]) {
      break block7
     }
     if (!(jsiObjectHasCallbacks(HEAP32[$0 + 140 >> 2], 17050) & 1)) {
      break block7
     }
     HEAP32[$0 + 120 >> 2] = jswrap_banglejs_getCompass();
     if (HEAP32[$0 + 120 >> 2]) {
      jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 17050, $0 + 120 | 0, 1);
      jsvUnLock(HEAP32[$0 + 120 >> 2]);
     }
    }
   }
   if (HEAP32[110209] & 536870912) {
    HEAP32[$0 + 116 >> 2] = _jswrap_banglejs_getHealthStatusObject(440931);
    if (HEAP32[$0 + 116 >> 2]) {
     jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 16179, $0 + 116 | 0, 1);
     jsvUnLock(HEAP32[$0 + 116 >> 2]);
    }
   }
   if (HEAP32[110209] & 1073741824) {
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 4808, 0, 0)
   }
   if (HEAP32[110209] & 32768) {
    if (jsiObjectHasCallbacks(HEAP32[$0 + 140 >> 2], 17684) & 1) {
     HEAP32[$0 + 112 >> 2] = jsvNewTypedArray(17, Math_imul(HEAPU8[440997], 3));
     if (HEAP32[$0 + 112 >> 2]) {
      HEAP32[$0 + 108 >> 2] = HEAPU8[440998] - Math_imul(HEAPU8[440997], 3);
      while (1) {
       if (HEAP32[$0 + 108 >> 2] < 0) {
        HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 108 >> 2] + 150;
        continue;
       }
       break;
      };
      jsvArrayBufferIteratorNew($0 + 48 | 0, HEAP32[$0 + 112 >> 2], 0);
      HEAP32[$0 + 44 >> 2] = 0;
      while (1) {
       if (HEAP32[$0 + 44 >> 2] < (Math_imul(HEAPU8[440997], 3) | 0)) {
        $1 = HEAP32[$0 + 108 >> 2];
        HEAP32[$0 + 108 >> 2] = $1 + 1;
        jsvArrayBufferIteratorSetByteValue($0 + 48 | 0, HEAP8[$1 + 441008 | 0] << 24 >> 24);
        jsvArrayBufferIteratorNext($0 + 48 | 0);
        if (HEAP32[$0 + 108 >> 2] >= 150) {
         HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 108 >> 2] - 150
        }
        HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 1;
        continue;
       }
       break;
      };
      jsvArrayBufferIteratorFree($0 + 48 | 0);
      jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 17684, $0 + 112 | 0, 1);
      jsvUnLock(HEAP32[$0 + 112 >> 2]);
     }
    }
   }
   if (HEAP32[110209] & 131072) {
    HEAP32[$0 + 40 >> 2] = jsvNewFromBool(HEAP8[441158] & 1);
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 17003, $0 + 40 | 0, 1);
    jsvUnLock(HEAP32[$0 + 40 >> 2]);
   }
   if (HEAP32[110209] & 262144) {
    HEAP32[$0 + 36 >> 2] = jsvNewFromInteger(HEAP32[110223]);
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 15014, $0 + 36 | 0, 1);
    jsvUnLock(HEAP32[$0 + 36 >> 2]);
   }
   if (HEAP32[110209] & 16777216) {
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 4463, 0, 0)
   }
   if (HEAP32[110209] & 33554432) {
    HEAP32[$0 + 32 >> 2] = jsvNewFromBool(HEAP8[441159] & 1);
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 15069, $0 + 32 | 0, 1);
    jsvUnLock(HEAP32[$0 + 32 >> 2]);
   }
   if (HEAP32[110209] & 524288) {
    HEAP32[$0 + 24 >> 2] = jsvNewFromInteger(HEAP32[110219] == 1 ? -1 : HEAP32[110219] == 2);
    HEAP32[($0 + 24 | 0) + 4 >> 2] = jsvNewFromInteger(HEAP32[110219] == 3 ? -1 : HEAP32[110219] == 4);
    HEAP32[110219] = 0;
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 17783, $0 + 24 | 0, 2);
    jsvUnLockMany(2, $0 + 24 | 0);
   }
   if (HEAP32[110209] & 3145728) {
    HEAP32[$0 + 16 >> 2] = jsvNewFromInteger(!!(HEAP32[110209] & 1048576) | (HEAP32[110209] & 2097152 ? 2 : 0));
    HEAP32[$0 + 20 >> 2] = jsvNewObject();
    HEAP32[$0 + 12 >> 2] = HEAP16[220433] << 16 >> 16;
    HEAP32[$0 + 8 >> 2] = HEAP16[220434] << 16 >> 16;
    if (HEAP32[$0 + 12 >> 2] < 0) {
     HEAP32[$0 + 12 >> 2] = 0
    }
    if (HEAP32[$0 + 8 >> 2] < 0) {
     HEAP32[$0 + 8 >> 2] = 0
    }
    if (HEAP32[$0 + 12 >> 2] >= 176) {
     HEAP32[$0 + 12 >> 2] = 175
    }
    if (HEAP32[$0 + 8 >> 2] >= 176) {
     HEAP32[$0 + 8 >> 2] = 175
    }
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 3934, jsvNewFromInteger(HEAP32[$0 + 12 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 3805, jsvNewFromInteger(HEAP32[$0 + 8 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 20 >> 2], 17778, jsvNewFromInteger(HEAPU8[440880]));
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 16355, $0 + 16 | 0, 2);
    jsvUnLockMany(2, $0 + 16 | 0);
   }
  }
  if (HEAP32[110209] & 4194304) {
   HEAP32[$0 + 4 >> 2] = jsvNewObject();
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 4 >> 2], 3934, jsvNewFromInteger(HEAP16[220433] << 16 >> 16));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 4 >> 2], 3805, jsvNewFromInteger(HEAP16[220434] << 16 >> 16));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 4 >> 2], 20533, jsvNewFromInteger(HEAP8[440870] & 1));
   $2 = HEAP32[$0 + 4 >> 2];
   if (HEAP8[440881] & 1) {
    $1 = (HEAP16[220433] << 16 >> 16) - (HEAP16[220441] << 16 >> 16) | 0
   } else {
    $1 = 0
   }
   jsvObjectSetChildAndUnLock($2, 3874, jsvNewFromInteger($1));
   $2 = HEAP32[$0 + 4 >> 2];
   if (HEAP8[440881] & 1) {
    $1 = (HEAP16[220434] << 16 >> 16) - (HEAP16[220442] << 16 >> 16) | 0
   } else {
    $1 = 0
   }
   jsvObjectSetChildAndUnLock($2, 3632, jsvNewFromInteger($1));
   jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 17042, $0 + 4 | 0, 1);
   jsvUnLock(HEAP32[$0 + 4 >> 2]);
   HEAP16[220441] = HEAPU16[220433];
   HEAP16[220442] = HEAPU16[220434];
   HEAP8[440881] = HEAP8[440870] & 1;
  }
  if (HEAP32[110209] & 8388608) {
   HEAP32[$0 >> 2] = unistroke_getEventVar();
   if (HEAP32[$0 >> 2]) {
    jsiQueueObjectCallbacks(HEAP32[$0 + 140 >> 2], 18043, $0, 1);
    jsvUnLock(HEAP32[$0 >> 2]);
   }
  }
  jsvUnLock(HEAP32[$0 + 140 >> 2]);
  HEAP32[110209] = 0;
  if ((HEAPU8[416672] | HEAPU8[416673] << 8) << 16 >> 16 >= (HEAPU8[416668] | HEAPU8[416669] << 8) << 16 >> 16) {
   graphicsInternalFlip()
  }
  if (!(HEAPU8[440969] | !HEAP32[110248])) {
   jspromise_resolve(HEAP32[110248], 0);
   jsvUnLock(HEAP32[110248]);
   HEAP32[110248] = 0;
  }
  if (!(HEAPU16[220485] | !HEAP32[110247])) {
   jspromise_resolve(HEAP32[110247], 0);
   jsvUnLock(HEAP32[110247]);
   HEAP32[110247] = 0;
  }
  __stack_pointer = $0 + 144 | 0;
  return 0;
 }
 
 function jswrap_banglejs_gps_character($0) {
  HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
  return 1;
 }
 
 function jswrap_banglejs_dbg() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = jsvNewObject();
  block : {
   if (!HEAP32[$0 + 8 >> 2]) {
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 3863, jsvNewFromInteger(HEAPU8[440998]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 4543, jsvNewFromInteger(HEAPU8[441160]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 4569, jsvNewFromInteger(HEAPU8[441161]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 15879, jsvNewFromInteger(HEAPU16[220425]));
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_banglejs_touchWr($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jswrap_banglejs_touchRd($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_accelWr($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jswrap_banglejs_accelRd($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_barometerWr($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jswrap_banglejs_barometerRd($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_compassWr($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jswrap_banglejs_compassRd($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_hrmWr($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
 }
 
 function jswrap_banglejs_hrmRd($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return 0;
 }
 
 function jswrap_banglejs_getPressure() {
  return HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2];
 }
 
 function jswrap_banglejs_project($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 60 >> 2] = $0;
  HEAPF64[$1 + 48 >> 3] = .017453292519943295;
  HEAPF64[$1 + 40 >> 3] = 85.0511287798;
  HEAPF64[$1 + 32 >> 3] = 6378137;
  HEAPF64[$1 + 24 >> 3] = jsvObjectGetFloatChild(HEAP32[$1 + 60 >> 2], 5038);
  HEAPF64[$1 + 16 >> 3] = jsvObjectGetFloatChild(HEAP32[$1 + 60 >> 2], 15178);
  if (HEAPF64[$1 + 24 >> 3] > 85.0511287798) {
   HEAPF64[$1 + 24 >> 3] = 85.0511287798
  }
  if (HEAPF64[$1 + 24 >> 3] < -85.0511287798) {
   HEAPF64[$1 + 24 >> 3] = -85.0511287798
  }
  HEAPF64[$1 + 8 >> 3] = jswrap_math_sin(HEAPF64[$1 + 24 >> 3] * .017453292519943295);
  HEAP32[$1 + 4 >> 2] = jsvNewObject();
  if (HEAP32[$1 + 4 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 3934, jsvNewFromFloat(HEAPF64[$1 + 16 >> 3] * 6378137.0 * .017453292519943295));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 3805, jsvNewFromFloat(log((HEAPF64[$1 + 8 >> 3] + 1.0) / (1.0 - HEAPF64[$1 + 8 >> 3])) * 6378137.0 * .5));
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function _jswrap_banglejs_setVibration() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 0;
  if (HEAP32[110206] & 128) {
   HEAP32[$0 + 12 >> 2] = HEAPU16[220485]
  }
  block1 : {
   if (!(HEAPU8[440969] | HEAP32[$0 + 12 >> 2])) {
    jshPinOutput(19, 0);
    break block1;
   }
   block2 : {
    if (!HEAP32[$0 + 12 >> 2]) {
     jshPinAnalogOutput(19, +HEAPU8[440969] * .6 / 255.0 + .4, 1.0e3, 0);
     break block2;
    }
    jshPinAnalogOutput(19, +HEAPU8[440969] * .6 / 255.0 + .2, +HEAP32[$0 + 12 >> 2], 0);
   }
  }
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jswrap_banglejs_beep($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  if (HEAP32[$2 + 8 >> 2] <= 0) {
   HEAP32[$2 + 8 >> 2] = 4e3
  }
  if (HEAP32[$2 + 8 >> 2] > 6e4) {
   HEAP32[$2 + 8 >> 2] = 6e4
  }
  if (HEAP32[$2 + 12 >> 2] <= 0) {
   HEAP32[$2 + 12 >> 2] = 200
  }
  if (HEAP32[$2 + 12 >> 2] > 5e3) {
   HEAP32[$2 + 12 >> 2] = 5e3
  }
  $0 = jswrap_promise_resolve(0);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_banglejs_buzz($0, $1) {
  $0 = $0 | 0;
  $1 = +$1;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAPF64[$2 + 16 >> 3] = $1;
  __DOUBLE_BITS_1314(HEAPF64[$2 + 16 >> 3]);
  $0 = i64toi32_i32$HIGH_BITS & 2147483647;
  block1 : {
   if (!(($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072)) {
    if (!(HEAPF64[$2 + 16 >> 3] > 1.0)) {
     break block1
    }
   }
   HEAPF64[$2 + 16 >> 3] = 1;
  }
  if (HEAPF64[$2 + 16 >> 3] < 0.0) {
   HEAPF64[$2 + 16 >> 3] = 0
  }
  if (HEAP32[$2 + 28 >> 2] <= 0) {
   HEAP32[$2 + 28 >> 2] = 200
  }
  if (HEAP32[$2 + 28 >> 2] > 5e3) {
   HEAP32[$2 + 28 >> 2] = 5e3
  }
  $0 = jswrap_promise_resolve(0);
  __stack_pointer = $2 + 32 | 0;
  return $0 | 0;
 }
 
 function jswrap_banglejs_off() {
  jsExceptionHere(1, 7816, 0);
 }
 
 function jswrap_banglejs_softOff() {
  jsExceptionHere(1, 7816, 0);
 }
 
 function jswrap_banglejs_factoryReset($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jsfResetStorage();
  if (!(HEAP8[$1 + 15 | 0] & 1)) {
   HEAP16[207230] = HEAPU16[207230] | 64
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_banglejs_appRect() {
  var $0 = 0;
  $0 = __stack_pointer - 48 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 40 >> 2] = jsvNewObject();
  block : {
   if (!HEAP32[$0 + 40 >> 2]) {
    HEAP32[$0 + 44 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 21126);
   HEAP32[$0 + 32 >> 2] = 0;
   HEAP32[$0 + 28 >> 2] = 0;
   if (jsvIsObject(HEAP32[$0 + 36 >> 2]) & 1) {
    jsvObjectIteratorNew($0 + 24 | 0, HEAP32[$0 + 36 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_1374($0 + 24 | 0) & 1) {
      HEAP32[$0 + 20 >> 2] = jsvObjectIteratorGetValue_1375($0 + 24 | 0);
      HEAP32[$0 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 20 >> 2], 20649);
      HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 20 >> 2], 16247);
      block1 : {
       if (!(jsvIsString(HEAP32[$0 + 16 >> 2]) & 1)) {
        break block1
       }
       if (!(jsvIsNumeric(HEAP32[$0 + 12 >> 2]) & 1)) {
        break block1
       }
       HEAP8[$0 + 11 | 0] = jsvGetCharInString(HEAP32[$0 + 16 >> 2], 0);
       HEAP32[$0 + 4 >> 2] = jsvGetIntegerAndUnLock(HEAP32[$0 + 12 >> 2]);
       if (!(HEAPU8[$0 + 11 | 0] != 116 | HEAP32[$0 + 4 >> 2] <= 0)) {
        HEAP32[$0 + 32 >> 2] = 24
       }
       if (!(HEAPU8[$0 + 11 | 0] != 98 | HEAP32[$0 + 4 >> 2] <= 0)) {
        HEAP32[$0 + 28 >> 2] = 24
       }
      }
      jsvUnLock2(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]);
      jsvObjectIteratorNext($0 + 24 | 0);
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1376($0 + 24 | 0);
   }
   jsvUnLock(HEAP32[$0 + 36 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 3934, jsvNewFromInteger(0));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 3805, jsvNewFromInteger(HEAP32[$0 + 32 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 4131, jsvNewFromInteger(HEAPU8[416640] | HEAPU8[416641] << 8));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 16557, jsvNewFromInteger((HEAPU8[416642] | HEAPU8[416643] << 8) - (HEAP32[$0 + 32 >> 2] + HEAP32[$0 + 28 >> 2] | 0) | 0));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 22356, jsvNewFromInteger((HEAPU8[416640] | HEAPU8[416641] << 8) - 1 | 0));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 22353, jsvNewFromInteger((HEAPU8[416642] | HEAPU8[416643] << 8) - (HEAP32[$0 + 28 >> 2] + 1 | 0) | 0));
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 40 >> 2];
  }
  __stack_pointer = $0 + 48 | 0;
  return HEAP32[$0 + 44 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1374($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1375($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1376($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsbangle_exec_pending($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAPU8[HEAP32[$2 + 28 >> 2]];
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP16[$2 + 18 >> 1] = HEAPU8[$0 + 1 | 0] | HEAPU8[$0 + 2 | 0] << 8;
  if (!HEAP32[$2 + 20 >> 2]) {
   HEAP32[$2 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[103307], 17919);
   if (HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 8 >> 2] = jsvNewFromInteger(HEAPU16[$2 + 18 >> 1]);
    jsiQueueObjectCallbacks(HEAP32[$2 + 12 >> 2], 4133, $2 + 8 | 0, 1);
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_banglejs_powerusage($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (jswrap_banglejs_isBacklightOn()) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 4833, jsvNewFromInteger(14e3))
  }
  if (!jswrap_banglejs_isLocked()) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 16364, jsvNewFromInteger(1600))
  }
  if (jswrap_banglejs_isHRMOn()) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 21226, jsvNewFromInteger(700))
  }
  if (jswrap_banglejs_isGPSOn()) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 21134, jsvNewFromInteger(2e4))
  }
  if (jswrap_banglejs_isCompassOn()) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 6937, jsvNewFromInteger(600))
  }
  if (jswrap_banglejs_isBarometerOn()) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 15109, jsvNewFromInteger(200))
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_graphics_setFont14($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvNewNativeString(184160, 7546);
  HEAP32[$2 >> 2] = jswrap_graphics_setFontPBF(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 >> 2];
 }
 
 function jswrap_graphics_setFont17($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvNewNativeString(191712, 9001);
  HEAP32[$2 >> 2] = jswrap_graphics_setFontPBF(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 >> 2];
 }
 
 function jswrap_graphics_setFont22($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvNewNativeString(200720, 11459);
  HEAP32[$2 >> 2] = jswrap_graphics_setFontPBF(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 >> 2];
 }
 
 function jswrap_graphics_setFont28($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvNewNativeString(212192, 14905);
  HEAP32[$2 >> 2] = jswrap_graphics_setFontPBF(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 >> 2];
 }
 
 function jswrap_graphics_setFont6x15($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  if (HEAP32[$2 + 24 >> 2] <= 0) {
   HEAP32[$2 + 24 >> 2] = 1
  }
  HEAP32[$2 + 20 >> 2] = jsvNewNativeString(227104, 1842);
  HEAP32[$2 + 16 >> 2] = jsvNewNativeString(228960, 224);
  HEAP32[$2 + 12 >> 2] = jswrap_graphics_setFontCustom(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 32, HEAP32[$2 + 16 >> 2], (HEAP32[$2 + 24 >> 2] << 8) + 15 | 0);
  jsvUnLock2(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_graphics_setFont12x20($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  if (HEAP32[$2 + 24 >> 2] <= 0) {
   HEAP32[$2 + 24 >> 2] = 1
  }
  HEAP32[$2 + 20 >> 2] = jsvNewNativeString(229184, 4723);
  HEAP32[$2 + 16 >> 2] = jsvNewNativeString(233920, 224);
  HEAP32[$2 + 12 >> 2] = jswrap_graphics_setFontCustom(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 32, HEAP32[$2 + 16 >> 2], (HEAP32[$2 + 24 >> 2] << 8) + 20 | 0);
  jsvUnLock2(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_unistroke_new($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = unistroke_convert(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_unistroke_recognise($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = unistroke_recognise_xy(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_array_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block1 : {
   if ((jsvGetArrayLength(HEAP32[$1 + 24 >> 2]) | 0) == 1) {
    HEAP32[$1 + 20 >> 2] = jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 24 >> 2], 0));
    if (jsvIsNumeric(HEAP32[$1 + 20 >> 2]) & 1) {
     HEAPF64[$1 + 8 >> 3] = jsvGetFloat(HEAP32[$1 + 20 >> 2]);
     HEAP32[$1 + 4 >> 2] = jsvGetInteger(HEAP32[$1 + 20 >> 2]);
     jsvUnLock(HEAP32[$1 + 20 >> 2]);
     if (!(HEAP32[$1 + 4 >> 2] >= 0 & HEAPF64[$1 + 8 >> 3] == +HEAP32[$1 + 4 >> 2])) {
      jsExceptionHere(1, 16198, 0);
      HEAP32[$1 + 28 >> 2] = 0;
      break block1;
     }
     HEAP32[$1 >> 2] = jsvNewEmptyArray();
     if (!HEAP32[$1 >> 2]) {
      HEAP32[$1 + 28 >> 2] = 0;
      break block1;
     }
     jsvSetArrayLength(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], 0);
     HEAP32[$1 + 28 >> 2] = HEAP32[$1 >> 2];
     break block1;
    }
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
   }
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jswrap_array_indexOf($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = jsvGetIndexOfFull(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0, 1, HEAP32[$3 + 16 >> 2]);
  block : {
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = jsvNewFromInteger(-1);
    break block;
   }
   HEAP32[$3 + 28 >> 2] = jsvNewFromInteger(jsvGetIntegerAndUnLock(HEAP32[$3 + 12 >> 2]));
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jswrap_array_includes($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 112 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 104 >> 2] = $0;
  HEAP32[$3 + 100 >> 2] = $1;
  HEAP32[$3 + 96 >> 2] = $2;
  if (HEAP32[$3 + 96 >> 2] < 0) {
   HEAP32[$3 + 96 >> 2] = jsvGetLength(HEAP32[$3 + 104 >> 2]) + HEAP32[$3 + 96 >> 2]
  }
  if (HEAP32[$3 + 96 >> 2] < 0) {
   HEAP32[$3 + 96 >> 2] = 0
  }
  if (jsvIsFloat(HEAP32[$3 + 100 >> 2]) & 1) {
   $0 = __DOUBLE_BITS_1390(jsvGetFloat(HEAP32[$3 + 100 >> 2]));
   $2 = $0;
   $1 = i64toi32_i32$HIGH_BITS;
   $0 = $1 & 2147483647;
   $1 = $2;
   $4 = ($0 | 0) == 2146435072 & ($1 | 0) != 0 | $0 >>> 0 > 2146435072;
  }
  HEAP8[$3 + 95 | 0] = $4;
  block : {
   if (!(jsvIsIterable(HEAP32[$3 + 104 >> 2]) & 1)) {
    HEAP8[$3 + 111 | 0] = 0;
    break block;
   }
   jsvIteratorNew($3 + 28 | 0, HEAP32[$3 + 104 >> 2], jsvIsUndefined(HEAP32[$3 + 100 >> 2]) & 1);
   while (1) {
    if (jsvIteratorHasElement($3 + 28 | 0) & 1) {
     HEAP32[$3 + 24 >> 2] = jsvIteratorGetKey($3 + 28 | 0);
     block1 : {
      if (!(jsvIsInt(HEAP32[$3 + 24 >> 2]) & 1)) {
       break block1
      }
      if ((jsvGetInteger(HEAP32[$3 + 24 >> 2]) | 0) < HEAP32[$3 + 96 >> 2]) {
       break block1
      }
      HEAP32[$3 + 20 >> 2] = jsvIteratorGetValue($3 + 28 | 0);
      block3 : {
       block2 : {
        if (HEAP32[$3 + 20 >> 2] == HEAP32[$3 + 100 >> 2]) {
         break block2
        }
        if (jsvMathsOpTypeEqual(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 100 >> 2]) & 1) {
         break block2
        }
        if (!(HEAP8[$3 + 95 | 0] & 1)) {
         break block3
        }
        if (!(jsvIsFloat(HEAP32[$3 + 20 >> 2]) & 1)) {
         break block3
        }
        $1 = __DOUBLE_BITS_1390(jsvGetFloat(HEAP32[$3 + 20 >> 2]));
        $2 = $1;
        $0 = i64toi32_i32$HIGH_BITS;
        $1 = $0 & 2147483647;
        $0 = $2;
        if (($1 | 0) == 2146435072 & ($0 | 0) != 0 | $1 >>> 0 > 2146435072) {
         break block2
        }
        break block3;
       }
       jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
       jsvIteratorFree($3 + 28 | 0);
       HEAP8[$3 + 111 | 0] = 1;
       break block;
      }
      jsvUnLock(HEAP32[$3 + 20 >> 2]);
     }
     jsvUnLock(HEAP32[$3 + 24 >> 2]);
     jsvIteratorNext($3 + 28 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 28 | 0);
   HEAP8[$3 + 111 | 0] = 0;
  }
  __stack_pointer = $3 + 112 | 0;
  return HEAP8[$3 + 111 | 0] & 1;
 }
 
 function __DOUBLE_BITS_1390($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_array_join($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (!(jsvIsIterable(HEAP32[$2 + 8 >> 2]) & 1)) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   block1 : {
    if (jsvIsUndefined(HEAP32[$2 + 4 >> 2]) & 1) {
     HEAP32[$2 + 4 >> 2] = jsvNewFromString(22853);
     break block1;
    }
    HEAP32[$2 + 4 >> 2] = jsvAsString(HEAP32[$2 + 4 >> 2]);
   }
   if (!HEAP32[$2 + 4 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$2 >> 2] = jsvArrayJoin(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 1);
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_array_push($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (!(jsvIsArray(HEAP32[$2 + 24 >> 2]) & 1)) {
    HEAP32[$2 + 28 >> 2] = -1;
    break block;
   }
   HEAP32[$2 + 16 >> 2] = -1;
   jsvObjectIteratorNew($2 + 12 | 0, HEAP32[$2 + 20 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1394($2 + 12 | 0) & 1) {
     HEAP32[$2 + 8 >> 2] = jsvObjectIteratorGetValue_1395($2 + 12 | 0);
     HEAP32[$2 + 16 >> 2] = jsvArrayPush(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 8 >> 2]);
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     jsvObjectIteratorNext($2 + 12 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1396($2 + 12 | 0);
   if (HEAP32[$2 + 16 >> 2] < 0) {
    HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2])
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1394($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1395($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1396($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_array_map($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1, 0, 0);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function _jswrap_array_iterate_with_callback($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 144 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 136 >> 2] = $0;
  HEAP32[$6 + 132 >> 2] = $1;
  HEAP32[$6 + 128 >> 2] = $2;
  HEAP32[$6 + 124 >> 2] = $3;
  HEAP8[$6 + 123 | 0] = $4;
  HEAP8[$6 + 122 | 0] = $5;
  block : {
   if (!(jsvIsIterable(HEAP32[$6 + 136 >> 2]) & 1)) {
    jsExceptionHere(1, 17962, 0);
    HEAP32[$6 + 140 >> 2] = 0;
    break block;
   }
   if (!(jsvIsFunction(HEAP32[$6 + 132 >> 2]) & 1)) {
    jsExceptionHere(1, 15357, 0);
    HEAP32[$6 + 140 >> 2] = 0;
    break block;
   }
   block1 : {
    if (jsvIsUndefined(HEAP32[$6 + 128 >> 2]) & 1) {
     break block1
    }
    if (jsvIsObject(HEAP32[$6 + 128 >> 2]) & 1) {
     break block1
    }
    jsExceptionHere(1, 19004, 0);
    HEAP32[$6 + 140 >> 2] = 0;
    break block;
   }
   HEAP32[$6 + 116 >> 2] = 0;
   if (HEAP32[$6 + 124 >> 2] == 1) {
    HEAP32[$6 + 116 >> 2] = jsvNewEmptyArray()
   }
   HEAP8[$6 + 115 | 0] = 0;
   if (!(!HEAP32[$6 + 116 >> 2] & HEAP32[$6 + 124 >> 2] == 1)) {
    jsvIteratorNew($6 + 48 | 0, HEAP32[$6 + 136 >> 2], 0);
    while (1) {
     $0 = 0;
     if (jsvIteratorHasElement($6 + 48 | 0) & 1) {
      $0 = HEAPU8[$6 + 115 | 0] ^ -1
     }
     if ($0 & 1) {
      HEAP32[$6 + 44 >> 2] = jsvIteratorGetKey($6 + 48 | 0);
      block8 : {
       if (jsvIsInt(HEAP32[$6 + 44 >> 2]) & 1) {
        HEAP32[$6 + 40 >> 2] = jsvGetInteger(HEAP32[$6 + 44 >> 2]);
        HEAP32[$6 + 36 >> 2] = jsvIteratorGetValue($6 + 48 | 0);
        HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 36 >> 2];
        HEAP32[$6 + 28 >> 2] = jsvNewFromInteger(HEAP32[$6 + 40 >> 2]);
        HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 136 >> 2];
        jsvIteratorNext($6 + 48 | 0);
        HEAP32[$6 + 20 >> 2] = jspeFunctionCall(HEAP32[$6 + 132 >> 2], 0, HEAP32[$6 + 128 >> 2], 0, 3, $6 + 24 | 0);
        jsvUnLock(HEAP32[$6 + 28 >> 2]);
        block7 : {
         if (HEAP8[$6 + 123 | 0] & 1) {
          HEAP8[$6 + 19 | 0] = (jsvGetBool(HEAP32[$6 + 20 >> 2]) & 1) == (HEAP8[$6 + 122 | 0] & 1);
          block3 : {
           if (HEAP32[$6 + 124 >> 2] == 1) {
            if (HEAP8[$6 + 19 | 0] & 1) {
             jsvArrayPush(HEAP32[$6 + 116 >> 2], HEAP32[$6 + 36 >> 2])
            }
            break block3;
           }
           block6 : {
            if (!(HEAP32[$6 + 124 >> 2] != 2 & HEAP32[$6 + 124 >> 2] != 3)) {
             if (HEAP8[$6 + 19 | 0] & 1) {
              block5 : {
               if (HEAP32[$6 + 124 >> 2] == 2) {
                $0 = jsvLockAgain(HEAP32[$6 + 36 >> 2]);
                break block5;
               }
               $0 = jsvNewFromInteger(jsvGetInteger(HEAP32[$6 + 44 >> 2]));
              }
              HEAP32[$6 + 116 >> 2] = $0;
              HEAP8[$6 + 115 | 0] = 1;
             }
             break block6;
            }
            if (!(HEAP8[$6 + 19 | 0] & 1)) {
             HEAP8[$6 + 115 | 0] = 1
            }
           }
          }
          break block7;
         }
         if (HEAP32[$6 + 124 >> 2] == 1) {
          HEAP32[$6 + 12 >> 2] = jsvNewFromInteger(HEAP32[$6 + 40 >> 2]);
          if (HEAP32[$6 + 12 >> 2]) {
           HEAP32[$6 + 12 >> 2] = jsvMakeIntoVariableName(HEAP32[$6 + 12 >> 2], HEAP32[$6 + 20 >> 2]);
           jsvAddName(HEAP32[$6 + 116 >> 2], HEAP32[$6 + 12 >> 2]);
           jsvUnLock(HEAP32[$6 + 12 >> 2]);
          }
         }
        }
        jsvUnLock2(HEAP32[$6 + 20 >> 2], HEAP32[$6 + 36 >> 2]);
        break block8;
       }
       jsvIteratorNext($6 + 48 | 0);
      }
      jsvUnLock(HEAP32[$6 + 44 >> 2]);
      continue;
     }
     break;
    };
    jsvIteratorFree($6 + 48 | 0);
   }
   if (!(HEAP32[$6 + 124 >> 2] | !(HEAP8[$6 + 123 | 0] & 1))) {
    HEAP32[$6 + 116 >> 2] = jsvNewFromBool((HEAP8[$6 + 115 | 0] & 1) != (HEAP8[$6 + 122 | 0] & 1))
   }
   HEAP32[$6 + 140 >> 2] = HEAP32[$6 + 116 >> 2];
  }
  __stack_pointer = $6 + 144 | 0;
  return HEAP32[$6 + 140 >> 2];
 }
 
 function jswrap_array_forEach($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 0, 0);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_array_filter($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1, 1, 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_array_find($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = _jswrap_array_iterate_with_callback(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 2, 1, 1);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_array_findIndex($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = _jswrap_array_iterate_with_callback(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 0, 3, 1, 1);
  block : {
   if (HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(-1);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_array_some($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 1, 0);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_array_every($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 1, 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_array_reduce($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 128 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 120 >> 2] = $0;
  HEAP32[$3 + 116 >> 2] = $1;
  HEAP32[$3 + 112 >> 2] = $2;
  block : {
   if (!(jsvIsIterable(HEAP32[$3 + 120 >> 2]) & 1)) {
    jsExceptionHere(1, 17962, 0);
    HEAP32[$3 + 124 >> 2] = 0;
    break block;
   }
   if (!(jsvIsFunction(HEAP32[$3 + 116 >> 2]) & 1)) {
    jsExceptionHere(1, 15357, 0);
    HEAP32[$3 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 108 >> 2] = jsvLockAgainSafe(HEAP32[$3 + 112 >> 2]);
   jsvIteratorNew($3 + 44 | 0, HEAP32[$3 + 120 >> 2], 0);
   if (!HEAP32[$3 + 108 >> 2]) {
    HEAP8[$3 + 43 | 0] = 0;
    while (1) {
     $0 = 0;
     if (!(HEAP8[$3 + 43 | 0] & 1)) {
      $0 = jsvIteratorHasElement($3 + 44 | 0)
     }
     if ($0 & 1) {
      HEAP32[$3 + 36 >> 2] = jsvIteratorGetKey($3 + 44 | 0);
      if (jsvIsInt(HEAP32[$3 + 36 >> 2]) & 1) {
       HEAP32[$3 + 108 >> 2] = jsvIteratorGetValue($3 + 44 | 0);
       HEAP8[$3 + 43 | 0] = 1;
      }
      jsvUnLock(HEAP32[$3 + 36 >> 2]);
      jsvIteratorNext($3 + 44 | 0);
      continue;
     }
     break;
    };
    if (!HEAP32[$3 + 108 >> 2]) {
     jsExceptionHere(1, 17347, 0)
    }
   }
   while (1) {
    if (jsvIteratorHasElement($3 + 44 | 0) & 1) {
     HEAP32[$3 + 32 >> 2] = jsvIteratorGetKey($3 + 44 | 0);
     if (jsvIsInt(HEAP32[$3 + 32 >> 2]) & 1) {
      HEAP32[$3 + 28 >> 2] = jsvGetInteger(HEAP32[$3 + 32 >> 2]);
      HEAP32[$3 >> 2] = HEAP32[$3 + 108 >> 2];
      HEAP32[$3 + 4 >> 2] = jsvIteratorGetValue($3 + 44 | 0);
      HEAP32[$3 + 8 >> 2] = jsvNewFromInteger(HEAP32[$3 + 28 >> 2]);
      HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 120 >> 2];
      HEAP32[$3 + 108 >> 2] = jspeFunctionCall(HEAP32[$3 + 116 >> 2], 0, 0, 0, 4, $3);
      jsvUnLockMany(3, $3);
     }
     jsvUnLock(HEAP32[$3 + 32 >> 2]);
     jsvIteratorNext($3 + 44 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 44 | 0);
   HEAP32[$3 + 124 >> 2] = HEAP32[$3 + 108 >> 2];
  }
  __stack_pointer = $3 + 128 | 0;
  return HEAP32[$3 + 124 >> 2];
 }
 
 function jswrap_array_splice($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 88 >> 2] = $0;
  HEAP32[$4 + 84 >> 2] = $1;
  HEAP32[$4 + 80 >> 2] = $2;
  HEAP32[$4 + 76 >> 2] = $3;
  block : {
   if (!(jsvIsArray(HEAP32[$4 + 88 >> 2]) & 1)) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 72 >> 2] = jsvGetArrayLength(HEAP32[$4 + 88 >> 2]);
   if (HEAP32[$4 + 84 >> 2] < 0) {
    HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 72 >> 2] + HEAP32[$4 + 84 >> 2]
   }
   if (HEAP32[$4 + 84 >> 2] < 0) {
    HEAP32[$4 + 84 >> 2] = 0
   }
   if (HEAP32[$4 + 84 >> 2] > HEAP32[$4 + 72 >> 2]) {
    HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 72 >> 2]
   }
   HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 72 >> 2];
   if (jsvIsNumeric(HEAP32[$4 + 80 >> 2]) & 1) {
    HEAP32[$4 + 68 >> 2] = jsvGetInteger(HEAP32[$4 + 80 >> 2])
   }
   if (HEAP32[$4 + 68 >> 2] > (HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 84 >> 2] | 0)) {
    HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 84 >> 2]
   }
   HEAP32[$4 + 64 >> 2] = jsvGetArrayLength(HEAP32[$4 + 76 >> 2]);
   HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 64 >> 2] - HEAP32[$4 + 68 >> 2];
   HEAP8[$4 + 59 | 0] = 0;
   HEAP32[$4 + 52 >> 2] = jsvNewEmptyArray();
   jsvObjectIteratorNew($4 + 48 | 0, HEAP32[$4 + 88 >> 2]);
   while (1) {
    $0 = 0;
    if (jsvObjectIteratorHasValue_1394($4 + 48 | 0) & 1) {
     $0 = HEAPU8[$4 + 59 | 0] ^ -1
    }
    if ($0 & 1) {
     HEAP8[$4 + 47 | 0] = 1;
     HEAP32[$4 + 40 >> 2] = jsvObjectIteratorGetKey_1407($4 + 48 | 0);
     block1 : {
      if (!HEAP32[$4 + 40 >> 2]) {
       break block1
      }
      if (!(jsvIsInt(HEAP32[$4 + 40 >> 2]) & 1)) {
       break block1
      }
      HEAP32[$4 + 36 >> 2] = jsvGetInteger(HEAP32[$4 + 40 >> 2]);
      if (HEAP32[$4 + 36 >> 2] >= HEAP32[$4 + 84 >> 2]) {
       block2 : {
        if (HEAP32[$4 + 36 >> 2] < (HEAP32[$4 + 84 >> 2] + HEAP32[$4 + 68 >> 2] | 0)) {
         if (HEAP32[$4 + 52 >> 2]) {
          HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetValue_1395($4 + 48 | 0);
          jsvArrayPushAndUnLock(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 32 >> 2]);
         }
         HEAP8[$4 + 47 | 0] = 0;
         HEAP32[$4 + 28 >> 2] = jsvObjectIteratorGetKey_1407($4 + 48 | 0);
         jsvObjectIteratorNext($4 + 48 | 0);
         jsvRemoveChildAndUnLock(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 28 >> 2]);
         break block2;
        }
        HEAP8[$4 + 59 | 0] = 1;
        HEAP8[$4 + 47 | 0] = 0;
       }
      }
     }
     jsvUnLock(HEAP32[$4 + 40 >> 2]);
     if (HEAP8[$4 + 47 | 0] & 1) {
      jsvObjectIteratorNext($4 + 48 | 0)
     }
     continue;
    }
    break;
   };
   HEAP32[$4 + 24 >> 2] = jsvObjectIteratorGetKey_1407($4 + 48 | 0);
   jsvObjectIteratorNew($4 + 20 | 0, HEAP32[$4 + 76 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1394($4 + 20 | 0) & 1) {
     HEAP32[$4 + 16 >> 2] = jsvObjectIteratorGetValue_1395($4 + 20 | 0);
     jsvArrayInsertBefore(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2]);
     jsvUnLock(HEAP32[$4 + 16 >> 2]);
     jsvObjectIteratorNext($4 + 20 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1396($4 + 20 | 0);
   jsvUnLock(HEAP32[$4 + 24 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1394($4 + 48 | 0) & 1) {
     HEAP32[$4 + 12 >> 2] = jsvObjectIteratorGetKey_1407($4 + 48 | 0);
     block3 : {
      if (!HEAP32[$4 + 12 >> 2]) {
       break block3
      }
      if (!(jsvIsInt(HEAP32[$4 + 12 >> 2]) & 1)) {
       break block3
      }
      jsvSetInteger(HEAP32[$4 + 12 >> 2], jsvGetInteger(HEAP32[$4 + 12 >> 2]) + HEAP32[$4 + 60 >> 2] | 0);
     }
     jsvUnLock(HEAP32[$4 + 12 >> 2]);
     jsvObjectIteratorNext($4 + 48 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1396($4 + 48 | 0);
   jsvSetArrayLength(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 72 >> 2] + HEAP32[$4 + 60 >> 2] | 0, 0);
   HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 52 >> 2];
  }
  __stack_pointer = $4 + 96 | 0;
  return HEAP32[$4 + 92 >> 2];
 }
 
 function jsvObjectIteratorGetKey_1407($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_array_splice_i($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = jsvNewFromInteger(HEAP32[$4 + 20 >> 2]);
  HEAP32[$4 + 8 >> 2] = jswrap_array_splice(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 16 >> 2]);
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 8 >> 2];
 }
 
 function jswrap_array_shift($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jswrap_array_splice_i(HEAP32[$1 + 12 >> 2], 0, 1, 0);
  HEAP32[$1 + 4 >> 2] = 0;
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 4 >> 2] = jsvSkipNameAndUnLock(jsvArrayPop(HEAP32[$1 + 8 >> 2]))
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function jswrap_array_unshift($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsvUnLock(jswrap_array_splice_i(HEAP32[$2 + 12 >> 2], 0, 0, HEAP32[$2 + 8 >> 2]));
  $0 = jsvGetLength(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_array_slice($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 112 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 104 >> 2] = $0;
  HEAP32[$3 + 100 >> 2] = $1;
  HEAP32[$3 + 96 >> 2] = $2;
  HEAP32[$3 + 92 >> 2] = jsvGetLength(HEAP32[$3 + 104 >> 2]);
  HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 92 >> 2];
  if (!(jsvIsUndefined(HEAP32[$3 + 96 >> 2]) & 1)) {
   HEAP32[$3 + 88 >> 2] = jsvGetInteger(HEAP32[$3 + 96 >> 2])
  }
  HEAP32[$3 + 84 >> 2] = 0;
  HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 92 >> 2];
  HEAP32[$3 + 76 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$3 + 76 >> 2]) {
    HEAP32[$3 + 108 >> 2] = 0;
    break block;
   }
   block2 : {
    if (HEAP32[$3 + 100 >> 2] < 0) {
     if ((HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 100 >> 2] | 0) > 0) {
      $0 = HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 100 >> 2] | 0
     } else {
      $0 = 0
     }
     HEAP32[$3 + 84 >> 2] = $0;
     break block2;
    }
    if (HEAP32[$3 + 100 >> 2] < HEAP32[$3 + 92 >> 2]) {
     $0 = HEAP32[$3 + 100 >> 2]
    } else {
     $0 = HEAP32[$3 + 92 >> 2]
    }
    HEAP32[$3 + 84 >> 2] = $0;
   }
   block5 : {
    if (HEAP32[$3 + 88 >> 2] < 0) {
     if ((HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 88 >> 2] | 0) > 0) {
      $0 = HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 88 >> 2] | 0
     } else {
      $0 = 0
     }
     HEAP32[$3 + 80 >> 2] = $0;
     break block5;
    }
    if (HEAP32[$3 + 88 >> 2] < HEAP32[$3 + 92 >> 2]) {
     $0 = HEAP32[$3 + 88 >> 2]
    } else {
     $0 = HEAP32[$3 + 92 >> 2]
    }
    HEAP32[$3 + 80 >> 2] = $0;
   }
   HEAP8[$3 + 75 | 0] = 0;
   jsvIteratorNew($3 + 8 | 0, HEAP32[$3 + 104 >> 2], 1);
   while (1) {
    $0 = 0;
    if (jsvIteratorHasElement($3 + 8 | 0) & 1) {
     $0 = HEAPU8[$3 + 75 | 0] ^ -1
    }
    if ($0 & 1) {
     HEAP32[$3 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvIteratorGetKey($3 + 8 | 0));
     block7 : {
      if (HEAP32[$3 + 4 >> 2] < HEAP32[$3 + 84 >> 2]) {
       jsvIteratorNext($3 + 8 | 0);
       break block7;
      }
      block8 : {
       if (HEAP32[$3 + 84 >> 2] < HEAP32[$3 + 80 >> 2]) {
        jsvArrayPushAndUnLock(HEAP32[$3 + 76 >> 2], jsvIteratorGetValue($3 + 8 | 0));
        jsvIteratorNext($3 + 8 | 0);
        HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 84 >> 2] + 1;
        break block8;
       }
       HEAP8[$3 + 75 | 0] = 1;
      }
     }
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 8 | 0);
   HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 76 >> 2];
  }
  __stack_pointer = $3 + 112 | 0;
  return HEAP32[$3 + 108 >> 2];
 }
 
 function jswrap_array_sort($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP32[$2 + 84 >> 2] = $1;
  block1 : {
   block : {
    if (jsvIsUndefined(HEAP32[$2 + 84 >> 2]) & 1) {
     break block
    }
    if (jsvIsFunction(HEAP32[$2 + 84 >> 2]) & 1) {
     break block
    }
    HEAP32[$2 >> 2] = HEAP32[$2 + 84 >> 2];
    jsExceptionHere(1, 5894, $2);
    HEAP32[$2 + 92 >> 2] = 0;
    break block1;
   }
   HEAP32[$2 + 16 >> 2] = 0;
   block3 : {
    block2 : {
     if (!(jsvIsArray(HEAP32[$2 + 88 >> 2]) & 1)) {
      if (!(jsvIsObject(HEAP32[$2 + 88 >> 2]) & 1)) {
       break block2
      }
     }
     jsvIteratorNew($2 + 20 | 0, HEAP32[$2 + 88 >> 2], 0);
     while (1) {
      if (jsvIteratorHasElement($2 + 20 | 0) & 1) {
       HEAP32[$2 + 12 >> 2] = jsvIteratorGetKey($2 + 20 | 0);
       if (jsvIsInt(HEAP32[$2 + 12 >> 2]) & 1) {
        jsvSetInteger(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
        HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
       }
       jsvUnLock(HEAP32[$2 + 12 >> 2]);
       jsvIteratorNext($2 + 20 | 0);
       continue;
      }
      break;
     };
     jsvIteratorFree($2 + 20 | 0);
     break block3;
    }
    HEAP32[$2 + 16 >> 2] = jsvGetLength(HEAP32[$2 + 88 >> 2]);
   }
   HEAP8[$2 + 11 | 0] = jsvGetLocks(HEAP32[$2 + 88 >> 2]);
   jsvIteratorNew($2 + 20 | 0, HEAP32[$2 + 88 >> 2], 0);
   _jswrap_array_sort($2 + 20 | 0, HEAP32[$2 + 16 >> 2], HEAP32[$2 + 84 >> 2]);
   jsvIteratorFree($2 + 20 | 0);
   if ((jsvGetLocks(HEAP32[$2 + 88 >> 2]) & 255) == 15) {
    $0 = HEAP32[$2 + 88 >> 2];
    $1 = HEAP32[$2 + 88 >> 2];
    $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -15361 | HEAPU8[$2 + 11 | 0] << 10;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
   HEAP32[$2 + 92 >> 2] = jsvLockAgain(HEAP32[$2 + 88 >> 2]);
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function _jswrap_array_sort($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 336 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 332 >> 2] = $0;
  HEAP32[$3 + 328 >> 2] = $1;
  HEAP32[$3 + 324 >> 2] = $2;
  block : {
   if (HEAP32[$3 + 328 >> 2] < 2) {
    break block
   }
   jsvIteratorClone($3 + 260 | 0, HEAP32[$3 + 332 >> 2]);
   if (HEAP32[$3 + 328 >> 2] > 10) {
    HEAP32[$3 + 256 >> 2] = HEAP32[$3 + 328 >> 2] >> 1;
    jsvIteratorClone($3 + 192 | 0, HEAP32[$3 + 332 >> 2]);
    HEAP32[$3 + 188 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 256 >> 2]) {
      jsvIteratorNext($3 + 192 | 0);
      HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
      continue;
     }
     break;
    };
    jsvIteratorClone($3 + 124 | 0, $3 + 192 | 0);
    HEAP32[$3 + 120 >> 2] = HEAP32[$3 + 256 >> 2];
    while (1) {
     if (HEAP32[$3 + 120 >> 2] < (HEAP32[$3 + 328 >> 2] - 1 | 0)) {
      jsvIteratorNext($3 + 124 | 0);
      HEAP32[$3 + 120 >> 2] = HEAP32[$3 + 120 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$3 + 116 >> 2] = jsvIteratorGetValue($3 + 260 | 0);
    HEAP32[$3 + 112 >> 2] = jsvIteratorGetValue($3 + 192 | 0);
    HEAP32[$3 + 108 >> 2] = jsvIteratorGetValue($3 + 124 | 0);
    HEAP32[$3 + 104 >> 2] = _jswrap_array_sort_compare(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 324 >> 2]);
    HEAP32[$3 + 100 >> 2] = _jswrap_array_sort_compare(HEAP32[$3 + 112 >> 2], HEAP32[$3 + 108 >> 2], HEAP32[$3 + 324 >> 2]);
    HEAP32[$3 + 96 >> 2] = _jswrap_array_sort_compare(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 108 >> 2], HEAP32[$3 + 324 >> 2]);
    block3 : {
     if (!(!(HEAP32[$3 + 104 >> 2] <= 0 & HEAP32[$3 + 100 >> 2] <= 0) & (HEAP32[$3 + 100 >> 2] < 0 | HEAP32[$3 + 96 >> 2] > 0))) {
      jsvIteratorSetValue($3 + 260 | 0, HEAP32[$3 + 112 >> 2]);
      jsvIteratorSetValue($3 + 192 | 0, HEAP32[$3 + 116 >> 2]);
      break block3;
     }
     if (!(!(HEAP32[$3 + 96 >> 2] <= 0 & HEAP32[$3 + 104 >> 2] >= 0) & (HEAP32[$3 + 100 >> 2] | HEAP32[$3 + 96 >> 2]) < 0)) {
      jsvIteratorSetValue($3 + 260 | 0, HEAP32[$3 + 108 >> 2]);
      jsvIteratorSetValue($3 + 124 | 0, HEAP32[$3 + 116 >> 2]);
     }
    }
    jsvUnLock3(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 108 >> 2]);
    jsvIteratorFree($3 + 192 | 0);
    jsvIteratorFree($3 + 124 | 0);
   }
   HEAP8[$3 + 95 | 0] = 1;
   HEAP32[$3 + 88 >> 2] = jsvIteratorGetValue($3 + 260 | 0);
   HEAP32[$3 + 84 >> 2] = 0;
   HEAP32[$3 + 80 >> 2] = 0;
   jsvIteratorClone($3 + 16 | 0, HEAP32[$3 + 332 >> 2]);
   jsvIteratorNext($3 + 16 | 0);
   while (1) {
    $0 = HEAP32[$3 + 328 >> 2] - 1 | 0;
    HEAP32[$3 + 328 >> 2] = $0;
    $1 = 0;
    if ($0) {
     $1 = jspIsInterrupted() ^ -1
    }
    if ($1 & 1) {
     HEAP32[$3 + 12 >> 2] = jsvIteratorGetValue($3 + 16 | 0);
     HEAP32[$3 + 8 >> 2] = _jswrap_array_sort_compare(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 88 >> 2], HEAP32[$3 + 324 >> 2]);
     block6 : {
      if (HEAP32[$3 + 8 >> 2] <= 0) {
       if (HEAP32[$3 + 8 >> 2] < 0) {
        HEAP8[$3 + 95 | 0] = 0
       }
       HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 84 >> 2] + 1;
       jsvIteratorSetValue($3 + 260 | 0, HEAP32[$3 + 12 >> 2]);
       jsvIteratorNext($3 + 260 | 0);
       jsvUnLock(jsvIteratorSetValue($3 + 16 | 0, jsvIteratorGetValue($3 + 260 | 0)));
       jsvIteratorSetValue($3 + 260 | 0, HEAP32[$3 + 88 >> 2]);
       break block6;
      }
      HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 80 >> 2] + 1;
     }
     jsvUnLock(HEAP32[$3 + 12 >> 2]);
     jsvIteratorNext($3 + 16 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 16 | 0);
   jsvUnLock(HEAP32[$3 + 88 >> 2]);
   if (jspIsInterrupted() & 1) {
    jsvIteratorFree($3 + 260 | 0);
    break block;
   }
   jsvIteratorNext($3 + 260 | 0);
   _jswrap_array_sort($3 + 260 | 0, HEAP32[$3 + 80 >> 2], HEAP32[$3 + 324 >> 2]);
   jsvIteratorFree($3 + 260 | 0);
   if (HEAP8[$3 + 95 | 0] & 1) {
    break block
   }
   _jswrap_array_sort(HEAP32[$3 + 332 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 324 >> 2]);
  }
  __stack_pointer = $3 + 336 | 0;
 }
 
 function _jswrap_array_sort_compare($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 40 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  HEAP32[$3 + 32 >> 2] = $2;
  block : {
   if (jsvIsUndefined(HEAP32[$3 + 40 >> 2]) & 1) {
    HEAP32[$3 + 44 >> 2] = 1;
    break block;
   }
   if (jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1) {
    HEAP32[$3 + 44 >> 2] = -1;
    break block;
   }
   if (HEAP32[$3 + 32 >> 2]) {
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 40 >> 2];
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 36 >> 2];
    HEAPF64[$3 + 16 >> 3] = jsvGetFloatAndUnLock(jspeFunctionCall(HEAP32[$3 + 32 >> 2], 0, 0, 0, 2, $3 + 24 | 0));
    if (HEAPF64[$3 + 16 >> 3] == 0.0) {
     HEAP32[$3 + 44 >> 2] = 0;
     break block;
    }
    HEAP32[$3 + 44 >> 2] = HEAPF64[$3 + 16 >> 3] < 0.0 ? -1 : 1;
    break block;
   }
   HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 40 >> 2]);
   HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 36 >> 2]);
   HEAP32[$3 + 4 >> 2] = jsvCompareString(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 0, 0, 0);
   jsvUnLock2(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 4 >> 2];
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 44 >> 2];
 }
 
 function jswrap_array_concat($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = jsvNewEmptyArray();
  jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 24 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 28 >> 2]);
  while (1) {
   block : {
    if (jsvIsArray(HEAP32[$2 + 12 >> 2]) & 1) {
     jsvArrayPushAll(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 12 >> 2], 0);
     break block;
    }
    jsvArrayPush(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 12 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   block1 : {
    if (jsvObjectIteratorHasValue_1394($2 + 16 | 0) & 1) {
     $0 = jsvObjectIteratorGetValue_1395($2 + 16 | 0);
     break block1;
    }
    $0 = 0;
   }
   HEAP32[$2 + 12 >> 2] = $0;
   jsvObjectIteratorNext($2 + 16 | 0);
   if (HEAP32[$2 + 12 >> 2]) {
    continue
   }
   break;
  };
  jsvObjectIteratorFree_1396($2 + 16 | 0);
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 20 >> 2];
 }
 
 function jswrap_array_fill($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 88 >> 2] = $0;
  HEAP32[$4 + 84 >> 2] = $1;
  HEAP32[$4 + 80 >> 2] = $2;
  HEAP32[$4 + 76 >> 2] = $3;
  block : {
   if (!(jsvIsIterable(HEAP32[$4 + 88 >> 2]) & 1)) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 72 >> 2] = jsvGetLength(HEAP32[$4 + 88 >> 2]);
   if (HEAP32[$4 + 80 >> 2] < 0) {
    HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + HEAP32[$4 + 72 >> 2]
   }
   if (HEAP32[$4 + 80 >> 2] < 0) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   block1 : {
    if (jsvIsNumeric(HEAP32[$4 + 76 >> 2]) & 1) {
     $0 = jsvGetInteger(HEAP32[$4 + 76 >> 2]);
     break block1;
    }
    $0 = HEAP32[$4 + 72 >> 2];
   }
   HEAP32[$4 + 68 >> 2] = $0;
   if (HEAP32[$4 + 68 >> 2] < 0) {
    HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 68 >> 2] + HEAP32[$4 + 72 >> 2]
   }
   if (HEAP32[$4 + 68 >> 2] < 0) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($4 + 4 | 0, HEAP32[$4 + 88 >> 2], 1);
   while (1) {
    $0 = 0;
    if (jsvIteratorHasElement($4 + 4 | 0) & 1) {
     $0 = jspIsInterrupted() ^ -1
    }
    if ($0 & 1) {
     HEAP32[$4 >> 2] = jsvGetIntegerAndUnLock(jsvIteratorGetKey($4 + 4 | 0));
     if (!(HEAP32[$4 >> 2] < HEAP32[$4 + 80 >> 2] | HEAP32[$4 >> 2] >= HEAP32[$4 + 68 >> 2])) {
      jsvIteratorSetValue($4 + 4 | 0, HEAP32[$4 + 84 >> 2])
     }
     jsvIteratorNext($4 + 4 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($4 + 4 | 0);
   HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
  }
  __stack_pointer = $4 + 96 | 0;
  return HEAP32[$4 + 92 >> 2];
 }
 
 function _jswrap_array_reverse_block($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 176 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 172 >> 2] = $0;
  HEAP32[$3 + 168 >> 2] = $1;
  HEAP32[$3 + 164 >> 2] = $2;
  jsvIteratorClone($3 + 100 | 0, HEAP32[$3 + 168 >> 2]);
  jsvIteratorClone($3 + 36 | 0, HEAP32[$3 + 168 >> 2]);
  HEAP32[$3 + 32 >> 2] = (HEAP32[$3 + 164 >> 2] + 1 | 0) / 2;
  while (1) {
   if (HEAP32[$3 + 32 >> 2] > 0) {
    jsvIteratorNext($3 + 36 | 0);
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] - 1;
    continue;
   }
   break;
  };
  if (HEAP32[$3 + 164 >> 2] > 3) {
   _jswrap_array_reverse_block(HEAP32[$3 + 172 >> 2], $3 + 100 | 0, HEAP32[$3 + 164 >> 2] / 2 | 0);
   _jswrap_array_reverse_block(HEAP32[$3 + 172 >> 2], $3 + 36 | 0, HEAP32[$3 + 164 >> 2] / 2 | 0);
  }
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 164 >> 2] / 2;
  while (1) {
   if (HEAP32[$3 + 32 >> 2] > 0) {
    HEAP32[$3 + 28 >> 2] = jsvIteratorGetValue($3 + 100 | 0);
    HEAP32[$3 + 24 >> 2] = jsvIteratorGetValue($3 + 36 | 0);
    jsvIteratorSetValue($3 + 100 | 0, HEAP32[$3 + 24 >> 2]);
    jsvIteratorSetValue($3 + 36 | 0, HEAP32[$3 + 28 >> 2]);
    jsvUnLock2(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
    if (jsvIsArray(HEAP32[$3 + 172 >> 2]) & 1) {
     HEAP32[$3 + 20 >> 2] = jsvIteratorGetKey($3 + 100 | 0);
     HEAP32[$3 + 16 >> 2] = jsvIteratorGetKey($3 + 36 | 0);
     HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 20 >> 2]);
     HEAP32[$3 + 8 >> 2] = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
     jsvSetInteger(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 8 >> 2]);
     jsvSetInteger(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]);
     jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
    }
    jsvIteratorNext($3 + 100 | 0);
    jsvIteratorNext($3 + 36 | 0);
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] - 1;
    continue;
   }
   break;
  };
  jsvIteratorFree($3 + 100 | 0);
  jsvIteratorFree($3 + 36 | 0);
  __stack_pointer = $3 + 176 | 0;
 }
 
 function jswrap_array_reverse($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 160 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 152 >> 2] = $0;
  block1 : {
   block : {
    if (jsvIsIterable(HEAP32[$1 + 152 >> 2]) & 1) {
     if (!(jsvIsObject(HEAP32[$1 + 152 >> 2]) & 1)) {
      break block
     }
    }
    HEAP32[$1 + 156 >> 2] = 0;
    break block1;
   }
   HEAP32[$1 + 148 >> 2] = 0;
   block2 : {
    if (jsvIsArray(HEAP32[$1 + 152 >> 2]) & 1) {
     jsvIteratorNew($1 + 84 | 0, HEAP32[$1 + 152 >> 2], 0);
     while (1) {
      if (jsvIteratorHasElement($1 + 84 | 0) & 1) {
       HEAP32[$1 + 80 >> 2] = jsvIteratorGetKey($1 + 84 | 0);
       if (jsvIsInt(HEAP32[$1 + 80 >> 2]) & 1) {
        HEAP32[$1 + 148 >> 2] = HEAP32[$1 + 148 >> 2] + 1
       }
       jsvUnLock(HEAP32[$1 + 80 >> 2]);
       jsvIteratorNext($1 + 84 | 0);
       continue;
      }
      break;
     };
     jsvIteratorFree($1 + 84 | 0);
     break block2;
    }
    HEAP32[$1 + 148 >> 2] = jsvGetLength(HEAP32[$1 + 152 >> 2]);
   }
   jsvIteratorNew($1 + 16 | 0, HEAP32[$1 + 152 >> 2], 0);
   if (HEAP32[$1 + 148 >> 2] > 1) {
    _jswrap_array_reverse_block(HEAP32[$1 + 152 >> 2], $1 + 16 | 0, HEAP32[$1 + 148 >> 2])
   }
   if (jsvIsArray(HEAP32[$1 + 152 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[$1 + 152 >> 2]) - 1;
    while (1) {
     if (jsvIteratorHasElement($1 + 16 | 0) & 1) {
      HEAP32[$1 + 8 >> 2] = jsvIteratorGetKey($1 + 16 | 0);
      if (jsvIsInt(HEAP32[$1 + 8 >> 2]) & 1) {
       jsvSetInteger(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2] - jsvGetInteger(HEAP32[$1 + 8 >> 2]) | 0)
      }
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
      jsvIteratorNext($1 + 16 | 0);
      continue;
     }
     break;
    };
   }
   jsvIteratorFree($1 + 16 | 0);
   HEAP32[$1 + 156 >> 2] = jsvLockAgain(HEAP32[$1 + 152 >> 2]);
  }
  __stack_pointer = $1 + 160 | 0;
  return HEAP32[$1 + 156 >> 2];
 }
 
 function jswrap_arraybuffer_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (HEAP32[$1 + 8 >> 2] < 0) {
    jsExceptionHere(1, 8171, 0);
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   if (HEAP32[$1 + 8 >> 2] > 16777215) {
    jsExceptionHere(1, 16585, 0);
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 4 >> 2] = 0;
   if (HEAP32[$1 + 8 >> 2] > 19) {
    HEAP32[$1 + 4 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 8 >> 2])
   }
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 4 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 8 >> 2], 0)
   }
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_typedarray_constructor($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 112 | 0;
  __stack_pointer = $4;
  HEAP8[$4 + 107 | 0] = $0;
  HEAP32[$4 + 100 >> 2] = $1;
  HEAP32[$4 + 96 >> 2] = $2;
  HEAP32[$4 + 92 >> 2] = $3;
  HEAP32[$4 + 88 >> 2] = 0;
  HEAP8[$4 + 87 | 0] = 0;
  block1 : {
   if (!(HEAP32[$4 + 96 >> 2] <= 65535 & HEAP32[$4 + 96 >> 2] >= 0)) {
    jsExceptionHere(1, 24793, 0);
    HEAP32[$4 + 108 >> 2] = 0;
    break block1;
   }
   block3 : {
    if (!(!(jsvIsArrayBuffer(HEAP32[$4 + 100 >> 2]) & 1) | HEAPU8[HEAP32[$4 + 100 >> 2] + 5 | 0] != 129)) {
     HEAP32[$4 + 88 >> 2] = jsvLockAgain(HEAP32[$4 + 100 >> 2]);
     break block3;
    }
    block4 : {
     if (jsvIsNumeric(HEAP32[$4 + 100 >> 2]) & 1) {
      HEAP32[$4 + 92 >> 2] = jsvGetInteger(HEAP32[$4 + 100 >> 2]);
      HEAP32[$4 + 96 >> 2] = 0;
      HEAP32[$4 + 88 >> 2] = jswrap_arraybuffer_constructor(Math_imul(HEAP32[$4 + 92 >> 2], HEAPU8[$4 + 107 | 0] & 15));
      break block4;
     }
     block5 : {
      if (!(jsvIsArray(HEAP32[$4 + 100 >> 2]) & 1)) {
       if (!(jsvIsArrayBuffer(HEAP32[$4 + 100 >> 2]) & 1)) {
        break block5
       }
      }
      HEAP32[$4 + 92 >> 2] = jsvGetLength(HEAP32[$4 + 100 >> 2]);
      HEAP32[$4 + 96 >> 2] = 0;
      HEAP32[$4 + 88 >> 2] = jswrap_arraybuffer_constructor(Math_imul(HEAP32[$4 + 92 >> 2], HEAPU8[$4 + 107 | 0] & 15));
      HEAP8[$4 + 87 | 0] = 1;
     }
    }
   }
   if (!HEAP32[$4 + 88 >> 2]) {
    HEAP32[$4 >> 2] = HEAP32[$4 + 100 >> 2];
    jsExceptionHere(1, 6365, $4);
    HEAP32[$4 + 108 >> 2] = 0;
    break block1;
   }
   if (!HEAP32[$4 + 92 >> 2]) {
    HEAP32[$4 + 92 >> 2] = (jsvGetArrayBufferLength(HEAP32[$4 + 88 >> 2]) - HEAP32[$4 + 96 >> 2] | 0) / (HEAPU8[$4 + 107 | 0] & 15);
    if (HEAP32[$4 + 92 >> 2] < 0) {
     HEAP32[$4 + 92 >> 2] = 0
    }
   }
   HEAP32[$4 + 80 >> 2] = jsvNewWithFlags(4);
   if (HEAP32[$4 + 80 >> 2]) {
    HEAP8[HEAP32[$4 + 80 >> 2] + 5 | 0] = HEAPU8[$4 + 107 | 0];
    $0 = HEAP32[$4 + 80 >> 2];
    $1 = HEAP32[$4 + 96 >> 2];
    HEAP8[$0 | 0] = $1;
    HEAP8[$0 + 1 | 0] = $1 >>> 8;
    $0 = HEAP32[$4 + 80 >> 2];
    $1 = HEAP32[$4 + 92 >> 2];
    HEAP8[$0 + 2 | 0] = $1;
    HEAP8[$0 + 3 | 0] = $1 >>> 8;
    HEAP8[$0 + 4 | 0] = $1 >>> 16;
    jsvSetFirstChild(HEAP32[$4 + 80 >> 2], jsvGetRef(jsvRef(HEAP32[$4 + 88 >> 2])) & 65535);
    if (HEAP8[$4 + 87 | 0] & 1) {
     jsvIteratorNew($4 + 16 | 0, HEAP32[$4 + 100 >> 2], 0);
     while (1) {
      if (jsvIteratorHasElement($4 + 16 | 0) & 1) {
       HEAP32[$4 + 12 >> 2] = jsvIteratorGetKey($4 + 16 | 0);
       if (jsvIsInt(HEAP32[$4 + 12 >> 2]) & 1) {
        HEAP32[$4 + 8 >> 2] = jsvIteratorGetValue($4 + 16 | 0);
        jsvArrayBufferSet(HEAP32[$4 + 80 >> 2], jsvGetInteger(HEAP32[$4 + 12 >> 2]), HEAP32[$4 + 8 >> 2]);
        jsvUnLock(HEAP32[$4 + 8 >> 2]);
       }
       jsvUnLock(HEAP32[$4 + 12 >> 2]);
       jsvIteratorNext($4 + 16 | 0);
       continue;
      }
      break;
     };
     jsvIteratorFree($4 + 16 | 0);
    }
   }
   jsvUnLock(HEAP32[$4 + 88 >> 2]);
   HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 80 >> 2];
  }
  __stack_pointer = $4 + 112 | 0;
  return HEAP32[$4 + 108 >> 2];
 }
 
 function jswrap_arraybufferview_set($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 176 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 172 >> 2] = $0;
  HEAP32[$3 + 168 >> 2] = $1;
  HEAP32[$3 + 164 >> 2] = $2;
  block1 : {
   block : {
    if (jsvIsString(HEAP32[$3 + 168 >> 2]) & 1) {
     break block
    }
    if (jsvIsArray(HEAP32[$3 + 168 >> 2]) & 1) {
     break block
    }
    if (jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1) {
     break block
    }
    HEAP32[$3 >> 2] = HEAP32[$3 + 168 >> 2];
    jsExceptionHere(1, 5057, $3);
    break block1;
   }
   block2 : {
    if (!(jsvIsArrayBuffer(HEAP32[$3 + 172 >> 2]) & 1)) {
     break block2
    }
    if (!(jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1)) {
     break block2
    }
    HEAP32[$3 + 160 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 172 >> 2], 0);
    HEAP32[$3 + 156 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 168 >> 2], 0);
    if (HEAP32[$3 + 160 >> 2] == HEAP32[$3 + 156 >> 2]) {
     $0 = HEAP32[$3 + 172 >> 2];
     $1 = HEAP32[$3 + 168 >> 2];
     $4 = (Math_imul(HEAP32[$3 + 164 >> 2], HEAPU8[HEAP32[$3 + 172 >> 2] + 5 | 0] & 15) + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) | 0) >= (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8);
    }
    HEAP8[$3 + 155 | 0] = $4;
    jsvUnLock2(HEAP32[$3 + 160 >> 2], HEAP32[$3 + 156 >> 2]);
    if (HEAP8[$3 + 155 | 0] & 1) {
     HEAP32[$3 + 148 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 168 >> 2]);
     HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 148 >> 2] - 1;
     while (1) {
      if (HEAP32[$3 + 144 >> 2] >= 0) {
       HEAP32[$3 + 140 >> 2] = jsvArrayBufferGet(HEAP32[$3 + 168 >> 2], HEAP32[$3 + 144 >> 2]);
       jsvArrayBufferSet(HEAP32[$3 + 172 >> 2], HEAP32[$3 + 164 >> 2] + HEAP32[$3 + 144 >> 2] | 0, HEAP32[$3 + 140 >> 2]);
       jsvUnLock(HEAP32[$3 + 140 >> 2]);
       HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 144 >> 2] - 1;
       continue;
      }
      break;
     };
     break block1;
    }
   }
   jsvIteratorNew($3 + 76 | 0, HEAP32[$3 + 168 >> 2], 1);
   jsvArrayBufferIteratorNew($3 + 16 | 0, HEAP32[$3 + 172 >> 2], HEAP32[$3 + 164 >> 2]);
   $0 = 1;
   if (HEAPU8[$3 + 56 | 0] & 32) {
    $0 = jsvIsString(HEAP32[$3 + 168 >> 2])
   }
   HEAP8[$3 + 15 | 0] = $0 & 1;
   while (1) {
    $0 = 0;
    if (jsvIteratorHasElement($3 + 76 | 0) & 1) {
     $0 = jsvArrayBufferIteratorHasElement($3 + 16 | 0)
    }
    if ($0 & 1) {
     block3 : {
      if (HEAP8[$3 + 15 | 0] & 1) {
       jsvArrayBufferIteratorSetIntegerValue($3 + 16 | 0, jsvIteratorGetIntegerValue($3 + 76 | 0));
       break block3;
      }
      HEAP32[$3 + 8 >> 2] = jsvIteratorGetValue($3 + 76 | 0);
      jsvArrayBufferIteratorSetValue($3 + 16 | 0, HEAP32[$3 + 8 >> 2], 0);
      jsvUnLock(HEAP32[$3 + 8 >> 2]);
     }
     jsvArrayBufferIteratorNext($3 + 16 | 0);
     jsvIteratorNext($3 + 76 | 0);
     continue;
    }
    break;
   };
   jsvArrayBufferIteratorFree($3 + 16 | 0);
   jsvIteratorFree($3 + 76 | 0);
  }
  __stack_pointer = $3 + 176 | 0;
 }
 
 function jswrap_arraybufferview_map($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 176 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 168 >> 2] = $0;
  HEAP32[$3 + 164 >> 2] = $1;
  HEAP32[$3 + 160 >> 2] = $2;
  block : {
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1)) {
    jsExceptionHere(1, 4083, 0);
    HEAP32[$3 + 172 >> 2] = 0;
    break block;
   }
   if (!(jsvIsFunction(HEAP32[$3 + 164 >> 2]) & 1)) {
    jsExceptionHere(1, 15357, 0);
    HEAP32[$3 + 172 >> 2] = 0;
    break block;
   }
   block1 : {
    if (jsvIsUndefined(HEAP32[$3 + 160 >> 2]) & 1) {
     break block1
    }
    if (jsvIsObject(HEAP32[$3 + 160 >> 2]) & 1) {
     break block1
    }
    jsExceptionHere(1, 19004, 0);
    HEAP32[$3 + 172 >> 2] = 0;
    break block;
   }
   HEAP8[$3 + 159 | 0] = HEAPU8[HEAP32[$3 + 168 >> 2] + 5 | 0];
   HEAP32[$3 + 152 >> 2] = jsvNewTypedArray(HEAPU8[$3 + 159 | 0], jsvGetArrayBufferLength(HEAP32[$3 + 168 >> 2]));
   if (!HEAP32[$3 + 152 >> 2]) {
    HEAP32[$3 + 172 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($3 + 88 | 0, HEAP32[$3 + 168 >> 2], 1);
   jsvArrayBufferIteratorNew($3 + 28 | 0, HEAP32[$3 + 152 >> 2], 0);
   while (1) {
    if (jsvIteratorHasElement($3 + 88 | 0) & 1) {
     HEAP32[$3 + 24 >> 2] = jsvIteratorGetKey($3 + 88 | 0);
     if (jsvIsInt(HEAP32[$3 + 24 >> 2]) & 1) {
      HEAP32[$3 + 20 >> 2] = jsvGetInteger(HEAP32[$3 + 24 >> 2]);
      HEAP32[$3 + 8 >> 2] = jsvIteratorGetValue($3 + 88 | 0);
      HEAP32[$3 + 12 >> 2] = jsvNewFromInteger(HEAP32[$3 + 20 >> 2]);
      HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 168 >> 2];
      HEAP32[$3 + 4 >> 2] = jspeFunctionCall(HEAP32[$3 + 164 >> 2], 0, HEAP32[$3 + 160 >> 2], 0, 3, $3 + 8 | 0);
      jsvUnLockMany(2, $3 + 8 | 0);
      if (HEAP32[$3 + 4 >> 2]) {
       jsvArrayBufferIteratorSetValue($3 + 28 | 0, HEAP32[$3 + 4 >> 2], 0);
       jsvUnLock(HEAP32[$3 + 4 >> 2]);
      }
     }
     jsvUnLock(HEAP32[$3 + 24 >> 2]);
     jsvIteratorNext($3 + 88 | 0);
     jsvArrayBufferIteratorNext($3 + 28 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 88 | 0);
   jsvArrayBufferIteratorFree($3 + 28 | 0);
   HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 152 >> 2];
  }
  __stack_pointer = $3 + 176 | 0;
  return HEAP32[$3 + 172 >> 2];
 }
 
 function jswrap_arraybufferview_subarray($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block : {
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 24 >> 2]) & 1)) {
    jsExceptionHere(1, 4017, 0);
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
   if (!(jsvIsNumeric(HEAP32[$3 + 16 >> 2]) & 1)) {
    HEAP32[$3 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2])
   }
   if (HEAP32[$3 + 20 >> 2] < 0) {
    HEAP32[$3 + 20 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 20 >> 2]
   }
   if (HEAP32[$3 + 12 >> 2] < 0) {
    HEAP32[$3 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 12 >> 2]
   }
   if (HEAP32[$3 + 12 >> 2] < 0) {
    HEAP32[$3 + 12 >> 2] = 0
   }
   if (HEAP32[$3 + 20 >> 2] > HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 20 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = 0;
   }
   HEAP8[$3 + 11 | 0] = HEAPU8[HEAP32[$3 + 24 >> 2] + 5 | 0];
   if (HEAP32[$3 + 20 >> 2] == HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = jsvNewTypedArray(HEAPU8[$3 + 11 | 0], 0);
    break block;
   }
   HEAP32[$3 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535);
   $0 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 >> 2] = jswrap_typedarray_constructor(HEAPU8[$3 + 11 | 0], HEAP32[$3 + 4 >> 2], Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$3 + 11 | 0] & 15) + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) | 0, HEAP32[$3 + 12 >> 2] - HEAP32[$3 + 20 >> 2] | 0);
   jsvUnLock(HEAP32[$3 + 4 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jswrap_arraybufferview_indexOf($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  block : {
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   if (!(HEAPU8[HEAP32[$3 + 88 >> 2] + 5 | 0] & 32)) {
    HEAP32[$3 + 76 >> 2] = jsvGetInteger(HEAP32[$3 + 84 >> 2]);
    jsvArrayBufferIteratorNew($3 + 16 | 0, HEAP32[$3 + 88 >> 2], HEAP32[$3 + 80 >> 2]);
    while (1) {
     if (jsvArrayBufferIteratorHasElement($3 + 16 | 0) & 1) {
      HEAP32[$3 + 12 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 16 | 0);
      if (HEAP32[$3 + 12 >> 2] == HEAP32[$3 + 76 >> 2]) {
       HEAP32[$3 + 8 >> 2] = jsvArrayBufferIteratorGetIndex($3 + 16 | 0);
       jsvArrayBufferIteratorFree($3 + 16 | 0);
       HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 8 >> 2];
       break block;
      } else {
       jsvArrayBufferIteratorNext($3 + 16 | 0);
       continue;
      }
     }
     break;
    };
    jsvArrayBufferIteratorFree($3 + 16 | 0);
   }
   HEAP32[$3 + 92 >> 2] = jswrap_array_indexOf(HEAP32[$3 + 88 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_arraybufferview_sort($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (!(jsvIsArrayBuffer(HEAP32[$2 + 24 >> 2]) & 1)) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP8[$2 + 19 | 0] = (HEAPU8[HEAP32[$2 + 24 >> 2] + 5 | 0] & 32) != 0;
   if (HEAP32[$2 + 20 >> 2]) {
    HEAP32[$2 + 28 >> 2] = jswrap_array_sort(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
    break block;
   }
   block1 : {
    if (HEAP8[$2 + 19 | 0] & 1) {
     $0 = jsvNewNativeFunction(635, 511);
     break block1;
    }
    $0 = jsvNewNativeFunction(636, 292);
   }
   HEAP32[$2 + 20 >> 2] = $0;
   HEAP32[$2 + 12 >> 2] = jswrap_array_sort(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function _jswrap_arraybufferview_sort_float($0, $1) {
  $0 = +$0;
  $1 = +$1;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAPF64[$2 + 8 >> 3] = $0;
  HEAPF64[$2 >> 3] = $1;
  return +(HEAPF64[$2 + 8 >> 3] - HEAPF64[$2 >> 3]);
 }
 
 function _jswrap_arraybufferview_sort_int($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  return HEAP32[$2 + 12 >> 2] - HEAP32[$2 + 8 >> 2] | 0;
 }
 
 function jswrap_dataview_constructor($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block1 : {
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 24 >> 2]) & 1 & HEAPU8[HEAP32[$3 + 24 >> 2] + 5 | 0] == 129)) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
    jsExceptionHere(3, 5743, $3);
    HEAP32[$3 + 28 >> 2] = 0;
    break block1;
   }
   HEAP32[$3 + 12 >> 2] = jspNewObject(0, 4124);
   if (HEAP32[$3 + 12 >> 2]) {
    jsvObjectSetChild(HEAP32[$3 + 12 >> 2], 8164, HEAP32[$3 + 24 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 12 >> 2], 4973, jsvNewFromInteger(HEAP32[$3 + 20 >> 2]));
    $1 = HEAP32[$3 + 12 >> 2];
    if (HEAP32[$3 + 16 >> 2]) {
     $0 = HEAP32[$3 + 16 >> 2]
    } else {
     $0 = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2])
    }
    jsvObjectSetChildAndUnLock($1, 16236, jsvNewFromInteger($0));
   }
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jswrap_dataview_get($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 88 >> 2] = $0;
  HEAP8[$4 + 87 | 0] = $1;
  HEAP32[$4 + 80 >> 2] = $2;
  HEAP8[$4 + 79 | 0] = $3;
  HEAP32[$4 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 88 >> 2], 8164);
  block : {
   if (!(jsvIsArrayBuffer(HEAP32[$4 + 72 >> 2]) & 1)) {
    jsvUnLock(HEAP32[$4 + 72 >> 2]);
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 80 >> 2] = jsvObjectGetIntegerChild(HEAP32[$4 + 88 >> 2], 4973) + HEAP32[$4 + 80 >> 2];
   HEAP32[$4 + 68 >> 2] = HEAPU8[$4 + 87 | 0] & 15;
   HEAP32[$4 + 64 >> 2] = jswrap_typedarray_constructor(HEAPU8[$4 + 87 | 0], HEAP32[$4 + 72 >> 2], HEAP32[$4 + 80 >> 2], HEAP32[$4 + 68 >> 2]);
   jsvUnLock(HEAP32[$4 + 72 >> 2]);
   if (!HEAP32[$4 + 64 >> 2]) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   jsvArrayBufferIteratorNew($4 + 4 | 0, HEAP32[$4 + 64 >> 2], 0);
   HEAP32[$4 >> 2] = jsvArrayBufferIteratorGetValue($4 + 4 | 0, (HEAPU8[$4 + 79 | 0] ^ -1) & 1);
   jsvArrayBufferIteratorFree($4 + 4 | 0);
   jsvUnLock(HEAP32[$4 + 64 >> 2]);
   HEAP32[$4 + 92 >> 2] = HEAP32[$4 >> 2];
  }
  __stack_pointer = $4 + 96 | 0;
  return HEAP32[$4 + 92 >> 2];
 }
 
 function jswrap_dataview_set($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 92 >> 2] = $0;
  HEAP8[$5 + 91 | 0] = $1;
  HEAP32[$5 + 84 >> 2] = $2;
  HEAP32[$5 + 80 >> 2] = $3;
  HEAP8[$5 + 79 | 0] = $4;
  HEAP32[$5 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$5 + 92 >> 2], 8164);
  block : {
   if (!(jsvIsArrayBuffer(HEAP32[$5 + 72 >> 2]) & 1)) {
    jsvUnLock(HEAP32[$5 + 72 >> 2]);
    break block;
   }
   HEAP32[$5 + 84 >> 2] = jsvObjectGetIntegerChild(HEAP32[$5 + 92 >> 2], 4973) + HEAP32[$5 + 84 >> 2];
   HEAP32[$5 + 68 >> 2] = HEAPU8[$5 + 91 | 0] & 15;
   HEAP32[$5 + 64 >> 2] = jswrap_typedarray_constructor(HEAPU8[$5 + 91 | 0], HEAP32[$5 + 72 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 68 >> 2]);
   jsvUnLock(HEAP32[$5 + 72 >> 2]);
   if (!HEAP32[$5 + 64 >> 2]) {
    break block
   }
   jsvArrayBufferIteratorNew($5 + 4 | 0, HEAP32[$5 + 64 >> 2], 0);
   jsvArrayBufferIteratorSetValue($5 + 4 | 0, HEAP32[$5 + 80 >> 2], (HEAPU8[$5 + 79 | 0] ^ -1) & 1);
   jsvArrayBufferIteratorFree($5 + 4 | 0);
   jsvUnLock(HEAP32[$5 + 64 >> 2]);
  }
  __stack_pointer = $5 + 96 | 0;
 }
 
 function integerDivideFloor($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  if (HEAP32[$2 + 12 >> 2] < 0) {
   $0 = (HEAP32[$2 + 12 >> 2] - HEAP32[$2 + 8 >> 2] | 0) + 1 | 0
  } else {
   $0 = HEAP32[$2 + 12 >> 2]
  }
  return ($0 | 0) / HEAP32[$2 + 8 >> 2] | 0;
 }
 
 function getDayNumberFromDate($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block1 : {
   if (!(HEAP32[$3 + 24 >> 2] < 125e4 & HEAP32[$3 + 24 >> 2] >= -125e4)) {
    jsExceptionHere(1, 7514, 0);
    HEAP32[$3 + 28 >> 2] = 0;
    break block1;
   }
   while (1) {
    if (HEAP32[$3 + 20 >> 2] < 2) {
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - 1;
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + 12;
     continue;
    }
    break;
   };
   HEAP32[$3 + 12 >> 2] = integerDivideFloor(HEAP32[$3 + 24 >> 2], 100);
   HEAP32[$3 + 28 >> 2] = ((((((Math_imul(HEAP32[$3 + 24 >> 2], 365) + integerDivideFloor(HEAP32[$3 + 24 >> 2], 4) | 0) - HEAP32[$3 + 12 >> 2] | 0) + integerDivideFloor(HEAP32[$3 + 12 >> 2], 4) | 0) + Math_imul(HEAP32[$3 + 20 >> 2], 30) | 0) + ((Math_imul(HEAP32[$3 + 20 >> 2], 3) + 6 | 0) / 5 | 0) | 0) + HEAP32[$3 + 16 >> 2] | 0) - 719531;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function getDateFromDayNumber($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] + 135081;
  HEAP32[$4 + 12 >> 2] = integerDivideFloor((HEAP32[$4 + 12 >> 2] - integerDivideFloor(HEAP32[$4 + 12 >> 2], 146097) | 0) + 146095 | 0, 36524);
  HEAP32[$4 + 12 >> 2] = (HEAP32[$4 + 28 >> 2] + HEAP32[$4 + 12 >> 2] | 0) - integerDivideFloor(HEAP32[$4 + 12 >> 2], 4);
  HEAP32[$4 + 8 >> 2] = integerDivideFloor((HEAP32[$4 + 12 >> 2] << 2) + 2877911 | 0, 1461);
  HEAP32[$4 + 4 >> 2] = ((HEAP32[$4 + 12 >> 2] + 719600 | 0) - Math_imul(HEAP32[$4 + 8 >> 2], 365) | 0) - integerDivideFloor(HEAP32[$4 + 8 >> 2], 4);
  HEAP32[$4 >> 2] = (Math_imul(HEAP32[$4 + 4 >> 2], 5) - 1 | 0) / 153;
  if (HEAP32[$4 + 16 >> 2]) {
   HEAP32[HEAP32[$4 + 16 >> 2] >> 2] = (HEAP32[$4 + 4 >> 2] - Math_imul(HEAP32[$4 >> 2], 30) | 0) - ((Math_imul(HEAP32[$4 >> 2], 3) | 0) / 5 | 0)
  }
  if (HEAP32[$4 + 20 >> 2]) {
   block : {
    if (HEAP32[$4 >> 2] < 14) {
     HEAP32[HEAP32[$4 + 20 >> 2] >> 2] = HEAP32[$4 >> 2] - 2;
     break block;
    }
    HEAP32[HEAP32[$4 + 20 >> 2] >> 2] = HEAP32[$4 >> 2] - 14;
   }
  }
  if (HEAP32[$4 + 24 >> 2]) {
   block1 : {
    if (HEAP32[$4 >> 2] > 13) {
     HEAP32[HEAP32[$4 + 24 >> 2] >> 2] = HEAP32[$4 + 8 >> 2] + 1;
     break block1;
    }
    HEAP32[HEAP32[$4 + 24 >> 2] >> 2] = HEAP32[$4 + 8 >> 2];
   }
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function getDstChangeTime($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
  var $10 = 0;
  $10 = __stack_pointer - 48 | 0;
  __stack_pointer = $10;
  HEAP32[$10 + 44 >> 2] = $0;
  HEAP32[$10 + 40 >> 2] = $1;
  HEAP32[$10 + 36 >> 2] = $2;
  HEAP32[$10 + 32 >> 2] = $3;
  HEAP32[$10 + 28 >> 2] = $4;
  HEAP32[$10 + 24 >> 2] = $5;
  HEAP8[$10 + 23 | 0] = $6;
  HEAP32[$10 + 16 >> 2] = $7;
  HEAP32[$10 + 12 >> 2] = $8;
  HEAP8[$10 + 11 | 0] = $9;
  if (HEAP32[$10 + 40 >> 2] == 4) {
   $0 = HEAP32[$10 + 32 >> 2] + 1 | 0;
   HEAP32[$10 + 32 >> 2] = $0;
   if (($0 | 0) > 11) {
    HEAP32[$10 + 44 >> 2] = HEAP32[$10 + 44 >> 2] + 1;
    HEAP32[$10 + 32 >> 2] = HEAP32[$10 + 32 >> 2] - 12;
   }
  }
  HEAP32[$10 + 4 >> 2] = getDayNumberFromDate(HEAP32[$10 + 44 >> 2], HEAP32[$10 + 32 >> 2], 1);
  block : {
   if (HEAP32[$10 + 40 >> 2] == 4) {
    HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] + (((HEAP32[$10 + 36 >> 2] + (14 - ((HEAP32[$10 + 4 >> 2] + 4 | 0) % 7 | 0) | 0) | 0) % 7 | 0) - 7 | 0);
    break block;
   }
   HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] + (Math_imul(HEAP32[$10 + 40 >> 2], 7) + ((HEAP32[$10 + 36 >> 2] + (14 - ((HEAP32[$10 + 4 >> 2] + 4 | 0) % 7 | 0) | 0) | 0) % 7 | 0) | 0);
  }
  HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 24 >> 2] + Math_imul(HEAP32[$10 + 4 >> 2] + HEAP32[$10 + 28 >> 2] | 0, 1440);
  if (!(HEAP8[$10 + 11 | 0] & 1)) {
   HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] - HEAP32[$10 + 12 >> 2];
   if (!(HEAP8[$10 + 23 | 0] & 1)) {
    HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] - HEAP32[$10 + 16 >> 2]
   }
  }
  __stack_pointer = $10 + 48 | 0;
  return +HEAP32[$10 + 4 >> 2] * 60.0;
 }
 
 function jsdGetEffectiveTimeZone($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 176 | 0;
  __stack_pointer = $3;
  HEAPF64[$3 + 160 >> 3] = $0;
  HEAP8[$3 + 159 | 0] = $1;
  HEAP32[$3 + 152 >> 2] = $2;
  HEAP32[$3 + 148 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 4484);
  block3 : {
   block4 : {
    block : {
     if (!HEAP32[$3 + 148 >> 2]) {
      break block
     }
     if (!(jsvIsArrayBuffer(HEAP32[$3 + 148 >> 2]) & 1)) {
      break block
     }
     if ((jsvGetLength(HEAP32[$3 + 148 >> 2]) | 0) != 12 | HEAPU8[HEAP32[$3 + 148 >> 2] + 5 | 0] != 18) {
      break block
     }
     jsvArrayBufferIteratorNew($3 + 36 | 0, HEAP32[$3 + 148 >> 2], 0);
     HEAP32[$3 + 144 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 144 >> 2] < 12) {
       $2 = jsvArrayBufferIteratorGetIntegerValue($3 + 36 | 0);
       $1 = HEAP32[$3 + 144 >> 2];
       HEAP32[$3 + 144 >> 2] = $1 + 1;
       HEAP32[($3 + 96 | 0) + ($1 << 2) >> 2] = $2;
       jsvArrayBufferIteratorNext($3 + 36 | 0);
       continue;
      }
      break;
     };
     jsvArrayBufferIteratorFree($3 + 36 | 0);
     jsvUnLock(HEAP32[$3 + 148 >> 2]);
     if (HEAP32[$3 + 96 >> 2]) {
      HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 160 >> 3] / 1.0e3;
      $0 = HEAPF64[$3 + 24 >> 3] / 86400.0;
      if (Math_abs($0) < 2147483647.0) {
       $1 = ~~$0
      } else {
       $1 = -2147483648
      }
      getDateFromDayNumber($1, $3 + 144 | 0, 0, 0);
      HEAPF64[$3 + 16 >> 3] = getDstChangeTime(HEAP32[$3 + 144 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 108 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 116 >> 2], HEAP32[$3 + 120 >> 2], 1, HEAP32[$3 + 96 >> 2], HEAP32[$3 + 100 >> 2], HEAP8[$3 + 159 | 0] & 1);
      HEAPF64[$3 + 8 >> 3] = getDstChangeTime(HEAP32[$3 + 144 >> 2], HEAP32[$3 + 124 >> 2], HEAP32[$3 + 128 >> 2], HEAP32[$3 + 132 >> 2], HEAP32[$3 + 136 >> 2], HEAP32[$3 + 140 >> 2], 0, HEAP32[$3 + 96 >> 2], HEAP32[$3 + 100 >> 2], HEAP8[$3 + 159 | 0] & 1);
      block1 : {
       if (HEAPF64[$3 + 16 >> 3] < HEAPF64[$3 + 8 >> 3]) {
        $4 = HEAPF64[$3 + 24 >> 3] >= HEAPF64[$3 + 16 >> 3] ? HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 8 >> 3] : $4;
        HEAP8[$3 + 7 | 0] = $4;
        break block1;
       }
       $1 = 1;
       $1 = HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 8 >> 3] ? $1 : HEAPF64[$3 + 24 >> 3] >= HEAPF64[$3 + 16 >> 3];
       HEAP8[$3 + 7 | 0] = $1;
      }
      if (HEAP32[$3 + 152 >> 2]) {
       HEAP8[HEAP32[$3 + 152 >> 2]] = HEAP8[$3 + 7 | 0] & 1
      }
      if (HEAP8[$3 + 7 | 0] & 1) {
       $1 = HEAP32[$3 + 96 >> 2] + HEAP32[$3 + 100 >> 2] | 0
      } else {
       $1 = HEAP32[$3 + 100 >> 2]
      }
      HEAP32[$3 + 172 >> 2] = $1;
      break block3;
     }
     break block4;
    }
    jsvUnLock(HEAP32[$3 + 148 >> 2]);
   }
   if (HEAP32[$3 + 152 >> 2]) {
    HEAP8[HEAP32[$3 + 152 >> 2]] = 0
   }
   HEAP32[$3 + 172 >> 2] = jsvObjectGetIntegerChild(HEAP32[103308], 3469);
  }
  __stack_pointer = $3 + 176 | 0;
  return HEAP32[$3 + 172 >> 2];
 }
 
 function setCorrectTimeZone($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsdGetEffectiveTimeZone(fromTimeInDay(HEAP32[$1 + 12 >> 2]), 1, HEAP32[$1 + 12 >> 2] + 24 | 0);
  HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] = $0;
  __stack_pointer = $1 + 16 | 0;
 }
 
 function fromTimeInDay($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return +HEAP32[HEAP32[$1 + 12 >> 2] >> 2] * 864.0e5 + +(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + Math_imul((HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2], 60) | 0) - HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] | 0, 60) | 0, 1e3) | 0);
 }
 
 function getTimeFromMilliSeconds($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAPF64[$3 + 24 >> 3] = $1;
  HEAP8[$3 + 23 | 0] = $2;
  if (HEAP8[$3 + 23 | 0] & 1) {
   $2 = 0
  } else {
   $2 = jsdGetEffectiveTimeZone(HEAPF64[$3 + 24 >> 3], 0, $0 + 24 | 0)
  }
  HEAP32[$0 + 20 >> 2] = $2;
  HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] + +(Math_imul(HEAP32[$0 + 20 >> 2], 6e4) | 0);
  $1 = HEAPF64[$3 + 24 >> 3] / 864.0e5;
  if (Math_abs($1) < 2147483647.0) {
   $2 = ~~$1
  } else {
   $2 = -2147483648
  }
  HEAP32[$0 >> 2] = $2;
  if (HEAP8[$3 + 23 | 0] & 1) {
   HEAP8[$0 + 24 | 0] = 0
  }
  $1 = +HEAP32[$0 >> 2] * -864.0e5 + HEAPF64[$3 + 24 >> 3];
  if (Math_abs($1) < 2147483647.0) {
   $2 = ~~$1
  } else {
   $2 = -2147483648
  }
  HEAP32[$3 + 16 >> 2] = $2;
  if (HEAP32[$3 + 16 >> 2] < 0) {
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 864e5;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - 1;
  }
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2] / 1e3;
  HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 16 >> 2] % 1e3;
  HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 12 >> 2] / 3600;
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] % 3600;
  HEAP32[$0 + 12 >> 2] = HEAP32[$3 + 12 >> 2] / 60;
  HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 12 >> 2] % 60;
  __stack_pointer = $3 + 32 | 0;
 }
 
 function getCalendarDate($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $1;
  getDateFromDayNumber(HEAP32[$2 + 12 >> 2], $0 + 12 | 0, $0 + 8 | 0, $0 + 4 | 0);
  HEAP32[$0 >> 2] = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 16 >> 2] = (HEAP32[$0 >> 2] + 4 | 0) % 7;
  if (HEAP32[$0 + 16 >> 2] < 0) {
   HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 7
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function fromCalendarDate($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  while (1) {
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] < 0) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] - 1;
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 12;
    continue;
   }
   break;
  };
  while (1) {
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] > 11) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] - 12;
    continue;
   }
   break;
  };
  $0 = getDayNumberFromDate(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2], HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2], HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jswrap_date_now() {
  return +((+(jshGetSystemTime() >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296.0) * (1.0e3 / (+(jshGetTimeFromMilliseconds(1.0e3) >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296.0)));
 }
 
 function jswrap_date_from_milliseconds($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAP32[$1 + 4 >> 2] = jspNewObject(0, 17647);
  jswrap_date_setTime(HEAP32[$1 + 4 >> 2], HEAPF64[$1 + 8 >> 3]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function jswrap_date_setTime($0, $1) {
  $0 = $0 | 0;
  $1 = +$1;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 20 >> 2] = $0;
  HEAPF64[$2 + 8 >> 3] = $1;
  block1 : {
   if (HEAPF64[$2 + 8 >> 3] < -395083256832.0e5 | HEAPF64[$2 + 8 >> 3] >= 393840543168.0e5) {
    jsExceptionHere(1, 7514, 0);
    HEAPF64[$2 + 24 >> 3] = 0;
    break block1;
   }
   if (HEAP32[$2 + 20 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 20 >> 2], 7201, jsvNewFromFloat(HEAPF64[$2 + 8 >> 3]))
   }
   HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 8 >> 3];
  }
  __stack_pointer = $2 + 32 | 0;
  return +HEAPF64[$2 + 24 >> 3];
 }
 
 function jswrap_date_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 76 >> 2] = $0;
  HEAPF64[$1 + 64 >> 3] = 0;
  block : {
   if (!jsvGetArrayLength(HEAP32[$1 + 76 >> 2])) {
    HEAPF64[$1 + 64 >> 3] = jswrap_date_now();
    break block;
   }
   block3 : {
    if ((jsvGetArrayLength(HEAP32[$1 + 76 >> 2]) | 0) == 1) {
     HEAP32[$1 + 60 >> 2] = jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 0);
     block1 : {
      if (jsvIsNumeric(HEAP32[$1 + 60 >> 2]) & 1) {
       HEAPF64[$1 + 64 >> 3] = jsvGetFloat(HEAP32[$1 + 60 >> 2]);
       break block1;
      }
      block2 : {
       if (jsvIsString(HEAP32[$1 + 60 >> 2]) & 1) {
        HEAPF64[$1 + 64 >> 3] = jswrap_date_parse(HEAP32[$1 + 60 >> 2]);
        break block2;
       }
       HEAP32[$1 >> 2] = HEAP32[$1 + 60 >> 2];
       jsExceptionHere(3, 7709, $1);
      }
     }
     jsvUnLock(HEAP32[$1 + 60 >> 2]);
     break block3;
    }
    HEAP32[$1 + 52 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 0));
    HEAP32[$1 + 48 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 1));
    HEAP32[$1 + 44 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 2));
    HEAP32[$1 + 12 >> 2] = fromCalendarDate($1 + 40 | 0);
    HEAP32[$1 + 28 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 3));
    HEAP32[$1 + 24 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 4));
    HEAP32[$1 + 20 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 5));
    HEAP32[$1 + 16 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 6));
    setCorrectTimeZone($1 + 12 | 0);
    HEAPF64[$1 + 64 >> 3] = fromTimeInDay($1 + 12 | 0);
   }
  }
  $0 = jswrap_date_from_milliseconds(HEAPF64[$1 + 64 >> 3]);
  __stack_pointer = $1 + 80 | 0;
  return $0 | 0;
 }
 
 function jswrap_date_parse($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 208 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 196 >> 2] = $0;
  block : {
   if (!(jsvIsString(HEAP32[$1 + 196 >> 2]) & 1)) {
    HEAPF64[$1 + 200 >> 3] = 0;
    break block;
   }
   HEAP32[$1 + 168 >> 2] = 0;
   HEAP32[$1 + 184 >> 2] = 0;
   HEAP32[$1 + 180 >> 2] = 0;
   HEAP32[$1 + 176 >> 2] = 0;
   HEAP32[$1 + 172 >> 2] = 0;
   HEAP32[$1 + 188 >> 2] = 0;
   HEAP8[$1 + 192 | 0] = 0;
   getCalendarDate($1 + 148 | 0, 0);
   HEAP8[$1 + 147 | 0] = 0;
   HEAP32[$1 + 4 >> 2] = jslSetLex($1 + 8 | 0);
   jslInit(HEAP32[$1 + 196 >> 2]);
   block4 : {
    if (HEAPU16[$1 + 10 >> 1] == 128) {
     HEAP32[$1 + 156 >> 2] = getMonth(jslGetTokenValueAsString());
     HEAP32[$1 + 164 >> 2] = getDay(jslGetTokenValueAsString());
     block1 : {
      if (HEAP32[$1 + 156 >> 2] >= 0) {
       jslGetNextToken();
       if (HEAPU16[$1 + 10 >> 1] == 129) {
        HEAP32[$1 + 152 >> 2] = _parse_int();
        jslGetNextToken();
        if (HEAPU16[$1 + 10 >> 1] == 44) {
         jslGetNextToken();
         if (HEAPU16[$1 + 10 >> 1] == 129) {
          HEAP32[$1 + 160 >> 2] = _parse_int();
          HEAP32[$1 + 168 >> 2] = fromCalendarDate($1 + 148 | 0);
          jslGetNextToken();
          if (HEAPU16[$1 + 10 >> 1] == 129) {
           _parse_time($1 + 168 | 0, 0);
           HEAP8[$1 + 147 | 0] = 1;
          }
         }
        }
       }
       break block1;
      }
      block3 : {
       if (HEAP32[$1 + 164 >> 2] >= 0) {
        HEAP32[$1 + 156 >> 2] = 0;
        jslGetNextToken();
        if (HEAPU16[$1 + 10 >> 1] == 44) {
         jslGetNextToken();
         if (HEAPU16[$1 + 10 >> 1] == 129) {
          HEAP32[$1 + 152 >> 2] = _parse_int();
          jslGetNextToken();
          block2 : {
           if (HEAPU16[$1 + 10 >> 1] != 128) {
            break block2
           }
           if ((getMonth(jslGetTokenValueAsString()) | 0) < 0) {
            break block2
           }
           HEAP32[$1 + 156 >> 2] = getMonth(jslGetTokenValueAsString());
           jslGetNextToken();
           if (HEAPU16[$1 + 10 >> 1] == 129) {
            HEAP32[$1 + 160 >> 2] = _parse_int();
            HEAP32[$1 + 168 >> 2] = fromCalendarDate($1 + 148 | 0);
            jslGetNextToken();
            if (HEAPU16[$1 + 10 >> 1] == 129) {
             _parse_time($1 + 168 | 0, 0);
             HEAP8[$1 + 147 | 0] = 1;
            }
           }
          }
         }
        }
        break block3;
       }
       HEAP32[$1 + 164 >> 2] = 0;
       HEAP32[$1 + 156 >> 2] = 0;
      }
     }
     break block4;
    }
    if (HEAPU16[$1 + 10 >> 1] == 129) {
     HEAP32[$1 + 160 >> 2] = _parse_int();
     jslGetNextToken();
     if (HEAPU16[$1 + 10 >> 1] == 45) {
      jslGetNextToken();
      if (HEAPU16[$1 + 10 >> 1] == 129) {
       HEAP32[$1 + 156 >> 2] = _parse_int() - 1;
       jslGetNextToken();
       if (HEAPU16[$1 + 10 >> 1] == 45) {
        jslGetNextToken();
        if (HEAPU16[$1 + 10 >> 1] == 129) {
         HEAP32[$1 + 152 >> 2] = _parse_int();
         HEAP32[$1 + 168 >> 2] = fromCalendarDate($1 + 148 | 0);
         jslGetNextToken();
         block5 : {
          if (HEAPU16[$1 + 10 >> 1] != 128) {
           break block5
          }
          if (HEAPU8[jslGetTokenValueAsString() | 0] != 84) {
           break block5
          }
          _parse_time($1 + 168 | 0, 1);
          HEAP8[$1 + 147 | 0] = 1;
         }
        }
       }
      }
     }
    }
   }
   if (!(HEAP8[$1 + 147 | 0] & 1)) {
    setCorrectTimeZone($1 + 168 | 0)
   }
   jslKill();
   jslSetLex(HEAP32[$1 + 4 >> 2]);
   HEAPF64[$1 + 200 >> 3] = fromTimeInDay($1 + 168 | 0);
  }
  __stack_pointer = $1 + 208 | 0;
  return +HEAPF64[$1 + 200 >> 3];
 }
 
 function getMonth($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = 0;
  block1 : {
   while (1) {
    if (HEAP32[$1 + 4 >> 2] < 12) {
     if (!(HEAPU8[HEAP32[$1 + 8 >> 2]] != HEAPU8[HEAP32[61120] + (HEAP32[$1 + 4 >> 2] << 2) | 0] | HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0] != HEAPU8[HEAP32[61120] + ((HEAP32[$1 + 4 >> 2] << 2) + 1 | 0) | 0] | HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0] != HEAPU8[HEAP32[61120] + ((HEAP32[$1 + 4 >> 2] << 2) + 2 | 0) | 0])) {
      HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
      break block1;
     }
     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$1 + 12 >> 2] = -1;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function getDay($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = 0;
  block : {
   while (1) {
    if (HEAP32[$1 + 4 >> 2] < 7) {
     if (strcmp(HEAP32[$1 + 8 >> 2], HEAP32[61121] + (HEAP32[$1 + 4 >> 2] << 2) | 0)) {
      HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
      continue;
     } else {
      HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
      break block;
     }
    }
    break;
   };
   HEAP32[$1 + 12 >> 2] = -1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function _parse_int() {
  return stringToIntWithRadix(jslGetTokenValueAsString(), 10, 0, 0);
 }
 
 function _parse_time($0, $1) {
  var $2 = 0, $3 = 0.0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  $0 = stringToIntWithRadix(jslGetTokenValueAsString() + HEAP32[$2 + 36 >> 2] | 0, 10, 0, 0);
  HEAP32[HEAP32[$2 + 40 >> 2] + 16 >> 2] = $0;
  jslGetNextToken();
  block2 : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 58) {
    jslGetNextToken();
    if (HEAPU16[HEAP32[61300] + 2 >> 1] == 129) {
     $0 = _parse_int();
     HEAP32[HEAP32[$2 + 40 >> 2] + 12 >> 2] = $0;
     jslGetNextToken();
     if (HEAPU16[HEAP32[61300] + 2 >> 1] == 58) {
      jslGetNextToken();
      if (!(HEAPU16[HEAP32[61300] + 2 >> 1] != 129 & HEAPU16[HEAP32[61300] + 2 >> 1] != 130)) {
       HEAPF64[$2 + 24 >> 3] = stringToFloat(jslGetTokenValueAsString());
       $1 = HEAP32[$2 + 40 >> 2];
       $3 = HEAPF64[$2 + 24 >> 3];
       if (Math_abs($3) < 2147483647.0) {
        $0 = ~~$3
       } else {
        $0 = -2147483648
       }
       HEAP32[$1 + 8 >> 2] = $0;
       $1 = HEAP32[$2 + 40 >> 2];
       $3 = HEAPF64[$2 + 24 >> 3] * 1.0e3;
       if (Math_abs($3) < 2147483647.0) {
        $0 = ~~$3
       } else {
        $0 = -2147483648
       }
       HEAP32[$1 + 4 >> 2] = ($0 | 0) % 1e3;
       jslGetNextToken();
       if (HEAPU16[HEAP32[61300] + 2 >> 1] == 128) {
        HEAP32[$2 + 20 >> 2] = jslGetTokenValueAsString();
        block3 : {
         block1 : {
          if (strcmp(HEAP32[$2 + 20 >> 2], 21064)) {
           if (strcmp(HEAP32[$2 + 20 >> 2], 20800)) {
            break block1
           }
          }
          HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2] = 0;
          jslGetNextToken();
          if (!HEAPU16[HEAP32[61300] + 2 >> 1]) {
           HEAP8[$2 + 47 | 0] = 1;
           break block2;
          }
          break block3;
         }
         setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
        }
       }
       block8 : {
        if (!(HEAPU16[HEAP32[61300] + 2 >> 1] != 43 & HEAPU16[HEAP32[61300] + 2 >> 1] != 45)) {
         HEAP32[$2 + 16 >> 2] = HEAPU16[HEAP32[61300] + 2 >> 1] == 43 ? 1 : -1;
         jslGetNextToken();
         block7 : {
          if (HEAPU16[HEAP32[61300] + 2 >> 1] == 129) {
           HEAP32[$2 + 12 >> 2] = _parse_int();
           HEAP32[$2 + 8 >> 2] = jslGetTokenLength();
           block5 : {
            if (HEAP32[$2 + 8 >> 2] == 4) {
             HEAP32[$2 + 12 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2] / 100 | 0, 60) + (HEAP32[$2 + 12 >> 2] % 100 | 0);
             break block5;
            }
            HEAP32[$2 + 12 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2], 60);
           }
           jslGetNextToken();
           if (!(HEAP32[$2 + 8 >> 2] != 2 | HEAPU16[HEAP32[61300] + 2 >> 1] != 58)) {
            jslGetNextToken();
            if (HEAPU16[HEAP32[61300] + 2 >> 1] == 129) {
             HEAP32[$2 + 12 >> 2] = _parse_int() + HEAP32[$2 + 12 >> 2]
            }
           }
           HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
           break block7;
          }
          setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
         }
         break block8;
        }
        setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
       }
       HEAP8[$2 + 47 | 0] = 1;
       break block2;
      }
     }
    }
   }
   setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
   HEAP8[$2 + 47 | 0] = 0;
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP8[$2 + 47 | 0] & 1;
 }
 
 function jswrap_date_getTimezoneOffset($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return 0 - HEAP32[$1 + 20 >> 2] | 0;
 }
 
 function getTimeFromDateVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP8[$3 + 11 | 0] = $2;
  getTimeFromMilliSeconds($0, jswrap_date_getTime(HEAP32[$3 + 12 >> 2]), HEAP8[$3 + 11 | 0] & 1);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_date_getTime($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = jsvObjectGetFloatChild(HEAP32[$1 + 12 >> 2], 7201);
  __stack_pointer = $1 + 16 | 0;
  return +$2;
 }
 
 function jswrap_date_getIsDST($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP8[$1 + 24 | 0] & 1;
 }
 
 function jswrap_date_getHours($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 16 >> 2];
 }
 
 function jswrap_date_getMinutes($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_date_getSeconds($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jswrap_date_getMilliseconds($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function jswrap_date_getDay($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 24 >> 2];
 }
 
 function getCalendarDateFromDateVar($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $1;
  HEAP8[$3 + 43 | 0] = $2;
  getTimeFromDateVar($3 + 12 | 0, HEAP32[$3 + 44 >> 2], HEAP8[$3 + 43 | 0] & 1);
  getCalendarDate($0, HEAP32[$3 + 12 >> 2]);
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jswrap_date_getDate($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_date_getMonth($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 16 >> 2];
 }
 
 function jswrap_date_getFullYear($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 20 >> 2];
 }
 
 function jswrap_date_setHours($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0, $6 = 0.0;
  $5 = __stack_pointer - 48 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 44 >> 2] = $0;
  HEAP32[$5 + 40 >> 2] = $1;
  HEAP32[$5 + 36 >> 2] = $2;
  HEAP32[$5 + 32 >> 2] = $3;
  HEAP32[$5 + 28 >> 2] = $4;
  getTimeFromDateVar($5, HEAP32[$5 + 44 >> 2], 0);
  HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 40 >> 2];
  if (jsvIsNumeric(HEAP32[$5 + 36 >> 2]) & 1) {
   HEAP32[$5 + 12 >> 2] = jsvGetInteger(HEAP32[$5 + 36 >> 2])
  }
  if (jsvIsNumeric(HEAP32[$5 + 32 >> 2]) & 1) {
   HEAP32[$5 + 8 >> 2] = jsvGetInteger(HEAP32[$5 + 32 >> 2])
  }
  if (jsvIsNumeric(HEAP32[$5 + 28 >> 2]) & 1) {
   HEAP32[$5 + 4 >> 2] = jsvGetInteger(HEAP32[$5 + 28 >> 2])
  }
  setCorrectTimeZone($5);
  $6 = jswrap_date_setTime(HEAP32[$5 + 44 >> 2], fromTimeInDay($5));
  __stack_pointer = $5 + 48 | 0;
  return +$6;
 }
 
 function jswrap_date_setMinutes($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0.0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP32[$4 + 32 >> 2] = $3;
  getTimeFromDateVar($4 + 4 | 0, HEAP32[$4 + 44 >> 2], 0);
  HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 40 >> 2];
  if (jsvIsNumeric(HEAP32[$4 + 36 >> 2]) & 1) {
   HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 36 >> 2])
  }
  if (jsvIsNumeric(HEAP32[$4 + 32 >> 2]) & 1) {
   HEAP32[$4 + 8 >> 2] = jsvGetInteger(HEAP32[$4 + 32 >> 2])
  }
  setCorrectTimeZone($4 + 4 | 0);
  $5 = jswrap_date_setTime(HEAP32[$4 + 44 >> 2], fromTimeInDay($4 + 4 | 0));
  __stack_pointer = $4 + 48 | 0;
  return +$5;
 }
 
 function jswrap_date_setSeconds($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  getTimeFromDateVar($3 + 8 | 0, HEAP32[$3 + 44 >> 2], 0);
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 40 >> 2];
  if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
   HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2])
  }
  setCorrectTimeZone($3 + 8 | 0);
  $4 = jswrap_date_setTime(HEAP32[$3 + 44 >> 2], fromTimeInDay($3 + 8 | 0));
  __stack_pointer = $3 + 48 | 0;
  return +$4;
 }
 
 function jswrap_date_setMilliseconds($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0.0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP32[$2 + 40 >> 2] = $1;
  getTimeFromDateVar($2 + 12 | 0, HEAP32[$2 + 44 >> 2], 0);
  HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 40 >> 2];
  setCorrectTimeZone($2 + 12 | 0);
  $3 = jswrap_date_setTime(HEAP32[$2 + 44 >> 2], fromTimeInDay($2 + 12 | 0));
  __stack_pointer = $2 + 48 | 0;
  return +$3;
 }
 
 function jswrap_date_setDate($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0.0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 60 >> 2] = $0;
  HEAP32[$2 + 56 >> 2] = $1;
  getTimeFromDateVar($2 + 28 | 0, HEAP32[$2 + 60 >> 2], 0);
  getCalendarDate($2 + 8 | 0, HEAP32[$2 + 28 >> 2]);
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 56 >> 2];
  HEAP32[$2 + 28 >> 2] = fromCalendarDate($2 + 8 | 0);
  setCorrectTimeZone($2 + 28 | 0);
  $3 = jswrap_date_setTime(HEAP32[$2 + 60 >> 2], fromTimeInDay($2 + 28 | 0));
  __stack_pointer = $2 - -64 | 0;
  return +$3;
 }
 
 function jswrap_date_setMonth($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  getTimeFromDateVar($3 + 24 | 0, HEAP32[$3 + 60 >> 2], 0);
  getCalendarDate($3 + 4 | 0, HEAP32[$3 + 24 >> 2]);
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 56 >> 2];
  if (jsvIsNumeric(HEAP32[$3 + 52 >> 2]) & 1) {
   HEAP32[$3 + 8 >> 2] = jsvGetInteger(HEAP32[$3 + 52 >> 2])
  }
  HEAP32[$3 + 24 >> 2] = fromCalendarDate($3 + 4 | 0);
  setCorrectTimeZone($3 + 24 | 0);
  $4 = jswrap_date_setTime(HEAP32[$3 + 60 >> 2], fromTimeInDay($3 + 24 | 0));
  __stack_pointer = $3 - -64 | 0;
  return +$4;
 }
 
 function jswrap_date_setFullYear($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0.0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP32[$4 + 48 >> 2] = $3;
  getTimeFromDateVar($4 + 20 | 0, HEAP32[$4 + 60 >> 2], 0);
  getCalendarDate($4, HEAP32[$4 + 20 >> 2]);
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 56 >> 2];
  if (jsvIsNumeric(HEAP32[$4 + 52 >> 2]) & 1) {
   HEAP32[$4 + 8 >> 2] = jsvGetInteger(HEAP32[$4 + 52 >> 2])
  }
  if (jsvIsNumeric(HEAP32[$4 + 48 >> 2]) & 1) {
   HEAP32[$4 + 4 >> 2] = jsvGetInteger(HEAP32[$4 + 48 >> 2])
  }
  HEAP32[$4 + 20 >> 2] = fromCalendarDate($4);
  setCorrectTimeZone($4 + 20 | 0);
  $5 = jswrap_date_setTime(HEAP32[$4 + 60 >> 2], fromTimeInDay($4 + 20 | 0));
  __stack_pointer = $4 - -64 | 0;
  return +$5;
 }
 
 function jswrap_date_toString($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 92 >> 2] = $0;
  getTimeFromDateVar($1 - -64 | 0, HEAP32[$1 + 92 >> 2], 0);
  getCalendarDate($1 + 44 | 0, HEAP32[$1 + 64 >> 2]);
  block : {
   if (HEAP32[$1 + 84 >> 2] < 0) {
    HEAP32[$1 + 36 >> 2] = 0 - HEAP32[$1 + 84 >> 2];
    HEAP8[$1 + 43 | 0] = 45;
    break block;
   }
   HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 84 >> 2];
   HEAP8[$1 + 43 | 0] = 43;
  }
  $0 = HEAP32[61121];
  $2 = HEAP32[$1 + 60 >> 2] << 2;
  $3 = HEAP32[61120];
  $4 = HEAP32[$1 + 52 >> 2] << 2;
  $5 = HEAP32[$1 + 48 >> 2];
  $6 = HEAP32[$1 + 56 >> 2];
  $7 = HEAP32[$1 + 80 >> 2];
  $8 = HEAP32[$1 + 76 >> 2];
  $9 = HEAP32[$1 + 72 >> 2];
  $10 = HEAP8[$1 + 43 | 0];
  HEAP32[$1 + 32 >> 2] = Math_imul(HEAP32[$1 + 36 >> 2] / 60 | 0, 100) + (HEAP32[$1 + 36 >> 2] % 60 | 0);
  HEAP32[$1 + 28 >> 2] = $10;
  HEAP32[$1 + 24 >> 2] = $9;
  HEAP32[$1 + 20 >> 2] = $8;
  HEAP32[$1 + 16 >> 2] = $7;
  HEAP32[$1 + 12 >> 2] = $6;
  HEAP32[$1 + 8 >> 2] = $5;
  HEAP32[$1 + 4 >> 2] = $3 + $4;
  HEAP32[$1 >> 2] = $0 + $2;
  $0 = jsvVarPrintf(19623, $1);
  __stack_pointer = $1 + 96 | 0;
  return $0 | 0;
 }
 
 function jswrap_date_toUTCString($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 76 >> 2] = $0;
  getTimeFromDateVar($1 + 48 | 0, HEAP32[$1 + 76 >> 2], 1);
  getCalendarDate($1 + 28 | 0, HEAP32[$1 + 48 >> 2]);
  $0 = HEAP32[61121];
  $2 = HEAP32[$1 + 44 >> 2] << 2;
  $3 = HEAP32[$1 + 32 >> 2];
  $4 = HEAP32[61120];
  $5 = HEAP32[$1 + 36 >> 2] << 2;
  $6 = HEAP32[$1 + 40 >> 2];
  $7 = HEAP32[$1 + 64 >> 2];
  $8 = HEAP32[$1 + 60 >> 2];
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 56 >> 2];
  HEAP32[$1 + 20 >> 2] = $8;
  HEAP32[$1 + 16 >> 2] = $7;
  HEAP32[$1 + 12 >> 2] = $6;
  HEAP32[$1 + 8 >> 2] = $4 + $5;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 >> 2] = $0 + $2;
  $0 = jsvVarPrintf(21036, $1);
  __stack_pointer = $1 + 80 | 0;
  return $0 | 0;
 }
 
 function jswrap_date_toISOString($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 76 >> 2] = $0;
  getTimeFromDateVar($1 + 48 | 0, HEAP32[$1 + 76 >> 2], 1);
  getCalendarDate($1 + 28 | 0, HEAP32[$1 + 48 >> 2]);
  $0 = HEAP32[$1 + 40 >> 2];
  $2 = HEAP32[$1 + 36 >> 2];
  $3 = HEAP32[$1 + 32 >> 2];
  $4 = HEAP32[$1 + 64 >> 2];
  $5 = HEAP32[$1 + 60 >> 2];
  $6 = HEAP32[$1 + 56 >> 2];
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 52 >> 2];
  HEAP32[$1 + 20 >> 2] = $6;
  HEAP32[$1 + 16 >> 2] = $5;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = $2 + 1;
  HEAP32[$1 >> 2] = $0;
  $0 = jsvVarPrintf(20768, $1);
  __stack_pointer = $1 + 80 | 0;
  return $0 | 0;
 }
 
 function jswrap_date_toLocalISOString($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 92 >> 2] = $0;
  getTimeFromDateVar($1 - -64 | 0, HEAP32[$1 + 92 >> 2], 0);
  getCalendarDate($1 + 44 | 0, HEAP32[$1 + 64 >> 2]);
  block : {
   if (HEAP32[$1 + 84 >> 2] < 0) {
    HEAP32[$1 + 36 >> 2] = 0 - HEAP32[$1 + 84 >> 2];
    HEAP8[$1 + 43 | 0] = 45;
    break block;
   }
   HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 84 >> 2];
   HEAP8[$1 + 43 | 0] = 43;
  }
  HEAP32[$1 + 36 >> 2] = Math_imul(HEAP32[$1 + 36 >> 2] / 60 | 0, 100) + (HEAP32[$1 + 36 >> 2] % 60 | 0);
  $0 = HEAP32[$1 + 56 >> 2];
  $2 = HEAP32[$1 + 52 >> 2];
  $3 = HEAP32[$1 + 48 >> 2];
  $4 = HEAP32[$1 + 80 >> 2];
  $5 = HEAP32[$1 + 76 >> 2];
  $6 = HEAP32[$1 + 72 >> 2];
  $7 = HEAP32[$1 + 68 >> 2];
  $8 = HEAP8[$1 + 43 | 0];
  HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 36 >> 2];
  HEAP32[$1 + 28 >> 2] = $8;
  HEAP32[$1 + 24 >> 2] = $7;
  HEAP32[$1 + 20 >> 2] = $6;
  HEAP32[$1 + 16 >> 2] = $5;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = $2 + 1;
  HEAP32[$1 >> 2] = $0;
  $0 = jsvVarPrintf(19584, $1);
  __stack_pointer = $1 + 96 | 0;
  return $0 | 0;
 }
 
 function _jswrap_error_constructor($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = jspNewObject(0, HEAP32[$2 + 20 >> 2]);
  block : {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   if (HEAP32[$2 + 24 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 18108, jsvAsString(HEAP32[$2 + 24 >> 2]))
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 17778, jsvNewFromString(HEAP32[$2 + 20 >> 2]));
   if (HEAP32[61300]) {
    HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_1475();
    if (HEAP32[$2 + 12 >> 2]) {
     jspAppendStackTrace(HEAP32[$2 + 12 >> 2], HEAP32[61300]);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 15983, HEAP32[$2 + 12 >> 2]);
    }
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvNewFromEmptyString_1475() {
  return jsvNewWithFlags(29);
 }
 
 function jswrap_error_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 7894);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_syntaxerror_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 7849);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_typeerror_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 7875);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_internalerror_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 7861);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_referenceerror_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 7885);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_error_toString($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 24 >> 2], 17778);
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 20 >> 2] = jsvNewFromString(7894)
  }
  block : {
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 24 >> 2], 18108);
   if (HEAP32[$1 + 16 >> 2]) {
    $0 = HEAP32[$1 + 20 >> 2];
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 16 >> 2];
    HEAP32[$1 >> 2] = $0;
    HEAP32[$1 + 12 >> 2] = jsvVarPrintf(4227, $1);
    jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 12 >> 2];
   }
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jswrap_global() {
  return jsvLockAgain(HEAP32[103307]) | 0;
 }
 
 function jswrap_arguments() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = 0;
  if (HEAP32[103310]) {
   HEAP32[$0 + 8 >> 2] = jsvLockAgain(HEAP32[103310])
  }
  block : {
   if (!(jsvIsFunction(HEAP32[$0 + 8 >> 2]) & 1)) {
    jsExceptionHere(1, 15305, 0);
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 4 >> 2] = jsvGetFunctionArgumentLength(HEAP32[$0 + 8 >> 2]);
   jsvObjectSetChild(HEAP32[$0 + 8 >> 2], 6800, HEAP32[$0 + 4 >> 2]);
   jsvUnLock(HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_function_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(7);
  block : {
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
   HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_1485($1 + 16 | 0);
   jsvObjectIteratorNext($1 + 16 | 0);
   while (1) {
    if (jsvObjectIteratorHasValue_1486($1 + 16 | 0) & 1) {
     HEAP32[$1 + 8 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
     if (HEAP32[$1 + 8 >> 2]) {
      HEAP32[$1 + 4 >> 2] = jsvNewFromString(1024);
      if (HEAP32[$1 + 4 >> 2]) {
       jsvAppendStringVarComplete(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
       jsvAddFunctionParameter(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 4 >> 2], 0);
      }
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
     }
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_1485($1 + 16 | 0);
     jsvObjectIteratorNext($1 + 16 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1487($1 + 16 | 0);
   if (!(jsvIsString(HEAP32[$1 + 12 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
    jsExceptionHere(3, 27051, $1);
    jsvUnLock2(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 18659, HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvObjectIteratorGetValue_1485($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1486($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorFree_1487($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_eval($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 >> 2] = jspEvaluateVar(HEAP32[$1 + 4 >> 2], 0, 15909);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_parseInt($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 144 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 136 >> 2] = $0;
  HEAP32[$2 + 132 >> 2] = $1;
  HEAP32[$2 + 128 >> 2] = 0;
  if (jsvIsNumeric(HEAP32[$2 + 132 >> 2]) & 1) {
   HEAP32[$2 + 128 >> 2] = jsvGetInteger(HEAP32[$2 + 132 >> 2])
  }
  block1 : {
   block : {
    if (!(jsvIsFloat(HEAP32[$2 + 136 >> 2]) & 1)) {
     break block
    }
    __DOUBLE_BITS_1491(jsvGetFloat(HEAP32[$2 + 136 >> 2]));
    if ((i64toi32_i32$HIGH_BITS & 2147483647) >>> 0 < 2146435072) {
     break block
    }
    HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(NaN);
    break block1;
   }
   HEAP32[$2 + 44 >> 2] = $2 + 48;
   jsvGetString(HEAP32[$2 + 136 >> 2], $2 + 48 | 0, 70);
   HEAP8[$2 + 43 | 0] = 0;
   if (!(HEAPU8[$2 + 49 | 0] != 120 & HEAPU8[$2 + 49 | 0] != 88 | (HEAPU8[$2 + 48 | 0] != 48 | (HEAP32[$2 + 128 >> 2] != 16 ? HEAP32[$2 + 128 >> 2] : 0)))) {
    HEAP32[$2 + 128 >> 2] = 16;
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 44 >> 2] + 2;
   }
   if (!HEAP32[$2 + 128 >> 2]) {
    HEAP32[$2 + 128 >> 2] = 10
   }
   HEAP32[$2 + 24 >> 2] = stringToIntWithRadix(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 128 >> 2], $2 + 43 | 0, $2 + 36 | 0);
   HEAP32[$2 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
   if (HEAP8[$2 + 43 | 0] & 1) {
    HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(NaN);
    break block1;
   }
   if (HEAP32[$2 + 36 >> 2] == ($2 + 117 | 0)) {
    jsExceptionHere(1, 8306, 0);
    HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(NaN);
    break block1;
   }
   HEAP32[$2 + 140 >> 2] = jsvNewFromLongInteger(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2]);
  }
  __stack_pointer = $2 + 144 | 0;
  return HEAP32[$2 + 140 >> 2];
 }
 
 function __DOUBLE_BITS_1491($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_parseFloat($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 100 >> 2] = $0;
  jsvGetString(HEAP32[$1 + 100 >> 2], $1 + 16 | 0, 70);
  block : {
   if (!strcmp($1 + 16 | 0, 3527)) {
    HEAPF64[$1 + 104 >> 3] = Infinity;
    break block;
   }
   if (!strcmp($1 + 16 | 0, 3526)) {
    HEAPF64[$1 + 104 >> 3] = -Infinity;
    break block;
   }
   HEAPF64[$1 >> 3] = stringToFloatWithRadix($1 + 16 | 0, 0, $1 + 12 | 0);
   if (HEAP32[$1 + 12 >> 2] == ($1 + 85 | 0)) {
    jsExceptionHere(1, 8306, 0);
    HEAPF64[$1 + 104 >> 3] = NaN;
    break block;
   }
   HEAPF64[$1 + 104 >> 3] = HEAPF64[$1 >> 3];
  }
  __stack_pointer = $1 + 112 | 0;
  return +HEAPF64[$1 + 104 >> 3];
 }
 
 function jswrap_isFinite($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAPF64[$1 + 16 >> 3] = jsvGetFloat(HEAP32[$1 + 28 >> 2]);
  $2 = __DOUBLE_BITS_1491(HEAPF64[$1 + 16 >> 3]);
  $0 = $2;
  $3 = i64toi32_i32$HIGH_BITS;
  $2 = $3 & 2147483647;
  $3 = $0;
  $0 = 0;
  block : {
   if (($2 | 0) == 2146435072 & ($3 | 0) != 0 | $2 >>> 0 > 2146435072) {
    break block
   }
   $0 = 0;
   if (HEAPF64[$1 + 16 >> 3] == Infinity) {
    break block
   }
   $0 = HEAPF64[$1 + 16 >> 3] != -Infinity;
  }
  __stack_pointer = $1 + 32 | 0;
  return $0 | 0;
 }
 
 function jswrap_isNaN($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  block2 : {
   block1 : {
    block : {
     if (jsvIsUndefined(HEAP32[$1 + 72 >> 2]) & 1) {
      break block
     }
     if (jsvIsObject(HEAP32[$1 + 72 >> 2]) & 1) {
      break block
     }
     if (!(jsvIsFloat(HEAP32[$1 + 72 >> 2]) & 1)) {
      if (!(jsvIsArray(HEAP32[$1 + 72 >> 2]) & 1)) {
       break block1
      }
     }
     $0 = __DOUBLE_BITS_1491(jsvGetFloat(HEAP32[$1 + 72 >> 2]));
     $3 = $0;
     $2 = i64toi32_i32$HIGH_BITS;
     $0 = $2 & 2147483647;
     $2 = $3;
     if (($0 | 0) == 2146435072 & ($2 | 0) != 0 | $0 >>> 0 > 2146435072) {
      break block
     }
     break block1;
    }
    HEAP8[$1 + 79 | 0] = 1;
    break block2;
   }
   if (jsvIsString(HEAP32[$1 + 72 >> 2]) & 1) {
    HEAP8[$1 + 71 | 0] = 1;
    jsvStringIteratorNew($1 + 28 | 0, HEAP32[$1 + 72 >> 2], 0);
    while (1) {
     if (jsvStringIteratorHasChar_1495($1 + 28 | 0) & 1) {
      if (isWhitespace(jsvStringIteratorGetCharAndNext($1 + 28 | 0) << 24 >> 24) & 1) {
       continue
      }
      HEAP8[$1 + 71 | 0] = 0;
     }
     break;
    };
    jsvStringIteratorFree_1496($1 + 28 | 0);
    if (HEAP8[$1 + 71 | 0] & 1) {
     HEAP8[$1 + 79 | 0] = 0;
     break block2;
    }
    $2 = __DOUBLE_BITS_1491(jsvGetFloat(HEAP32[$1 + 72 >> 2]));
    $3 = $2;
    $0 = i64toi32_i32$HIGH_BITS;
    $2 = $0 & 2147483647;
    $0 = $3;
    HEAP8[$1 + 79 | 0] = ($2 | 0) == 2146435072 & ($0 | 0) != 0 | $2 >>> 0 > 2146435072;
    break block2;
   }
   HEAP8[$1 + 79 | 0] = 0;
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP8[$1 + 79 | 0] & 1;
 }
 
 function jsvStringIteratorHasChar_1495($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorFree_1496($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_btoa($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 160 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 152 >> 2] = $0;
  block : {
   if (!(jsvIsIterable(HEAP32[$1 + 152 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 152 >> 2];
    jsExceptionHere(1, 5445, $1);
    HEAP32[$1 + 156 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 148 >> 2] = jsvGetLength(HEAP32[$1 + 152 >> 2]);
   HEAP32[$1 + 144 >> 2] = (HEAP32[$1 + 148 >> 2] + 2 >>> 0) / 3 << 2;
   HEAP32[$1 + 140 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 144 >> 2], 0);
   if (!HEAP32[$1 + 140 >> 2]) {
    HEAP32[$1 + 156 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($1 + 76 | 0, HEAP32[$1 + 152 >> 2], 1);
   jsvStringIteratorNew($1 + 36 | 0, HEAP32[$1 + 140 >> 2], 0);
   HEAP32[$1 + 32 >> 2] = 0;
   while (1) {
    $0 = 0;
    if (jsvIteratorHasElement($1 + 76 | 0) & 1) {
     $0 = jspIsInterrupted() ^ -1
    }
    if ($0 & 1) {
     HEAP32[$1 + 28 >> 2] = jsvIteratorGetIntegerValue($1 + 76 | 0) & 255;
     jsvIteratorNext($1 + 76 | 0);
     HEAP32[$1 + 24 >> 2] = 0;
     HEAP32[$1 + 20 >> 2] = 0;
     block2 : {
      if (jsvIteratorHasElement($1 + 76 | 0) & 1) {
       HEAP32[$1 + 24 >> 2] = jsvIteratorGetIntegerValue($1 + 76 | 0) & 255;
       jsvIteratorNext($1 + 76 | 0);
       block1 : {
        if (jsvIteratorHasElement($1 + 76 | 0) & 1) {
         HEAP32[$1 + 20 >> 2] = jsvIteratorGetIntegerValue($1 + 76 | 0) & 255;
         jsvIteratorNext($1 + 76 | 0);
         HEAP32[$1 + 32 >> 2] = 0;
         break block1;
        }
        HEAP32[$1 + 32 >> 2] = 1;
       }
       break block2;
      }
      HEAP32[$1 + 32 >> 2] = 2;
     }
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 20 >> 2] + ((HEAP32[$1 + 28 >> 2] << 16) + (HEAP32[$1 + 24 >> 2] << 8) | 0);
     jsvStringIteratorSetCharAndNext($1 + 36 | 0, jswrap_btoa_encode(HEAP32[$1 + 16 >> 2] >> 18) << 24 >> 24);
     jsvStringIteratorSetCharAndNext($1 + 36 | 0, jswrap_btoa_encode(HEAP32[$1 + 16 >> 2] >> 12) << 24 >> 24);
     $2 = $1 + 36 | 0;
     if (HEAP32[$1 + 32 >> 2] > 1) {
      $0 = 61
     } else {
      $0 = jswrap_btoa_encode(HEAP32[$1 + 16 >> 2] >> 6)
     }
     jsvStringIteratorSetCharAndNext($2, $0 << 24 >> 24);
     $2 = $1 + 36 | 0;
     if (HEAP32[$1 + 32 >> 2] > 0) {
      $0 = 61
     } else {
      $0 = jswrap_btoa_encode(HEAP32[$1 + 16 >> 2])
     }
     jsvStringIteratorSetCharAndNext($2, $0 << 24 >> 24);
     continue;
    }
    break;
   };
   jsvIteratorFree($1 + 76 | 0);
   jsvStringIteratorFree_1496($1 + 36 | 0);
   HEAP32[$1 + 156 >> 2] = HEAP32[$1 + 140 >> 2];
  }
  __stack_pointer = $1 + 160 | 0;
  return HEAP32[$1 + 156 >> 2];
 }
 
 function jswrap_btoa_encode($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] & 63;
  block : {
   if (HEAP32[$1 + 8 >> 2] < 26) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 65;
    break block;
   }
   if (HEAP32[$1 + 8 >> 2] < 52) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 71;
    break block;
   }
   if (HEAP32[$1 + 8 >> 2] < 62) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] - 4;
    break block;
   }
   if (HEAP32[$1 + 8 >> 2] == 62) {
    HEAP32[$1 + 12 >> 2] = 43;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = 47;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_atob($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 128 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 120 >> 2] = $0;
  block : {
   if (!(jsvIsString(HEAP32[$1 + 120 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
    jsExceptionHere(1, 6022, $1);
    HEAP32[$1 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 116 >> 2] = 0;
   jsvStringIteratorNew($1 + 76 | 0, HEAP32[$1 + 120 >> 2], 0);
   HEAP8[$1 + 75 | 0] = 0;
   HEAP8[$1 + 74 | 0] = 0;
   while (1) {
    if (jsvStringIteratorHasChar_1495($1 + 76 | 0) & 1) {
     HEAP8[$1 + 73 | 0] = jsvStringIteratorGetChar_1500($1 + 76 | 0);
     if (!(isWhitespace(HEAP8[$1 + 73 | 0] << 24 >> 24) & 1)) {
      HEAP8[$1 + 74 | 0] = HEAPU8[$1 + 75 | 0];
      HEAP8[$1 + 75 | 0] = HEAPU8[$1 + 73 | 0];
      HEAP32[$1 + 116 >> 2] = HEAP32[$1 + 116 >> 2] + 1;
     }
     jsvStringIteratorNext($1 + 76 | 0);
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1496($1 + 76 | 0);
   HEAP32[$1 + 68 >> 2] = Math_imul(HEAP32[$1 + 116 >> 2], 3) >>> 2;
   if (HEAPU8[$1 + 75 | 0] == 61) {
    HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] - 1
   }
   if (HEAPU8[$1 + 74 | 0] == 61) {
    HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] - 1
   }
   HEAP32[$1 + 64 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 68 >> 2], 0);
   if (!HEAP32[$1 + 64 >> 2]) {
    HEAP32[$1 + 124 >> 2] = 0;
    break block;
   }
   jsvStringIteratorNew($1 + 76 | 0, HEAP32[$1 + 120 >> 2], 0);
   jsvStringIteratorNew($1 + 24 | 0, HEAP32[$1 + 64 >> 2], 0);
   while (1) {
    $0 = 0;
    if (jsvStringIteratorHasChar_1495($1 + 76 | 0) & 1) {
     $0 = jspIsInterrupted() ^ -1
    }
    if ($0 & 1) {
     HEAP32[$1 + 20 >> 2] = 0;
     HEAP32[$1 + 12 >> 2] = 0;
     HEAP32[$1 + 16 >> 2] = 0;
     while (1) {
      if (HEAP32[$1 + 16 >> 2] < 4) {
       if (jsvStringIteratorHasChar_1495($1 + 76 | 0) & 1) {
        HEAP8[$1 + 11 | 0] = 32;
        while (1) {
         $0 = 0;
         if (HEAP8[$1 + 11 | 0] << 24 >> 24) {
          $0 = isWhitespace(HEAP8[$1 + 11 | 0] << 24 >> 24)
         }
         if ($0 & 1) {
          HEAP8[$1 + 11 | 0] = jsvStringIteratorGetCharAndNext($1 + 76 | 0);
          continue;
         }
         break;
        };
        HEAP32[$1 + 4 >> 2] = jswrap_atob_decode(HEAP8[$1 + 11 | 0] << 24 >> 24);
        if (HEAP32[$1 + 4 >> 2] >= 0) {
         HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] | HEAP32[$1 + 4 >> 2] << Math_imul(3 - HEAP32[$1 + 16 >> 2] | 0, 6);
         HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 16 >> 2];
        }
       }
       HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
       continue;
      }
      break;
     };
     if (HEAP32[$1 + 12 >> 2] > 0) {
      jsvStringIteratorSetCharAndNext($1 + 24 | 0, HEAP32[$1 + 20 >> 2] >>> 16 << 24 >> 24)
     }
     if (HEAP32[$1 + 12 >> 2] > 1) {
      jsvStringIteratorSetCharAndNext($1 + 24 | 0, HEAP32[$1 + 20 >> 2] >>> 8 << 24 >> 24)
     }
     if (HEAP32[$1 + 12 >> 2] > 2) {
      jsvStringIteratorSetCharAndNext($1 + 24 | 0, HEAP32[$1 + 20 >> 2] << 24 >> 24)
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1496($1 + 76 | 0);
   jsvStringIteratorFree_1496($1 + 24 | 0);
   HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 64 >> 2];
  }
  __stack_pointer = $1 + 128 | 0;
  return HEAP32[$1 + 124 >> 2];
 }
 
 function jsvStringIteratorGetChar_1500($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function jswrap_atob_decode($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] & 255;
  block1 : {
   if (!(HEAP32[$1 + 8 >> 2] < 65 | HEAP32[$1 + 8 >> 2] > 90)) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] - 65;
    break block1;
   }
   if (!(HEAP32[$1 + 8 >> 2] < 97 | HEAP32[$1 + 8 >> 2] > 122)) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] - 71;
    break block1;
   }
   if (!(HEAP32[$1 + 8 >> 2] < 48 | HEAP32[$1 + 8 >> 2] > 57)) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 4;
    break block1;
   }
   if (HEAP32[$1 + 8 >> 2] == 43) {
    HEAP32[$1 + 12 >> 2] = 62;
    break block1;
   }
   if (HEAP32[$1 + 8 >> 2] == 47) {
    HEAP32[$1 + 12 >> 2] = 63;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = -1;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_encodeURIComponent($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 104 >> 2] = $0;
  HEAP32[$1 + 100 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
  block : {
   if (!HEAP32[$1 + 100 >> 2]) {
    HEAP32[$1 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 96 >> 2] = jsvNewFromEmptyString_1503();
   if (HEAP32[$1 + 96 >> 2]) {
    jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 100 >> 2], 0);
    jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 96 >> 2], 0);
    while (1) {
     if (jsvStringIteratorHasChar_1495($1 + 56 | 0) & 1) {
      HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
      block3 : {
       block2 : {
        block1 : {
         if (isAlpha(HEAP8[$1 + 15 | 0] << 24 >> 24) & 1) {
          break block1
         }
         if (isNumeric(HEAP8[$1 + 15 | 0] << 24 >> 24) & 1 | HEAPU8[$1 + 15 | 0] == 45 | (HEAPU8[$1 + 15 | 0] == 46 | HEAPU8[$1 + 15 | 0] == 33)) {
          break block1
         }
         if (HEAPU8[$1 + 15 | 0] == 126 | HEAPU8[$1 + 15 | 0] == 42 | (HEAPU8[$1 + 15 | 0] == 39 | HEAPU8[$1 + 15 | 0] == 40)) {
          break block1
         }
         if (HEAPU8[$1 + 15 | 0] != 41) {
          break block2
         }
        }
        jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 15 | 0] << 24 >> 24);
        break block3;
       }
       jsvStringIteratorAppend($1 + 16 | 0, 37);
       HEAP32[$1 + 8 >> 2] = HEAP8[$1 + 15 | 0] << 24 >> 24 >>> 4;
       $2 = $1 + 16 | 0;
       if (HEAPU32[$1 + 8 >> 2] > 9) {
        $0 = HEAP32[$1 + 8 >> 2] + 55 | 0
       } else {
        $0 = HEAP32[$1 + 8 >> 2] + 48 | 0
       }
       jsvStringIteratorAppend($2, $0 << 24 >> 24);
       HEAP32[$1 + 8 >> 2] = HEAP8[$1 + 15 | 0] << 24 >> 24 & 15;
       $2 = $1 + 16 | 0;
       if (HEAPU32[$1 + 8 >> 2] > 9) {
        $0 = HEAP32[$1 + 8 >> 2] + 55 | 0
       } else {
        $0 = HEAP32[$1 + 8 >> 2] + 48 | 0
       }
       jsvStringIteratorAppend($2, $0 << 24 >> 24);
      }
      continue;
     }
     break;
    };
    jsvStringIteratorFree_1496($1 + 16 | 0);
    jsvStringIteratorFree_1496($1 + 56 | 0);
   }
   jsvUnLock(HEAP32[$1 + 100 >> 2]);
   HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
  }
  __stack_pointer = $1 + 112 | 0;
  return HEAP32[$1 + 108 >> 2];
 }
 
 function jsvNewFromEmptyString_1503() {
  return jsvNewWithFlags(29);
 }
 
 function jswrap_decodeURIComponent($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 104 >> 2] = $0;
  HEAP32[$1 + 100 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
  block : {
   if (!HEAP32[$1 + 100 >> 2]) {
    HEAP32[$1 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 96 >> 2] = jsvNewFromEmptyString_1503();
   if (HEAP32[$1 + 96 >> 2]) {
    jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 100 >> 2], 0);
    jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 96 >> 2], 0);
    while (1) {
     block1 : {
      if (!(jsvStringIteratorHasChar_1495($1 + 56 | 0) & 1)) {
       break block1
      }
      HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
      if (HEAP8[$1 + 15 | 0] << 24 >> 24 >> 7) {
       jsExceptionHere(1, 3614, 0);
       break block1;
      }
      if (HEAPU8[$1 + 15 | 0] == 37) {
       HEAP8[$1 + 14 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
       HEAP8[$1 + 13 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
       HEAP32[$1 + 8 >> 2] = hexToByte(HEAP8[$1 + 14 | 0] << 24 >> 24, HEAP8[$1 + 13 | 0] << 24 >> 24) << 24 >> 24;
       if (HEAP32[$1 + 8 >> 2] < 0) {
        jsExceptionHere(1, 21373, 0);
        break block1;
       }
       HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2];
      }
      jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 15 | 0] << 24 >> 24);
      continue;
     }
     break;
    };
    jsvStringIteratorFree_1496($1 + 16 | 0);
    jsvStringIteratorFree_1496($1 + 56 | 0);
   }
   jsvUnLock(HEAP32[$1 + 100 >> 2]);
   HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
  }
  __stack_pointer = $1 + 112 | 0;
  return HEAP32[$1 + 108 >> 2];
 }
 
 function jswrap_trace($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
    jsvTrace(HEAP32[103307], 0);
    break block;
   }
   jsvTrace(HEAP32[$1 + 12 >> 2], 0);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_print($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsiConsoleRemoveInputLine();
  jsvObjectIteratorNew($1 + 8 | 0, HEAP32[$1 + 12 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_1486($1 + 8 | 0) & 1) {
    HEAP32[$1 + 4 >> 2] = jsvObjectIteratorGetValue_1485($1 + 8 | 0);
    block : {
     if (jsvIsString(HEAP32[$1 + 4 >> 2]) & 1) {
      jsiConsolePrintStringVar(HEAP32[$1 + 4 >> 2]);
      break block;
     }
     jsfPrintJSON(HEAP32[$1 + 4 >> 2], 261);
    }
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    jsvObjectIteratorNext($1 + 8 | 0);
    if (jsvObjectIteratorHasValue_1486($1 + 8 | 0) & 1) {
     jsiConsolePrintString(27706)
    }
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_1487($1 + 8 | 0);
  jsiConsolePrintString(28752);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_console_trace($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   jswrap_print(HEAP32[$1 + 12 >> 2])
  }
  jslPrintStackTrace(7, 0, HEAP32[61300]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_json_stringify($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  HEAP32[$3 + 32 >> 2] = 15568;
  HEAP32[$3 + 28 >> 2] = jsvNewFromEmptyString_1509();
  if (HEAP32[$3 + 28 >> 2]) {
   HEAP8[$3 + 23 | 0] = 0;
   HEAP8[$3 + 24 | 0] = 0;
   HEAP8[$3 + 25 | 0] = 0;
   HEAP8[$3 + 26 | 0] = 0;
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 20 >> 2] = 0;
   block : {
    if (jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1) {
     break block
    }
    if (jsvIsNull(HEAP32[$3 + 36 >> 2]) & 1) {
     break block
    }
    block1 : {
     if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
      HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
      if (HEAP32[$3 + 12 >> 2] < 0) {
       HEAP32[$3 + 12 >> 2] = 0
      }
      if (HEAP32[$3 + 12 >> 2] > 10) {
       HEAP32[$3 + 12 >> 2] = 10
      }
      HEAP8[HEAP32[$3 + 12 >> 2] + ($3 + 16 | 0) | 0] = 0;
      while (1) {
       if (HEAP32[$3 + 12 >> 2]) {
        $0 = HEAP32[$3 + 12 >> 2] - 1 | 0;
        HEAP32[$3 + 12 >> 2] = $0;
        HEAP8[($3 + 16 | 0) + $0 | 0] = 32;
        continue;
       }
       break;
      };
      break block1;
     }
     jsvGetString(HEAP32[$3 + 36 >> 2], $3 + 16 | 0, 10);
    }
   }
   if (strlen($3 + 16 | 0)) {
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | 6
   }
   jsfGetJSONWhitespace(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2], $3 + 16 | 0);
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvNewFromEmptyString_1509() {
  return jsvNewWithFlags(29);
 }
 
 function jsfGetJSONWhitespace($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP32[$4 + 48 >> 2] = $3;
  jsvStringIteratorNew($4 + 8 | 0, HEAP32[$4 + 56 >> 2], 0);
  jsvStringIteratorGotoEnd($4 + 8 | 0);
  jsfGetJSONWithCallback(HEAP32[$4 + 60 >> 2], 0, HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 2, $4 + 8 | 0);
  jsvStringIteratorFree_1512($4 + 8 | 0);
  __stack_pointer = $4 - -64 | 0;
 }
 
 function jsfGetJSONWithCallback($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0;
  $6 = __stack_pointer - 352 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 348 >> 2] = $0;
  HEAP32[$6 + 344 >> 2] = $1;
  HEAP32[$6 + 340 >> 2] = $2;
  HEAP32[$6 + 336 >> 2] = $3;
  HEAP32[$6 + 332 >> 2] = $4;
  HEAP32[$6 + 328 >> 2] = $5;
  HEAP32[$6 + 324 >> 2] = HEAP32[$6 + 340 >> 2] + 16384;
  if (!HEAP32[$6 + 336 >> 2]) {
   HEAP32[$6 + 336 >> 2] = 27702
  }
  block : {
   if (jsvIsUndefined(HEAP32[$6 + 348 >> 2]) & 1) {
    cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 64 ? 15755 : 19123, 0);
    break block;
   }
   block2 : {
    $0 = HEAP32[$6 + 348 >> 2];
    block1 : {
     if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512) {
      break block1
     }
     if (jsuGetFreeStack() >>> 0 < 512) {
      break block1
     }
     if (!(jspIsInterrupted() & 1)) {
      break block2
     }
    }
    cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 27675, 0);
    break block;
   }
   $0 = HEAP32[$6 + 348 >> 2];
   $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
   block12 : {
    if (jsvIsArray(HEAP32[$6 + 348 >> 2]) & 1) {
     HEAP32[$6 + 320 >> 2] = jsvGetArrayLength(HEAP32[$6 + 348 >> 2]);
     $7 = HEAP32[$6 + 340 >> 2] & 8 ? HEAP32[$6 + 320 >> 2] > 15 : $7;
     HEAP8[$6 + 319 | 0] = $7;
     HEAP8[$6 + 318 | 0] = 0;
     cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 27562 : 20766, 0);
     HEAP32[$6 + 312 >> 2] = -1;
     HEAP8[$6 + 311 | 0] = 1;
     HEAP8[$6 + 310 | 0] = 1;
     jsvObjectIteratorNew($6 + 304 | 0, HEAP32[$6 + 348 >> 2]);
     while (1) {
      $0 = 0;
      block3 : {
       if (HEAP32[$6 + 320 >> 2] <= (HEAP32[$6 + 312 >> 2] + 1 | 0)) {
        break block3
       }
       $0 = 0;
       if (!(HEAP8[$6 + 311 | 0] & 1)) {
        break block3
       }
       $0 = jspIsInterrupted() ^ -1;
      }
      if ($0 & 1) {
       HEAP32[$6 + 300 >> 2] = jsvObjectIteratorGetKey_1519($6 + 304 | 0);
       block11 : {
        block4 : {
         if (jsvObjectIteratorHasValue_1518($6 + 304 | 0) & 1) {
          if (!(jsvIsNumeric(HEAP32[$6 + 300 >> 2]) & 1)) {
           break block4
          }
         }
         block5 : {
          if (jsvObjectIteratorHasValue_1518($6 + 304 | 0) & 1) {
           $0 = jsvGetInteger(HEAP32[$6 + 300 >> 2]);
           break block5;
          }
          $0 = HEAP32[$6 + 320 >> 2] - 1 | 0;
         }
         HEAP32[$6 + 296 >> 2] = $0;
         HEAP32[$6 + 292 >> 2] = jsvObjectIteratorGetValue_1520($6 + 304 | 0);
         while (1) {
          if (HEAP32[$6 + 312 >> 2] < HEAP32[$6 + 296 >> 2]) {
           HEAP32[$6 + 312 >> 2] = HEAP32[$6 + 312 >> 2] + 1;
           if (!(!(!(HEAP8[$6 + 319 | 0] & 1) | HEAP32[$6 + 312 >> 2] < 5) & HEAP32[$6 + 312 >> 2] < (HEAP32[$6 + 320 >> 2] - 5 | 0))) {
            if (!(HEAP8[$6 + 310 | 0] & 1)) {
             cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 27689 : 22853, 0)
            }
            HEAP8[$6 + 310 | 0] = 0;
            if (!(!(HEAP8[$6 + 319 | 0] & 1) | HEAP32[$6 + 312 >> 2] != (HEAP32[$6 + 320 >> 2] - 5 | 0))) {
             cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[61122], 0)
            }
            $0 = 0;
            if (HEAP32[$6 + 340 >> 2] & 1) {
             $0 = jsonNeedsNewLine(HEAP32[$6 + 292 >> 2])
            }
            HEAP8[$6 + 291 | 0] = $0 & 1;
            if (HEAP32[$6 + 340 >> 2] & 2) {
             HEAP8[$6 + 318 | 0] = 1;
             HEAP8[$6 + 291 | 0] = 1;
            }
            if (HEAP8[$6 + 318 | 0] & 1 | HEAP8[$6 + 291 | 0] & 1) {
             jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
             HEAP8[$6 + 318 | 0] = 0;
            }
            block10 : {
             if (HEAP32[$6 + 312 >> 2] == HEAP32[$6 + 296 >> 2]) {
              HEAP32[$6 + 284 >> 2] = jsvNewFromInteger(HEAP32[$6 + 296 >> 2]);
              jsfGetJSONWithCallback(HEAP32[$6 + 292 >> 2], HEAP32[$6 + 284 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
              jsvUnLock(HEAP32[$6 + 284 >> 2]);
              break block10;
             }
             cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 64 ? 15755 : 19123, 0);
            }
            HEAP8[$6 + 318 | 0] = HEAP8[$6 + 291 | 0] & 1;
           }
           continue;
          }
          break;
         };
         jsvUnLock(HEAP32[$6 + 292 >> 2]);
         jsvObjectIteratorNext($6 + 304 | 0);
         break block11;
        }
        HEAP8[$6 + 311 | 0] = 0;
       }
       jsvUnLock(HEAP32[$6 + 300 >> 2]);
       continue;
      }
      break;
     };
     if (HEAP32[$6 + 340 >> 2] & 4) {
      jsfGetJSONForObjectItWithCallback($6 + 304 | 0, HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP8[$6 + 310 | 0] & 1)
     }
     jsvObjectIteratorFree_1521($6 + 304 | 0);
     if (HEAP8[$6 + 318 | 0] & 1) {
      jsonNewLine(HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2])
     }
     cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 20750 : 20751, 0);
     break block12;
    }
    block19 : {
     if (jsvIsArrayBuffer(HEAP32[$6 + 348 >> 2]) & 1) {
      HEAP8[$6 + 223 | 0] = 1;
      jsvArrayBufferIteratorNew($6 + 224 | 0, HEAP32[$6 + 348 >> 2], 0);
      while (1) {
       if (jsvArrayBufferIteratorHasElement($6 + 224 | 0) & 1) {
        if (jsvArrayBufferIteratorGetFloatValue($6 + 224 | 0) != 0.0) {
         HEAP8[$6 + 223 | 0] = 0
        }
        jsvArrayBufferIteratorNext($6 + 224 | 0);
        continue;
       }
       break;
      };
      jsvArrayBufferIteratorFree($6 + 224 | 0);
      HEAP8[$6 + 222 | 0] = (HEAP32[$6 + 340 >> 2] & 128) != 0;
      block14 : {
       if (!(!(HEAP8[$6 + 223 | 0] & 1) | HEAP8[$6 + 222 | 0] & 1)) {
        $0 = HEAP32[$6 + 332 >> 2];
        $1 = HEAP32[$6 + 328 >> 2];
        $2 = jswGetBasicObjectName(HEAP32[$6 + 348 >> 2]);
        HEAP32[$6 + 20 >> 2] = jsvGetArrayBufferLength(HEAP32[$6 + 348 >> 2]);
        HEAP32[$6 + 16 >> 2] = $2;
        cbprintf($0, $1, 24890, $6 + 16 | 0);
        break block14;
       }
       HEAP32[$6 + 216 >> 2] = jswGetBasicObjectName(HEAP32[$6 + 348 >> 2]);
       HEAP8[$6 + 215 | 0] = !strcmp(HEAP32[$6 + 216 >> 2], 8255);
       if (HEAP8[$6 + 215 | 0] & 1) {
        HEAP32[$6 + 216 >> 2] = 3698
       }
       $0 = HEAP32[$6 + 332 >> 2];
       $1 = HEAP32[$6 + 328 >> 2];
       $2 = HEAP8[$6 + 222 | 0] & 1;
       HEAP32[$6 >> 2] = HEAP32[$6 + 216 >> 2];
       cbprintf($0, $1, $2 ? 20766 : 20759, $6);
       if (HEAP32[$6 + 340 >> 2] & 2) {
        jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2])
       }
       HEAP32[$6 + 208 >> 2] = jsvGetArrayBufferLength(HEAP32[$6 + 348 >> 2]);
       $7 = HEAP32[$6 + 340 >> 2] & 8 ? HEAPU32[$6 + 208 >> 2] > 15 : $7;
       HEAP8[$6 + 207 | 0] = $7;
       jsvArrayBufferIteratorNew($6 + 224 | 0, HEAP32[$6 + 348 >> 2], 0);
       while (1) {
        $0 = 0;
        if (jsvArrayBufferIteratorHasElement($6 + 224 | 0) & 1) {
         $0 = jspIsInterrupted() ^ -1
        }
        if ($0 & 1) {
         if (!(!(!(HEAP8[$6 + 207 | 0] & 1) | HEAPU32[$6 + 276 >> 2] < 5) & HEAPU32[$6 + 276 >> 2] < HEAP32[$6 + 208 >> 2] - 5 >>> 0)) {
          if (HEAP32[$6 + 276 >> 2]) {
           cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 27689 : 22853, 0)
          }
          if (HEAP32[$6 + 340 >> 2] & 2) {
           jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2])
          }
          if (!(!(HEAP8[$6 + 207 | 0] & 1) | HEAP32[$6 + 276 >> 2] != (HEAP32[$6 + 208 >> 2] - 5 | 0))) {
           cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[61122], 0)
          }
          HEAP32[$6 + 200 >> 2] = jsvArrayBufferIteratorGetValue($6 + 224 | 0, 0);
          jsfGetJSONWithCallback(HEAP32[$6 + 200 >> 2], 0, HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
          jsvUnLock(HEAP32[$6 + 200 >> 2]);
         }
         jsvArrayBufferIteratorNext($6 + 224 | 0);
         continue;
        }
        break;
       };
       if (HEAP32[$6 + 340 >> 2] & 2) {
        jsonNewLine(HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2])
       }
       jsvArrayBufferIteratorFree($6 + 224 | 0);
       cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP8[$6 + 222 | 0] & 1 ? 20751 : 25981, 0);
       if (!(!(HEAP8[$6 + 215 | 0] & 1) | HEAP8[$6 + 222 | 0] & 1)) {
        cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 8163, 0)
       }
      }
      break block19;
     }
     block25 : {
      if (jsvIsObject(HEAP32[$6 + 348 >> 2]) & 1) {
       block20 : {
        if (HEAP32[$6 + 340 >> 2] & 32) {
         $0 = jsiGetDeviceFromClass(HEAP32[$6 + 348 >> 2]) & 255;
         break block20;
        }
        $0 = 0;
       }
       HEAP8[$6 + 199 | 0] = $0;
       block21 : {
        if (HEAPU8[$6 + 199 | 0]) {
         $0 = HEAP32[$6 + 332 >> 2];
         $1 = HEAP32[$6 + 328 >> 2];
         HEAP32[$6 + 32 >> 2] = jshGetDeviceString(HEAPU8[$6 + 199 | 0]);
         cbprintf($0, $1, 7674, $6 + 32 | 0);
         break block21;
        }
        HEAP8[$6 + 198 | 0] = 1;
        if (HEAP32[$6 + 340 >> 2] & 256) {
         HEAP32[$6 + 192 >> 2] = jsvObjectGetChildIfExists(HEAP32[$6 + 348 >> 2], 20670);
         if (jsvHasChildren(HEAP32[$6 + 192 >> 2]) & 1) {
          HEAP32[$6 + 188 >> 2] = jsvObjectGetChildIfExists(HEAP32[$6 + 192 >> 2], 7797);
          if (HEAP32[$6 + 188 >> 2]) {
           HEAP32[$6 + 184 >> 2] = jsvGetIndexOf(HEAP32[103307], HEAP32[$6 + 188 >> 2], 1);
           if (HEAP32[$6 + 184 >> 2]) {
            $0 = HEAP32[$6 + 332 >> 2];
            $1 = HEAP32[$6 + 328 >> 2];
            HEAP32[$6 + 64 >> 2] = HEAP32[$6 + 184 >> 2];
            cbprintf($0, $1, 27592, $6 - -64 | 0);
           }
           jsvUnLock2(HEAP32[$6 + 184 >> 2], HEAP32[$6 + 188 >> 2]);
           HEAP32[$6 + 180 >> 2] = jspGetNamedField(HEAP32[$6 + 348 >> 2], 16691, 0);
           block22 : {
            if (!(jsvIsFunction(HEAP32[$6 + 180 >> 2]) & 1)) {
             break block22
            }
            $0 = HEAP32[$6 + 180 >> 2];
            if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 1) {
             break block22
            }
            HEAP32[$6 + 176 >> 2] = jspExecuteFunction(HEAP32[$6 + 180 >> 2], HEAP32[$6 + 348 >> 2], 0, 0);
            $0 = HEAP32[$6 + 332 >> 2];
            $1 = HEAP32[$6 + 328 >> 2];
            HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 176 >> 2];
            cbprintf($0, $1, 4263, $6 + 48 | 0);
            jsvUnLock(HEAP32[$6 + 176 >> 2]);
            HEAP8[$6 + 198 | 0] = 0;
           }
           jsvUnLock(HEAP32[$6 + 180 >> 2]);
          }
         }
         jsvUnLock(HEAP32[$6 + 192 >> 2]);
        }
        if (HEAP8[$6 + 198 | 0] & 1) {
         HEAP32[$6 + 172 >> 2] = 0;
         if (HEAP32[$6 + 340 >> 2] & 8192) {
          HEAP32[$6 + 172 >> 2] = jspGetNamedField(HEAP32[$6 + 348 >> 2], 21204, 0)
         }
         block24 : {
          if (jsvIsFunction(HEAP32[$6 + 172 >> 2]) & 1) {
           block23 : {
            if (HEAP32[$6 + 344 >> 2]) {
             $0 = jsvAsString(HEAP32[$6 + 344 >> 2]);
             break block23;
            }
            $0 = 0;
           }
           HEAP32[$6 + 168 >> 2] = $0;
           HEAP32[$6 + 164 >> 2] = jspExecuteFunction(HEAP32[$6 + 172 >> 2], HEAP32[$6 + 348 >> 2], 1, $6 + 168 | 0);
           jsvUnLock(HEAP32[$6 + 168 >> 2]);
           if (HEAP32[$6 + 164 >> 2] == HEAP32[$6 + 348 >> 2]) {
            $0 = HEAP32[$6 + 348 >> 2];
            $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
            HEAP8[$0 + 12 | 0] = $1;
            HEAP8[$0 + 13 | 0] = $1 >>> 8;
           }
           jsfGetJSONWithCallback(HEAP32[$6 + 164 >> 2], 0, HEAP32[$6 + 340 >> 2] & -8193, HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
           jsvUnLock(HEAP32[$6 + 164 >> 2]);
           break block24;
          }
          jsvObjectIteratorNew($6 + 160 | 0, HEAP32[$6 + 348 >> 2]);
          cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 27472 : 3467, 0);
          HEAP8[$6 + 159 | 0] = jsfGetJSONForObjectItWithCallback($6 + 160 | 0, HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 1) & 1;
          jsvObjectIteratorFree_1521($6 + 160 | 0);
          if (HEAP8[$6 + 159 | 0] & 1) {
           jsonNewLine(HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2])
          }
          cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 3456 : 3460, 0);
         }
         jsvUnLock(HEAP32[$6 + 172 >> 2]);
        }
       }
       break block25;
      }
      block26 : {
       if (jsvIsFunction(HEAP32[$6 + 348 >> 2]) & 1) {
        if (HEAP32[$6 + 340 >> 2] & 16) {
         cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 19123, 0);
         break block26;
        }
        cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 27501, 0);
        jsfGetJSONForFunctionWithCallback(HEAP32[$6 + 348 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
        break block26;
       }
       block31 : {
        block28 : {
         block27 : {
          if (jsvIsString(HEAP32[$6 + 348 >> 2]) & 1) {
           if (!(jsvIsName(HEAP32[$6 + 348 >> 2]) & 1)) {
            break block27
           }
          }
          if (!(HEAP32[$6 + 340 >> 2] & 1024)) {
           break block28
          }
          if (!(jsvIsPin(HEAP32[$6 + 348 >> 2]) & 1)) {
           break block28
          }
         }
         block30 : {
          block29 : {
           if (!(HEAP32[$6 + 340 >> 2] & 8)) {
            break block29
           }
           if (jsvGetStringLength(HEAP32[$6 + 348 >> 2]) >>> 0 <= 60) {
            break block29
           }
           HEAP32[$6 + 152 >> 2] = jsvNewFromStringVar(HEAP32[$6 + 348 >> 2], 0, 27);
           HEAP32[$6 + 148 >> 2] = jsvNewFromStringVar(HEAP32[$6 + 348 >> 2], jsvGetStringLength(HEAP32[$6 + 348 >> 2]) - 27 | 0, 27);
           $0 = HEAP32[$6 + 332 >> 2];
           $1 = HEAP32[$6 + 328 >> 2];
           $2 = HEAP32[$6 + 152 >> 2];
           $3 = HEAP32[61122];
           HEAP32[$6 + 88 >> 2] = HEAP32[$6 + 148 >> 2];
           HEAP32[$6 + 84 >> 2] = $3;
           HEAP32[$6 + 80 >> 2] = $2;
           cbprintf($0, $1, 14639, $6 + 80 | 0);
           jsvUnLock2(HEAP32[$6 + 152 >> 2], HEAP32[$6 + 148 >> 2]);
           break block30;
          }
          $0 = HEAP32[$6 + 332 >> 2];
          $1 = HEAP32[$6 + 328 >> 2];
          $2 = HEAP32[$6 + 340 >> 2] & 2048;
          HEAP32[$6 + 96 >> 2] = HEAP32[$6 + 348 >> 2];
          cbprintf($0, $1, $2 ? 21158 : 14859, $6 + 96 | 0);
         }
         break block31;
        }
        block33 : {
         block32 : {
          if (!(HEAP32[$6 + 340 >> 2] & 4096)) {
           break block32
          }
          if (!(jsvIsFloat(HEAP32[$6 + 348 >> 2]) & 1)) {
           break block32
          }
          __DOUBLE_BITS_1526(jsvGetFloat(HEAP32[$6 + 348 >> 2]));
          if ((i64toi32_i32$HIGH_BITS & 2147483647) >>> 0 < 2146435072) {
           break block32
          }
          cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 15755, 0);
          break block33;
         }
         $0 = HEAP32[$6 + 332 >> 2];
         $1 = HEAP32[$6 + 328 >> 2];
         HEAP32[$6 + 112 >> 2] = HEAP32[$6 + 348 >> 2];
         cbprintf($0, $1, 4263, $6 + 112 | 0);
        }
       }
      }
     }
    }
   }
   $0 = HEAP32[$6 + 348 >> 2];
   $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
  }
  __stack_pointer = $6 + 352 | 0;
 }
 
 function jsvStringIteratorFree_1512($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_json_parse_internal($0) {
  var $1 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 104 >> 2] = $0;
  block8 : {
   block7 : {
    block1 : {
     block : {
      block4 : {
       block3 : {
        block2 : {
         $0 = HEAP16[HEAP32[61300] + 2 >> 1];
         if (($0 | 0) != 45) {
          if (($0 | 0) == 91) {
           break block
          }
          if (($0 | 0) == 123) {
           break block1
          }
          if (($0 | 0) == 129) {
           break block2
          }
          if (($0 | 0) == 130) {
           break block3
          }
          if (($0 | 0) == 131) {
           break block4
          }
          block6 : {
           block5 : {
            if (($0 | 0) != 180) {
             if (($0 | 0) == 181) {
              break block5
             }
             if (($0 | 0) == 182) {
              break block6
             }
             break block7;
            }
            jslGetNextToken();
            HEAP32[$1 + 108 >> 2] = jsvNewFromBool(1);
            break block8;
           }
           jslGetNextToken();
           HEAP32[$1 + 108 >> 2] = jsvNewFromBool(0);
           break block8;
          }
          jslGetNextToken();
          HEAP32[$1 + 108 >> 2] = jsvNewWithFlags(2);
          break block8;
         }
         jslGetNextToken();
         if (!(HEAPU16[HEAP32[61300] + 2 >> 1] == 129 | HEAPU16[HEAP32[61300] + 2 >> 1] == 130)) {
          HEAP32[$1 + 108 >> 2] = 0;
          break block8;
         }
         HEAP32[$1 + 100 >> 2] = jswrap_json_parse_internal(HEAP32[$1 + 104 >> 2]);
         HEAP32[$1 + 96 >> 2] = jsvNewFromInteger(0);
         HEAP32[$1 + 92 >> 2] = jsvMathsOp(HEAP32[$1 + 96 >> 2], HEAP32[$1 + 100 >> 2], 45);
         jsvUnLock2(HEAP32[$1 + 100 >> 2], HEAP32[$1 + 96 >> 2]);
         HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 92 >> 2];
         break block8;
        }
        HEAP32[$1 + 88 >> 2] = jslGetTokenValueAsVar();
        jslGetNextToken();
        HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 88 >> 2];
        break block8;
       }
       HEAPF64[$1 + 80 >> 3] = stringToFloat(jslGetTokenValueAsString());
       jslGetNextToken();
       HEAP32[$1 + 108 >> 2] = jsvNewFromFloat(HEAPF64[$1 + 80 >> 3]);
       break block8;
      }
      HEAP32[$1 + 76 >> 2] = jslGetTokenValueAsVar();
      if (HEAP8[HEAP32[61300] + 82 | 0] & 1) {
       HEAP32[$1 + 76 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$1 + 76 >> 2])
      }
      jslGetNextToken();
      HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 76 >> 2];
      break block8;
     }
     HEAP32[$1 + 72 >> 2] = jsvNewEmptyArray();
     if (!HEAP32[$1 + 72 >> 2]) {
      HEAP32[$1 + 108 >> 2] = 0;
      break block8;
     }
     jslGetNextToken();
     while (1) {
      $0 = 0;
      if (HEAPU16[HEAP32[61300] + 2 >> 1] != 93) {
       $0 = jspHasError() ^ -1
      }
      if ($0 & 1) {
       HEAP32[$1 + 68 >> 2] = jswrap_json_parse_internal(HEAP32[$1 + 104 >> 2]);
       block10 : {
        if (HEAP32[$1 + 68 >> 2]) {
         if (HEAPU16[HEAP32[61300] + 2 >> 1] == 93) {
          break block10
         }
         if (jslMatch(44) & 1) {
          break block10
         }
        }
        jsvUnLock2(HEAP32[$1 + 68 >> 2], HEAP32[$1 + 72 >> 2]);
        HEAP32[$1 + 108 >> 2] = 0;
        break block8;
       }
       jsvArrayPush(HEAP32[$1 + 72 >> 2], HEAP32[$1 + 68 >> 2]);
       jsvUnLock(HEAP32[$1 + 68 >> 2]);
       continue;
      }
      break;
     };
     if (!(jslMatch(93) & 1)) {
      jsvUnLock(HEAP32[$1 + 72 >> 2]);
      HEAP32[$1 + 108 >> 2] = 0;
      break block8;
     }
     HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 72 >> 2];
     break block8;
    }
    HEAP32[$1 + 64 >> 2] = jsvNewObject();
    if (!HEAP32[$1 + 64 >> 2]) {
     HEAP32[$1 + 108 >> 2] = 0;
     break block8;
    }
    jslGetNextToken();
    while (1) {
     block12 : {
      if (!(HEAPU16[HEAP32[61300] + 2 >> 1] == 131 | HEAPU16[HEAP32[61300] + 2 >> 1] == 129)) {
       $0 = 0;
       if (!(jslIsIDOrReservedWord() & 1)) {
        break block12
       }
      }
      $0 = jspHasError() ^ -1;
     }
     if ($0 & 1) {
      block13 : {
       if (HEAP32[$1 + 104 >> 2] & 512) {
        break block13
       }
       if (!(jslIsIDOrReservedWord() & 1) & HEAPU16[HEAP32[61300] + 2 >> 1] != 129) {
        break block13
       }
       jslMatch(131);
       HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 64 >> 2];
       break block8;
      }
      HEAP32[$1 + 60 >> 2] = jsvAsArrayIndexAndUnLock(jslGetTokenValueAsVar());
      jslGetNextToken();
      HEAP32[$1 + 56 >> 2] = 0;
      block15 : {
       block14 : {
        if (!(jslMatch(58) & 1)) {
         break block14
        }
        $0 = jswrap_json_parse_internal(HEAP32[$1 + 104 >> 2]);
        HEAP32[$1 + 56 >> 2] = $0;
        if (!$0) {
         break block14
        }
        if (HEAPU16[HEAP32[61300] + 2 >> 1] == 125) {
         break block15
        }
        if (jslMatch(44) & 1) {
         break block15
        }
       }
       jsvUnLock3(HEAP32[$1 + 60 >> 2], HEAP32[$1 + 56 >> 2], HEAP32[$1 + 64 >> 2]);
       HEAP32[$1 + 108 >> 2] = 0;
       break block8;
      }
      jsvAddName(HEAP32[$1 + 64 >> 2], jsvMakeIntoVariableName(HEAP32[$1 + 60 >> 2], HEAP32[$1 + 56 >> 2]));
      jsvUnLock2(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 60 >> 2]);
      continue;
     }
     break;
    };
    if (!(jslMatch(125) & 1)) {
     jsvUnLock(HEAP32[$1 + 64 >> 2]);
     HEAP32[$1 + 108 >> 2] = 0;
     break block8;
    }
    HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 64 >> 2];
    break block8;
   }
   jslTokenAsString(HEAP16[HEAP32[61300] + 2 >> 1] << 16 >> 16, $1 + 16 | 0, 32);
   HEAP32[$1 >> 2] = $1 + 16;
   jsExceptionHere(2, 7575, $1);
   HEAP32[$1 + 108 >> 2] = 0;
  }
  __stack_pointer = $1 + 112 | 0;
  return HEAP32[$1 + 108 >> 2];
 }
 
 function jswrap_json_parse_ext($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 160 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 156 >> 2] = $0;
  HEAP32[$2 + 152 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = jsvAsString(HEAP32[$2 + 156 >> 2]);
  HEAP32[$2 + 8 >> 2] = jslSetLex($2 + 16 | 0);
  jslInit(HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP32[$2 + 4 >> 2] = jswrap_json_parse_internal(HEAP32[$2 + 152 >> 2]);
  jslKill();
  jslSetLex(HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 160 | 0;
  return HEAP32[$2 + 4 >> 2];
 }
 
 function jswrap_json_parse($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_json_parse_ext(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_json_parse_liberal($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  HEAP32[$2 + 4 >> 2] = jswrap_json_parse_ext(HEAP32[$2 + 12 >> 2], 512);
  if (HEAP8[$2 + 11 | 0] & 1) {
   jsvUnLock(jspGetException());
   HEAP32[103315] = HEAP32[103315] & -33;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 4 >> 2];
 }
 
 function jsfGetJSONForFunctionWithCallback($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 60 >> 2] = $0;
  HEAP32[$4 + 56 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $2;
  HEAP32[$4 + 48 >> 2] = $3;
  HEAP32[$4 + 44 >> 2] = 0;
  jsvObjectIteratorNew($4 + 40 | 0, HEAP32[$4 + 60 >> 2]);
  HEAP8[$4 + 39 | 0] = 1;
  cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 27049, 0);
  while (1) {
   if (jsvObjectIteratorHasValue_1518($4 + 40 | 0) & 1) {
    HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetKey_1519($4 + 40 | 0);
    block1 : {
     if (jsvIsFunctionParameter(HEAP32[$4 + 32 >> 2]) & 1) {
      block : {
       if (HEAP8[$4 + 39 | 0] & 1) {
        HEAP8[$4 + 39 | 0] = 0;
        break block;
       }
       cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 22853, 0);
      }
      HEAP32[$4 + 28 >> 2] = jsvNewFromStringVar(HEAP32[$4 + 32 >> 2], 1, 2147483647);
      $0 = HEAP32[$4 + 52 >> 2];
      $1 = HEAP32[$4 + 48 >> 2];
      HEAP32[$4 >> 2] = HEAP32[$4 + 28 >> 2];
      cbprintf($0, $1, 4263, $4);
      jsvUnLock(HEAP32[$4 + 28 >> 2]);
      break block1;
     }
     block2 : {
      if (!(jsvIsString(HEAP32[$4 + 32 >> 2]) & 1)) {
       break block2
      }
      if (!(jsvIsStringEqual(HEAP32[$4 + 32 >> 2], 18659) & 1)) {
       break block2
      }
      HEAP32[$4 + 44 >> 2] = jsvObjectIteratorGetValue_1520($4 + 40 | 0);
     }
    }
    jsvUnLock(HEAP32[$4 + 32 >> 2]);
    jsvObjectIteratorNext($4 + 40 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_1521($4 + 40 | 0);
  cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 27692, 0);
  block3 : {
   if (jsvIsNativeFunction(HEAP32[$4 + 60 >> 2]) & 1) {
    cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 3441, 0);
    break block3;
   }
   block4 : {
    if (HEAP32[$4 + 44 >> 2]) {
     if (HEAP32[$4 + 56 >> 2] & 8) {
      $0 = HEAP32[$4 + 52 >> 2];
      $1 = HEAP32[$4 + 48 >> 2];
      HEAP32[$4 + 16 >> 2] = HEAP32[61122];
      cbprintf($0, $1, 1962, $4 + 16 | 0);
      break block4;
     }
     HEAP8[$4 + 27 | 0] = (jsvGetStringIndexOf(HEAP32[$4 + 44 >> 2], 10) | 0) >= 0;
     FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](HEAP8[$4 + 27 | 0] & 1 ? 27700 : 3467, HEAP32[$4 + 48 >> 2]);
     if (jsvIsFunctionReturn(HEAP32[$4 + 60 >> 2]) & 1) {
      FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](27493, HEAP32[$4 + 48 >> 2])
     }
     jslPrintTokenisedString(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2]);
     FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](HEAP8[$4 + 27 | 0] & 1 ? 3459 : 3460, HEAP32[$4 + 48 >> 2]);
     break block4;
    }
    cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 1959, 0);
   }
  }
  jsvUnLock(HEAP32[$4 + 44 >> 2]);
  __stack_pointer = $4 - -64 | 0;
 }
 
 function jsvObjectIteratorHasValue_1518($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetKey_1519($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorGetValue_1520($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1521($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jsonNeedsNewLine($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = 1;
  block : {
   if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
    break block
   }
   $0 = 1;
   if (jsvIsNull(HEAP32[$1 + 12 >> 2]) & 1) {
    break block
   }
   $0 = jsvIsNumeric(HEAP32[$1 + 12 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return ($0 ^ -1) & 1;
 }
 
 function jsonNewLine($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  FUNCTION_TABLE[HEAP32[$4 + 20 >> 2]](28752, HEAP32[$4 + 16 >> 2]);
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] >>> 14;
  while (1) {
   $0 = HEAP32[$4 + 12 >> 2];
   HEAP32[$4 + 12 >> 2] = $0 - 1;
   if ($0) {
    FUNCTION_TABLE[HEAP32[$4 + 20 >> 2]](HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jsfGetJSONForObjectItWithCallback($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0;
  $7 = __stack_pointer - 128 | 0;
  __stack_pointer = $7;
  HEAP32[$7 + 124 >> 2] = $0;
  HEAP32[$7 + 120 >> 2] = $1;
  HEAP32[$7 + 116 >> 2] = $2;
  HEAP32[$7 + 112 >> 2] = $3;
  HEAP32[$7 + 108 >> 2] = $4;
  HEAP32[$7 + 104 >> 2] = $5;
  HEAP8[$7 + 103 | 0] = $6;
  HEAP8[$7 + 102 | 0] = 0;
  HEAP32[$7 + 96 >> 2] = 0;
  while (1) {
   $0 = 0;
   if (jsvObjectIteratorHasValue_1518(HEAP32[$7 + 124 >> 2]) & 1) {
    $0 = jspIsInterrupted() ^ -1
   }
   if ($0 & 1) {
    HEAP32[$7 + 92 >> 2] = jsvObjectIteratorGetKey_1519(HEAP32[$7 + 124 >> 2]);
    HEAP32[$7 + 88 >> 2] = jsvGetValueOfName(HEAP32[$7 + 92 >> 2]);
    $0 = 1;
    block : {
     if (jsvIsInternalObjectKey(HEAP32[$7 + 92 >> 2]) & 1) {
      break block
     }
     if (HEAP32[$7 + 120 >> 2] & 16) {
      $0 = 1;
      if (jsvIsFunction(HEAP32[$7 + 88 >> 2]) & 1) {
       break block
      }
     }
     if (HEAP32[$7 + 120 >> 2] & 64) {
      $0 = 1;
      if (jsvIsUndefined(HEAP32[$7 + 88 >> 2]) & 1) {
       break block
      }
     }
     $0 = jsvIsGetterOrSetter(HEAP32[$7 + 88 >> 2]);
    }
    HEAP8[$7 + 87 | 0] = $0 & 1;
    if (!(HEAP8[$7 + 87 | 0] & 1)) {
     HEAP32[$7 + 96 >> 2] = HEAP32[$7 + 96 >> 2] + 1;
     if (!(HEAP8[$7 + 103 | 0] & 1)) {
      cbprintf(HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2], HEAP32[$7 + 120 >> 2] & 4 ? 27689 : 22853, 0)
     }
     $0 = 0;
     if (HEAP32[$7 + 120 >> 2] & 1) {
      $0 = jsonNeedsNewLine(HEAP32[$7 + 88 >> 2])
     }
     HEAP8[$7 + 86 | 0] = $0 & 1;
     if (!(!(HEAP32[$7 + 120 >> 2] & 1) | HEAPU32[$7 + 96 >> 2] <= 4)) {
      HEAP8[$7 + 102 | 0] = 1
     }
     if (HEAP32[$7 + 120 >> 2] & 2) {
      HEAP8[$7 + 102 | 0] = 1;
      HEAP8[$7 + 86 | 0] = 1;
     }
     if (HEAP8[$7 + 102 | 0] & 1 | HEAP8[$7 + 86 | 0] & 1) {
      jsonNewLine(HEAP32[$7 + 112 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2]);
      HEAP8[$7 + 102 | 0] = 0;
      HEAP32[$7 + 96 >> 2] = 0;
     }
     HEAP8[$7 + 85 | 0] = 1;
     if (HEAP32[$7 + 120 >> 2] & 512) {
      block3 : {
       if (jsvIsIntegerish(HEAP32[$7 + 92 >> 2]) & 1) {
        HEAP8[$7 + 85 | 0] = 0;
        break block3;
       }
       block4 : {
        if (!(jsvIsString(HEAP32[$7 + 92 >> 2]) & 1)) {
         break block4
        }
        if (jsvGetStringLength(HEAP32[$7 + 92 >> 2]) >>> 0 >= 63) {
         break block4
        }
        jsvGetString(HEAP32[$7 + 92 >> 2], $7 + 16 | 0, 64);
        if (isIDString($7 + 16 | 0) & 1) {
         HEAP8[$7 + 85 | 0] = 0
        }
       }
      }
     }
     $1 = HEAP32[$7 + 108 >> 2];
     $2 = HEAP32[$7 + 104 >> 2];
     if (HEAP8[$7 + 85 | 0] & 1) {
      $0 = HEAP32[$7 + 120 >> 2] & 2048 ? 7564 : 7559
     } else {
      $0 = 7554
     }
     $3 = HEAP32[$7 + 92 >> 2];
     HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 120 >> 2] & 4 ? 27620 : 22239;
     HEAP32[$7 >> 2] = $3;
     cbprintf($1, $2, $0, $7);
     if (HEAP8[$7 + 103 | 0] & 1) {
      HEAP8[$7 + 103 | 0] = 0
     }
     jsfGetJSONWithCallback(HEAP32[$7 + 88 >> 2], HEAP32[$7 + 92 >> 2], HEAP32[$7 + 112 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2]);
     HEAP8[$7 + 102 | 0] = HEAP8[$7 + 86 | 0] & 1;
    }
    jsvUnLock2(HEAP32[$7 + 92 >> 2], HEAP32[$7 + 88 >> 2]);
    jsvObjectIteratorNext(HEAP32[$7 + 124 >> 2]);
    continue;
   }
   break;
  };
  __stack_pointer = $7 + 128 | 0;
  return HEAP8[$7 + 102 | 0] & 1;
 }
 
 function __DOUBLE_BITS_1526($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jsfGetJSON($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jsfGetJSONWhitespace(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jsfPrintJSON($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsfGetJSONWithCallback(HEAP32[$2 + 12 >> 2], 0, HEAP32[$2 + 8 >> 2], 0, 7, 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_number_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (!jsvGetArrayLength(HEAP32[$1 + 24 >> 2])) {
    HEAP32[$1 + 28 >> 2] = jsvNewFromInteger(0);
    break block;
   }
   HEAP32[$1 + 20 >> 2] = jsvGetArrayItem(HEAP32[$1 + 24 >> 2], 0);
   HEAP32[$1 + 16 >> 2] = 0;
   block4 : {
    if (jsvIsArray(HEAP32[$1 + 20 >> 2]) & 1) {
     HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[$1 + 20 >> 2]);
     block1 : {
      if (!HEAP32[$1 + 12 >> 2]) {
       HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
       break block1;
      }
      if (HEAP32[$1 + 12 >> 2] == 1) {
       HEAP32[$1 + 8 >> 2] = jsvGetArrayItem(HEAP32[$1 + 20 >> 2], 0);
       block3 : {
        block2 : {
         if (!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1)) {
          break block2
         }
         if (!(jsvIsEmptyString(HEAP32[$1 + 8 >> 2]) & 1)) {
          break block2
         }
         HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
         break block3;
        }
        if (!(jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1)) {
         HEAP32[$1 + 16 >> 2] = jsvAsNumber(HEAP32[$1 + 8 >> 2])
        }
       }
       jsvUnLock(HEAP32[$1 + 8 >> 2]);
      }
     }
     break block4;
    }
    block6 : {
     block5 : {
      if (!(jsvIsUndefined(HEAP32[$1 + 20 >> 2]) & 1)) {
       if (!(jsvIsObject(HEAP32[$1 + 20 >> 2]) & 1)) {
        break block5
       }
      }
      HEAP32[$1 + 16 >> 2] = 0;
      break block6;
     }
     block8 : {
      block7 : {
       if (!(jsvIsString(HEAP32[$1 + 20 >> 2]) & 1)) {
        break block7
       }
       if (!(jsvIsEmptyString(HEAP32[$1 + 20 >> 2]) & 1)) {
        break block7
       }
       HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
       break block8;
      }
      HEAP32[$1 + 16 >> 2] = jsvAsNumber(HEAP32[$1 + 20 >> 2]);
     }
    }
   }
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
   if (HEAP32[$1 + 16 >> 2]) {
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
    break block;
   }
   HEAP32[$1 + 28 >> 2] = jsvNewFromFloat(NaN);
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jswrap_number_toFixed($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 76 >> 2] = $0;
  HEAP32[$2 + 72 >> 2] = $1;
  if (HEAP32[$2 + 72 >> 2] < 0) {
   HEAP32[$2 + 72 >> 2] = 0
  }
  if (HEAP32[$2 + 72 >> 2] > 20) {
   HEAP32[$2 + 72 >> 2] = 20
  }
  ftoa_bounded_extra(jsvGetFloat(HEAP32[$2 + 76 >> 2]), $2, 70, 10, HEAP32[$2 + 72 >> 2]);
  $0 = jsvNewFromString($2);
  __stack_pointer = $2 + 80 | 0;
  return $0 | 0;
 }
 
 function jswrap_object_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block2 : {
   block1 : {
    block : {
     if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
      break block
     }
     if (jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1) {
      break block
     }
     if (!(jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1)) {
      break block1
     }
    }
    HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
    break block2;
   }
   HEAP32[$1 + 20 >> 2] = jswGetBasicObjectName(HEAP32[$1 + 24 >> 2]);
   block3 : {
    if (HEAP32[$1 + 20 >> 2]) {
     $0 = jspGetNamedVariable(HEAP32[$1 + 20 >> 2]);
     break block3;
    }
    $0 = 0;
   }
   HEAP32[$1 + 16 >> 2] = $0;
   if (!HEAP32[$1 + 16 >> 2]) {
    HEAP32[$1 + 28 >> 2] = jsvNewObject();
    break block2;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[$1 + 16 >> 2]);
   HEAP32[$1 + 8 >> 2] = jspeFunctionCall(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2], 0, 0, 1, $1 + 24 | 0);
   jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jswrap_object_length($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block4 : {
   block : {
    if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
     HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 8 >> 2]);
     break block;
    }
    block1 : {
     if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
      HEAP32[$1 + 4 >> 2] = jsvGetArrayBufferLength(HEAP32[$1 + 8 >> 2]);
      break block1;
     }
     block2 : {
      if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
       HEAP32[$1 + 4 >> 2] = jsvGetStringLength(HEAP32[$1 + 8 >> 2]);
       break block2;
      }
      block3 : {
       if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
        HEAP32[$1 >> 2] = jsvGetFunctionArgumentLength(HEAP32[$1 + 8 >> 2]);
        HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 >> 2]);
        jsvUnLock(HEAP32[$1 >> 2]);
        break block3;
       }
       HEAP32[$1 + 12 >> 2] = 0;
       break block4;
      }
     }
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(HEAP32[$1 + 4 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_object_valueOf($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
    jsExceptionHere(3, 17131, $1);
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_object_toString($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP32[$2 + 84 >> 2] = $1;
  block3 : {
   block : {
    if (!(jsvIsInt(HEAP32[$2 + 84 >> 2]) & 1)) {
     break block
    }
    if (!(jsvIsNumeric(HEAP32[$2 + 88 >> 2]) & 1)) {
     break block
    }
    HEAP32[$2 + 80 >> 2] = jsvGetInteger(HEAP32[$2 + 84 >> 2]);
    if (!(HEAP32[$2 + 80 >> 2] < 2 | HEAP32[$2 + 80 >> 2] > 36)) {
     block2 : {
      if (jsvIsInt(HEAP32[$2 + 88 >> 2]) & 1) {
       itostr_1535(jsvGetInteger(HEAP32[$2 + 88 >> 2]), $2, HEAP32[$2 + 80 >> 2]);
       break block2;
      }
      ftoa_bounded_extra(jsvGetFloat(HEAP32[$2 + 88 >> 2]), $2, 70, HEAP32[$2 + 80 >> 2], -1);
     }
     HEAP32[$2 + 92 >> 2] = jsvNewFromString($2);
     break block3;
    }
   }
   HEAP32[$2 + 92 >> 2] = jsvAsString(HEAP32[$2 + 88 >> 2]);
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function itostr_1535($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_object_clone($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvCopy(HEAP32[$1 + 8 >> 2], 1);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_object_keys_or_property_names_cb($0, $1, $2, $3) {
  var $4 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
  $4 = __stack_pointer - 144 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 140 >> 2] = $0;
  HEAP32[$4 + 136 >> 2] = $1;
  HEAP32[$4 + 132 >> 2] = $2;
  HEAP32[$4 + 128 >> 2] = $3;
  block : {
   if (!(jsvIsIterable(HEAP32[$4 + 140 >> 2]) & 1)) {
    break block
   }
   if (wasm2js_i32$0 = jsvIsArrayBuffer(HEAP32[$4 + 140 >> 2]) & 1, wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAP32[$4 + 136 >> 2] & 4, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
    break block
   }
   HEAP32[$4 + 124 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$4 + 140 >> 2]);
   jsvIteratorNew($4 + 60 | 0, HEAP32[$4 + 140 >> 2], 0);
   while (1) {
    if (jsvIteratorHasElement($4 + 60 | 0) & 1) {
     HEAP32[$4 + 56 >> 2] = jsvIteratorGetKey($4 + 60 | 0);
     block2 : {
      block1 : {
       if (!HEAP32[$4 + 124 >> 2]) {
        break block1
       }
       if (!(FUNCTION_TABLE[HEAP32[$4 + 124 >> 2]](HEAP32[$4 + 56 >> 2]) & 1)) {
        break block1
       }
       if (!(jsvIsStringEqual(HEAP32[$4 + 56 >> 2], 7797) & 1)) {
        break block2
       }
      }
      HEAP32[$4 + 52 >> 2] = jsvAsStringAndUnLock(jsvCopyNameOnly(HEAP32[$4 + 56 >> 2], 0, 0));
      if (HEAP32[$4 + 52 >> 2]) {
       FUNCTION_TABLE[HEAP32[$4 + 132 >> 2]](HEAP32[$4 + 128 >> 2], HEAP32[$4 + 52 >> 2]);
       jsvUnLock(HEAP32[$4 + 52 >> 2]);
      }
     }
     jsvUnLock(HEAP32[$4 + 56 >> 2]);
     jsvIteratorNext($4 + 60 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($4 + 60 | 0);
  }
  if (HEAP32[$4 + 136 >> 2] & 1) {
   HEAP32[$4 + 48 >> 2] = jswGetSymbolListForObjectProto(0);
   HEAP32[$4 + 44 >> 2] = jspGetPrototypeOwner(HEAP32[$4 + 140 >> 2]);
   block3 : {
    if (HEAP32[$4 + 44 >> 2]) {
     HEAP32[$4 + 40 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$4 + 44 >> 2]);
     jsvUnLock(HEAP32[$4 + 44 >> 2]);
     _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
     break block3;
    }
    block4 : {
     if (jsvIsObject(HEAP32[$4 + 140 >> 2]) & 1) {
      if (!(jsvIsRoot(HEAP32[$4 + 140 >> 2]) & 1)) {
       break block4
      }
     }
     HEAP32[$4 + 36 >> 2] = jswGetSymbolListForObject(HEAP32[$4 + 140 >> 2]);
     _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
    }
   }
   if (HEAP32[$4 + 136 >> 2] & 2) {
    HEAP32[$4 + 32 >> 2] = 0;
    block5 : {
     if (!(jsvIsObject(HEAP32[$4 + 140 >> 2]) & 1)) {
      if (!(jsvIsFunction(HEAP32[$4 + 140 >> 2]) & 1)) {
       break block5
      }
     }
     HEAP32[$4 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 140 >> 2], 20670);
    }
    block6 : {
     if (jsvIsObject(HEAP32[$4 + 32 >> 2]) & 1) {
      jswrap_object_keys_or_property_names_cb(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 136 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
      break block6;
     }
     HEAP32[$4 + 28 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$4 + 140 >> 2]);
     _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
     if (HEAP32[$4 + 48 >> 2] != HEAP32[$4 + 28 >> 2]) {
      _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 48 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2])
     }
    }
    jsvUnLock(HEAP32[$4 + 32 >> 2]);
   }
   block7 : {
    if (!(jsvIsArray(HEAP32[$4 + 140 >> 2]) & 1)) {
     if (!(jsvIsString(HEAP32[$4 + 140 >> 2]) & 1)) {
      break block7
     }
    }
    HEAP32[$4 + 24 >> 2] = jsvNewFromString(16212);
    FUNCTION_TABLE[HEAP32[$4 + 132 >> 2]](HEAP32[$4 + 128 >> 2], HEAP32[$4 + 24 >> 2]);
    jsvUnLock(HEAP32[$4 + 24 >> 2]);
   }
  }
  if (jsvIsRoot(HEAP32[$4 + 140 >> 2]) & 1) {
   HEAP32[$4 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$4 + 20 >> 2] < 48) {
     jshGetPinString($4 + 10 | 0, HEAP32[$4 + 20 >> 2] & 255);
     HEAP32[$4 + 4 >> 2] = jsvNewFromString($4 + 10 | 0);
     FUNCTION_TABLE[HEAP32[$4 + 132 >> 2]](HEAP32[$4 + 128 >> 2], HEAP32[$4 + 4 >> 2]);
     jsvUnLock(HEAP32[$4 + 4 >> 2]);
     HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
     continue;
    }
    break;
   };
  }
  __stack_pointer = $4 + 144 | 0;
 }
 
 function _jswrap_object_keys_or_property_names_iterator($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (!HEAP32[$3 + 28 >> 2]) {
    break block
   }
   HEAP8[$3 + 15 | 0] = HEAPU8[HEAP32[$3 + 28 >> 2] + 8 | 0];
   HEAP32[$3 + 16 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 16 >> 2] >= HEAPU8[$3 + 15 | 0]) {
     break block
    }
    $0 = HEAP32[$3 + 28 >> 2];
    $0 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] << 3) | 0;
    HEAP16[$3 + 12 >> 1] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
    $0 = HEAP32[$3 + 28 >> 2];
    HEAP32[$3 + 8 >> 2] = jsvNewFromString(HEAPU16[$3 + 12 >> 1] + (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) | 0);
    FUNCTION_TABLE[HEAP32[$3 + 24 >> 2]](HEAP32[$3 + 20 >> 2], HEAP32[$3 + 8 >> 2]);
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
    continue;
   };
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jswrap_object_keys_or_property_names($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   jswrap_object_keys_or_property_names_cb(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 637, HEAP32[$2 >> 2]);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function _jswrap_object_values_cb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  HEAP32[$2 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 8 >> 2]);
  jsvArrayPushAndUnLock(HEAP32[HEAP32[$2 + 4 >> 2] >> 2], jspGetVarNamedField(HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2], HEAP32[$2 >> 2], 0));
  jsvUnLock(HEAP32[$2 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function _jswrap_object_entries_cb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 28 >> 2];
  HEAP32[$2 + 16 >> 2] = jsvNewEmptyArray();
  if (HEAP32[$2 + 16 >> 2]) {
   jsvArrayPush(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 12 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 24 >> 2]);
   jsvArrayPushAndUnLock(HEAP32[$2 + 16 >> 2], jspGetVarNamedField(HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2], HEAP32[$2 + 12 >> 2], 0));
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   jsvArrayPushAndUnLock(HEAP32[HEAP32[$2 + 20 >> 2] >> 2], HEAP32[$2 + 16 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_object_values_or_entries($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP8[$2 + 23 | 0] = $1;
  HEAP32[$2 + 12 >> 2] = jsvNewEmptyArray();
  HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2];
  block : {
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   jswrap_object_keys_or_property_names_cb(HEAP32[$2 + 24 >> 2], 0, HEAP8[$2 + 23 | 0] & 1 ? 638 : 639, $2 + 12 | 0);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jswrap_object_fromEntries($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (!(jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1)) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 20 >> 2] = jsvNewObject();
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1544($1 + 16 | 0) & 1) {
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_1545($1 + 16 | 0);
     if (jsvIsArray(HEAP32[$1 + 12 >> 2]) & 1) {
      HEAP32[$1 + 8 >> 2] = jsvGetArrayItem(HEAP32[$1 + 12 >> 2], 0);
      HEAP32[$1 + 4 >> 2] = jsvGetArrayItem(HEAP32[$1 + 12 >> 2], 1);
      if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
       jsvObjectSetChildVar(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2])
      }
      jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
     }
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
     jsvObjectIteratorNext($1 + 16 | 0);
     continue;
    }
    break;
   };
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1544($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1545($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_object_create($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block1 : {
   block : {
    if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
     break block
    }
    if (jsvIsNull(HEAP32[$2 + 24 >> 2]) & 1) {
     break block
    }
    HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
    jsExceptionHere(3, 6630, $2);
    HEAP32[$2 + 28 >> 2] = 0;
    break block1;
   }
   if (jsvIsObject(HEAP32[$2 + 20 >> 2]) & 1) {
    jsExceptionHere(1, 4889, 0)
   }
   HEAP32[$2 + 16 >> 2] = jsvNewObject();
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block1;
   }
   if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
    jsvObjectSetChild(HEAP32[$2 + 16 >> 2], 20670, HEAP32[$2 + 24 >> 2])
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jswrap_object_getOwnPropertyDescriptor($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  block : {
   if (!(jswrap_object_hasOwnProperty(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]) & 1)) {
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 32 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 36 >> 2]);
   HEAP32[$2 + 28 >> 2] = jspGetVarNamedField(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 32 >> 2], 1);
   jsvUnLock(HEAP32[$2 + 32 >> 2]);
   if (!HEAP32[$2 + 28 >> 2]) {
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 24 >> 2] = jsvNewObject();
   if (!HEAP32[$2 + 24 >> 2]) {
    jsvUnLock(HEAP32[$2 + 28 >> 2]);
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   HEAP8[$2 + 23 | 0] = jsvIsNewChild(HEAP32[$2 + 28 >> 2]) & 1;
   HEAP32[$2 + 16 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$2 + 40 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 17940, jsvNewFromBool((jsvIsConstant(HEAP32[$2 + 28 >> 2]) ^ -1) & 1));
   $0 = 1;
   $1 = HEAP32[$2 + 24 >> 2];
   if (HEAP32[$2 + 16 >> 2]) {
    $0 = FUNCTION_TABLE[HEAP32[$2 + 16 >> 2]](HEAP32[$2 + 28 >> 2]) ^ -1
   }
   jsvObjectSetChildAndUnLock($1, 17999, jsvNewFromBool($0 & 1));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 17949, jsvNewFromBool((HEAPU8[$2 + 23 | 0] ^ -1) & 1));
   HEAP32[$2 + 12 >> 2] = jsvGetValueOfName(HEAP32[$2 + 28 >> 2]);
   block1 : {
    if (jsvIsGetterOrSetter(HEAP32[$2 + 12 >> 2]) & 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 4994, jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 4994));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 4980, jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 4980));
     break block1;
    }
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 17383, jsvSkipName(HEAP32[$2 + 28 >> 2]));
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 24 >> 2];
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jswrap_object_hasOwnProperty($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 76 >> 2] = $0;
  HEAP32[$2 + 72 >> 2] = $1;
  HEAP32[$2 + 68 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 72 >> 2]);
  HEAP8[$2 + 67 | 0] = 0;
  if (jsvHasChildren(HEAP32[$2 + 76 >> 2]) & 1) {
   HEAP32[$2 + 60 >> 2] = jsvFindChildFromVar(HEAP32[$2 + 76 >> 2], HEAP32[$2 + 68 >> 2], 0);
   if (HEAP32[$2 + 60 >> 2]) {
    HEAP8[$2 + 67 | 0] = 1;
    jsvUnLock(HEAP32[$2 + 60 >> 2]);
   }
  }
  block : {
   if (HEAP8[$2 + 67 | 0] & 1) {
    break block
   }
   if (jsvIsObject(HEAP32[$2 + 76 >> 2]) & 1) {
    break block
   }
   HEAP32[$2 + 56 >> 2] = jswGetSymbolListForObject(HEAP32[$2 + 76 >> 2]);
   if (HEAP32[$2 + 56 >> 2]) {
    jsvGetString(HEAP32[$2 + 68 >> 2], $2 + 16 | 0, 32);
    HEAP32[$2 + 12 >> 2] = jswBinarySearch(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 76 >> 2], $2 + 16 | 0);
    if (HEAP32[$2 + 12 >> 2]) {
     HEAP8[$2 + 67 | 0] = 1
    }
    jsvUnLock(HEAP32[$2 + 12 >> 2]);
   }
  }
  jsvUnLock(HEAP32[$2 + 68 >> 2]);
  __stack_pointer = $2 + 80 | 0;
  return HEAP8[$2 + 67 | 0] & 1;
 }
 
 function jswrap_object_getOwnPropertyDescriptors($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (!(jsvHasChildren(HEAP32[$1 + 24 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 24 >> 2];
    jsExceptionHere(3, 5585, $1);
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 20 >> 2] = jsvNewObject();
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 16 >> 2] = jswrap_object_keys_or_property_names(HEAP32[$1 + 24 >> 2], 1);
   jsvObjectIteratorNew($1 + 12 | 0, HEAP32[$1 + 16 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1544($1 + 12 | 0) & 1) {
     HEAP32[$1 + 8 >> 2] = jsvObjectIteratorGetValue_1545($1 + 12 | 0);
     HEAP32[$1 + 4 >> 2] = jswrap_object_getOwnPropertyDescriptor(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 8 >> 2]);
     jsvObjectSetChildVar(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
     jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
     jsvObjectIteratorNext($1 + 12 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1550($1 + 12 | 0);
   jsvUnLock(HEAP32[$1 + 16 >> 2]);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvObjectIteratorFree_1550($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_object_defineProperty($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 56 >> 2] = $0;
  HEAP32[$3 + 52 >> 2] = $1;
  HEAP32[$3 + 48 >> 2] = $2;
  block1 : {
   block : {
    if (jsvIsObject(HEAP32[$3 + 56 >> 2]) & 1) {
     break block
    }
    if (jsvIsFunction(HEAP32[$3 + 56 >> 2]) & 1) {
     break block
    }
    if (jsvIsArray(HEAP32[$3 + 56 >> 2]) & 1) {
     break block
    }
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 56 >> 2];
    jsExceptionHere(1, 5388, $3 + 16 | 0);
    HEAP32[$3 + 60 >> 2] = 0;
    break block1;
   }
   if (!(jsvIsObject(HEAP32[$3 + 48 >> 2]) & 1)) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 48 >> 2];
    jsExceptionHere(1, 5662, $3);
    HEAP32[$3 + 60 >> 2] = 0;
    break block1;
   }
   HEAP32[$3 + 44 >> 2] = jsvAsArrayIndex(HEAP32[$3 + 52 >> 2]);
   HEAP32[$3 + 40 >> 2] = 0;
   HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 4994);
   HEAP32[$3 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 4980);
   if (HEAP32[$3 + 36 >> 2] | HEAP32[$3 + 32 >> 2]) {
    HEAP32[$3 + 40 >> 2] = jsvNewWithFlags(6);
    if (HEAP32[$3 + 40 >> 2]) {
     if (HEAP32[$3 + 36 >> 2]) {
      jsvObjectSetChild(HEAP32[$3 + 40 >> 2], 4994, HEAP32[$3 + 36 >> 2])
     }
     if (HEAP32[$3 + 32 >> 2]) {
      jsvObjectSetChild(HEAP32[$3 + 40 >> 2], 4980, HEAP32[$3 + 32 >> 2])
     }
    }
    jsvUnLock2(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 32 >> 2]);
   }
   if (!HEAP32[$3 + 40 >> 2]) {
    HEAP32[$3 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 17383)
   }
   jsvObjectSetChildVar(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
   HEAP32[$3 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 17940);
   block3 : {
    if (jsvIsUndefined(HEAP32[$3 + 28 >> 2]) & 1) {
     break block3
    }
    if (jsvGetBoolAndUnLock(HEAP32[$3 + 28 >> 2]) & 1) {
     break block3
    }
    $0 = HEAP32[$3 + 44 >> 2];
    $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 64;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
   jsvUnLock2(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
   HEAP32[$3 + 60 >> 2] = jsvLockAgain(HEAP32[$3 + 56 >> 2]);
  }
  __stack_pointer = $3 - -64 | 0;
  return HEAP32[$3 + 60 >> 2];
 }
 
 function jswrap_object_defineProperties($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  block : {
   if (!(jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1)) {
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 40 >> 2];
    jsExceptionHere(1, 5585, $2 + 16 | 0);
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   if (!(jsvIsObject(HEAP32[$2 + 36 >> 2]) & 1)) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
    jsExceptionHere(1, 5623, $2);
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   jsvObjectIteratorNew($2 + 32 | 0, HEAP32[$2 + 36 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1544($2 + 32 | 0) & 1) {
     HEAP32[$2 + 28 >> 2] = jsvObjectIteratorGetKey_1553($2 + 32 | 0);
     HEAP32[$2 + 24 >> 2] = jsvObjectIteratorGetValue_1545($2 + 32 | 0);
     jsvUnLock3(jswrap_object_defineProperty(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]), HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
     jsvObjectIteratorNext($2 + 32 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1550($2 + 32 | 0);
   HEAP32[$2 + 44 >> 2] = jsvLockAgain(HEAP32[$2 + 40 >> 2]);
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jsvObjectIteratorGetKey_1553($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_object_getPrototypeOf($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jspGetNamedField(HEAP32[$1 + 12 >> 2], 20670, 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_object_setPrototypeOf($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block1 : {
   block : {
    if (!(jsvIsFunction(HEAP32[$2 + 12 >> 2]) & 1)) {
     if (!(jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1)) {
      break block
     }
    }
    $0 = jsvFindOrAddChildFromString(HEAP32[$2 + 12 >> 2], 20670);
    break block1;
   }
   $0 = 0;
  }
  HEAP32[$2 + 4 >> 2] = $0;
  block2 : {
   if (!(jsvIsName(HEAP32[$2 + 4 >> 2]) & 1)) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 4 >> 2];
    jsExceptionHere(3, 6446, $2);
    break block2;
   }
   jsvSetValueOfName(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  $0 = jsvLockAgainSafe(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_object_assign($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP32[$1 + 24 >> 2] = 0;
  jsvObjectIteratorNew($1 + 20 | 0, HEAP32[$1 + 28 >> 2]);
  HEAP8[$1 + 19 | 0] = 0;
  while (1) {
   $0 = 0;
   if (!(HEAP8[$1 + 19 | 0] & 1)) {
    $0 = jsvObjectIteratorHasValue_1544($1 + 20 | 0)
   }
   if ($0 & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_1545($1 + 20 | 0);
    block : {
     if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
      break block
     }
     if (jsvIsNull(HEAP32[$1 + 12 >> 2]) & 1) {
      break block
     }
     block1 : {
      if (!(jsvIsObject(HEAP32[$1 + 12 >> 2]) & 1)) {
       HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
       jsExceptionHere(3, 5560, $1);
       HEAP8[$1 + 19 | 0] = 1;
       break block1;
      }
      block2 : {
       if (!HEAP32[$1 + 24 >> 2]) {
        HEAP32[$1 + 24 >> 2] = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
        break block2;
       }
       jsvObjectAppendAll(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 12 >> 2]);
      }
     }
    }
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($1 + 20 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_1550($1 + 20 | 0);
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 24 >> 2];
 }
 
 function jswrap_boolean_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvGetBool(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jswrap_object_addEventListener($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP16[$4 + 18 >> 1] = $3;
  HEAP32[$4 + 12 >> 2] = jsvNewFromString(HEAP32[$4 + 24 >> 2]);
  HEAP32[$4 + 8 >> 2] = jsvNewNativeFunction(HEAP32[$4 + 20 >> 2], HEAPU16[$4 + 18 >> 1]);
  jswrap_object_on(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
  jsvUnLock2(HEAP32[$4 + 8 >> 2], HEAP32[$4 + 12 >> 2]);
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jswrap_object_on($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jswrap_object_on_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_object_on_X($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP8[$4 + 35 | 0] = $3;
  block : {
   if (!(jsvHasChildren(HEAP32[$4 + 44 >> 2]) & 1)) {
    jsExceptionHere(3, 20399, 0);
    break block;
   }
   if (!(jsvIsString(HEAP32[$4 + 40 >> 2]) & 1)) {
    jsExceptionHere(3, 16768, 0);
    break block;
   }
   block1 : {
    if (jsvIsFunction(HEAP32[$4 + 36 >> 2]) & 1) {
     break block1
    }
    if (jsvIsString(HEAP32[$4 + 36 >> 2]) & 1) {
     break block1
    }
    jsExceptionHere(3, 16798, 0);
    break block;
   }
   HEAP32[$4 >> 2] = HEAP32[$4 + 40 >> 2];
   HEAP32[$4 + 28 >> 2] = jsvVarPrintf(4161, $4);
   if (!HEAP32[$4 + 28 >> 2]) {
    break block
   }
   HEAP32[$4 + 24 >> 2] = jsvFindChildFromVar(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 28 >> 2], 1);
   jsvUnLock(HEAP32[$4 + 28 >> 2]);
   HEAP32[$4 + 20 >> 2] = jsvSkipName(HEAP32[$4 + 24 >> 2]);
   HEAP32[$4 + 16 >> 2] = 0;
   block2 : {
    if (HEAP8[$4 + 35 | 0] & 1) {
     HEAP32[$4 + 16 >> 2] = jsvNewArray($4 + 36 | 0, 1);
     if (HEAP32[$4 + 20 >> 2]) {
      jsvArrayPushAll(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 20 >> 2], 0)
     }
     break block2;
    }
    HEAP32[$4 + 16 >> 2] = jsvNewEmptyArray();
    if (HEAP32[$4 + 20 >> 2]) {
     jsvArrayPushAll(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 20 >> 2], 0)
    }
    jsvArrayPush(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 36 >> 2]);
   }
   jsvUnLock(HEAP32[$4 + 20 >> 2]);
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 16 >> 2];
   jsvSetValueOfName(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
   jsvUnLock2(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
   if (!(jsvIsStringEqual(HEAP32[$4 + 40 >> 2], 20636) & 1)) {
    break block
   }
   HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 44 >> 2], 17070);
   if (jsvIsString(HEAP32[$4 + 12 >> 2]) & 1) {
    jsiQueueObjectCallbacks(HEAP32[$4 + 44 >> 2], 20544, $4 + 12 | 0, 1);
    jsvObjectRemoveChild(HEAP32[$4 + 44 >> 2], 17070);
   }
   jsvUnLock(HEAP32[$4 + 12 >> 2]);
  }
  __stack_pointer = $4 + 48 | 0;
 }
 
 function jswrap_object_prependListener($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jswrap_object_on_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_object_emit($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $4 = __stack_pointer + -64 | 0;
  $3 = $4;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  block : {
   if (!(jsvHasChildren(HEAP32[$3 + 60 >> 2]) & 1)) {
    jsExceptionHere(3, 20399, 0);
    break block;
   }
   if (!(jsvIsString(HEAP32[$3 + 56 >> 2]) & 1)) {
    jsExceptionHere(3, 16768, 0);
    break block;
   }
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 56 >> 2];
   HEAP32[$3 + 48 >> 2] = jsvVarPrintf(4161, $3 + 16 | 0);
   if (!HEAP32[$3 + 48 >> 2]) {
    break block
   }
   HEAP32[$3 + 44 >> 2] = 4;
   HEAP32[$3 + 40 >> 2] = $4;
   $4 = $4 - 16 | 0;
   __stack_pointer = $4;
   HEAP32[$3 + 36 >> 2] = 0;
   jsvObjectIteratorNew($3 + 32 | 0, HEAP32[$3 + 52 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1544($3 + 32 | 0) & 1) {
     if (HEAPU32[$3 + 36 >> 2] >= 4) {
      HEAP32[$3 >> 2] = 4;
      jsExceptionHere(3, 24865, $3);
     } else {
      $0 = jsvObjectIteratorGetValue_1545($3 + 32 | 0);
      $1 = HEAP32[$3 + 36 >> 2];
      HEAP32[$3 + 36 >> 2] = $1 + 1;
      HEAP32[($1 << 2) + $4 >> 2] = $0;
      jsvObjectIteratorNext($3 + 32 | 0);
      continue;
     }
    }
    break;
   };
   jsvObjectIteratorFree_1550($3 + 32 | 0);
   HEAP32[$3 + 28 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 48 >> 2], 0));
   jsvUnLock(HEAP32[$3 + 48 >> 2]);
   if (HEAP32[$3 + 28 >> 2]) {
    jsiQueueEvents(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 28 >> 2], $4, HEAP32[$3 + 36 >> 2])
   }
   jsvUnLock(HEAP32[$3 + 28 >> 2]);
   jsvUnLockMany(HEAP32[$3 + 36 >> 2], $4);
  }
  __stack_pointer = $3 - -64 | 0;
 }
 
 function jswrap_object_removeListener($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (!(jsvHasChildren(HEAP32[$3 + 28 >> 2]) & 1)) {
    jsExceptionHere(3, 20399, 0);
    break block;
   }
   if (jsvIsString(HEAP32[$3 + 24 >> 2]) & 1) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
    HEAP32[$3 + 16 >> 2] = jsvVarPrintf(4161, $3);
    if (!HEAP32[$3 + 16 >> 2]) {
     break block
    }
    HEAP32[$3 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], 1);
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    HEAP32[$3 + 8 >> 2] = jsvSkipName(HEAP32[$3 + 12 >> 2]);
    if (HEAP32[$3 + 8 >> 2]) {
     if (jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) {
      HEAP32[$3 + 4 >> 2] = jsvGetIndexOf(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], 1);
      if (HEAP32[$3 + 4 >> 2]) {
       jsvRemoveChildAndUnLock(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2])
      }
     }
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
    }
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    break block;
   }
   jsExceptionHere(3, 16768, 0);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jswrap_object_removeAllListeners($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block : {
   if (!(jsvHasChildren(HEAP32[$2 + 28 >> 2]) & 1)) {
    jsExceptionHere(3, 20399, 0);
    break block;
   }
   if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 + 20 >> 2] = jsvVarPrintf(4161, $2);
    if (!HEAP32[$2 + 20 >> 2]) {
     break block
    }
    HEAP32[$2 + 16 >> 2] = jsvFindChildFromVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 1);
    jsvUnLock(HEAP32[$2 + 20 >> 2]);
    if (HEAP32[$2 + 16 >> 2]) {
     jsvRemoveChildAndUnLock(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2])
    }
    break block;
   }
   block1 : {
    if (jsvIsUndefined(HEAP32[$2 + 24 >> 2]) & 1) {
     jsvObjectIteratorNew($2 + 12 | 0, HEAP32[$2 + 28 >> 2]);
     while (1) {
      if (jsvObjectIteratorHasValue_1544($2 + 12 | 0) & 1) {
       HEAP32[$2 + 8 >> 2] = jsvObjectIteratorGetKey_1553($2 + 12 | 0);
       jsvObjectIteratorNext($2 + 12 | 0);
       if (jsvIsStringEqualOrStartsWith(HEAP32[$2 + 8 >> 2], 15492, 1) & 1) {
        jsvRemoveChild(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 8 >> 2])
       }
       jsvUnLock(HEAP32[$2 + 8 >> 2]);
       continue;
      }
      break;
     };
     jsvObjectIteratorFree_1550($2 + 12 | 0);
     break block1;
    }
    jsExceptionHere(3, 19048, 0);
   }
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_object_removeAllListeners_cstr($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvNewFromString(HEAP32[$2 + 8 >> 2]);
  if (HEAP32[$2 + 4 >> 2]) {
   jswrap_object_removeAllListeners(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2]);
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_function_replaceWith($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block1 : {
   block : {
    if (jsvIsFunction(HEAP32[$2 + 28 >> 2]) & 1) {
     if (jsvIsFunction(HEAP32[$2 + 24 >> 2]) & 1) {
      break block
     }
    }
    jsExceptionHere(3, 15391, 0);
    break block1;
   }
   if ((jsvIsNativeFunction(HEAP32[$2 + 28 >> 2]) & 1) != (jsvIsNativeFunction(HEAP32[$2 + 24 >> 2]) & 1)) {
    block2 : {
     if (jsvIsNativeFunction(HEAP32[$2 + 24 >> 2]) & 1) {
      $0 = HEAP32[$2 + 28 >> 2];
      $1 = HEAP32[$2 + 28 >> 2];
      $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 8;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
      $0 = HEAP32[$2 + 28 >> 2];
      $1 = HEAP32[$2 + 24 >> 2];
      $3 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
      HEAP8[$0 | 0] = $3;
      HEAP8[$0 + 1 | 0] = $3 >>> 8;
      HEAP8[$0 + 2 | 0] = $3 >>> 16;
      HEAP8[$0 + 3 | 0] = $3 >>> 24;
      $1 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8;
      HEAP8[$0 + 4 | 0] = $1;
      HEAP8[$0 + 5 | 0] = $1 >>> 8;
      break block2;
     }
     $0 = HEAP32[$2 + 28 >> 2];
     HEAP8[$0 | 0] = 0;
     HEAP8[$0 + 1 | 0] = 0;
     HEAP8[$0 + 2 | 0] = 0;
     HEAP8[$0 + 3 | 0] = 0;
     HEAP8[$0 + 4 | 0] = 0;
     HEAP8[$0 + 5 | 0] = 0;
     $0 = HEAP32[$2 + 28 >> 2];
     $1 = HEAP32[$2 + 28 >> 2];
     $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 7;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
    }
   }
   if ((jsvIsFunctionReturn(HEAP32[$2 + 28 >> 2]) & 1) != (jsvIsFunctionReturn(HEAP32[$2 + 24 >> 2]) & 1)) {
    block3 : {
     if (jsvIsFunctionReturn(HEAP32[$2 + 24 >> 2]) & 1) {
      $0 = HEAP32[$2 + 28 >> 2];
      $1 = HEAP32[$2 + 28 >> 2];
      $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 9;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
      break block3;
     }
     $0 = HEAP32[$2 + 28 >> 2];
     $1 = HEAP32[$2 + 28 >> 2];
     $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 7;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
    }
   }
   HEAP32[$2 + 20 >> 2] = jsvFindChildFromString(HEAP32[$2 + 28 >> 2], 15114);
   HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 28 >> 2], 17727);
   jsvRemoveAllChildren(HEAP32[$2 + 28 >> 2]);
   jsvObjectIteratorNew($2 + 12 | 0, HEAP32[$2 + 24 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1544($2 + 12 | 0) & 1) {
     HEAP32[$2 + 8 >> 2] = jsvObjectIteratorGetKey_1553($2 + 12 | 0);
     jsvObjectIteratorNext($2 + 12 | 0);
     block4 : {
      if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 15114) & 1) {
       break block4
      }
      if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 17727) & 1) {
       break block4
      }
      block5 : {
       if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 18659) & 1) {
        HEAP32[$2 >> 2] = jsvSkipName(HEAP32[$2 + 8 >> 2]);
        HEAP32[$2 + 4 >> 2] = jsvMakeIntoVariableName(jsvNewFromStringVarComplete(HEAP32[$2 + 8 >> 2]), HEAP32[$2 >> 2]);
        jsvUnLock(HEAP32[$2 >> 2]);
        break block5;
       }
       HEAP32[$2 + 4 >> 2] = jsvCopy(HEAP32[$2 + 8 >> 2], 1);
      }
      if (HEAP32[$2 + 4 >> 2]) {
       jsvAddName(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 4 >> 2]);
       jsvUnLock(HEAP32[$2 + 4 >> 2]);
      }
     }
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1550($2 + 12 | 0);
   if (HEAP32[$2 + 20 >> 2]) {
    jsvAddName(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2])
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   if (HEAP32[$2 + 16 >> 2]) {
    jsvAddName(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2])
   }
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_function_apply_or_call($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $4 = __stack_pointer - 128 | 0;
  $3 = $4;
  __stack_pointer = $3;
  HEAP32[$3 + 120 >> 2] = $0;
  HEAP32[$3 + 116 >> 2] = $1;
  HEAP32[$3 + 112 >> 2] = $2;
  HEAP32[$3 + 104 >> 2] = 0;
  HEAP32[$3 + 100 >> 2] = 0;
  block : {
   block2 : {
    if (jsvIsIterable(HEAP32[$3 + 112 >> 2]) & 1) {
     HEAP32[$3 + 100 >> 2] = jsvGetLength(HEAP32[$3 + 112 >> 2]);
     if (HEAPU32[$3 + 100 >> 2] > 256) {
      HEAP32[$3 >> 2] = HEAP32[$3 + 100 >> 2];
      jsExceptionHere(1, 19702, $3);
      HEAP32[$3 + 124 >> 2] = 0;
      break block;
     }
     $4 = $4 - ((HEAP32[$3 + 100 >> 2] << 2) + 15 & -16) | 0;
     __stack_pointer = $4;
     HEAP32[$3 + 104 >> 2] = $4;
     HEAP32[$3 + 108 >> 2] = 0;
     while (1) {
      if (HEAPU32[$3 + 108 >> 2] < HEAPU32[$3 + 100 >> 2]) {
       HEAP32[HEAP32[$3 + 104 >> 2] + (HEAP32[$3 + 108 >> 2] << 2) >> 2] = 0;
       HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 108 >> 2] + 1;
       continue;
      }
      break;
     };
     jsvIteratorNew($3 + 36 | 0, HEAP32[$3 + 112 >> 2], 1);
     while (1) {
      if (jsvIteratorHasElement($3 + 36 | 0) & 1) {
       HEAP32[$3 + 32 >> 2] = jsvIteratorGetKey($3 + 36 | 0);
       if (jsvIsIntegerish(HEAP32[$3 + 32 >> 2]) & 1) {
        HEAP32[$3 + 28 >> 2] = jsvGetInteger(HEAP32[$3 + 32 >> 2]);
        if (!(HEAP32[$3 + 28 >> 2] < 0 | HEAP32[$3 + 28 >> 2] >= HEAP32[$3 + 100 >> 2])) {
         $0 = jsvIteratorGetValue($3 + 36 | 0);
         HEAP32[HEAP32[$3 + 104 >> 2] + (HEAP32[$3 + 28 >> 2] << 2) >> 2] = $0;
        }
       }
       jsvUnLock(HEAP32[$3 + 32 >> 2]);
       jsvIteratorNext($3 + 36 | 0);
       continue;
      }
      break;
     };
     jsvIteratorFree($3 + 36 | 0);
     break block2;
    }
    if (!(jsvIsUndefined(HEAP32[$3 + 112 >> 2]) & 1)) {
     HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 112 >> 2];
     jsExceptionHere(1, 6121, $3 + 16 | 0);
     HEAP32[$3 + 124 >> 2] = 0;
     break block;
    }
   }
   HEAP32[$3 + 24 >> 2] = jspeFunctionCall(HEAP32[$3 + 120 >> 2], 0, HEAP32[$3 + 116 >> 2], 0, HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
   jsvUnLockMany(HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
   HEAP32[$3 + 124 >> 2] = HEAP32[$3 + 24 >> 2];
  }
  __stack_pointer = $3 + 128 | 0;
  return HEAP32[$3 + 124 >> 2];
 }
 
 function jswrap_function_bind($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 72 >> 2] = $0;
  HEAP32[$3 + 68 >> 2] = $1;
  HEAP32[$3 + 64 >> 2] = $2;
  block : {
   if (!(jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1)) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 72 >> 2];
    jsExceptionHere(3, 5812, $3);
    HEAP32[$3 + 76 >> 2] = 0;
    break block;
   }
   block1 : {
    if (jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1) {
     $0 = HEAP32[$3 + 72 >> 2];
     $1 = HEAP32[$3 + 72 >> 2];
     HEAP32[$3 + 60 >> 2] = jsvNewNativeFunction(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8);
     break block1;
    }
    HEAP32[$3 + 60 >> 2] = jsvNewWithFlags(jsvIsFunctionReturn(HEAP32[$3 + 72 >> 2]) & 1 ? 9 : 7);
   }
   if (!HEAP32[$3 + 60 >> 2]) {
    HEAP32[$3 + 76 >> 2] = 0;
    break block;
   }
   jsvObjectIteratorNew($3 + 56 | 0, HEAP32[$3 + 72 >> 2]);
   while (1) {
    block2 : {
     if (!(jsvObjectIteratorHasValue_1544($3 + 56 | 0) & 1)) {
      break block2
     }
     HEAP32[$3 + 52 >> 2] = jsvObjectIteratorGetKey_1553($3 + 56 | 0);
     HEAP32[$3 + 48 >> 2] = jsvObjectIteratorGetValue_1545($3 + 56 | 0);
     $0 = 0;
     if (jsvIsFunctionParameter(HEAP32[$3 + 52 >> 2]) & 1) {
      $0 = HEAP32[$3 + 48 >> 2] != 0
     }
     HEAP8[$3 + 47 | 0] = $0;
     if (HEAP8[$3 + 47 | 0] & 1) {
      HEAP32[$3 + 40 >> 2] = jsvCopy(HEAP32[$3 + 52 >> 2], 1);
      if (HEAP32[$3 + 40 >> 2]) {
       jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 40 >> 2]);
       jsvUnLock(HEAP32[$3 + 40 >> 2]);
      }
     }
     jsvUnLock2(HEAP32[$3 + 52 >> 2], HEAP32[$3 + 48 >> 2]);
     if (!(HEAP8[$3 + 47 | 0] & 1)) {
      break block2
     }
     jsvObjectIteratorNext($3 + 56 | 0);
     continue;
    }
    break;
   };
   if (HEAP32[$3 + 64 >> 2]) {
    jsvObjectIteratorNew($3 + 36 | 0, HEAP32[$3 + 64 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_1544($3 + 36 | 0) & 1) {
      HEAP32[$3 + 32 >> 2] = jsvObjectIteratorGetValue_1545($3 + 36 | 0);
      HEAP8[$3 + 31 | 0] = 0;
      while (1) {
       $0 = 0;
       if (!(HEAP8[$3 + 31 | 0] & 1)) {
        $0 = jsvObjectIteratorHasValue_1544($3 + 56 | 0)
       }
       block3 : {
        if (!($0 & 1)) {
         break block3
        }
        HEAP32[$3 + 24 >> 2] = jsvObjectIteratorGetKey_1553($3 + 56 | 0);
        if (!(jsvIsFunctionParameter(HEAP32[$3 + 24 >> 2]) & 1)) {
         jsvUnLock(HEAP32[$3 + 24 >> 2]);
         break block3;
        }
        HEAP32[$3 + 20 >> 2] = jsvCopyNameOnly(HEAP32[$3 + 24 >> 2], 0, 1);
        jsvSetValueOfName(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 32 >> 2]);
        jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 20 >> 2]);
        HEAP8[$3 + 31 | 0] = 1;
        jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
        jsvObjectIteratorNext($3 + 56 | 0);
        continue;
       }
       break;
      };
      if (!(HEAP8[$3 + 31 | 0] & 1)) {
       jsvAddFunctionParameter(HEAP32[$3 + 60 >> 2], 0, HEAP32[$3 + 32 >> 2])
      }
      jsvUnLock(HEAP32[$3 + 32 >> 2]);
      jsvObjectIteratorNext($3 + 36 | 0);
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1550($3 + 36 | 0);
   }
   while (1) {
    if (jsvObjectIteratorHasValue_1544($3 + 56 | 0) & 1) {
     HEAP32[$3 + 16 >> 2] = jsvObjectIteratorGetKey_1553($3 + 56 | 0);
     HEAP32[$3 + 12 >> 2] = jsvCopyNameOnly(HEAP32[$3 + 16 >> 2], 1, 1);
     if (HEAP32[$3 + 12 >> 2]) {
      jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 12 >> 2]);
      jsvUnLock(HEAP32[$3 + 12 >> 2]);
     }
     jsvUnLock(HEAP32[$3 + 16 >> 2]);
     jsvObjectIteratorNext($3 + 56 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1550($3 + 56 | 0);
   jsvObjectSetChild(HEAP32[$3 + 60 >> 2], 7212, HEAP32[$3 + 68 >> 2]);
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 60 >> 2];
  }
  __stack_pointer = $3 + 80 | 0;
  return HEAP32[$3 + 76 >> 2];
 }
 
 function matchcharacter($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 40 >> 2] = $0;
  HEAP32[$4 + 36 >> 2] = $1;
  HEAP32[$4 + 32 >> 2] = $2;
  HEAP32[$4 + 28 >> 2] = $3;
  HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 1;
  HEAP8[$4 + 27 | 0] = jsvStringIteratorGetChar_1570(HEAP32[$4 + 36 >> 2]);
  block : {
   if (HEAPU8[HEAP32[$4 + 40 >> 2]] == 46) {
    HEAP8[$4 + 47 | 0] = 1;
    break block;
   }
   if (HEAPU8[HEAP32[$4 + 40 >> 2]] == 91) {
    HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] = 1;
    HEAP8[$4 + 26 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 1 | 0] == 94;
    if (HEAP8[$4 + 26 | 0] & 1) {
     $0 = HEAP32[$4 + 32 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    }
    HEAP8[$4 + 25 | 0] = 0;
    while (1) {
     $0 = 0;
     $0 = HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] << 24 >> 24 ? HEAPU8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] != 93 : $0;
     if ($0) {
      if (HEAPU8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] == 46) {
       HEAP8[$4 + 25 | 0] = HEAP8[$4 + 25 | 0] & 1 | HEAPU8[$4 + 27 | 0] == 46;
       $0 = HEAP32[$4 + 32 >> 2];
       HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
       continue;
      }
      HEAP8[$4 + 25 | 0] = matchcharacter(HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0, HEAP32[$4 + 36 >> 2], $4 + 20 | 0, HEAP32[$4 + 28 >> 2]) & 1 | HEAP8[$4 + 25 | 0] & 1;
      $0 = HEAP32[$4 + 32 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$4 + 20 >> 2] + HEAP32[$0 >> 2];
      continue;
     }
     break;
    };
    block1 : {
     if (HEAPU8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] == 93) {
      $0 = HEAP32[$4 + 32 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      break block1;
     }
     jsExceptionHere(1, 3881, 0);
     HEAP8[$4 + 47 | 0] = 0;
     break block;
    }
    HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] = 0;
    HEAP8[$4 + 47 | 0] = (HEAP8[$4 + 25 | 0] & 1) != (HEAP8[$4 + 26 | 0] & 1);
    break block;
   }
   HEAP8[$4 + 19 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2]];
   block2 : {
    if (HEAPU8[$4 + 19 | 0] != 92) {
     break block2
    }
    HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 2;
    HEAP8[$4 + 19 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 1 | 0];
    if (HEAPU8[$4 + 19 | 0] == 100) {
     HEAP8[$4 + 47 | 0] = isNumeric(HEAP8[$4 + 27 | 0] << 24 >> 24) & 1;
     break block;
    }
    if (HEAPU8[$4 + 19 | 0] == 68) {
     HEAP8[$4 + 47 | 0] = (isNumeric(HEAP8[$4 + 27 | 0] << 24 >> 24) ^ -1) & 1;
     break block;
    }
    if (HEAPU8[$4 + 19 | 0] == 102) {
     HEAP8[$4 + 19 | 0] = 12;
     break block2;
    }
    if (HEAPU8[$4 + 19 | 0] == 98) {
     HEAP8[$4 + 19 | 0] = 8;
     break block2;
    }
    if (HEAPU8[$4 + 19 | 0] == 110) {
     HEAP8[$4 + 19 | 0] = 10;
     break block2;
    }
    if (HEAPU8[$4 + 19 | 0] == 114) {
     HEAP8[$4 + 19 | 0] = 13;
     break block2;
    }
    if (HEAPU8[$4 + 19 | 0] == 115) {
     HEAP8[$4 + 47 | 0] = isWhitespace(HEAP8[$4 + 27 | 0] << 24 >> 24) & 1;
     break block;
    }
    if (HEAPU8[$4 + 19 | 0] == 83) {
     HEAP8[$4 + 47 | 0] = (isWhitespace(HEAP8[$4 + 27 | 0] << 24 >> 24) ^ -1) & 1;
     break block;
    }
    if (HEAPU8[$4 + 19 | 0] == 116) {
     HEAP8[$4 + 19 | 0] = 9;
     break block2;
    }
    if (HEAPU8[$4 + 19 | 0] == 118) {
     HEAP8[$4 + 19 | 0] = 11;
     break block2;
    }
    if (HEAPU8[$4 + 19 | 0] == 119) {
     $0 = 1;
     block3 : {
      if (isNumeric(HEAP8[$4 + 27 | 0] << 24 >> 24) & 1) {
       break block3
      }
      $0 = 1;
      if (isAlpha(HEAP8[$4 + 27 | 0] << 24 >> 24) & 1) {
       break block3
      }
      $0 = HEAPU8[$4 + 27 | 0] == 95;
     }
     HEAP8[$4 + 47 | 0] = $0;
     break block;
    }
    if (HEAPU8[$4 + 19 | 0] == 87) {
     $0 = 1;
     block4 : {
      if (isNumeric(HEAP8[$4 + 27 | 0] << 24 >> 24) & 1) {
       break block4
      }
      $0 = 1;
      if (isAlpha(HEAP8[$4 + 27 | 0] << 24 >> 24) & 1) {
       break block4
      }
      $0 = HEAPU8[$4 + 27 | 0] == 95;
     }
     HEAP8[$4 + 47 | 0] = ($0 ^ -1) & 1;
     break block;
    }
    if (HEAPU8[$4 + 19 | 0] == 48) {
     HEAP8[$4 + 19 | 0] = 0;
     break block2;
    }
    if (!(HEAP8[$4 + 19 | 0] << 24 >> 24 < 49 | HEAP8[$4 + 19 | 0] << 24 >> 24 > 57)) {
     jsExceptionHere(1, 18816, 0);
     HEAP8[$4 + 47 | 0] = 0;
     break block;
    }
    if (!(!HEAPU8[HEAP32[$4 + 40 >> 2] + 3 | 0] | (!HEAPU8[HEAP32[$4 + 40 >> 2] + 2 | 0] | HEAPU8[$4 + 19 | 0] != 120))) {
     HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 4;
     HEAP8[$4 + 19 | 0] = hexToByte(HEAP8[HEAP32[$4 + 40 >> 2] + 2 | 0] << 24 >> 24, HEAP8[HEAP32[$4 + 40 >> 2] + 3 | 0] << 24 >> 24);
    }
   }
   if (!(!(HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) | HEAPU8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] != 45 | HEAPU8[HEAP32[$4 + 40 >> 2] + (HEAP32[HEAP32[$4 + 32 >> 2] >> 2] + 1 | 0) | 0] == 93)) {
    HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] = HEAP8[$4 + 19 | 0] << 24 >> 24;
    $0 = HEAP32[$4 + 32 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    HEAP8[$4 + 11 | 0] = matchcharacter(HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0, HEAP32[$4 + 36 >> 2], $4 + 12 | 0, HEAP32[$4 + 28 >> 2]) & 1;
    $0 = HEAP32[$4 + 32 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$4 + 12 >> 2] + HEAP32[$0 >> 2];
    HEAP8[$4 + 47 | 0] = HEAP8[$4 + 11 | 0] & 1;
    break block;
   }
   if (HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1) {
    HEAP8[$4 + 27 | 0] = charToLowerCase(HEAP8[$4 + 27 | 0] << 24 >> 24);
    HEAP8[$4 + 19 | 0] = charToLowerCase(HEAP8[$4 + 19 | 0] << 24 >> 24);
   }
   if (HEAPU16[HEAP32[$4 + 28 >> 2] + 10 >> 1] != 256) {
    HEAP8[$4 + 10 | 0] = HEAPU16[HEAP32[$4 + 28 >> 2] + 10 >> 1];
    if (HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1) {
     HEAP8[$4 + 10 | 0] = charToLowerCase(HEAP8[$4 + 10 | 0] << 24 >> 24)
    }
    HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] = 256;
    $0 = 0;
    block8 : {
     if (HEAP8[$4 + 27 | 0] << 24 >> 24 < HEAP8[$4 + 10 | 0] << 24 >> 24) {
      break block8
     }
     $0 = 0;
     if (HEAP8[$4 + 27 | 0] << 24 >> 24 > HEAP8[$4 + 19 | 0] << 24 >> 24) {
      break block8
     }
     $0 = HEAP8[$4 + 10 | 0] << 24 >> 24 < HEAP8[$4 + 19 | 0] << 24 >> 24;
    }
    HEAP8[$4 + 47 | 0] = $0;
    break block;
   }
   HEAP8[$4 + 47 | 0] = HEAPU8[$4 + 19 | 0] == HEAPU8[$4 + 27 | 0];
  }
  __stack_pointer = $4 + 48 | 0;
  return HEAP8[$4 + 47 | 0] & 1;
 }
 
 function jsvStringIteratorGetChar_1570($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function jswrap_regexp_constructor($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 128 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 120 >> 2] = $0;
  HEAP32[$2 + 116 >> 2] = $1;
  block : {
   if (!(jsvIsString(HEAP32[$2 + 120 >> 2]) & 1)) {
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 120 >> 2];
    jsExceptionHere(3, 5479, $2 + 16 | 0);
    HEAP32[$2 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 112 >> 2] = jspNewObject(0, 14862);
   jsvObjectSetChild(HEAP32[$2 + 112 >> 2], 18251, HEAP32[$2 + 120 >> 2]);
   if (!(jsvIsUndefined(HEAP32[$2 + 116 >> 2]) & 1)) {
    block1 : {
     if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
      HEAP32[$2 >> 2] = HEAP32[$2 + 120 >> 2];
      jsExceptionHere(3, 5479, $2);
      break block1;
     }
     jsvObjectSetChild(HEAP32[$2 + 112 >> 2], 7222, HEAP32[$2 + 116 >> 2]);
    }
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 112 >> 2], 3853, jsvNewFromInteger(0));
   jsvStringIteratorNew($2 + 72 | 0, HEAP32[$2 + 120 >> 2], 0);
   HEAP8[$2 + 71 | 0] = 0;
   HEAP8[$2 + 70 | 0] = 1;
   HEAP32[$2 + 28 >> 2] = 0;
   while (1) {
    if (jsvStringIteratorHasChar_1572($2 + 72 | 0) & 1) {
     HEAP8[$2 + 27 | 0] = HEAPU8[$2 + 71 | 0] == 92;
     block2 : {
      if (!HEAPU8[$2 + 71 | 0]) {
       break block2
      }
      if (!strchr(27302, HEAP8[$2 + 71 | 0] << 24 >> 24)) {
       break block2
      }
      HEAP8[$2 + 70 | 0] = 0;
     }
     HEAP8[$2 + 71 | 0] = jsvStringIteratorGetCharAndNext($2 + 72 | 0);
     if (HEAP8[$2 + 27 | 0] & 1) {
      if (!strchr(20756, HEAP8[$2 + 71 | 0] << 24 >> 24)) {
       HEAP8[$2 + 70 | 0] = 0;
       HEAP8[$2 + 71 | 0] = 0;
      }
     }
     if (!(!HEAPU8[$2 + 71 | 0] | !(HEAP8[$2 + 27 | 0] & 1) & HEAPU8[$2 + 71 | 0] == 92 | HEAPU32[$2 + 28 >> 2] >= 32)) {
      $1 = HEAPU8[$2 + 71 | 0];
      $0 = HEAP32[$2 + 28 >> 2];
      HEAP32[$2 + 28 >> 2] = $0 + 1;
      HEAP8[($2 + 32 | 0) + $0 | 0] = $1;
     }
     if (HEAP8[$2 + 27 | 0] & 1) {
      HEAP8[$2 + 71 | 0] = 0
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1573($2 + 72 | 0);
   if (!(!(HEAP8[$2 + 70 | 0] & 1) | HEAPU8[$2 + 71 | 0] != 36 | HEAPU32[$2 + 28 >> 2] >= 32)) {
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] - 1;
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 112 >> 2], 16189, jsvNewStringOfLength(HEAP32[$2 + 28 >> 2], $2 + 32 | 0));
   }
   HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 112 >> 2];
  }
  __stack_pointer = $2 + 128 | 0;
  return HEAP32[$2 + 124 >> 2];
 }
 
 function jsvStringIteratorHasChar_1572($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorFree_1573($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_regexp_exec($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  $2 = $3;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  HEAP32[$2 + 48 >> 2] = jsvAsString(HEAP32[$2 + 52 >> 2]);
  HEAP32[$2 + 44 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 56 >> 2], 3853);
  HEAP32[$2 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 56 >> 2], 16189);
  block1 : {
   if (HEAP32[$2 + 40 >> 2]) {
    HEAP32[$2 + 36 >> 2] = jsvGetStringLength(HEAP32[$2 + 52 >> 2]) - jsvGetStringLength(HEAP32[$2 + 40 >> 2]);
    block : {
     if (HEAP32[$2 + 44 >> 2] > HEAP32[$2 + 36 >> 2]) {
      break block
     }
     if (jsvCompareString(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0, 1)) {
      break block
     }
     HEAP32[$2 + 32 >> 2] = jsvNewEmptyArray();
     jsvSetArrayItem(HEAP32[$2 + 32 >> 2], 0, HEAP32[$2 + 40 >> 2]);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 32 >> 2], 3847, jsvNewFromInteger(HEAP32[$2 + 36 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 32 >> 2], 4286, HEAP32[$2 + 48 >> 2]);
     jsvUnLock(HEAP32[$2 + 40 >> 2]);
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 32 >> 2];
     break block1;
    }
    jsvUnLock(HEAP32[$2 + 40 >> 2]);
   }
   HEAP32[$2 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 56 >> 2], 18251);
   block2 : {
    if (jsvIsString(HEAP32[$2 + 28 >> 2]) & 1) {
     if (HEAP32[$2 + 44 >> 2] <= (jsvGetStringLength(HEAP32[$2 + 48 >> 2]) | 0)) {
      break block2
     }
    }
    jsvUnLock2(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 28 >> 2]);
    HEAP32[$2 + 60 >> 2] = 0;
    break block1;
   }
   HEAP32[$2 + 24 >> 2] = jsvGetStringLength(HEAP32[$2 + 28 >> 2]);
   $3 = $3 - (HEAP32[$2 + 24 >> 2] + 16 & -16) | 0;
   __stack_pointer = $3;
   HEAP32[$2 + 20 >> 2] = $3;
   if (!HEAP32[$2 + 20 >> 2]) {
    jsvUnLock2(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 28 >> 2]);
    HEAP32[$2 + 60 >> 2] = 0;
    break block1;
   }
   jsvGetString(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2] + 1 | 0);
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 16 >> 2] = match(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 48 >> 2], HEAP32[$2 + 44 >> 2], jswrap_regexp_hasFlag(HEAP32[$2 + 56 >> 2], 105) & 1);
   jsvUnLock(HEAP32[$2 + 48 >> 2]);
   block3 : {
    if (!HEAP32[$2 + 16 >> 2]) {
     HEAP32[$2 + 16 >> 2] = jsvNewWithFlags(2);
     HEAP32[$2 + 44 >> 2] = 0;
     break block3;
    }
    block4 : {
     if (jswrap_regexp_hasFlag(HEAP32[$2 + 56 >> 2], 103) & 1) {
      HEAP32[$2 + 12 >> 2] = jsvGetArrayItem(HEAP32[$2 + 16 >> 2], 0);
      HEAP32[$2 + 44 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 16 >> 2], 3847) + jsvGetStringLength(HEAP32[$2 + 12 >> 2]);
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      break block4;
     }
     HEAP32[$2 + 44 >> 2] = 0;
    }
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 56 >> 2], 3853, jsvNewFromInteger(HEAP32[$2 + 44 >> 2]));
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jswrap_regexp_hasFlag($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 60 >> 2] = $0;
  HEAP8[$2 + 59 | 0] = $1;
  HEAP32[$2 + 52 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 60 >> 2], 7222);
  HEAP8[$2 + 51 | 0] = 0;
  if (jsvIsString(HEAP32[$2 + 52 >> 2]) & 1) {
   jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 52 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1572($2 + 8 | 0) & 1) {
     HEAP8[$2 + 51 | 0] = (jsvStringIteratorGetCharAndNext($2 + 8 | 0) & 255) == HEAPU8[$2 + 59 | 0] | HEAP8[$2 + 51 | 0] & 1;
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1573($2 + 8 | 0);
  }
  jsvUnLock(HEAP32[$2 + 52 >> 2]);
  __stack_pointer = $2 - -64 | 0;
  return HEAP8[$2 + 51 | 0] & 1;
 }
 
 function match($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 368 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 364 >> 2] = $0;
  HEAP32[$4 + 360 >> 2] = $1;
  HEAP32[$4 + 356 >> 2] = $2;
  HEAP8[$4 + 355 | 0] = $3;
  HEAP32[$4 + 264 >> 2] = HEAP32[$4 + 360 >> 2];
  HEAP32[$4 + 268 >> 2] = HEAP32[$4 + 356 >> 2];
  HEAP8[$4 + 272 | 0] = HEAP8[$4 + 355 | 0] & 1;
  HEAP8[$4 + 273 | 0] = 0;
  HEAP16[$4 + 274 >> 1] = 256;
  HEAP32[$4 + 276 >> 2] = 0;
  jsvStringIteratorNew($4 + 220 | 0, HEAP32[$4 + 360 >> 2], HEAP32[$4 + 356 >> 2]);
  jsvStringIteratorClone($4 + 180 | 0, $4 + 220 | 0);
  $0 = HEAP32[$4 + 364 >> 2];
  wasm2js_memory_copy($4 + 92 | 0, $4 + 264 | 0, 88);
  HEAP32[$4 + 260 >> 2] = matchhere($0, $4 + 180 | 0, $4 + 92 | 0);
  jsvStringIteratorFree_1573($4 + 180 | 0);
  jsvStringIteratorNext($4 + 220 | 0);
  while (1) {
   $0 = 0;
   if (!HEAP32[$4 + 260 >> 2]) {
    $0 = jsvStringIteratorHasChar_1572($4 + 220 | 0)
   }
   if ($0 & 1) {
    HEAP32[$4 + 268 >> 2] = HEAP32[$4 + 268 >> 2] + 1;
    jsvStringIteratorClone($4 + 180 | 0, $4 + 220 | 0);
    $0 = HEAP32[$4 + 364 >> 2];
    wasm2js_memory_copy($4 + 4 | 0, $4 + 264 | 0, 88);
    HEAP32[$4 + 260 >> 2] = matchhere($0, $4 + 180 | 0, $4 + 4 | 0);
    jsvStringIteratorFree_1573($4 + 180 | 0);
    jsvStringIteratorNext($4 + 220 | 0);
    continue;
   }
   break;
  };
  jsvStringIteratorFree_1573($4 + 220 | 0);
  __stack_pointer = $4 + 368 | 0;
  return HEAP32[$4 + 260 >> 2];
 }
 
 function matchhere($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 1040 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 1032 >> 2] = $0;
  HEAP32[$3 + 1028 >> 2] = $1;
  block : {
   if (jspIsInterrupted() & 1) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break block;
   }
   if (!(HEAPU8[HEAP32[$3 + 1032 >> 2]] != 124 ? HEAP8[HEAP32[$3 + 1032 >> 2]] << 24 >> 24 : 0)) {
    $0 = HEAP32[$3 + 1028 >> 2];
    wasm2js_memory_copy($3, $2, 88);
    HEAP32[$3 + 1036 >> 2] = matchfound($0, $3);
    break block;
   }
   if (HEAPU8[HEAP32[$3 + 1032 >> 2]] == 94) {
    if (jsvStringIteratorGetIndex_1580(HEAP32[$3 + 1028 >> 2])) {
     HEAP32[$3 + 1036 >> 2] = 0;
     break block;
    }
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$3 + 1036 >> 2] = 0;
     break block;
    }
    $0 = HEAP32[$3 + 1032 >> 2];
    $1 = HEAP32[$3 + 1028 >> 2];
    wasm2js_memory_copy($3 + 88 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 88 | 0);
    break block;
   }
   if (HEAPU8[HEAP32[$3 + 1032 >> 2]] == 36) {
    if (!(jsvStringIteratorHasChar_1572(HEAP32[$3 + 1028 >> 2]) & 1)) {
     $0 = HEAP32[$3 + 1032 >> 2];
     $1 = HEAP32[$3 + 1028 >> 2];
     wasm2js_memory_copy($3 + 264 | 0, $2, 88);
     HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 264 | 0);
     break block;
    }
    $0 = HEAP32[$3 + 1032 >> 2];
    wasm2js_memory_copy($3 + 176 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = nomatchfound($0 + 1 | 0, $3 + 176 | 0);
    break block;
   }
   if (HEAPU8[HEAP32[$3 + 1032 >> 2]] == 40) {
    $0 = jsvStringIteratorGetIndex_1580(HEAP32[$3 + 1028 >> 2]);
    HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = $0;
    HEAP32[($2 + 52 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2];
    if (HEAP32[$2 + 12 >> 2] < 9) {
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1
    }
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$3 + 1036 >> 2] = 0;
     break block;
    }
    $0 = HEAP32[$3 + 1032 >> 2];
    $1 = HEAP32[$3 + 1028 >> 2];
    wasm2js_memory_copy($3 + 352 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 352 | 0);
    break block;
   }
   if (HEAPU8[HEAP32[$3 + 1032 >> 2]] == 41) {
    if (HEAP32[$2 + 12 >> 2] > 0) {
     $0 = jsvStringIteratorGetIndex_1580(HEAP32[$3 + 1028 >> 2]);
     HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 48 >> 2] = $0;
    }
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$3 + 1036 >> 2] = 0;
     break block;
    }
    $0 = HEAP32[$3 + 1032 >> 2];
    $1 = HEAP32[$3 + 1028 >> 2];
    wasm2js_memory_copy($3 + 440 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 440 | 0);
    break block;
   }
   HEAP8[$3 + 1023 | 0] = matchcharacter(HEAP32[$3 + 1032 >> 2], HEAP32[$3 + 1028 >> 2], $3 + 1024 | 0, $2) & 1;
   if (!(HEAPU8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0] != 42 & HEAPU8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0] != 43)) {
    HEAP8[$3 + 1022 | 0] = HEAPU8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0];
    if (!(HEAP8[$3 + 1023 | 0] & 1 | HEAPU8[$3 + 1022 | 0] != 43)) {
     $0 = HEAP32[$3 + 1032 >> 2];
     $1 = HEAP32[$3 + 1024 >> 2];
     wasm2js_memory_copy($3 + 704 | 0, $2, 88);
     HEAP32[$3 + 1036 >> 2] = nomatchfound(($1 + 1 | 0) + $0 | 0, $3 + 704 | 0);
     break block;
    }
    HEAP32[$3 + 1016 >> 2] = (HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0) + 1;
    jsvStringIteratorClone($3 + 976 | 0, HEAP32[$3 + 1028 >> 2]);
    $0 = HEAP32[$3 + 1016 >> 2];
    wasm2js_memory_copy($3 + 616 | 0, $2, 88);
    HEAP32[$3 + 972 >> 2] = matchhere($0, $3 + 976 | 0, $3 + 616 | 0);
    jsvStringIteratorFree_1573($3 + 976 | 0);
    while (1) {
     $0 = 0;
     if (jsvStringIteratorHasChar_1572(HEAP32[$3 + 1028 >> 2]) & 1) {
      $0 = HEAPU8[$3 + 1023 | 0]
     }
     if ($0 & 1) {
      jsvStringIteratorNext(HEAP32[$3 + 1028 >> 2]);
      HEAP8[$3 + 1023 | 0] = matchcharacter(HEAP32[$3 + 1032 >> 2], HEAP32[$3 + 1028 >> 2], $3 + 1024 | 0, $2) & 1;
      jsvStringIteratorClone($3 + 976 | 0, HEAP32[$3 + 1028 >> 2]);
      $0 = HEAP32[$3 + 1016 >> 2];
      wasm2js_memory_copy($3 + 528 | 0, $2, 88);
      HEAP32[$3 + 968 >> 2] = matchhere($0, $3 + 976 | 0, $3 + 528 | 0);
      jsvStringIteratorFree_1573($3 + 976 | 0);
      if (HEAP32[$3 + 968 >> 2]) {
       jsvUnLock(HEAP32[$3 + 972 >> 2]);
       HEAP32[$3 + 972 >> 2] = HEAP32[$3 + 968 >> 2];
      }
      continue;
     }
     break;
    };
    HEAP32[$3 + 1036 >> 2] = HEAP32[$3 + 972 >> 2];
    break block;
   }
   if (!(!(jsvStringIteratorHasChar_1572(HEAP32[$3 + 1028 >> 2]) & 1) | !(HEAP8[$3 + 1023 | 0] & 1))) {
    jsvStringIteratorNext(HEAP32[$3 + 1028 >> 2]);
    if (!(jspCheckStackPosition() & 1)) {
     HEAP32[$3 + 1036 >> 2] = 0;
     break block;
    }
    $0 = HEAP32[$3 + 1032 >> 2];
    $1 = HEAP32[$3 + 1024 >> 2];
    $4 = HEAP32[$3 + 1028 >> 2];
    wasm2js_memory_copy($3 + 792 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = matchhere($0 + $1 | 0, $4, $3 + 792 | 0);
    break block;
   }
   $0 = HEAP32[$3 + 1032 >> 2];
   $1 = HEAP32[$3 + 1024 >> 2];
   wasm2js_memory_copy($3 + 880 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = nomatchfound($0 + $1 | 0, $3 + 880 | 0);
  }
  __stack_pointer = $3 + 1040 | 0;
  return HEAP32[$3 + 1036 >> 2];
 }
 
 function jswrap_regexp_test($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  if (HEAP32[$2 + 4 >> 2]) {
   $3 = jsvIsNull(HEAP32[$2 + 4 >> 2]) ^ -1
  }
  HEAP8[$2 + 3 | 0] = $3 & 1;
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP8[$2 + 3 | 0] & 1;
 }
 
 function matchfound($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = jsvNewEmptyArray();
  HEAP32[$2 + 20 >> 2] = jsvStringIteratorGetIndex_1580(HEAP32[$2 + 28 >> 2]);
  HEAP32[$2 + 16 >> 2] = jsvNewFromStringVar(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$2 + 20 >> 2] - HEAP32[$1 + 4 >> 2] | 0);
  jsvSetArrayItem(HEAP32[$2 + 24 >> 2], 0, HEAP32[$2 + 16 >> 2]);
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[$1 + 12 >> 2]) {
    HEAP32[$2 + 16 >> 2] = jsvNewFromStringVar(HEAP32[$1 >> 2], HEAP32[($1 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2], HEAP32[($1 + 52 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] - HEAP32[($1 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] | 0);
    jsvSetArrayItem(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2] + 1 | 0, HEAP32[$2 + 16 >> 2]);
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 3847, jsvNewFromInteger(HEAP32[$1 + 4 >> 2]));
  jsvObjectSetChild(HEAP32[$2 + 24 >> 2], 4286, HEAP32[$1 >> 2]);
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 24 >> 2];
 }
 
 function jsvStringIteratorGetIndex_1580($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
 }
 
 function nomatchfound($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 144 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 136 >> 2] = $0;
  block : {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$2 + 140 >> 2] = 0;
    break block;
   }
   while (1) {
    $0 = 0;
    $0 = HEAP8[HEAP32[$2 + 136 >> 2]] << 24 >> 24 ? HEAPU8[HEAP32[$2 + 136 >> 2]] != 124 : $0;
    if ($0) {
     if (HEAPU8[HEAP32[$2 + 136 >> 2]] == 92) {
      HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
      if (!HEAPU8[HEAP32[$2 + 136 >> 2]]) {
       HEAP32[$2 + 140 >> 2] = 0;
       break block;
      }
     }
     HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
     continue;
    }
    break;
   };
   if (HEAPU8[HEAP32[$2 + 136 >> 2]] != 124) {
    HEAP32[$2 + 140 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
   jsvStringIteratorNew($2 + 96 | 0, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
   $0 = HEAP32[$2 + 136 >> 2];
   wasm2js_memory_copy($2 + 4 | 0, $1, 88);
   HEAP32[$2 + 92 >> 2] = matchhere($0, $2 + 96 | 0, $2 + 4 | 0);
   jsvStringIteratorFree_1573($2 + 96 | 0);
   HEAP32[$2 + 140 >> 2] = HEAP32[$2 + 92 >> 2];
  }
  __stack_pointer = $2 + 144 | 0;
  return HEAP32[$2 + 140 >> 2];
 }
 
 function jstOnRunInterruptJSEvent($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP8[441162] = 1;
  HEAP32[103315] = HEAP32[103315] & -129;
  HEAP32[$2 + 20 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 20 >> 2] < HEAPU32[$2 + 24 >> 2]) {
    HEAP8[$2 + 19 | 0] = HEAPU8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 20 >> 2] | 0];
    HEAP32[$2 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 21221);
    if (HEAP32[$2 + 12 >> 2]) {
     HEAP32[$2 + 8 >> 2] = jsvGetArrayItem(HEAP32[$2 + 12 >> 2], HEAPU8[$2 + 19 | 0]);
     if (jsvIsFunction(HEAP32[$2 + 8 >> 2]) & 1) {
      jsvUnLock(jspExecuteFunction(HEAP32[$2 + 8 >> 2], HEAP32[103307], 0, 0));
      jsiCheckErrors(0);
     }
     jsvUnLock2(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
    }
    HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP8[441162] = 0;
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jstRunInterruptingJS() {
  var $0 = 0;
  $0 = __stack_pointer - 80 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = 0;
  if (jshPopIOEventOfType(24, $0 + 16 | 0, $0 + 12 | 0) & 255) {
   jstOnRunInterruptJSEvent($0 + 16 | 0, HEAP32[$0 + 12 >> 2])
  }
  __stack_pointer = $0 + 80 | 0;
 }
 
 function jswrap_timer_list() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jsvNewEmptyArray();
  HEAP32[$0 + 8 >> 2] = 0;
  while (1) {
   if (HEAP32[$0 + 8 >> 2] < 16) {
    HEAP32[$0 + 4 >> 2] = jswrap_timer_get(HEAP32[$0 + 8 >> 2]);
    if (HEAP32[$0 + 4 >> 2]) {
     jsvSetArrayItem(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
     jsvUnLock(HEAP32[$0 + 4 >> 2]);
    }
    HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_timer_get($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  block1 : {
   if (!(HEAP32[$1 + 72 >> 2] < 16 & HEAP32[$1 + 72 >> 2] >= 0)) {
    HEAP32[$1 + 76 >> 2] = 0;
    break block1;
   }
   jshInterruptOff();
   $2 = Math_imul(HEAP32[$1 + 72 >> 2], 25) + 416192 | 0;
   HEAP8[$1 + 64 | 0] = HEAPU8[$2 + 24 | 0];
   $0 = HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24);
   $3 = HEAPU8[$2 + 20 | 0] | HEAPU8[$2 + 21 | 0] << 8 | (HEAPU8[$2 + 22 | 0] << 16 | HEAPU8[$2 + 23 | 0] << 24);
   HEAP32[$1 + 56 >> 2] = $0;
   HEAP32[$1 + 60 >> 2] = $3;
   $0 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | (HEAPU8[$2 + 14 | 0] << 16 | HEAPU8[$2 + 15 | 0] << 24);
   $3 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
   HEAP32[$1 + 48 >> 2] = $3;
   HEAP32[$1 + 52 >> 2] = $0;
   $3 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
   $0 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
   HEAP32[$1 + 40 >> 2] = $0;
   HEAP32[$1 + 44 >> 2] = $3;
   jshInterruptOn();
   if (!HEAPU8[$1 + 64 | 0]) {
    HEAP32[$1 + 76 >> 2] = 0;
    break block1;
   }
   HEAP32[$1 + 36 >> 2] = jsvNewObject();
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 18704, jsvNewFromInteger(HEAP32[$1 + 72 >> 2]));
   HEAP32[$1 + 32 >> 2] = 0;
   block9 : {
    block4 : {
     switch (HEAPU8[$1 + 64 | 0] - 1 | 0) {
     case 0:
      HEAP32[$1 + 32 >> 2] = 21161;
      break block9;
     case 1:
      HEAP32[$1 + 32 >> 2] = 21116;
      jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 17383, jsvNewFromInteger(HEAPU8[$1 + 56 | 0]));
      break block9;
     case 3:
      HEAP32[$1 + 32 >> 2] = 22245;
      break block9;
     case 4:
      HEAP32[$1 + 32 >> 2] = 22249;
      break block9;
     case 5:
      HEAP32[$1 + 32 >> 2] = 22271;
      break block9;
     case 6:
      HEAP32[$1 + 32 >> 2] = 22276;
      break block9;
     case 2:
      break block4;
     default:
      break block9;
     };
    }
    HEAP32[$1 + 32 >> 2] = 21578;
    block10 : {
     if ((HEAPU8[$1 + 48 | 0] | HEAPU8[$1 + 49 | 0] << 8 | (HEAPU8[$1 + 50 | 0] << 16 | HEAPU8[$1 + 51 | 0] << 24)) == 640) {
      HEAP32[$1 + 28 >> 2] = HEAPU8[$1 + 52 | 0] | HEAPU8[$1 + 53 | 0] << 8 | (HEAPU8[$1 + 54 | 0] << 16 | HEAPU8[$1 + 55 | 0] << 24);
      HEAP32[$1 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 21221);
      if (HEAP32[$1 + 24 >> 2]) {
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 15554, jsvGetArrayItem(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 28 >> 2]));
       jsvUnLock(HEAP32[$1 + 24 >> 2]);
      }
      break block10;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 7683, jsvNewFromInteger(HEAPU8[$1 + 48 | 0] | HEAPU8[$1 + 49 | 0] << 8 | (HEAPU8[$1 + 50 | 0] << 16 | HEAPU8[$1 + 51 | 0] << 24)));
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 20535, jsvNewFromInteger(HEAPU8[$1 + 52 | 0] | HEAPU8[$1 + 53 | 0] << 8 | (HEAPU8[$1 + 54 | 0] << 16 | HEAPU8[$1 + 55 | 0] << 24)));
    }
   }
   if (HEAPU8[$1 + 64 | 0] == 2) {
    HEAP32[$1 + 20 >> 2] = jsvNewEmptyArray();
    HEAP32[$1 + 16 >> 2] = 8;
    HEAP32[$1 + 12 >> 2] = 0;
    while (1) {
     if (HEAP32[$1 + 12 >> 2] < HEAP32[$1 + 16 >> 2]) {
      if (HEAPU8[HEAP32[$1 + 12 >> 2] + ($1 + 48 | 0) | 0] != 255) {
       jsvArrayPushAndUnLock(HEAP32[$1 + 20 >> 2], jsvNewFromPin(HEAPU8[HEAP32[$1 + 12 >> 2] + ($1 + 48 | 0) | 0]))
      }
      HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
      continue;
     }
     break;
    };
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 7173, HEAP32[$1 + 20 >> 2]);
   }
   block13 : {
    if (!(HEAPU8[$1 + 64 | 0] == 4 | HEAPU8[$1 + 64 | 0] == 5 | HEAPU8[$1 + 64 | 0] == 6)) {
     if (HEAPU8[$1 + 64 | 0] != 7) {
      break block13
     }
    }
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 8164, jsvLock(HEAPU8[$1 + 52 | 0] | HEAPU8[$1 + 53 | 0] << 8));
    if (HEAPU8[$1 + 54 | 0] | HEAPU8[$1 + 55 | 0] << 8) {
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 22359, jsvLock(HEAPU8[$1 + 54 | 0] | HEAPU8[$1 + 55 | 0] << 8))
    }
   }
   $0 = HEAP32[$1 + 36 >> 2];
   block14 : {
    if (HEAP32[$1 + 32 >> 2]) {
     $2 = jsvNewFromString(HEAP32[$1 + 32 >> 2]);
     break block14;
    }
    $2 = jsvNewFromInteger(HEAPU8[$1 + 64 | 0]);
   }
   jsvObjectSetChildAndUnLock($0, 17778, $2);
   $3 = HEAPU8[$1 + 40 | 0] | HEAPU8[$1 + 41 | 0] << 8 | (HEAPU8[$1 + 42 | 0] << 16 | HEAPU8[$1 + 43 | 0] << 24);
   $0 = $3 >> 31;
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 17804, jsvNewFromFloat(jshGetMillisecondsFromTime($3, $0)));
   if (HEAPU8[$1 + 44 | 0] | HEAPU8[$1 + 45 | 0] << 8 | (HEAPU8[$1 + 46 | 0] << 16 | HEAPU8[$1 + 47 | 0] << 24)) {
    $0 = HEAPU8[$1 + 44 | 0] | HEAPU8[$1 + 45 | 0] << 8 | (HEAPU8[$1 + 46 | 0] << 16 | HEAPU8[$1 + 47 | 0] << 24);
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 15870, jsvNewFromFloat(jshGetMillisecondsFromTime($0, 0)));
   }
   HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 36 >> 2];
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jswrap_timer_queue_interrupt_js($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 8 >> 2] = $0;
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP8[$3 + 3 | 0] = HEAP32[$3 + 4 >> 2];
  if (!(HEAP8[441162] & 1)) {
   jshPushIOCharEvents(24, $3 + 3 | 0, 1);
   HEAP32[103315] = HEAP32[103315] | 128;
   jshHadEvent();
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_timer_add($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 224 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 216 >> 2] = $0;
  HEAPF64[$1 + 208 >> 3] = 0;
  HEAPF64[$1 + 200 >> 3] = 0;
  HEAP32[$1 + 196 >> 2] = 0;
  HEAP32[$1 + 192 >> 2] = 0;
  HEAP32[$1 + 188 >> 2] = 0;
  HEAP32[$1 + 184 >> 2] = 0;
  HEAP32[$1 + 180 >> 2] = 0;
  $2 = HEAPU8[234224] | HEAPU8[234225] << 8 | (HEAPU8[234226] << 16 | HEAPU8[234227] << 24);
  $0 = HEAPU8[234220] | HEAPU8[234221] << 8 | (HEAPU8[234222] << 16 | HEAPU8[234223] << 24);
  HEAP32[$1 + 168 >> 2] = $0;
  HEAP32[$1 + 172 >> 2] = $2;
  HEAP32[$1 + 32 >> 2] = 17778;
  HEAP16[$1 + 36 >> 1] = 29;
  HEAP16[($1 + 32 | 0) + 6 >> 1] = 0;
  HEAP32[$1 + 40 >> 2] = $1 + 196;
  HEAP32[$1 + 44 >> 2] = 17804;
  HEAP16[$1 + 48 >> 1] = 11;
  HEAP16[($1 + 32 | 0) + 18 >> 1] = 0;
  HEAP32[$1 + 52 >> 2] = $1 + 208;
  HEAP32[$1 + 56 >> 2] = 15870;
  HEAP16[$1 + 60 >> 1] = 11;
  HEAP16[($1 + 32 | 0) + 30 >> 1] = 0;
  HEAP32[$1 + 64 >> 2] = $1 + 200;
  HEAP32[$1 + 68 >> 2] = 17383;
  HEAP16[$1 + 72 >> 1] = 10;
  HEAP16[($1 + 32 | 0) + 42 >> 1] = 0;
  HEAP32[$1 + 76 >> 2] = $1 + 188;
  HEAP32[$1 + 80 >> 2] = 15554;
  HEAP16[$1 + 84 >> 1] = 5;
  HEAP16[($1 + 32 | 0) + 54 >> 1] = 0;
  HEAP32[$1 + 88 >> 2] = $1 + 192;
  HEAP32[$1 + 92 >> 2] = 7683;
  HEAP16[$1 + 96 >> 1] = 10;
  HEAP16[($1 + 32 | 0) + 66 >> 1] = 0;
  HEAP32[$1 + 100 >> 2] = $1 + 184;
  HEAP32[$1 + 104 >> 2] = 20535;
  HEAP16[$1 + 108 >> 1] = 10;
  HEAP16[($1 + 32 | 0) + 78 >> 1] = 0;
  HEAP32[$1 + 112 >> 2] = $1 + 180;
  HEAP32[$1 + 116 >> 2] = 15509;
  HEAP16[$1 + 120 >> 1] = 13;
  HEAP16[($1 + 32 | 0) + 90 >> 1] = 0;
  HEAP32[$1 + 124 >> 2] = $1 + 168;
  HEAP32[$1 + 128 >> 2] = 22367;
  HEAP16[$1 + 132 >> 1] = 13;
  HEAP16[($1 + 32 | 0) + 102 >> 1] = 0;
  HEAP32[$1 + 136 >> 2] = $1 + 169;
  HEAP32[$1 + 140 >> 2] = 22337;
  HEAP16[$1 + 144 >> 1] = 13;
  HEAP16[($1 + 32 | 0) + 114 >> 1] = 0;
  HEAP32[$1 + 148 >> 2] = $1 + 170;
  HEAP32[$1 + 152 >> 2] = 22281;
  HEAP16[$1 + 156 >> 1] = 13;
  HEAP16[($1 + 32 | 0) + 126 >> 1] = 0;
  HEAP32[$1 + 160 >> 2] = $1 + 171;
  block : {
   if (!(jsvReadConfigObject(HEAP32[$1 + 216 >> 2], $1 + 32 | 0, 11) & 1)) {
    HEAP32[$1 + 220 >> 2] = -1;
    break block;
   }
   HEAP8[$1 + 31 | 0] = 0;
   block1 : {
    if (jsvIsStringIEqual(HEAP32[$1 + 196 >> 2], 21116) & 1) {
     if (HEAPU8[$1 + 168 | 0] != 255) {
      HEAP8[$1 + 31 | 0] = 2;
      break block1;
     }
     jsExceptionHere(1, 7974, 0);
     break block1;
    }
    block3 : {
     if (jsvIsStringIEqual(HEAP32[$1 + 196 >> 2], 21578) & 1) {
      block2 : {
       if (!HEAP32[$1 + 184 >> 2]) {
        if (!(jsvIsFunction(HEAP32[$1 + 192 >> 2]) & 1)) {
         break block2
        }
       }
       HEAP8[$1 + 31 | 0] = 3;
       break block3;
      }
      jsExceptionHere(1, 8003, 0);
      break block3;
     }
     HEAP32[$1 >> 2] = HEAP32[$1 + 196 >> 2];
     jsExceptionHere(1, 14698, $1);
    }
   }
   jsvUnLock(HEAP32[$1 + 196 >> 2]);
   if (!HEAPU8[$1 + 31 | 0]) {
    jsvUnLock(HEAP32[$1 + 192 >> 2]);
    HEAP32[$1 + 220 >> 2] = -1;
    break block;
   }
   HEAP32[$1 + 24 >> 2] = utilTimerGetUnusedIndex(1);
   if (HEAP32[$1 + 24 >> 2] < 0) {
    HEAP32[$1 + 220 >> 2] = -1;
    break block;
   }
   HEAP32[$1 + 20 >> 2] = Math_imul(HEAP32[$1 + 24 >> 2], 25) + 416192;
   $2 = jshGetTimeFromMilliseconds(HEAPF64[$1 + 208 >> 3]);
   $0 = HEAP32[$1 + 20 >> 2];
   HEAP8[$0 | 0] = $2;
   HEAP8[$0 + 1 | 0] = $2 >>> 8;
   HEAP8[$0 + 2 | 0] = $2 >>> 16;
   HEAP8[$0 + 3 | 0] = $2 >>> 24;
   $0 = jshGetTimeFromMilliseconds(HEAPF64[$1 + 200 >> 3]);
   $2 = HEAP32[$1 + 20 >> 2];
   HEAP8[$2 + 4 | 0] = $0;
   HEAP8[$2 + 5 | 0] = $0 >>> 8;
   HEAP8[$2 + 6 | 0] = $0 >>> 16;
   HEAP8[$2 + 7 | 0] = $0 >>> 24;
   block4 : {
    if (HEAPU8[$1 + 31 | 0] == 2) {
     HEAP32[$1 + 16 >> 2] = 0;
     while (1) {
      if (HEAP32[$1 + 16 >> 2] < 8) {
       HEAP8[HEAP32[$1 + 16 >> 2] + (HEAP32[$1 + 20 >> 2] + 8 | 0) | 0] = HEAPU8[HEAP32[$1 + 16 >> 2] + ($1 + 168 | 0) | 0];
       HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP8[HEAP32[$1 + 20 >> 2] + 16 | 0] = HEAP32[$1 + 188 >> 2];
     break block4;
    }
    if (HEAPU8[$1 + 31 | 0] == 3) {
     if (jsvIsFunction(HEAP32[$1 + 192 >> 2]) & 1) {
      HEAP32[$1 + 12 >> 2] = jsvObjectGetChild(HEAP32[103308], 21221, 3);
      if (HEAP32[$1 + 12 >> 2]) {
       jsvSetArrayItem(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 + 192 >> 2])
      }
      jsvUnLock(HEAP32[$1 + 12 >> 2]);
      HEAP32[$1 + 184 >> 2] = 640;
      HEAP32[$1 + 180 >> 2] = HEAP32[$1 + 24 >> 2];
     }
     $0 = HEAP32[$1 + 20 >> 2];
     $2 = HEAP32[$1 + 184 >> 2];
     HEAP8[$0 + 8 | 0] = $2;
     HEAP8[$0 + 9 | 0] = $2 >>> 8;
     HEAP8[$0 + 10 | 0] = $2 >>> 16;
     HEAP8[$0 + 11 | 0] = $2 >>> 24;
     $0 = HEAP32[$1 + 20 >> 2];
     $2 = HEAP32[$1 + 180 >> 2];
     HEAP8[$0 + 12 | 0] = $2;
     HEAP8[$0 + 13 | 0] = $2 >>> 8;
     HEAP8[$0 + 14 | 0] = $2 >>> 16;
     HEAP8[$0 + 15 | 0] = $2 >>> 24;
    }
   }
   HEAP8[HEAP32[$1 + 20 >> 2] + 24 | 0] = HEAPU8[$1 + 31 | 0];
   jsvUnLock(HEAP32[$1 + 192 >> 2]);
   utilTimerInsertTask(HEAP32[$1 + 24 >> 2] & 255, 0, 0);
   HEAP32[$1 + 220 >> 2] = HEAP32[$1 + 24 >> 2];
  }
  __stack_pointer = $1 + 224 | 0;
  return HEAP32[$1 + 220 >> 2];
 }
 
 function jswrap_timer_remove($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = utilTimerRemoveTask(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jswrap_string_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!jsvGetArrayLength(HEAP32[$1 + 8 >> 2])) {
    HEAP32[$1 + 12 >> 2] = jsvNewFromEmptyString_1590();
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvAsStringAndUnLock(jsvGetArrayItem(HEAP32[$1 + 8 >> 2], 0));
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvNewFromEmptyString_1590() {
  return jsvNewWithFlags(29);
 }
 
 function jswrap_string_fromCharCode($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = jsvNewFromEmptyString_1590();
  block : {
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1592($1 + 16 | 0) & 1) {
     HEAP8[$1 + 15 | 0] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue_1593($1 + 16 | 0));
     jsvAppendStringBuf(HEAP32[$1 + 20 >> 2], $1 + 15 | 0, 1);
     jsvObjectIteratorNext($1 + 16 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1594($1 + 16 | 0);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1592($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1593($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1594($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jswrap_string_charCodeAt($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  block : {
   if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
    HEAP32[$2 + 60 >> 2] = -1;
    break block;
   }
   jsvStringIteratorNewUTF8($2 + 12 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
   HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 12 | 0);
   jsvStringIteratorFree_1596($2 + 12 | 0);
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 8 >> 2];
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jsvStringIteratorFree_1596($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_string_charAt_undefined($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = _jswrap_string_charCodeAt(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
  block : {
   if (HEAP32[$2 + 16 >> 2] < 0) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   if (jsUTF8Bytes(HEAP32[$2 + 16 >> 2]) >>> 0 > 1) {
    HEAP32[$2 + 8 >> 2] = jsUTF8Encode(HEAP32[$2 + 16 >> 2], $2 + 12 | 0);
    HEAP32[$2 + 28 >> 2] = jsvNewUTF8StringAndUnLock(jsvNewStringOfLength(HEAP32[$2 + 8 >> 2], $2 + 12 | 0));
    break block;
   }
   HEAP8[$2 + 7 | 0] = HEAP32[$2 + 16 >> 2];
   HEAP32[$2 + 28 >> 2] = jsvNewStringOfLength(1, $2 + 7 | 0);
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jswrap_string_charAt($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = jswrap_string_charAt_undefined(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
  block : {
   if (HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_1590();
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_string_charCodeAt($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = _jswrap_string_charCodeAt(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
  block : {
   if (HEAP32[$2 >> 2] < 0) {
    HEAP32[$2 + 12 >> 2] = jsvNewFromFloat(NaN);
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_string_indexOf($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 144 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 136 >> 2] = $0;
  HEAP32[$4 + 132 >> 2] = $1;
  HEAP32[$4 + 128 >> 2] = $2;
  HEAP8[$4 + 127 | 0] = $3;
  block : {
   if (!(jsvIsString(HEAP32[$4 + 136 >> 2]) & 1)) {
    HEAP32[$4 + 140 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 132 >> 2] = jsvAsString(HEAP32[$4 + 132 >> 2]);
   if (!HEAP32[$4 + 132 >> 2]) {
    HEAP32[$4 + 140 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 120 >> 2] = jsvGetStringLength(HEAP32[$4 + 136 >> 2]);
   HEAP32[$4 + 116 >> 2] = jsvGetStringLength(HEAP32[$4 + 132 >> 2]);
   if (HEAP32[$4 + 116 >> 2] > HEAP32[$4 + 120 >> 2]) {
    jsvUnLock(HEAP32[$4 + 132 >> 2]);
    HEAP32[$4 + 140 >> 2] = -1;
    break block;
   }
   HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 120 >> 2] - HEAP32[$4 + 116 >> 2];
   HEAP32[$4 + 96 >> 2] = -1;
   if (!(HEAP8[$4 + 127 | 0] & 1)) {
    HEAP32[$4 + 104 >> 2] = 1;
    HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 112 >> 2] + 1;
    HEAP32[$4 + 108 >> 2] = 0;
    if (jsvIsNumeric(HEAP32[$4 + 128 >> 2]) & 1) {
     HEAP32[$4 + 108 >> 2] = jsvGetInteger(HEAP32[$4 + 128 >> 2]);
     if (HEAP32[$4 + 108 >> 2] < 0) {
      HEAP32[$4 + 108 >> 2] = 0
     }
     if (HEAP32[$4 + 108 >> 2] > HEAP32[$4 + 100 >> 2]) {
      HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 100 >> 2]
     }
    }
    jsvStringIteratorNewUTF8($4 + 56 | 0, HEAP32[$4 + 136 >> 2], HEAP32[$4 + 108 >> 2]);
    while (1) {
     if (jsvStringIteratorHasChar_1601($4 + 56 | 0) & 1) {
      jsvStringIteratorClone($4 + 16 | 0, $4 + 56 | 0);
      HEAP32[$4 + 12 >> 2] = jsvCompareStringIt($4 + 16 | 0, HEAP32[$4 + 132 >> 2], 0, 1);
      jsvStringIteratorFree_1596($4 + 16 | 0);
      if (HEAP32[$4 + 12 >> 2]) {
       jsvStringIteratorNextUTF8($4 + 56 | 0);
       HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 108 >> 2] + 1;
       continue;
      } else {
       HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 108 >> 2]
      }
     }
     break;
    };
    jsvStringIteratorFree_1596($4 + 56 | 0);
    jsvUnLock(HEAP32[$4 + 132 >> 2]);
    HEAP32[$4 + 140 >> 2] = HEAP32[$4 + 96 >> 2];
    break block;
   }
   HEAP32[$4 + 104 >> 2] = -1;
   HEAP32[$4 + 100 >> 2] = -1;
   HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 112 >> 2];
   if (jsvIsNumeric(HEAP32[$4 + 128 >> 2]) & 1) {
    HEAP32[$4 + 108 >> 2] = jsvGetInteger(HEAP32[$4 + 128 >> 2]);
    if (HEAP32[$4 + 108 >> 2] < 0) {
     HEAP32[$4 + 108 >> 2] = 0
    }
    if (HEAP32[$4 + 108 >> 2] > HEAP32[$4 + 112 >> 2]) {
     HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 112 >> 2]
    }
   }
   while (1) {
    if (HEAP32[$4 + 108 >> 2] != HEAP32[$4 + 100 >> 2]) {
     if (jsvCompareString(HEAP32[$4 + 136 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 108 >> 2], 0, 1)) {
      HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 104 >> 2] + HEAP32[$4 + 108 >> 2];
      continue;
     } else {
      HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 108 >> 2]
     }
    }
    break;
   };
   jsvUnLock(HEAP32[$4 + 132 >> 2]);
   HEAP32[$4 + 140 >> 2] = HEAP32[$4 + 96 >> 2];
  }
  __stack_pointer = $4 + 144 | 0;
  return HEAP32[$4 + 140 >> 2];
 }
 
 function jsvStringIteratorHasChar_1601($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jswrap_string_match($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  block : {
   if (!(jsvIsString(HEAP32[$2 + 40 >> 2]) & 1)) {
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   if (jsvIsUndefined(HEAP32[$2 + 36 >> 2]) & 1) {
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   if (jsvIsInstanceOf(HEAP32[$2 + 36 >> 2], 14862) & 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 3853, jsvNewFromInteger(0));
    HEAP32[$2 + 32 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
    if (!(jswrap_regexp_hasFlag(HEAP32[$2 + 36 >> 2], 103) & 1)) {
     HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
     break block;
    }
    HEAP32[$2 + 28 >> 2] = jsvNewEmptyArray();
    if (!HEAP32[$2 + 28 >> 2]) {
     HEAP32[$2 + 44 >> 2] = 0;
     break block;
    }
    while (1) {
     $0 = 0;
     if (HEAP32[$2 + 32 >> 2]) {
      $0 = jsvIsNull(HEAP32[$2 + 32 >> 2]) ^ -1
     }
     if ($0 & 1) {
      HEAP32[$2 + 24 >> 2] = jsvGetArrayItem(HEAP32[$2 + 32 >> 2], 0);
      HEAP32[$2 + 20 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 32 >> 2], 3847);
      HEAP32[$2 + 16 >> 2] = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2];
      jsvArrayPushAndUnLock(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
      jsvUnLock(HEAP32[$2 + 32 >> 2]);
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 3853, jsvNewFromInteger(HEAP32[$2 + 12 >> 2] + !HEAP32[$2 + 16 >> 2] | 0));
      HEAP32[$2 + 32 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
      continue;
     }
     break;
    };
    jsvUnLock(HEAP32[$2 + 32 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 3853, jsvNewFromInteger(0));
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 28 >> 2];
    break block;
   }
   HEAP32[$2 + 36 >> 2] = jsvAsString(HEAP32[$2 + 36 >> 2]);
   HEAP32[$2 + 8 >> 2] = jswrap_string_indexOf(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0, 0);
   if (HEAP32[$2 + 8 >> 2] >= 0) {
    HEAP32[$2 + 4 >> 2] = jsvNewEmptyArray();
    if (!HEAP32[$2 + 4 >> 2]) {
     jsvUnLock(HEAP32[$2 + 36 >> 2]);
     HEAP32[$2 + 44 >> 2] = 0;
     break block;
    }
    jsvArrayPush(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 36 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 3847, jsvNewFromInteger(HEAP32[$2 + 8 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 4286, HEAP32[$2 + 36 >> 2]);
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 4 >> 2];
    break block;
   }
   jsvUnLock(HEAP32[$2 + 36 >> 2]);
   HEAP32[$2 + 44 >> 2] = jsvNewNull();
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jsvNewNull() {
  return jsvNewWithFlags(2);
 }
 
 function jswrap_string_replace($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = _jswrap_string_replace(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function _jswrap_string_replace($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 240 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 232 >> 2] = $0;
  HEAP32[$4 + 228 >> 2] = $1;
  HEAP32[$4 + 224 >> 2] = $2;
  HEAP8[$4 + 223 | 0] = $3;
  HEAP32[$4 + 216 >> 2] = jsvAsString(HEAP32[$4 + 232 >> 2]);
  block7 : {
   if (jsvIsInstanceOf(HEAP32[$4 + 228 >> 2], 14862) & 1) {
    block1 : {
     block : {
      if (!(jsvIsFunction(HEAP32[$4 + 224 >> 2]) & 1)) {
       if (!(jsvIsString(HEAP32[$4 + 224 >> 2]) & 1)) {
        break block
       }
      }
      HEAP32[$4 + 212 >> 2] = jsvLockAgain(HEAP32[$4 + 224 >> 2]);
      break block1;
     }
     HEAP32[$4 + 212 >> 2] = jsvAsString(HEAP32[$4 + 224 >> 2]);
    }
    jsvObjectSetChildAndUnLock(HEAP32[$4 + 228 >> 2], 3853, jsvNewFromInteger(0));
    HEAP8[$4 + 211 | 0] = jswrap_regexp_hasFlag(HEAP32[$4 + 228 >> 2], 103) & 1;
    if (HEAP8[$4 + 223 | 0] & 1) {
     HEAP8[$4 + 211 | 0] = 1
    }
    HEAP32[$4 + 204 >> 2] = jsvNewFromEmptyString_1590();
    jsvStringIteratorNew($4 + 164 | 0, HEAP32[$4 + 204 >> 2], 0);
    HEAP32[$4 + 160 >> 2] = 0;
    HEAP32[$4 + 156 >> 2] = jswrap_regexp_exec(HEAP32[$4 + 228 >> 2], HEAP32[$4 + 216 >> 2]);
    while (1) {
     $0 = 0;
     block2 : {
      if (!HEAP32[$4 + 156 >> 2]) {
       break block2
      }
      $0 = 0;
      if (jsvIsNull(HEAP32[$4 + 156 >> 2]) & 1) {
       break block2
      }
      $0 = jspIsInterrupted() ^ -1;
     }
     if ($0 & 1) {
      HEAP32[$4 + 152 >> 2] = jsvGetArrayItem(HEAP32[$4 + 156 >> 2], 0);
      HEAP32[$4 + 148 >> 2] = jsvObjectGetIntegerChild(HEAP32[$4 + 156 >> 2], 3847);
      HEAP32[$4 + 144 >> 2] = jsvGetStringLength(HEAP32[$4 + 152 >> 2]);
      jsvStringIteratorAppendString($4 + 164 | 0, HEAP32[$4 + 216 >> 2], HEAP32[$4 + 160 >> 2], HEAP32[$4 + 148 >> 2] - HEAP32[$4 + 160 >> 2] | 0);
      block3 : {
       if (jsvIsFunction(HEAP32[$4 + 212 >> 2]) & 1) {
        HEAP32[$4 + 140 >> 2] = 0;
        $1 = jsvLockAgain(HEAP32[$4 + 152 >> 2]);
        $0 = HEAP32[$4 + 140 >> 2];
        HEAP32[$4 + 140 >> 2] = $0 + 1;
        HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
        while (1) {
         $1 = jsvGetArrayItem(HEAP32[$4 + 156 >> 2], HEAP32[$4 + 140 >> 2]);
         HEAP32[$4 + 76 >> 2] = $1;
         $0 = 0;
         $0 = $1 ? HEAPU32[$4 + 140 >> 2] < 11 : $0;
         if ($0) {
          $1 = HEAP32[$4 + 76 >> 2];
          $0 = HEAP32[$4 + 140 >> 2];
          HEAP32[$4 + 140 >> 2] = $0 + 1;
          HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
          continue;
         }
         break;
        };
        $1 = jsvObjectGetChildIfExists(HEAP32[$4 + 156 >> 2], 3847);
        $0 = HEAP32[$4 + 140 >> 2];
        HEAP32[$4 + 140 >> 2] = $0 + 1;
        HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
        $1 = jsvObjectGetChildIfExists(HEAP32[$4 + 156 >> 2], 4286);
        $0 = HEAP32[$4 + 140 >> 2];
        HEAP32[$4 + 140 >> 2] = $0 + 1;
        HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
        HEAP32[$4 + 72 >> 2] = jsvAsStringAndUnLock(jspeFunctionCall(HEAP32[$4 + 212 >> 2], 0, 0, 0, HEAP32[$4 + 140 >> 2], $4 + 80 | 0));
        jsvUnLockMany(HEAP32[$4 + 140 >> 2], $4 + 80 | 0);
        jsvStringIteratorAppendString($4 + 164 | 0, HEAP32[$4 + 72 >> 2], 0, 2147483647);
        jsvUnLock(HEAP32[$4 + 72 >> 2]);
        break block3;
       }
       jsvStringIteratorNew($4 + 32 | 0, HEAP32[$4 + 212 >> 2], 0);
       while (1) {
        if (jsvStringIteratorHasChar_1601($4 + 32 | 0) & 1) {
         HEAP8[$4 + 31 | 0] = jsvStringIteratorGetCharAndNext($4 + 32 | 0);
         block6 : {
          if (HEAPU8[$4 + 31 | 0] == 36) {
           HEAP8[$4 + 31 | 0] = jsvStringIteratorGetCharAndNext($4 + 32 | 0);
           HEAP32[$4 + 24 >> 2] = 0;
           if (!(HEAP8[$4 + 31 | 0] << 24 >> 24 <= 48 | HEAP8[$4 + 31 | 0] << 24 >> 24 > 57)) {
            HEAP32[$4 + 24 >> 2] = jsvGetArrayItem(HEAP32[$4 + 156 >> 2], (HEAP8[$4 + 31 | 0] << 24 >> 24) - 48 | 0)
           }
           block5 : {
            if (HEAP32[$4 + 24 >> 2]) {
             jsvStringIteratorAppendString($4 + 164 | 0, HEAP32[$4 + 24 >> 2], 0, 2147483647);
             jsvUnLock(HEAP32[$4 + 24 >> 2]);
             break block5;
            }
            jsvStringIteratorAppend($4 + 164 | 0, 36);
            jsvStringIteratorAppend($4 + 164 | 0, HEAP8[$4 + 31 | 0] << 24 >> 24);
           }
           break block6;
          }
          jsvStringIteratorAppend($4 + 164 | 0, HEAP8[$4 + 31 | 0] << 24 >> 24);
         }
         continue;
        }
        break;
       };
       jsvStringIteratorFree_1596($4 + 32 | 0);
      }
      HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 148 >> 2] + HEAP32[$4 + 144 >> 2];
      jsvUnLock(HEAP32[$4 + 152 >> 2]);
      jsvUnLock(HEAP32[$4 + 156 >> 2]);
      HEAP32[$4 + 156 >> 2] = 0;
      if (HEAP8[$4 + 211 | 0] & 1) {
       jsvObjectSetChildAndUnLock(HEAP32[$4 + 228 >> 2], 3853, jsvNewFromInteger(HEAP32[$4 + 160 >> 2] + !HEAP32[$4 + 144 >> 2] | 0));
       HEAP32[$4 + 156 >> 2] = jswrap_regexp_exec(HEAP32[$4 + 228 >> 2], HEAP32[$4 + 216 >> 2]);
      }
      continue;
     }
     break;
    };
    jsvStringIteratorAppendString($4 + 164 | 0, HEAP32[$4 + 216 >> 2], HEAP32[$4 + 160 >> 2], 2147483647);
    jsvStringIteratorFree_1596($4 + 164 | 0);
    jsvUnLock3(HEAP32[$4 + 156 >> 2], HEAP32[$4 + 212 >> 2], HEAP32[$4 + 216 >> 2]);
    if (HEAP8[$4 + 211 | 0] & 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$4 + 228 >> 2], 3853, jsvNewFromInteger(0))
    }
    HEAP32[$4 + 236 >> 2] = HEAP32[$4 + 204 >> 2];
    break block7;
   }
   HEAP32[$4 + 224 >> 2] = jsvAsString(HEAP32[$4 + 224 >> 2]);
   HEAP32[$4 + 228 >> 2] = jsvAsString(HEAP32[$4 + 228 >> 2]);
   HEAP32[$4 + 20 >> 2] = jswrap_string_indexOf(HEAP32[$4 + 216 >> 2], HEAP32[$4 + 228 >> 2], 0, 0);
   while (1) {
    $0 = 0;
    if (HEAP32[$4 + 20 >> 2] >= 0) {
     $0 = jspIsInterrupted() ^ -1
    }
    if ($0 & 1) {
     HEAP32[$4 + 16 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$4 + 216 >> 2], 0, HEAP32[$4 + 20 >> 2]);
     jsvAppendStringVarComplete(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 224 >> 2]);
     jsvAppendStringVar(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 216 >> 2], HEAP32[$4 + 20 >> 2] + jsvGetStringLength(HEAP32[$4 + 228 >> 2]) | 0, 2147483647);
     jsvUnLock(HEAP32[$4 + 216 >> 2]);
     HEAP32[$4 + 216 >> 2] = HEAP32[$4 + 16 >> 2];
     block8 : {
      if (HEAP8[$4 + 223 | 0] & 1) {
       HEAP32[$4 + 12 >> 2] = jsvNewFromInteger(HEAP32[$4 + 20 >> 2] + jsvGetStringLength(HEAP32[$4 + 224 >> 2]) | 0);
       HEAP32[$4 + 20 >> 2] = jswrap_string_indexOf(HEAP32[$4 + 216 >> 2], HEAP32[$4 + 228 >> 2], HEAP32[$4 + 12 >> 2], 0);
       jsvUnLock(HEAP32[$4 + 12 >> 2]);
       break block8;
      }
      HEAP32[$4 + 20 >> 2] = -1;
     }
     continue;
    }
    break;
   };
   jsvUnLock2(HEAP32[$4 + 228 >> 2], HEAP32[$4 + 224 >> 2]);
   HEAP32[$4 + 236 >> 2] = HEAP32[$4 + 216 >> 2];
  }
  __stack_pointer = $4 + 240 | 0;
  return HEAP32[$4 + 236 >> 2];
 }
 
 function jswrap_string_replaceAll($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = _jswrap_string_replace(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_string_substring($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  if (jsvIsUndefined(HEAP32[$3 + 20 >> 2]) & 1) {
   $0 = 2147483647
  } else {
   $0 = jsvGetInteger(HEAP32[$3 + 20 >> 2])
  }
  HEAP32[$3 + 16 >> 2] = $0;
  if (HEAP32[$3 + 24 >> 2] < 0) {
   HEAP32[$3 + 24 >> 2] = 0
  }
  if (HEAP32[$3 + 16 >> 2] < 0) {
   HEAP32[$3 + 16 >> 2] = 0
  }
  if (HEAP32[$3 + 16 >> 2] < HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 12 >> 2];
  }
  $0 = jsvNewFromStringVar(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 24 >> 2] | 0);
  __stack_pointer = $3 + 32 | 0;
  return $0 | 0;
 }
 
 function jswrap_string_substr($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  if (jsvIsUndefined(HEAP32[$3 + 4 >> 2]) & 1) {
   $0 = 2147483647
  } else {
   $0 = jsvGetInteger(HEAP32[$3 + 4 >> 2])
  }
  HEAP32[$3 >> 2] = $0;
  if (HEAP32[$3 >> 2] < 0) {
   HEAP32[$3 >> 2] = 0
  }
  if (HEAP32[$3 + 8 >> 2] < 0) {
   HEAP32[$3 + 8 >> 2] = jsvGetStringLength(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 8 >> 2]
  }
  if (HEAP32[$3 + 8 >> 2] < 0) {
   HEAP32[$3 + 8 >> 2] = 0
  }
  $0 = jsvNewFromStringVar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 >> 2]);
  __stack_pointer = $3 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_string_slice($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  if (jsvIsUndefined(HEAP32[$3 + 16 >> 2]) & 1) {
   $0 = 2147483647
  } else {
   $0 = jsvGetInteger(HEAP32[$3 + 16 >> 2])
  }
  HEAP32[$3 + 12 >> 2] = $0;
  if (HEAP32[$3 + 20 >> 2] < 0) {
   HEAP32[$3 + 20 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 20 >> 2]
  }
  if (HEAP32[$3 + 12 >> 2] < 0) {
   HEAP32[$3 + 12 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 12 >> 2]
  }
  if (HEAP32[$3 + 20 >> 2] < 0) {
   HEAP32[$3 + 20 >> 2] = 0
  }
  if (HEAP32[$3 + 12 >> 2] < 0) {
   HEAP32[$3 + 12 >> 2] = 0
  }
  block : {
   if (HEAP32[$3 + 12 >> 2] <= HEAP32[$3 + 20 >> 2]) {
    HEAP32[$3 + 28 >> 2] = jsvNewFromEmptyString_1590();
    break block;
   }
   HEAP32[$3 + 28 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2] - HEAP32[$3 + 20 >> 2] | 0);
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jswrap_string_split($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 56 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  block : {
   if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
    HEAP32[$2 + 60 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 48 >> 2] = jsvNewEmptyArray();
   if (!HEAP32[$2 + 48 >> 2]) {
    HEAP32[$2 + 60 >> 2] = 0;
    break block;
   }
   if (jsvIsUndefined(HEAP32[$2 + 52 >> 2]) & 1) {
    jsvArrayPush(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 56 >> 2]);
    HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
    break block;
   }
   if (jsvIsInstanceOf(HEAP32[$2 + 52 >> 2], 14862) & 1) {
    HEAP32[$2 + 44 >> 2] = 0;
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 3853, jsvNewFromInteger(0));
    HEAP32[$2 + 40 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 56 >> 2]);
    while (1) {
     $0 = 0;
     if (HEAP32[$2 + 40 >> 2]) {
      $0 = jsvIsNull(HEAP32[$2 + 40 >> 2]) ^ -1
     }
     if ($0 & 1) {
      HEAP32[$2 + 36 >> 2] = jsvGetArrayItem(HEAP32[$2 + 40 >> 2], 0);
      HEAP32[$2 + 32 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 40 >> 2], 3847);
      HEAP32[$2 + 28 >> 2] = jsvGetStringLength(HEAP32[$2 + 36 >> 2]);
      jsvUnLock(HEAP32[$2 + 36 >> 2]);
      jsvArrayPushAndUnLock(HEAP32[$2 + 48 >> 2], jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 44 >> 2], HEAP32[$2 + 32 >> 2] - HEAP32[$2 + 44 >> 2] | 0));
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2] + HEAP32[$2 + 28 >> 2];
      jsvUnLock(HEAP32[$2 + 40 >> 2]);
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 3853, jsvNewFromInteger(HEAP32[$2 + 44 >> 2]));
      HEAP32[$2 + 40 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 56 >> 2]);
      continue;
     }
     break;
    };
    jsvUnLock(HEAP32[$2 + 40 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 3853, jsvNewFromInteger(0));
    if (HEAP32[$2 + 44 >> 2] <= (jsvGetStringLength(HEAP32[$2 + 56 >> 2]) | 0)) {
     jsvArrayPushAndUnLock(HEAP32[$2 + 48 >> 2], jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 44 >> 2], 2147483647))
    }
    HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
    break block;
   }
   HEAP32[$2 + 52 >> 2] = jsvAsString(HEAP32[$2 + 52 >> 2]);
   HEAP32[$2 + 20 >> 2] = 0;
   if (jsvIsUndefined(HEAP32[$2 + 52 >> 2]) & 1) {
    $0 = 0
   } else {
    $0 = jsvGetStringLength(HEAP32[$2 + 52 >> 2])
   }
   HEAP32[$2 + 16 >> 2] = $0;
   HEAP32[$2 + 12 >> 2] = (jsvGetStringLength(HEAP32[$2 + 56 >> 2]) + 1 | 0) - HEAP32[$2 + 16 >> 2];
   HEAP32[$2 + 24 >> 2] = 0;
   while (1) {
    block1 : {
     if (HEAP32[$2 + 24 >> 2] > HEAP32[$2 + 12 >> 2]) {
      break block1
     }
     if (HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 24 >> 2]) {
      block5 : {
       if (!(!HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 24 >> 2] == HEAP32[$2 + 12 >> 2])) {
        if (jsvCompareString(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], HEAP32[$2 + 24 >> 2], 0, 1)) {
         break block5
        }
       }
       if (HEAP32[$2 + 24 >> 2] == HEAP32[$2 + 12 >> 2]) {
        HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 16 >> 2];
        if (!HEAP32[$2 + 16 >> 2]) {
         break block1
        }
       }
       HEAP32[$2 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], jsvConvertFromUTF8Index(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 20 >> 2]), jsvConvertFromUTF8Index(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 24 >> 2]) - jsvConvertFromUTF8Index(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 20 >> 2]) | 0);
       if (!HEAP32[$2 + 8 >> 2]) {
        break block1
       }
       jsvArrayPush(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 8 >> 2]);
       jsvUnLock(HEAP32[$2 + 8 >> 2]);
       HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2] + HEAP32[$2 + 16 >> 2];
      }
     }
     HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] + 1;
     continue;
    }
    break;
   };
   jsvUnLock(HEAP32[$2 + 52 >> 2]);
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
  }
  __stack_pointer = $2 - -64 | 0;
  return HEAP32[$2 + 60 >> 2];
 }
 
 function jswrap_string_toUpperLowerCase($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $0;
  HEAP8[$2 + 103 | 0] = $1;
  HEAP32[$2 + 96 >> 2] = jsvNewFromEmptyString_1590();
  block : {
   if (!HEAP32[$2 + 96 >> 2]) {
    HEAP32[$2 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 92 >> 2] = jsvAsString(HEAP32[$2 + 104 >> 2]);
   jsvStringIteratorNew($2 + 52 | 0, HEAP32[$2 + 92 >> 2], 0);
   jsvStringIteratorNew($2 + 12 | 0, HEAP32[$2 + 96 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1601($2 + 52 | 0) & 1) {
     HEAP8[$2 + 11 | 0] = jsvStringIteratorGetCharAndNext($2 + 52 | 0);
     block1 : {
      if (HEAP8[$2 + 103 | 0] & 1) {
       $0 = charToUpperCase(HEAP8[$2 + 11 | 0] << 24 >> 24) << 24 >> 24;
       break block1;
      }
      $0 = charToLowerCase(HEAP8[$2 + 11 | 0] << 24 >> 24) << 24 >> 24;
     }
     HEAP8[$2 + 11 | 0] = $0;
     jsvStringIteratorAppend($2 + 12 | 0, HEAP8[$2 + 11 | 0] << 24 >> 24);
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1596($2 + 52 | 0);
   jsvStringIteratorFree_1596($2 + 12 | 0);
   jsvUnLock(HEAP32[$2 + 92 >> 2]);
   HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 96 >> 2];
  }
  __stack_pointer = $2 + 112 | 0;
  return HEAP32[$2 + 108 >> 2];
 }
 
 function jswrap_string_removeAccents($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 112 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 104 >> 2] = $0;
  HEAP32[$1 + 96 >> 2] = jsvNewFromEmptyString_1590();
  block : {
   if (!HEAP32[$1 + 96 >> 2]) {
    HEAP32[$1 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 92 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
   jsvStringIteratorNew($1 + 52 | 0, HEAP32[$1 + 92 >> 2], 0);
   jsvStringIteratorNew($1 + 12 | 0, HEAP32[$1 + 96 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1601($1 + 52 | 0) & 1) {
     HEAP8[$1 + 11 | 0] = jsvStringIteratorGetCharAndNext($1 + 52 | 0);
     block1 : {
      if (HEAPU8[$1 + 11 | 0] >= 224) {
       HEAP8[$1 + 103 | 0] = 1;
       HEAP8[$1 + 11 | 0] = HEAPU8[$1 + 11 | 0] - 32;
       break block1;
      }
      HEAP8[$1 + 103 | 0] = 0;
     }
     if (HEAPU8[$1 + 11 | 0] >= 192) {
      block10 : {
       block14 : {
        switch (HEAPU8[$1 + 11 | 0] - 192 | 0) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
         HEAP8[$1 + 11 | 0] = 65;
         break block10;
        case 6:
         jsvStringIteratorAppend($1 + 12 | 0, HEAP8[$1 + 103 | 0] & 1 ? 97 : 65);
         HEAP8[$1 + 11 | 0] = 69;
         break block10;
        case 7:
         HEAP8[$1 + 11 | 0] = 67;
         break block10;
        case 8:
        case 9:
        case 10:
        case 11:
         HEAP8[$1 + 11 | 0] = 69;
         break block10;
        case 12:
        case 13:
        case 14:
        case 15:
         HEAP8[$1 + 11 | 0] = 73;
         break block10;
        case 16:
         HEAP8[$1 + 11 | 0] = 68;
         break block10;
        case 17:
         HEAP8[$1 + 11 | 0] = 78;
         break block10;
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 24:
         HEAP8[$1 + 11 | 0] = 79;
         break block10;
        case 25:
        case 26:
        case 27:
        case 28:
         HEAP8[$1 + 11 | 0] = 85;
         break block10;
        case 29:
         HEAP8[$1 + 11 | 0] = 89;
         break block10;
        case 30:
         HEAP8[$1 + 11 | 0] = 80;
         break block10;
        case 31:
         break block14;
        default:
         break block10;
        };
       }
       block15 : {
        if (HEAP8[$1 + 103 | 0] & 1) {
         HEAP8[$1 + 11 | 0] = 89;
         break block15;
        }
        jsvStringIteratorAppend($1 + 12 | 0, 83);
        HEAP8[$1 + 11 | 0] = 83;
       }
      }
     }
     $2 = $1 + 12 | 0;
     if (HEAP8[$1 + 103 | 0] & 1) {
      $0 = HEAPU8[$1 + 11 | 0] + 32 | 0
     } else {
      $0 = HEAP8[$1 + 11 | 0]
     }
     jsvStringIteratorAppend($2, $0 << 24 >> 24);
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1596($1 + 52 | 0);
   jsvStringIteratorFree_1596($1 + 12 | 0);
   jsvUnLock(HEAP32[$1 + 92 >> 2]);
   HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
  }
  __stack_pointer = $1 + 112 | 0;
  return HEAP32[$1 + 108 >> 2];
 }
 
 function jswrap_string_trim($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  HEAP32[$1 + 68 >> 2] = jsvAsString(HEAP32[$1 + 72 >> 2]);
  block : {
   if (!HEAP32[$1 + 68 >> 2]) {
    HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 68 >> 2];
    break block;
   }
   HEAP32[$1 + 64 >> 2] = 0;
   HEAP32[$1 + 60 >> 2] = -1;
   jsvStringIteratorNew($1 + 20 | 0, HEAP32[$1 + 68 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1601($1 + 20 | 0) & 1) {
     HEAP32[$1 + 16 >> 2] = jsvStringIteratorGetIndex_1614($1 + 20 | 0);
     HEAP8[$1 + 15 | 0] = isWhitespace(jsvStringIteratorGetCharAndNext($1 + 20 | 0) << 24 >> 24) & 1;
     if (!(HEAP8[$1 + 15 | 0] & 1)) {
      if (HEAP32[$1 + 60 >> 2] < 0) {
       HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 16 >> 2]
      }
      HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 16 >> 2];
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1596($1 + 20 | 0);
   HEAP32[$1 + 8 >> 2] = 0;
   if (HEAP32[$1 + 60 >> 2] >= HEAP32[$1 + 64 >> 2]) {
    HEAP32[$1 + 8 >> 2] = (HEAP32[$1 + 60 >> 2] + 1 | 0) - HEAP32[$1 + 64 >> 2]
   }
   HEAP32[$1 + 4 >> 2] = jsvNewFromStringVar(HEAP32[$1 + 68 >> 2], HEAP32[$1 + 64 >> 2], HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 68 >> 2]);
   HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jsvStringIteratorGetIndex_1614($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
 }
 
 function jswrap_string_concat($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (!(jsvIsString(HEAP32[$2 + 24 >> 2]) & 1)) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 16 >> 2] = jsvNewFromStringVarComplete(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 12 >> 2] = jsvArrayJoin(HEAP32[$2 + 20 >> 2], 0, 0);
   jsvAppendStringVarComplete(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jswrap_string_startsWith($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block : {
   if (!(jsvIsString(HEAP32[$3 + 24 >> 2]) & 1)) {
    HEAP8[$3 + 31 | 0] = 0;
    break block;
   }
   HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 20 >> 2]);
   HEAP8[$3 + 11 | 0] = 0;
   block1 : {
    if (HEAP32[$3 + 16 >> 2] < 0) {
     break block1
    }
    if ((jsvGetStringLength(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 16 >> 2] | 0) > (jsvGetStringLength(HEAP32[$3 + 24 >> 2]) | 0)) {
     break block1
    }
    HEAP8[$3 + 11 | 0] = !jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2], 0, 1);
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP8[$3 + 31 | 0] = HEAP8[$3 + 11 | 0] & 1;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 31 | 0] & 1;
 }
 
 function jswrap_string_endsWith($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block : {
   if (!(jsvIsString(HEAP32[$3 + 24 >> 2]) & 1)) {
    HEAP8[$3 + 31 | 0] = 0;
    break block;
   }
   block1 : {
    if (jsvIsNumeric(HEAP32[$3 + 16 >> 2]) & 1) {
     $0 = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
     break block1;
    }
    $0 = jsvGetStringLength(HEAP32[$3 + 24 >> 2]);
   }
   HEAP32[$3 + 12 >> 2] = $0;
   HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 20 >> 2]);
   $0 = jsvGetStringLength(HEAP32[$3 + 8 >> 2]);
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] - $0;
   HEAP8[$3 + 7 | 0] = 0;
   block2 : {
    if (HEAP32[$3 + 12 >> 2] < 0) {
     break block2
    }
    if ((jsvGetStringLength(HEAP32[$3 + 8 >> 2]) + HEAP32[$3 + 12 >> 2] | 0) > (jsvGetStringLength(HEAP32[$3 + 24 >> 2]) | 0)) {
     break block2
    }
    HEAP8[$3 + 7 | 0] = !jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2], 0, 1);
   }
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
   HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 31 | 0] & 1;
 }
 
 function jswrap_string_repeat($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 4 >> 2] < 0) {
    jsExceptionHere(1, 17327, 0);
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$2 >> 2] = jsvNewFromEmptyString_1590();
   while (1) {
    $0 = HEAP32[$2 + 4 >> 2];
    HEAP32[$2 + 4 >> 2] = $0 - 1;
    $1 = 0;
    if ($0) {
     $1 = jspIsInterrupted() ^ -1
    }
    if ($1 & 1) {
     jsvAppendStringVarComplete(HEAP32[$2 >> 2], HEAP32[$2 + 8 >> 2]);
     continue;
    }
    break;
   };
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_string_padX($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP8[$4 + 15 | 0] = $3;
  block1 : {
   block : {
    if (jsvIsString(HEAP32[$4 + 24 >> 2]) & 1) {
     if ((jsvGetStringLength(HEAP32[$4 + 24 >> 2]) | 0) < HEAP32[$4 + 20 >> 2]) {
      break block
     }
    }
    HEAP32[$4 + 28 >> 2] = jsvLockAgain(HEAP32[$4 + 24 >> 2]);
    break block1;
   }
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 20 >> 2] - jsvGetStringLength(HEAP32[$4 + 24 >> 2]);
   block2 : {
    if (HEAP8[$4 + 15 | 0] & 1) {
     $0 = jsvNewFromEmptyString_1590();
     break block2;
    }
    $0 = jsvNewFromStringVarComplete(HEAP32[$4 + 24 >> 2]);
   }
   HEAP32[$4 + 4 >> 2] = $0;
   if (!HEAP32[$4 + 4 >> 2]) {
    HEAP32[$4 + 28 >> 2] = 0;
    break block1;
   }
   block3 : {
    if (HEAP32[$4 + 16 >> 2]) {
     $0 = jsvAsString(HEAP32[$4 + 16 >> 2]);
     break block3;
    }
    $0 = jsvNewFromString(27706);
   }
   HEAP32[$4 + 16 >> 2] = $0;
   HEAP32[$4 >> 2] = jsvGetStringLength(HEAP32[$4 + 16 >> 2]);
   while (1) {
    if (HEAP32[$4 + 8 >> 2] > 0) {
     $1 = HEAP32[$4 + 4 >> 2];
     $2 = HEAP32[$4 + 16 >> 2];
     if (HEAP32[$4 >> 2] > HEAP32[$4 + 8 >> 2]) {
      $0 = HEAP32[$4 + 8 >> 2]
     } else {
      $0 = HEAP32[$4 >> 2]
     }
     jsvAppendStringVar($1, $2, 0, $0);
     HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2];
     continue;
    }
    break;
   };
   if (HEAP8[$4 + 15 | 0] & 1) {
    jsvAppendStringVarComplete(HEAP32[$4 + 4 >> 2], HEAP32[$4 + 24 >> 2])
   }
   jsvUnLock(HEAP32[$4 + 16 >> 2]);
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2];
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 28 >> 2];
 }
 
 function jswrap_require($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 256 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 248 >> 2] = $0;
  block : {
   if (!(jsvIsString(HEAP32[$1 + 248 >> 2]) & 1)) {
    HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 248 >> 2];
    jsExceptionHere(3, 5980, $1 + 48 | 0);
    HEAP32[$1 + 252 >> 2] = 0;
    break block;
   }
   if (jsvGetString(HEAP32[$1 + 248 >> 2], $1 + 112 | 0, 128) >>> 0 >= 128) {
    jsExceptionHere(3, 24627, 0);
    HEAP32[$1 + 252 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 108 >> 2] = jswrap_modules_getModuleList();
   if (!HEAP32[$1 + 108 >> 2]) {
    HEAP32[$1 + 252 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 104 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$1 + 108 >> 2], $1 + 112 | 0));
   jsvUnLock(HEAP32[$1 + 108 >> 2]);
   if (HEAP32[$1 + 104 >> 2]) {
    HEAP32[$1 + 252 >> 2] = HEAP32[$1 + 104 >> 2];
    break block;
   }
   HEAP32[$1 + 100 >> 2] = jswGetBuiltInLibrary($1 + 112 | 0);
   if (HEAP32[$1 + 100 >> 2]) {
    HEAP32[$1 + 104 >> 2] = jsvNewNativeFunction(HEAP32[$1 + 100 >> 2], 0)
   }
   block1 : {
    if (HEAP32[$1 + 104 >> 2]) {
     break block1
    }
    if (strlen($1 + 112 | 0) >>> 0 > 28) {
     break block1
    }
    jsfNameFromString($1 + 72 | 0, $1 + 112 | 0);
    HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 96 >> 2];
    $2 = HEAP32[$1 + 92 >> 2];
    $0 = HEAP32[$1 + 88 >> 2];
    HEAP32[$1 + 32 >> 2] = $0;
    HEAP32[$1 + 36 >> 2] = $2;
    $0 = HEAP32[$1 + 84 >> 2];
    $2 = HEAP32[$1 + 80 >> 2];
    HEAP32[$1 + 24 >> 2] = $2;
    HEAP32[$1 + 28 >> 2] = $0;
    $2 = HEAP32[$1 + 76 >> 2];
    $0 = HEAP32[$1 + 72 >> 2];
    HEAP32[$1 + 16 >> 2] = $0;
    HEAP32[$1 + 20 >> 2] = $2;
    HEAP32[$1 + 68 >> 2] = jsfReadFile($1 + 16 | 0, 0, 0);
    if (HEAP32[$1 + 68 >> 2]) {
     HEAP32[$1 + 104 >> 2] = jspEvaluateModule(HEAP32[$1 + 68 >> 2]);
     jsvUnLock(HEAP32[$1 + 68 >> 2]);
    }
   }
   if (!HEAP32[$1 + 104 >> 2]) {
    HEAP32[$1 + 64 >> 2] = jswGetBuiltInJSLibrary($1 + 112 | 0);
    if (HEAP32[$1 + 64 >> 2]) {
     HEAP32[$1 + 60 >> 2] = jsvNewNativeString(HEAP32[$1 + 64 >> 2], strlen(HEAP32[$1 + 64 >> 2]));
     if (HEAP32[$1 + 60 >> 2]) {
      HEAP32[$1 + 104 >> 2] = jspEvaluateModule(HEAP32[$1 + 60 >> 2]);
      jsvUnLock(HEAP32[$1 + 60 >> 2]);
     }
    }
   }
   block2 : {
    if (HEAP32[$1 + 104 >> 2]) {
     HEAP32[$1 + 56 >> 2] = jswrap_modules_getModuleList();
     if (HEAP32[$1 + 56 >> 2]) {
      jsvObjectSetChild(HEAP32[$1 + 56 >> 2], $1 + 112 | 0, HEAP32[$1 + 104 >> 2])
     }
     jsvUnLock(HEAP32[$1 + 56 >> 2]);
     break block2;
    }
    HEAP32[$1 >> 2] = HEAP32[$1 + 248 >> 2];
    jsExceptionHere(1, 18664, $1);
   }
   HEAP32[$1 + 252 >> 2] = HEAP32[$1 + 104 >> 2];
  }
  __stack_pointer = $1 + 256 | 0;
  return HEAP32[$1 + 252 >> 2];
 }
 
 function jswrap_modules_getModuleList() {
  return jsvObjectGetChild(HEAP32[103308], 7293, 5);
 }
 
 function jswrap_modules_getCached() {
  var $0 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 24 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$0 + 24 >> 2]) {
    HEAP32[$0 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 20 >> 2] = jswrap_modules_getModuleList();
   if (!HEAP32[$0 + 20 >> 2]) {
    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
    break block;
   }
   jsvObjectIteratorNew($0 + 16 | 0, HEAP32[$0 + 20 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1623($0 + 16 | 0) & 1) {
     HEAP32[$0 + 12 >> 2] = jsvObjectIteratorGetKey_1624($0 + 16 | 0);
     HEAP32[$0 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$0 + 12 >> 2], 0, 0);
     jsvArrayPushAndUnLock(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 8 >> 2]);
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
     jsvObjectIteratorNext($0 + 16 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1625($0 + 16 | 0);
   jsvUnLock(HEAP32[$0 + 20 >> 2]);
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
  }
  __stack_pointer = $0 + 32 | 0;
  return HEAP32[$0 + 28 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1623($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetKey_1624($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1625($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_modules_removeCached($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!(jsvIsString(HEAP32[$1 + 12 >> 2]) & 1)) {
    jsExceptionHere(1, 16768, 0);
    break block;
   }
   HEAP32[$1 + 8 >> 2] = jswrap_modules_getModuleList();
   if (!HEAP32[$1 + 8 >> 2]) {
    break block
   }
   HEAP32[$1 + 4 >> 2] = jsvFindChildFromVar(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 0);
   block1 : {
    if (!HEAP32[$1 + 4 >> 2]) {
     HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
     jsExceptionHere(1, 18664, $1);
     break block1;
    }
    jsvRemoveChildAndUnLock(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_modules_removeAllCached() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jswrap_modules_getModuleList();
  if (HEAP32[$0 + 12 >> 2]) {
   jsvRemoveAllChildren(HEAP32[$0 + 12 >> 2]);
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
  }
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jswrap_modules_addCached($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block1 : {
   block : {
    if (jsvIsString(HEAP32[$2 + 28 >> 2]) & 1) {
     if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
      break block
     }
     if (jsvIsFunction(HEAP32[$2 + 24 >> 2]) & 1) {
      break block
     }
    }
    jsExceptionHere(1, 24745, 0);
    break block1;
   }
   HEAP32[$2 + 20 >> 2] = jswrap_modules_getModuleList();
   if (!HEAP32[$2 + 20 >> 2]) {
    break block1
   }
   HEAP32[$2 + 16 >> 2] = jspEvaluateModule(HEAP32[$2 + 24 >> 2]);
   block2 : {
    if (!HEAP32[$2 + 16 >> 2]) {
     HEAP32[$2 >> 2] = HEAP32[$2 + 28 >> 2];
     jsExceptionHere(1, 14788, $2);
     break block2;
    }
    jsvObjectSetChildVar(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]);
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_math_sin($0) {
  $0 = +$0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = sin(HEAPF64[$1 + 8 >> 3]);
  __stack_pointer = $1 + 16 | 0;
  return +$0;
 }
 
 function jswrap_math_cos($0) {
  $0 = +$0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3] + 1.5707963267948966);
  __stack_pointer = $1 + 16 | 0;
  return +$0;
 }
 
 function jswrap_math_asin($0) {
  $0 = +$0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = jswrap_math_atan(HEAPF64[$1 + 8 >> 3] / jswrap_math_sqrt(-HEAPF64[$1 + 8 >> 3] * HEAPF64[$1 + 8 >> 3] + 1.0));
  __stack_pointer = $1 + 16 | 0;
  return +$0;
 }
 
 function jswrap_math_sqrt($0) {
  $0 = +$0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  block : {
   if (HEAPF64[$1 + 8 >> 3] >= 0.0) {
    $0 = exp(log(HEAPF64[$1 + 8 >> 3]) * .5);
    break block;
   }
   $0 = NaN;
  }
  __stack_pointer = $1 + 16 | 0;
  return +$0;
 }
 
 function jswrap_math_atan($0) {
  $0 = +$0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  $0 = atan(HEAPF64[$1 + 8 >> 3]);
  __stack_pointer = $1 + 16 | 0;
  return +$0;
 }
 
 function jswrap_math_atan2($0, $1) {
  $0 = +$0;
  $1 = +$1;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAPF64[$2 + 8 >> 3] = $0;
  HEAPF64[$2 >> 3] = $1;
  $0 = atan2(HEAPF64[$2 + 8 >> 3], HEAPF64[$2 >> 3]);
  __stack_pointer = $2 + 16 | 0;
  return +$0;
 }
 
 function jswrap_math_mod($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAPF64[$2 + 64 >> 3] = $0;
  HEAPF64[$2 + 56 >> 3] = $1;
  HEAPF64[$2 + 32 >> 3] = HEAPF64[$2 + 64 >> 3];
  $3 = __DOUBLE_BITS_1637(HEAPF64[$2 + 64 >> 3]);
  $5 = $3;
  $4 = i64toi32_i32$HIGH_BITS;
  $3 = $4 & 2147483647;
  block2 : {
   block1 : {
    block : {
     if (($3 | 0) == 2146435072 | $3 >>> 0 > 2146435072) {
      break block
     }
     $4 = __DOUBLE_BITS_1637(HEAPF64[$2 + 56 >> 3]);
     $5 = $4;
     $3 = i64toi32_i32$HIGH_BITS;
     $4 = $3 & 2147483647;
     $3 = $5;
     if (($4 | 0) == 2146435072 & ($3 | 0) != 0 | $4 >>> 0 > 2146435072) {
      break block
     }
     if (HEAPF64[$2 + 56 >> 3] != 0.0) {
      break block1
     }
    }
    HEAPF64[$2 + 72 >> 3] = NaN;
    break block2;
   }
   if (HEAPF64[$2 + 56 >> 3] == Infinity) {
    HEAPF64[$2 + 72 >> 3] = HEAPF64[$2 + 64 >> 3];
    break block2;
   }
   if (HEAPF64[$2 + 32 >> 3] < 0.0) {
    HEAPF64[$2 + 64 >> 3] = -HEAPF64[$2 + 64 >> 3]
   }
   if (HEAPF64[$2 + 56 >> 3] < 0.0) {
    HEAPF64[$2 + 56 >> 3] = -HEAPF64[$2 + 56 >> 3]
   }
   block4 : {
    if (!(!(HEAPF64[$2 + 64 >> 3] <= 1797693134862315708145274.0e284) | (!(HEAPF64[$2 + 56 >> 3] <= 1797693134862315708145274.0e284) | HEAPF64[$2 + 56 >> 3] == 0.0))) {
     while (1) {
      if (HEAPF64[$2 + 64 >> 3] >= HEAPF64[$2 + 56 >> 3]) {
       HEAPF64[$2 + 48 >> 3] = HEAPF64[$2 + 64 >> 3] * .5;
       HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 56 >> 3];
       while (1) {
        if (HEAPF64[$2 + 48 >> 3] >= HEAPF64[$2 + 40 >> 3]) {
         $0 = HEAPF64[$2 + 40 >> 3];
         HEAPF64[$2 + 40 >> 3] = $0 + $0;
         continue;
        }
        break;
       };
       HEAPF64[$2 + 64 >> 3] = HEAPF64[$2 + 64 >> 3] - HEAPF64[$2 + 40 >> 3];
       continue;
      }
      break;
     };
     break block4;
    }
    HEAPF64[$2 + 64 >> 3] = 0;
   }
   if (HEAPF64[$2 + 32 >> 3] < 0.0) {
    $0 = -HEAPF64[$2 + 64 >> 3]
   } else {
    $0 = HEAPF64[$2 + 64 >> 3]
   }
   HEAPF64[$2 + 72 >> 3] = $0;
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAPF64[$2 + 72 >> 3];
 }
 
 function __DOUBLE_BITS_1637($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_math_pow($0, $1) {
  $0 = +$0;
  $1 = +$1;
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAPF64[$2 + 32 >> 3] = $0;
  HEAPF64[$2 + 24 >> 3] = $1;
  $0 = HEAPF64[$2 + 24 >> 3];
  if (Math_abs($0) < 2147483647.0) {
   $3 = ~~$0
  } else {
   $3 = -2147483648
  }
  HEAP32[$2 + 12 >> 2] = $3;
  block1 : {
   if (!(HEAP32[$2 + 12 >> 2] < 0 | HEAP32[$2 + 12 >> 2] >= 10 | HEAPF64[$2 + 24 >> 3] != +HEAP32[$2 + 12 >> 2])) {
    if (!HEAP32[$2 + 12 >> 2]) {
     HEAPF64[$2 + 40 >> 3] = 1;
     break block1;
    }
    HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 32 >> 3];
    while (1) {
     if (HEAP32[$2 + 12 >> 2] > 1) {
      HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 16 >> 3] * HEAPF64[$2 + 32 >> 3];
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - 1;
      continue;
     }
     break;
    };
    HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 16 >> 3];
    break block1;
   }
   block4 : {
    block2 : {
     if (!(HEAPF64[$2 + 32 >> 3] < 0.0)) {
      break block2
     }
     if (jswrap_math_mod(HEAPF64[$2 + 24 >> 3], 1.0) != 0.0) {
      break block2
     }
     block3 : {
      if (jswrap_math_mod(HEAPF64[$2 + 24 >> 3], 2.0) == 0.0) {
       HEAPF64[$2 + 16 >> 3] = exp(log(-HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
       break block3;
      }
      HEAPF64[$2 + 16 >> 3] = -exp(log(-HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
     }
     break block4;
    }
    block6 : {
     if (!(!(HEAPF64[$2 + 24 >> 3] <= 0.0) & HEAPF64[$2 + 32 >> 3] == 0.0)) {
      HEAPF64[$2 + 16 >> 3] = exp(log(HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
      break block6;
     }
     HEAPF64[$2 + 16 >> 3] = 0;
    }
   }
   HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 16 >> 3];
  }
  __stack_pointer = $2 + 48 | 0;
  return +HEAPF64[$2 + 40 >> 3];
 }
 
 function jswrap_math_round($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 32 >> 3] = $0;
  $2 = __DOUBLE_BITS_1637(HEAPF64[$1 + 32 >> 3]);
  $4 = $2;
  $3 = i64toi32_i32$HIGH_BITS;
  $2 = $3 & 2147483647;
  block2 : {
   block1 : {
    if (!(($2 | 0) == 2146435072 | $2 >>> 0 > 2146435072)) {
     if (!(isNegativeZero(HEAPF64[$1 + 32 >> 3]) & 1)) {
      break block1
     }
    }
    HEAP32[$1 + 44 >> 2] = jsvNewFromFloat(HEAPF64[$1 + 32 >> 3]);
    break block2;
   }
   HEAPF64[$1 + 32 >> 3] = HEAPF64[$1 + 32 >> 3] + (HEAPF64[$1 + 32 >> 3] < 0.0 ? -.5 : .5);
   $2 = $1;
   $0 = HEAPF64[$1 + 32 >> 3];
   if (Math_abs($0) < 9223372036854775808.0) {
    if (Math_abs($0) >= 1.0) {
     $3 = ~~($0 > 0.0 ? Math_min(Math_floor($0 * 2.3283064365386963e-10), 4294967295.0) : Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0
    } else {
     $3 = 0
    }
    $5 = ~~$0 >>> 0;
   } else {
    $3 = -2147483648
   }
   HEAP32[$2 + 24 >> 2] = $5;
   HEAP32[$2 + 28 >> 2] = $3;
   $3 = HEAP32[$1 + 24 >> 2];
   $2 = HEAP32[$1 + 28 >> 2];
   if (!(!!($3 | $2) | !(HEAPF64[$1 + 32 >> 3] < 0.0))) {
    HEAP32[$1 + 44 >> 2] = jsvNewFromFloat(-0.0);
    break block2;
   }
   $2 = HEAP32[$1 + 24 >> 2];
   $3 = HEAP32[$1 + 28 >> 2];
   HEAP32[$1 + 44 >> 2] = jsvNewFromLongInteger($2, $3);
  }
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 44 >> 2];
 }
 
 function isNegativeZero($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $1 = __stack_pointer - 32 | 0;
  HEAPF64[$1 + 24 >> 3] = $0;
  HEAPF64[$1 + 16 >> 3] = -0;
  HEAP32[$1 + 12 >> 2] = $1 + 16;
  HEAP32[$1 + 8 >> 2] = $1 + 24;
  $2 = HEAP32[$1 + 8 >> 2];
  $3 = HEAP32[$2 >> 2];
  $4 = HEAP32[$2 + 4 >> 2];
  $2 = HEAP32[$1 + 12 >> 2];
  $1 = HEAP32[$2 >> 2];
  $5 = HEAP32[$2 + 4 >> 2];
  $2 = $3;
  return ($2 | 0) == ($1 | 0) & ($4 | 0) == ($5 | 0);
 }
 
 function jswrap_math_clip($0, $1, $2) {
  $0 = +$0;
  $1 = +$1;
  $2 = +$2;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAPF64[$3 + 24 >> 3] = $0;
  HEAPF64[$3 + 16 >> 3] = $1;
  HEAPF64[$3 + 8 >> 3] = $2;
  if (HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 16 >> 3]) {
   HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 16 >> 3]
  }
  if (HEAPF64[$3 + 24 >> 3] > HEAPF64[$3 + 8 >> 3]) {
   HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 8 >> 3]
  }
  return +HEAPF64[$3 + 24 >> 3];
 }
 
 function jswrap_math_minmax($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP8[$2 + 43 | 0] = $1 & 1;
  HEAPF64[$2 + 32 >> 3] = HEAP8[$2 + 43 | 0] & 1 ? -Infinity : Infinity;
  jsvObjectIteratorNew($2 + 28 | 0, HEAP32[$2 + 44 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_1643($2 + 28 | 0) & 1) {
    HEAPF64[$2 + 16 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_1644($2 + 28 | 0));
    block1 : {
     block : {
      if (HEAP8[$2 + 43 | 0] & 1 & HEAPF64[$2 + 16 >> 3] > HEAPF64[$2 + 32 >> 3] | !(HEAP8[$2 + 43 | 0] & 1) & HEAPF64[$2 + 16 >> 3] < HEAPF64[$2 + 32 >> 3]) {
       break block
      }
      $1 = __DOUBLE_BITS_1637(HEAPF64[$2 + 16 >> 3]);
      $0 = $1;
      $3 = i64toi32_i32$HIGH_BITS;
      $1 = $3 & 2147483647;
      $3 = $0;
      if (($1 | 0) == 2146435072 & ($3 | 0) != 0 | $1 >>> 0 > 2146435072) {
       break block
      }
      break block1;
     }
     HEAPF64[$2 + 32 >> 3] = HEAPF64[$2 + 16 >> 3];
    }
    jsvObjectIteratorNext($2 + 28 | 0);
    continue;
   }
   break;
  };
  jsvObjectIteratorFree_1645($2 + 28 | 0);
  __stack_pointer = $2 + 48 | 0;
  return HEAPF64[$2 + 32 >> 3];
 }
 
 function jsvObjectIteratorHasValue_1643($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1644($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1645($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_math_sign($0) {
  $0 = +$0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 >> 3] = $0;
  block1 : {
   block : {
    if (HEAPF64[$1 >> 3] != 0.0) {
     if (!(isNegativeZero(HEAPF64[$1 >> 3]) & 1)) {
      break block
     }
    }
    HEAP32[$1 + 12 >> 2] = 0;
    break block1;
   }
   HEAP32[$1 + 12 >> 2] = HEAPF64[$1 >> 3] > 0.0 ? 1 : -1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_espruino_getTemperature($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $2 = jshReadTemperature();
  __stack_pointer = $1 + 16 | 0;
  return +$2;
 }
 
 function nativeCallGetCType() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  block : {
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 192) {
    jslMatch(192);
    HEAP32[$0 + 12 >> 2] = 0;
    break block;
   }
   if (HEAPU16[HEAP32[61300] + 2 >> 1] == 128) {
    HEAP32[$0 + 8 >> 2] = -1;
    HEAP32[$0 + 4 >> 2] = jslGetTokenValueAsString();
    if (!strcmp(HEAP32[$0 + 4 >> 2], 4612)) {
     HEAP32[$0 + 8 >> 2] = 4
    }
    if (!strcmp(HEAP32[$0 + 4 >> 2], 17926)) {
     HEAP32[$0 + 8 >> 2] = 7
    }
    if (!strcmp(HEAP32[$0 + 4 >> 2], 15743)) {
     HEAP32[$0 + 8 >> 2] = 3
    }
    if (!strcmp(HEAP32[$0 + 4 >> 2], 15532)) {
     HEAP32[$0 + 8 >> 2] = 5
    }
    if (!strcmp(HEAP32[$0 + 4 >> 2], 8400)) {
     HEAP32[$0 + 8 >> 2] = 1
    }
    if (!strcmp(HEAP32[$0 + 4 >> 2], 5031)) {
     HEAP32[$0 + 8 >> 2] = 6
    }
    jslMatch(128);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
    break block;
   }
   HEAP32[$0 + 12 >> 2] = -1;
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_espruino_nativeCall($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 192 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 184 >> 2] = $0;
  HEAP32[$3 + 180 >> 2] = $1;
  HEAP32[$3 + 176 >> 2] = $2;
  HEAP32[$3 + 172 >> 2] = 0;
  block3 : {
   if (!(jsvIsUndefined(HEAP32[$3 + 180 >> 2]) & 1)) {
    block4 : {
     if (jsvIsString(HEAP32[$3 + 180 >> 2]) & 1) {
      HEAP32[$3 + 32 >> 2] = jslSetLex($3 + 36 | 0);
      jslInit(HEAP32[$3 + 180 >> 2]);
      HEAP8[$3 + 27 | 0] = 1;
      HEAP32[$3 + 20 >> 2] = 0;
      HEAP32[$3 + 28 >> 2] = nativeCallGetCType();
      block : {
       if (HEAP32[$3 + 28 >> 2] >= 0) {
        $1 = HEAP32[$3 + 28 >> 2];
        $0 = HEAP32[$3 + 20 >> 2];
        HEAP32[$3 + 20 >> 2] = $0 + 1;
        HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 172 >> 2] | $1 << Math_imul($0, 3);
        break block;
       }
       HEAP8[$3 + 27 | 0] = 0;
      }
      if (HEAP8[$3 + 27 | 0] & 1) {
       HEAP8[$3 + 27 | 0] = jslMatch(40) & 1
      }
      while (1) {
       $0 = 0;
       block1 : {
        if (!(HEAP8[$3 + 27 | 0] & 1)) {
         break block1
        }
        $0 = 0;
        if (!HEAPU16[$3 + 38 >> 1]) {
         break block1
        }
        $0 = HEAPU16[$3 + 38 >> 1] != 41;
       }
       if ($0) {
        HEAP32[$3 + 28 >> 2] = nativeCallGetCType();
        block2 : {
         if (HEAP32[$3 + 28 >> 2] >= 0) {
          $1 = HEAP32[$3 + 28 >> 2];
          $0 = HEAP32[$3 + 20 >> 2];
          HEAP32[$3 + 20 >> 2] = $0 + 1;
          HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 172 >> 2] | $1 << Math_imul($0, 3);
          if (HEAPU16[$3 + 38 >> 1] != 41) {
           HEAP8[$3 + 27 | 0] = jslMatch(44) & 1
          }
          break block2;
         }
         HEAP8[$3 + 27 | 0] = 0;
        }
        continue;
       }
       break;
      };
      if (HEAP8[$3 + 27 | 0] & 1) {
       HEAP8[$3 + 27 | 0] = jslMatch(41) & 1
      }
      jslKill();
      jslSetLex(HEAP32[$3 + 32 >> 2]);
      if (HEAP32[$3 + 172 >> 2] & -65536) {
       HEAP8[$3 + 27 | 0] = 0
      }
      if (!(HEAP8[$3 + 27 | 0] & 1)) {
       HEAP32[$3 >> 2] = HEAP32[$3 + 20 >> 2];
       jsExceptionHere(1, 19786, $3);
       HEAP32[$3 + 188 >> 2] = 0;
       break block3;
      }
      break block4;
     }
     jsExceptionHere(1, 17695, 0);
     HEAP32[$3 + 188 >> 2] = 0;
     break block3;
    }
   }
   HEAP32[$3 + 16 >> 2] = jsvNewNativeFunction(HEAP32[$3 + 184 >> 2], HEAP32[$3 + 172 >> 2] & 65535);
   if (HEAP32[$3 + 176 >> 2]) {
    HEAP32[$3 + 12 >> 2] = jsvAsFlatString(HEAP32[$3 + 176 >> 2]);
    if (!HEAP32[$3 + 12 >> 2]) {
     jsvUnLock(HEAP32[$3 + 16 >> 2]);
     HEAP32[$3 + 188 >> 2] = 0;
     break block3;
    }
    jsvAddNamedChildAndUnLock(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], 18659);
   }
   HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 16 >> 2];
  }
  __stack_pointer = $3 + 192 | 0;
  return HEAP32[$3 + 188 >> 2];
 }
 
 function jswrap_espruino_clip($0, $1, $2) {
  $0 = +$0;
  $1 = +$1;
  $2 = +$2;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAPF64[$3 + 24 >> 3] = $0;
  HEAPF64[$3 + 16 >> 3] = $1;
  HEAPF64[$3 + 8 >> 3] = $2;
  if (HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 16 >> 3]) {
   HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 16 >> 3]
  }
  if (HEAPF64[$3 + 24 >> 3] > HEAPF64[$3 + 8 >> 3]) {
   HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 8 >> 3]
  }
  return +HEAPF64[$3 + 24 >> 3];
 }
 
 function jswrap_espruino_sum($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 84 >> 2] = $0;
  block1 : {
   block : {
    if (jsvIsString(HEAP32[$1 + 84 >> 2]) & 1) {
     break block
    }
    if (jsvIsArray(HEAP32[$1 + 84 >> 2]) & 1) {
     break block
    }
    if (jsvIsArrayBuffer(HEAP32[$1 + 84 >> 2]) & 1) {
     break block
    }
    HEAP32[$1 >> 2] = HEAP32[$1 + 84 >> 2];
    jsExceptionHere(1, 5057, $1);
    HEAPF64[$1 + 88 >> 3] = NaN;
    break block1;
   }
   HEAPF64[$1 + 72 >> 3] = 0;
   jsvIteratorNew($1 + 8 | 0, HEAP32[$1 + 84 >> 2], 0);
   while (1) {
    if (jsvIteratorHasElement($1 + 8 | 0) & 1) {
     $2 = jsvIteratorGetFloatValue($1 + 8 | 0);
     HEAPF64[$1 + 72 >> 3] = HEAPF64[$1 + 72 >> 3] + $2;
     jsvIteratorNext($1 + 8 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($1 + 8 | 0);
   HEAPF64[$1 + 88 >> 3] = HEAPF64[$1 + 72 >> 3];
  }
  __stack_pointer = $1 + 96 | 0;
  return +HEAPF64[$1 + 88 >> 3];
 }
 
 function jswrap_espruino_variance($0, $1) {
  $0 = $0 | 0;
  $1 = +$1;
  var $2 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 100 >> 2] = $0;
  HEAPF64[$2 + 88 >> 3] = $1;
  block : {
   if (!(jsvIsIterable(HEAP32[$2 + 100 >> 2]) & 1)) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 100 >> 2];
    jsExceptionHere(1, 5265, $2);
    HEAPF64[$2 + 104 >> 3] = NaN;
    break block;
   }
   HEAPF64[$2 + 80 >> 3] = 0;
   jsvIteratorNew($2 + 16 | 0, HEAP32[$2 + 100 >> 2], 1);
   while (1) {
    if (jsvIteratorHasElement($2 + 16 | 0) & 1) {
     HEAPF64[$2 + 8 >> 3] = jsvIteratorGetFloatValue($2 + 16 | 0);
     HEAPF64[$2 + 8 >> 3] = HEAPF64[$2 + 8 >> 3] - HEAPF64[$2 + 88 >> 3];
     HEAPF64[$2 + 80 >> 3] = HEAPF64[$2 + 8 >> 3] * HEAPF64[$2 + 8 >> 3] + HEAPF64[$2 + 80 >> 3];
     jsvIteratorNext($2 + 16 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($2 + 16 | 0);
   HEAPF64[$2 + 104 >> 3] = HEAPF64[$2 + 80 >> 3];
  }
  __stack_pointer = $2 + 112 | 0;
  return +HEAPF64[$2 + 104 >> 3];
 }
 
 function jswrap_espruino_convolve($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 176 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 164 >> 2] = $0;
  HEAP32[$3 + 160 >> 2] = $1;
  HEAP32[$3 + 156 >> 2] = $2;
  block1 : {
   block : {
    if (jsvIsIterable(HEAP32[$3 + 164 >> 2]) & 1) {
     if (jsvIsIterable(HEAP32[$3 + 160 >> 2]) & 1) {
      break block
     }
    }
    $0 = HEAP32[$3 + 164 >> 2];
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 160 >> 2];
    HEAP32[$3 >> 2] = $0;
    jsExceptionHere(1, 6462, $3);
    HEAPF64[$3 + 168 >> 3] = NaN;
    break block1;
   }
   HEAPF64[$3 + 144 >> 3] = 0;
   jsvIteratorNew($3 + 80 | 0, HEAP32[$3 + 164 >> 2], 1);
   jsvIteratorNew($3 + 16 | 0, HEAP32[$3 + 160 >> 2], 1);
   HEAP32[$3 + 12 >> 2] = jsvGetLength(HEAP32[$3 + 160 >> 2]);
   HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] % HEAP32[$3 + 12 >> 2];
   if (HEAP32[$3 + 156 >> 2] < 0) {
    HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 156 >> 2]
   }
   while (1) {
    $0 = HEAP32[$3 + 156 >> 2];
    HEAP32[$3 + 156 >> 2] = $0 - 1;
    if (($0 | 0) > 0) {
     jsvIteratorNext($3 + 16 | 0);
     continue;
    }
    break;
   };
   while (1) {
    if (jsvIteratorHasElement($3 + 80 | 0) & 1) {
     HEAPF64[$3 + 144 >> 3] = jsvIteratorGetFloatValue($3 + 80 | 0) * jsvIteratorGetFloatValue($3 + 16 | 0) + HEAPF64[$3 + 144 >> 3];
     jsvIteratorNext($3 + 80 | 0);
     jsvIteratorNext($3 + 16 | 0);
     if (!(jsvIteratorHasElement($3 + 16 | 0) & 1)) {
      jsvIteratorFree($3 + 16 | 0);
      jsvIteratorNew($3 + 16 | 0, HEAP32[$3 + 160 >> 2], 1);
     }
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 80 | 0);
   jsvIteratorFree($3 + 16 | 0);
   HEAPF64[$3 + 168 >> 3] = HEAPF64[$3 + 144 >> 3];
  }
  __stack_pointer = $3 + 176 | 0;
  return +HEAPF64[$3 + 168 >> 3];
 }
 
 function FFT($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 128 | 0;
  __stack_pointer = $4;
  HEAP16[$4 + 126 >> 1] = $0;
  HEAP32[$4 + 120 >> 2] = $1;
  HEAP32[$4 + 116 >> 2] = $2;
  HEAP32[$4 + 112 >> 2] = $3;
  HEAP32[$4 + 108 >> 2] = 1;
  HEAP32[$4 + 104 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 120 >> 2]) {
    HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 108 >> 2] << 1;
    HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 108 >> 2] >> 1;
  HEAP32[$4 + 96 >> 2] = 0;
  HEAP32[$4 + 104 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 104 >> 2] < (HEAP32[$4 + 108 >> 2] - 1 | 0)) {
    if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 96 >> 2]) {
     HEAPF64[$4 + 48 >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3];
     HEAPF64[$4 + 40 >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3];
     HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3];
     HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3];
     HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3] = HEAPF64[$4 + 48 >> 3];
     HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3] = HEAPF64[$4 + 40 >> 3];
    }
    HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 88 >> 2];
    while (1) {
     if (HEAP32[$4 + 92 >> 2] <= HEAP32[$4 + 96 >> 2]) {
      HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 96 >> 2] - HEAP32[$4 + 92 >> 2];
      HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 92 >> 2] >> 1;
      continue;
     }
     break;
    };
    HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 92 >> 2] + HEAP32[$4 + 96 >> 2];
    HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAPF64[$4 + 64 >> 3] = -1;
  HEAPF64[$4 + 56 >> 3] = 0;
  HEAP32[$4 + 76 >> 2] = 1;
  HEAP32[$4 + 84 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 84 >> 2] < HEAP32[$4 + 120 >> 2]) {
    HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 76 >> 2];
    HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] << 1;
    HEAPF64[$4 + 16 >> 3] = 1;
    HEAPF64[$4 + 8 >> 3] = 0;
    HEAP32[$4 + 96 >> 2] = 0;
    while (1) {
     if (HEAP32[$4 + 96 >> 2] < HEAP32[$4 + 80 >> 2]) {
      HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 96 >> 2];
      while (1) {
       if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 108 >> 2]) {
        HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 104 >> 2] + HEAP32[$4 + 80 >> 2];
        HEAPF64[$4 + 32 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] - HEAPF64[$4 + 8 >> 3] * HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3];
        HEAPF64[$4 + 24 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] + HEAPF64[$4 + 8 >> 3] * HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3];
        HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] - HEAPF64[$4 + 32 >> 3];
        HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] - HEAPF64[$4 + 24 >> 3];
        $0 = HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
        HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] + HEAPF64[$4 + 32 >> 3];
        $0 = HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
        HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] + HEAPF64[$4 + 24 >> 3];
        HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 76 >> 2] + HEAP32[$4 + 104 >> 2];
        continue;
       }
       break;
      };
      HEAPF64[$4 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[$4 + 64 >> 3] - HEAPF64[$4 + 8 >> 3] * HEAPF64[$4 + 56 >> 3];
      HEAPF64[$4 + 8 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[$4 + 56 >> 3] + HEAPF64[$4 + 8 >> 3] * HEAPF64[$4 + 64 >> 3];
      HEAPF64[$4 + 16 >> 3] = HEAPF64[$4 >> 3];
      HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 96 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAPF64[$4 + 56 >> 3] = jswrap_math_sqrt((1.0 - HEAPF64[$4 + 64 >> 3]) * .5);
    if (HEAPU16[$4 + 126 >> 1] == 1) {
     HEAPF64[$4 + 56 >> 3] = -HEAPF64[$4 + 56 >> 3]
    }
    HEAPF64[$4 + 64 >> 3] = jswrap_math_sqrt((HEAPF64[$4 + 64 >> 3] + 1.0) * .5);
    HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 84 >> 2] + 1;
    continue;
   }
   break;
  };
  if (HEAPU16[$4 + 126 >> 1] == 1) {
   HEAP32[$4 + 104 >> 2] = 0;
   while (1) {
    if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 108 >> 2]) {
     $0 = HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
     HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] / +HEAP32[$4 + 108 >> 2];
     $0 = HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
     HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] / +HEAP32[$4 + 108 >> 2];
     HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
     continue;
    }
    break;
   };
  }
  __stack_pointer = $4 + 128 | 0;
  return 1;
 }
 
 function _jswrap_espruino_FFT_getData($0, $1, $2) {
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 76 >> 2] = $0;
  HEAP32[$3 + 72 >> 2] = $1;
  HEAP32[$3 + 68 >> 2] = $2;
  HEAP32[$3 >> 2] = 0;
  if (jsvIsIterable(HEAP32[$3 + 72 >> 2]) & 1) {
   jsvIteratorNew($3 + 4 | 0, HEAP32[$3 + 72 >> 2], 1);
   while (1) {
    $0 = 0;
    if (HEAPU32[$3 >> 2] < HEAPU32[$3 + 68 >> 2]) {
     $0 = jsvIteratorHasElement($3 + 4 | 0)
    }
    if ($0 & 1) {
     $4 = jsvIteratorGetFloatValue($3 + 4 | 0);
     $1 = HEAP32[$3 + 76 >> 2];
     $0 = HEAP32[$3 >> 2];
     HEAP32[$3 >> 2] = $0 + 1;
     HEAPF64[($0 << 3) + $1 >> 3] = $4;
     jsvIteratorNext($3 + 4 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 4 | 0);
  }
  while (1) {
   if (HEAPU32[$3 >> 2] < HEAPU32[$3 + 68 >> 2]) {
    $1 = HEAP32[$3 + 76 >> 2];
    $0 = HEAP32[$3 >> 2];
    HEAP32[$3 >> 2] = $0 + 1;
    HEAPF64[($0 << 3) + $1 >> 3] = 0;
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 80 | 0;
 }
 
 function _jswrap_espruino_FFT_setData($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 92 >> 2] = $0;
  HEAP32[$4 + 88 >> 2] = $1;
  HEAP32[$4 + 84 >> 2] = $2;
  HEAP32[$4 + 80 >> 2] = $3;
  jsvIteratorNew($4 + 16 | 0, HEAP32[$4 + 92 >> 2], 1);
  HEAP32[$4 + 12 >> 2] = 0;
  while (1) {
   $0 = 0;
   if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 80 >> 2]) {
    $0 = jsvIteratorHasElement($4 + 16 | 0)
   }
   if ($0 & 1) {
    block : {
     if (HEAP32[$4 + 84 >> 2]) {
      HEAPF64[$4 >> 3] = jswrap_math_sqrt(HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] * HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] + HEAPF64[HEAP32[$4 + 84 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] * HEAPF64[HEAP32[$4 + 84 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3]);
      break block;
     }
     HEAPF64[$4 >> 3] = HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3];
    }
    jsvUnLock(jsvIteratorSetValue($4 + 16 | 0, jsvNewFromFloat(HEAPF64[$4 >> 3])));
    HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
    jsvIteratorNext($4 + 16 | 0);
    continue;
   }
   break;
  };
  jsvIteratorFree($4 + 16 | 0);
  __stack_pointer = $4 + 96 | 0;
 }
 
 function jswrap_espruino_FFT($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  $3 = $4;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP8[$3 + 39 | 0] = $2;
  block1 : {
   block : {
    if (jsvIsIterable(HEAP32[$3 + 44 >> 2]) & 1) {
     if (jsvIsUndefined(HEAP32[$3 + 40 >> 2]) & 1) {
      break block
     }
     if (jsvIsIterable(HEAP32[$3 + 40 >> 2]) & 1) {
      break block
     }
    }
    $0 = HEAP32[$3 + 44 >> 2];
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 40 >> 2];
    HEAP32[$3 >> 2] = $0;
    jsExceptionHere(1, 6520, $3);
    break block1;
   }
   HEAP32[$3 + 32 >> 2] = jsvGetLength(HEAP32[$3 + 44 >> 2]);
   HEAP32[$3 + 28 >> 2] = 1;
   HEAP32[$3 + 24 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 28 >> 2] < HEAPU32[$3 + 32 >> 2]) {
     HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] << 1;
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 1;
     continue;
    }
    break;
   };
   if (jsuGetFreeStack() >>> 0 < (HEAP32[$3 + 28 >> 2] << 4) + 256 >>> 0) {
    jsExceptionHere(1, 21079, 0);
    break block1;
   }
   $4 = $4 - (HEAP32[$3 + 28 >> 2] << 4) | 0;
   __stack_pointer = $4;
   HEAP32[$3 + 20 >> 2] = $4;
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 28 >> 2] << 3);
   _jswrap_espruino_FFT_getData(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 44 >> 2], HEAP32[$3 + 28 >> 2]);
   _jswrap_espruino_FFT_getData(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 28 >> 2]);
   FFT(HEAP8[$3 + 39 | 0] & 1 ? -1 : 1, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
   HEAP8[$3 + 15 | 0] = jsvIsIterable(HEAP32[$3 + 40 >> 2]) & 1;
   _jswrap_espruino_FFT_setData(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 20 >> 2], HEAP8[$3 + 15 | 0] & 1 ? 0 : HEAP32[$3 + 16 >> 2], HEAP32[$3 + 28 >> 2]);
   if (!(HEAP8[$3 + 15 | 0] & 1)) {
    break block1
   }
   _jswrap_espruino_FFT_setData(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 16 >> 2], 0, HEAP32[$3 + 28 >> 2]);
  }
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jswrap_espruino_enableWatchdog($0, $1) {
  $0 = +$0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAPF64[$2 + 24 >> 3] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block1 : {
   block : {
    if (HEAPF64[$2 + 24 >> 3] < 0.0) {
     break block
    }
    $3 = __DOUBLE_BITS_1660(HEAPF64[$2 + 24 >> 3]);
    $1 = $3;
    $4 = i64toi32_i32$HIGH_BITS;
    $3 = $4 & 2147483647;
    $4 = $1;
    if (($3 | 0) == 2146435072 & ($4 | 0) != 0 | $3 >>> 0 > 2146435072) {
     break block
    }
    break block1;
   }
   HEAPF64[$2 + 24 >> 3] = 1;
  }
  block3 : {
   block2 : {
    if (!(jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1)) {
     if (!(jsvGetBool(HEAP32[$2 + 20 >> 2]) & 1)) {
      break block2
     }
    }
    HEAP16[207230] = HEAPU16[207230] | 512;
    break block3;
   }
   HEAP16[207230] = HEAPU16[207230] & -513;
  }
  jshEnableWatchDog(HEAPF64[$2 + 24 >> 3]);
  __stack_pointer = $2 + 32 | 0;
 }
 
 function __DOUBLE_BITS_1660($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_espruino_kickWatchdog() {
  jshKickWatchDog();
 }
 
 function jswrap_espruino_getErrorFlagArray($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 11 | 0] = $0;
  HEAP32[$1 + 4 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   if (HEAP8[$1 + 11 | 0] & 1) {
    jsvArrayPushString(HEAP32[$1 + 4 >> 2], 21296)
   }
   if (HEAPU8[$1 + 11 | 0] & 2) {
    jsvArrayPushString(HEAP32[$1 + 4 >> 2], 21284)
   }
   if (HEAPU8[$1 + 11 | 0] & 4) {
    jsvArrayPushString(HEAP32[$1 + 4 >> 2], 21355)
   }
   if (HEAPU8[$1 + 11 | 0] & 8) {
    jsvArrayPushString(HEAP32[$1 + 4 >> 2], 20824)
   }
   if (HEAPU8[$1 + 11 | 0] & 16) {
    jsvArrayPushString(HEAP32[$1 + 4 >> 2], 20842)
   }
   if (HEAPU8[$1 + 11 | 0] & 32) {
    jsvArrayPushString(HEAP32[$1 + 4 >> 2], 20812)
   }
   if (HEAPU8[$1 + 11 | 0] & 64) {
    jsvArrayPushString(HEAP32[$1 + 4 >> 2], 20965)
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_espruino_getErrorFlags() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 15 | 0] = HEAPU8[413226];
  HEAP8[413226] = 0;
  $1 = jswrap_espruino_getErrorFlagArray(HEAPU8[$0 + 15 | 0]);
  __stack_pointer = $0 + 16 | 0;
  return $1 | 0;
 }
 
 function jswrap_espruino_toArrayBuffer($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function _jswrap_espruino_toString_char($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsvStringIteratorSetCharAndNext(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_espruino_toStringX($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP8[$2 + 71 | 0] = $1;
  block2 : {
   if ((jsvGetArrayLength(HEAP32[$2 + 72 >> 2]) | 0) == 1) {
    HEAP32[$2 + 64 >> 2] = jsvGetArrayItem(HEAP32[$2 + 72 >> 2], 0);
    block1 : {
     if (!(jsvIsString(HEAP32[$2 + 64 >> 2]) & 1 & !(HEAP8[$2 + 71 | 0] & 1))) {
      if (!(jsvIsFlatString(HEAP32[$2 + 64 >> 2]) & 1)) {
       break block1
      }
     }
     HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 64 >> 2];
     break block2;
    }
    block3 : {
     if (!(jsvIsArrayBuffer(HEAP32[$2 + 64 >> 2]) & 1) | (HEAPU8[HEAP32[$2 + 64 >> 2] + 5 | 0] & 15) != 1) {
      break block3
     }
     $0 = HEAP32[$2 + 64 >> 2];
     if (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) {
      break block3
     }
     HEAP32[$2 + 60 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 64 >> 2], 0);
     block5 : {
      if (!(HEAP8[$2 + 71 | 0] & 1 ? 0 : HEAP32[$2 + 60 >> 2])) {
       if (!(jsvIsFlatString(HEAP32[$2 + 60 >> 2]) & 1)) {
        break block5
       }
      }
      $1 = jsvGetLength(HEAP32[$2 + 60 >> 2]);
      $0 = HEAP32[$2 + 64 >> 2];
      if (($1 | 0) != (HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8))) {
       break block5
      }
      jsvUnLock(HEAP32[$2 + 64 >> 2]);
      HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 60 >> 2];
      break block2;
     }
     jsvUnLock(HEAP32[$2 + 60 >> 2]);
    }
    jsvUnLock(HEAP32[$2 + 64 >> 2]);
   }
   HEAP32[$2 + 56 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 72 >> 2]);
   block6 : {
    if (HEAP8[$2 + 71 | 0] & 1) {
     $0 = jsvNewFlatStringOfLength(HEAP32[$2 + 56 >> 2]);
     break block6;
    }
    $0 = jsvNewStringOfLength(HEAP32[$2 + 56 >> 2], 0);
   }
   HEAP32[$2 + 52 >> 2] = $0;
   if (!(HEAP32[$2 + 52 >> 2] | !(HEAP8[$2 + 71 | 0] & 1))) {
    jsvDefragment();
    HEAP32[$2 + 52 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 56 >> 2]);
   }
   if (!HEAP32[$2 + 52 >> 2]) {
    HEAP32[$2 + 76 >> 2] = 0;
    break block2;
   }
   jsvStringIteratorNew($2 + 12 | 0, HEAP32[$2 + 52 >> 2], 0);
   jsvIterateCallback(HEAP32[$2 + 72 >> 2], 641, $2 + 12 | 0);
   jsvStringIteratorFree_1667($2 + 12 | 0);
   HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 52 >> 2];
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAP32[$2 + 76 >> 2];
 }
 
 function jsvStringIteratorFree_1667($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_espruino_toString($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_espruino_toStringX(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_espruino_toFlatString($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_espruino_toStringX(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_espruino_asUTF8($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvNewUTF8StringAndUnLock(jsvAsString(HEAP32[$1 + 12 >> 2]));
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_espruino_fromUTF8($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvGetUTF8BackingString(HEAP32[$1 + 8 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_espruino_isUTF8($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsvIsUTF8String(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function _jswrap_espruino_toUint8Array_char($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsvArrayBufferIteratorSetByteValue(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
  jsvArrayBufferIteratorNext(HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_espruino_toUint8Array($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  HEAP32[$1 + 68 >> 2] = jsvNewTypedArray(1, jsvIterateCallbackCount(HEAP32[$1 + 72 >> 2]));
  block : {
   if (!HEAP32[$1 + 68 >> 2]) {
    HEAP32[$1 + 76 >> 2] = 0;
    break block;
   }
   jsvArrayBufferIteratorNew($1 + 8 | 0, HEAP32[$1 + 68 >> 2], 0);
   jsvIterateCallback(HEAP32[$1 + 72 >> 2], 642, $1 + 8 | 0);
   jsvArrayBufferIteratorFree($1 + 8 | 0);
   HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 68 >> 2];
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jswrap_espruino_toJS($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = 8896;
  HEAP32[$1 + 4 >> 2] = jsvNewFromEmptyString_1676();
  if (HEAP32[$1 + 4 >> 2]) {
   jsfGetJSON(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2])
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 4 >> 2];
 }
 
 function jsvNewFromEmptyString_1676() {
  return jsvNewWithFlags(29);
 }
 
 function jswrap_espruino_memoryArea($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block1 : {
   if (!(HEAP32[$2 + 4 >> 2] >= 0 ? HEAP32[$2 + 8 >> 2] : 0)) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block1;
   }
   HEAP32[$2 >> 2] = jshFlashGetMemMapAddress(HEAP32[$2 + 8 >> 2]);
   HEAP32[$2 + 12 >> 2] = jsvNewNativeString(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_espruino_setBootCode($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  block : {
   if (jsvIsString(HEAP32[$2 + 12 >> 2]) & 1) {
    HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_1676();
  }
  jsfSaveBootCodeToFlash(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0] & 1);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_espruino_setClock($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jshSetSystemClock(HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_espruino_getClock() {
  return jshGetSystemClock() | 0;
 }
 
 function jswrap_espruino_setConsole($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 108 >> 2] = $0;
  HEAP32[$2 + 104 >> 2] = $1;
  HEAP8[$2 + 103 | 0] = 0;
  HEAP32[$2 + 88 >> 2] = 18258;
  HEAP16[$2 + 92 >> 1] = 12;
  HEAP16[($2 + 88 | 0) + 6 >> 1] = 0;
  HEAP32[$2 + 96 >> 2] = $2 + 103;
  block : {
   if (!(jsvReadConfigObject(HEAP32[$2 + 104 >> 2], $2 + 88 | 0, 1) & 1)) {
    break block
   }
   HEAP8[$2 + 87 | 0] = 0;
   block1 : {
    if (jsvIsObject(HEAP32[$2 + 108 >> 2]) & 1) {
     HEAP8[$2 + 87 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 108 >> 2]);
     break block1;
    }
    if (jsvIsString(HEAP32[$2 + 108 >> 2]) & 1) {
     jsvGetString(HEAP32[$2 + 108 >> 2], $2 + 16 | 0, 64);
     HEAP8[$2 + 87 | 0] = jshFromDeviceString($2 + 16 | 0);
    }
   }
   block2 : {
    if (HEAPU8[$2 + 87 | 0]) {
     break block2
    }
    if (jsvIsNull(HEAP32[$2 + 108 >> 2]) & 1) {
     break block2
    }
    HEAP32[$2 >> 2] = HEAPU8[$2 + 87 | 0];
    jsExceptionHere(1, 14743, $2);
    break block;
   }
   if (!(!HEAPU8[$2 + 87 | 0] | HEAPU8[$2 + 87 | 0] <= 22 & HEAPU8[$2 + 87 | 0] >= 17)) {
    jsExceptionHere(1, 7405, 0);
    break block;
   }
   jsiSetConsoleDevice(HEAPU8[$2 + 87 | 0], HEAP8[$2 + 103 | 0] & 1);
  }
  __stack_pointer = $2 + 112 | 0;
 }
 
 function jswrap_espruino_getConsole() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 11 | 0] = jsiGetConsoleDevice();
  block : {
   if (!HEAPU8[$0 + 11 | 0]) {
    HEAP32[$0 + 12 >> 2] = jsvNewNull_1683();
    break block;
   }
   HEAP32[$0 + 12 >> 2] = jsvNewFromString(jshGetDeviceString(HEAPU8[$0 + 11 | 0]));
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jsvNewNull_1683() {
  return jsvNewWithFlags(2);
 }
 
 function jswrap_espruino_reverseByte($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2] & 255;
  return Math_imul(Math_imul(HEAP32[$1 + 8 >> 2], 2050) & 139536 | Math_imul(HEAP32[$1 + 8 >> 2], 32800) & 558144, 65793) >>> 16 & 255;
 }
 
 function jswrap_e_dumpFragmentation() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  while (1) {
   if (HEAPU32[$0 + 24 >> 2] < jsvGetMemoryTotal() >>> 0) {
    HEAP32[$0 + 20 >> 2] = _jsvGetAddressOf(HEAP32[$0 + 24 >> 2] + 1 & 65535);
    $1 = HEAP32[$0 + 20 >> 2];
    if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
     HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2]
    }
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$0 + 12 >> 2] < HEAPU32[$0 + 28 >> 2]) {
    HEAP32[$0 + 8 >> 2] = _jsvGetAddressOf(HEAP32[$0 + 12 >> 2] + 1 & 65535);
    $1 = HEAP32[$0 + 8 >> 2];
    block : {
     if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63)) {
      jsiConsolePrintString(27706);
      $1 = HEAP32[$0 + 16 >> 2];
      HEAP32[$0 + 16 >> 2] = $1 + 1;
      if (($1 | 0) > 80) {
       jsiConsolePrintString(28752);
       HEAP32[$0 + 16 >> 2] = 0;
      }
      break block;
     }
     block1 : {
      if (jsvGetLocks(HEAP32[$0 + 8 >> 2]) & 255) {
       jsiConsolePrintString(21349);
       break block1;
      }
      jsiConsolePrintString(27313);
     }
     $1 = HEAP32[$0 + 16 >> 2];
     HEAP32[$0 + 16 >> 2] = $1 + 1;
     if (($1 | 0) > 80) {
      jsiConsolePrintString(28752);
      HEAP32[$0 + 16 >> 2] = 0;
     }
     if (jsvIsFlatString(HEAP32[$0 + 8 >> 2]) & 1) {
      HEAP32[$0 + 4 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 8 >> 2]);
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2] + HEAP32[$0 + 12 >> 2];
      while (1) {
       $1 = HEAP32[$0 + 4 >> 2];
       HEAP32[$0 + 4 >> 2] = $1 - 1;
       if ($1) {
        jsiConsolePrintString(21748);
        $1 = HEAP32[$0 + 16 >> 2];
        HEAP32[$0 + 16 >> 2] = $1 + 1;
        if (($1 | 0) > 80) {
         jsiConsolePrintString(28752);
         HEAP32[$0 + 16 >> 2] = 0;
        }
        continue;
       }
       break;
      };
     }
    }
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  jsiConsolePrintString(28752);
  __stack_pointer = $0 + 32 | 0;
 }
 
 function jswrap_e_dumpVariables() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0;
  $0 = __stack_pointer - 128 | 0;
  __stack_pointer = $0;
  jsiConsolePrintf(28604, 0);
  HEAP32[$0 + 124 >> 2] = 0;
  while (1) {
   if (HEAPU32[$0 + 124 >> 2] < jsvGetMemoryTotal() >>> 0) {
    HEAP16[$0 + 122 >> 1] = HEAP32[$0 + 124 >> 2] + 1;
    HEAP32[$0 + 116 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 122 >> 1]);
    $1 = HEAP32[$0 + 116 >> 2];
    block : {
     if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63)) {
      break block
     }
     if (jsvIsStringExt(HEAP32[$0 + 116 >> 2]) & 1) {
      break block
     }
     HEAP32[$0 + 112 >> 2] = 1;
     block1 : {
      if (jsvIsFlatString(HEAP32[$0 + 116 >> 2]) & 1) {
       HEAP32[$0 + 108 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 116 >> 2]);
       HEAP32[$0 + 124 >> 2] = HEAP32[$0 + 108 >> 2] + HEAP32[$0 + 124 >> 2];
       HEAP32[$0 + 112 >> 2] = HEAP32[$0 + 108 >> 2] + HEAP32[$0 + 112 >> 2];
       break block1;
      }
      if (jsvHasCharacterData(HEAP32[$0 + 116 >> 2]) & 1) {
       HEAP16[$0 + 106 >> 1] = jsvGetLastChild(HEAP32[$0 + 116 >> 2]);
       while (1) {
        if (HEAPU16[$0 + 106 >> 1]) {
         HEAP32[$0 + 100 >> 2] = jsvLock(HEAPU16[$0 + 106 >> 1]);
         HEAP32[$0 + 112 >> 2] = HEAP32[$0 + 112 >> 2] + 1;
         HEAP16[$0 + 106 >> 1] = jsvGetLastChild(HEAP32[$0 + 100 >> 2]);
         jsvUnLock(HEAP32[$0 + 100 >> 2]);
         continue;
        }
        break;
       };
      }
     }
     $2 = HEAPU16[$0 + 122 >> 1];
     $3 = HEAP32[$0 + 112 >> 2];
     $1 = HEAP32[$0 + 116 >> 2];
     HEAP32[$0 + 72 >> 2] = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63;
     HEAP32[$0 + 68 >> 2] = $3;
     HEAP32[$0 + 64 >> 2] = $2;
     jsiConsolePrintf(22822, $0 - -64 | 0);
     block2 : {
      if (jsvIsName(HEAP32[$0 + 116 >> 2]) & 1) {
       HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 116 >> 2];
       jsiConsolePrintf(22796, $0 + 16 | 0);
       break block2;
      }
      block3 : {
       if (jsvIsNumeric(HEAP32[$0 + 116 >> 2]) & 1) {
        HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 116 >> 2];
        jsiConsolePrintf(22800, $0 + 32 | 0);
        break block3;
       }
       block5 : {
        if (jsvIsString(HEAP32[$0 + 116 >> 2]) & 1) {
         block4 : {
          if (jsvGetStringLength(HEAP32[$0 + 116 >> 2]) >>> 0 > 20) {
           HEAP32[$0 + 96 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$0 + 116 >> 2], 0, 17);
           jsvAppendString(HEAP32[$0 + 96 >> 2], 22775);
           break block4;
          }
          HEAP32[$0 + 96 >> 2] = jsvLockAgain(HEAP32[$0 + 116 >> 2]);
         }
         HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 96 >> 2];
         jsiConsolePrintf(22811, $0 + 48 | 0);
         jsvUnLock(HEAP32[$0 + 96 >> 2]);
         break block5;
        }
        block6 : {
         if (jsvIsObject(HEAP32[$0 + 116 >> 2]) & 1) {
          jsiConsolePrintf(22788, 0);
          break block6;
         }
         block7 : {
          if (jsvIsArray(HEAP32[$0 + 116 >> 2]) & 1) {
           jsiConsolePrintf(22781, 0);
           break block7;
          }
          jsiConsolePrintf(22853, 0);
         }
        }
       }
      }
     }
     block8 : {
      if (!(jsvHasSingleChild(HEAP32[$0 + 116 >> 2]) & 1)) {
       if (!(jsvHasChildren(HEAP32[$0 + 116 >> 2]) & 1)) {
        break block8
       }
      }
      HEAP16[$0 + 94 >> 1] = jsvGetFirstChild(HEAP32[$0 + 116 >> 2]);
      while (1) {
       if (HEAPU16[$0 + 94 >> 1]) {
        HEAP32[$0 + 88 >> 2] = jsvLock(HEAPU16[$0 + 94 >> 1]);
        HEAP32[$0 >> 2] = HEAPU16[$0 + 94 >> 1];
        jsiConsolePrintf(22828, $0);
        block9 : {
         if (jsvHasChildren(HEAP32[$0 + 116 >> 2]) & 1) {
          HEAP16[$0 + 94 >> 1] = jsvGetNextSibling(HEAP32[$0 + 88 >> 2]);
          break block9;
         }
         HEAP16[$0 + 94 >> 1] = 0;
        }
        jsvUnLock(HEAP32[$0 + 88 >> 2]);
        continue;
       }
       break;
      };
     }
     jsiConsolePrintString(28752);
    }
    HEAP32[$0 + 124 >> 2] = HEAP32[$0 + 124 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $0 + 128 | 0;
 }
 
 function jswrap_espruino_getSizeOf($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block1 : {
   block : {
    if (HEAP32[$2 + 20 >> 2] <= 0) {
     break block
    }
    if (!(jsvHasChildren(HEAP32[$2 + 24 >> 2]) & 1)) {
     break block
    }
    HEAP32[$2 + 16 >> 2] = jsvNewEmptyArray();
    if (!HEAP32[$2 + 16 >> 2]) {
     HEAP32[$2 + 28 >> 2] = 0;
     break block1;
    }
    jsvObjectIteratorNew($2 + 12 | 0, HEAP32[$2 + 24 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_1688($2 + 12 | 0) & 1) {
      HEAP32[$2 + 8 >> 2] = jsvObjectIteratorGetKey_1689($2 + 12 | 0);
      HEAP32[$2 + 4 >> 2] = jsvSkipName(HEAP32[$2 + 8 >> 2]);
      HEAP32[$2 >> 2] = jsvNewObject();
      if (HEAP32[$2 >> 2]) {
       jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 17830, jsvAsString(HEAP32[$2 + 8 >> 2]));
       jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 17227, jswrap_espruino_getSizeOf(HEAP32[$2 + 8 >> 2], 0));
       block2 : {
        if (HEAP32[$2 + 20 >> 2] <= 1) {
         break block2
        }
        if (!(jsvHasChildren(HEAP32[$2 + 4 >> 2]) & 1)) {
         break block2
        }
        jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 17713, jswrap_espruino_getSizeOf(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 20 >> 2] - 1 | 0));
       }
       jsvArrayPushAndUnLock(HEAP32[$2 + 16 >> 2], HEAP32[$2 >> 2]);
      }
      jsvUnLock2(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
      jsvObjectIteratorNext($2 + 12 | 0);
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1690($2 + 12 | 0);
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
    break block1;
   }
   HEAP32[$2 + 28 >> 2] = jsvNewFromInteger(jsvCountJsVarsUsed(HEAP32[$2 + 24 >> 2]));
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1688($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetKey_1689($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1690($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_espruino_getAddressOf($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP8[$2 + 7 | 0] = $1;
  block : {
   if (HEAP8[$2 + 7 | 0] & 1) {
    HEAP32[$2 >> 2] = 0;
    HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2);
    break block;
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_espruino_mapInPlace($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 176 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 172 >> 2] = $0;
  HEAP32[$4 + 168 >> 2] = $1;
  HEAP32[$4 + 164 >> 2] = $2;
  HEAP32[$4 + 160 >> 2] = $3;
  block1 : {
   block : {
    if (jsvIsArrayBuffer(HEAP32[$4 + 172 >> 2]) & 1) {
     if (jsvIsArrayBuffer(HEAP32[$4 + 168 >> 2]) & 1) {
      break block
     }
    }
    jsExceptionHere(1, 7025, 0);
    break block1;
   }
   block2 : {
    if (!HEAP32[$4 + 164 >> 2]) {
     break block2
    }
    if (jsvIsArray(HEAP32[$4 + 164 >> 2]) & 1) {
     break block2
    }
    if (jsvIsArrayBuffer(HEAP32[$4 + 164 >> 2]) & 1) {
     break block2
    }
    if (jsvIsFunction(HEAP32[$4 + 164 >> 2]) & 1) {
     break block2
    }
    jsExceptionHere(1, 3635, 0);
    break block1;
   }
   HEAP8[$4 + 159 | 0] = jsvIsFunction(HEAP32[$4 + 164 >> 2]) & 1;
   HEAP32[$4 + 152 >> 2] = (HEAPU8[HEAP32[$4 + 172 >> 2] + 5 | 0] & 15) << 3;
   HEAP8[$4 + 151 | 0] = 1;
   if (HEAP32[$4 + 160 >> 2] < 0) {
    HEAP32[$4 + 160 >> 2] = 0 - HEAP32[$4 + 160 >> 2];
    HEAP8[$4 + 151 | 0] = 0;
   }
   if (!HEAP32[$4 + 160 >> 2]) {
    HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 152 >> 2]
   }
   jsvArrayBufferIteratorNew($4 + 88 | 0, HEAP32[$4 + 172 >> 2], 0);
   HEAP32[$4 + 24 >> 2] = 0;
   HEAP32[$4 + 20 >> 2] = 0;
   jsvArrayBufferIteratorNew($4 + 28 | 0, HEAP32[$4 + 168 >> 2], 0);
   while (1) {
    block3 : {
     if (!(jsvArrayBufferIteratorHasElement($4 + 88 | 0) & 1)) {
      $0 = 0;
      if (HEAP32[$4 + 20 >> 2] < HEAP32[$4 + 160 >> 2]) {
       break block3
      }
     }
     $0 = jsvArrayBufferIteratorHasElement($4 + 28 | 0);
    }
    if ($0 & 1) {
     block4 : {
      if (HEAP8[$4 + 159 | 0] & 1) {
       $0 = jsvArrayBufferIteratorGetIndex($4 + 88 | 0);
       break block4;
      }
      $0 = 0;
     }
     HEAP32[$4 + 16 >> 2] = $0;
     while (1) {
      if (HEAP32[$4 + 20 >> 2] < HEAP32[$4 + 160 >> 2]) {
       block5 : {
        if (HEAP8[$4 + 151 | 0] & 1) {
         HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] << HEAP32[$4 + 152 >> 2] | jsvArrayBufferIteratorGetIntegerValue($4 + 88 | 0);
         break block5;
        }
        HEAP32[$4 + 24 >> 2] = jsvArrayBufferIteratorGetIntegerValue($4 + 88 | 0) << HEAP32[$4 + 20 >> 2] | HEAP32[$4 + 24 >> 2];
       }
       jsvArrayBufferIteratorNext($4 + 88 | 0);
       HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 152 >> 2] + HEAP32[$4 + 20 >> 2];
       continue;
      }
      break;
     };
     block6 : {
      if (HEAP8[$4 + 151 | 0] & 1) {
       HEAP32[$4 + 12 >> 2] = (1 << HEAP32[$4 + 160 >> 2]) - 1 & HEAP32[$4 + 24 >> 2] >> HEAP32[$4 + 20 >> 2] - HEAP32[$4 + 160 >> 2];
       break block6;
      }
      HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] & (1 << HEAP32[$4 + 160 >> 2]) - 1;
      HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] >> HEAP32[$4 + 160 >> 2];
     }
     HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] - HEAP32[$4 + 160 >> 2];
     block9 : {
      if (HEAP32[$4 + 164 >> 2]) {
       HEAP32[$4 + 8 >> 2] = 0;
       block7 : {
        if (HEAP8[$4 + 159 | 0] & 1) {
         HEAP32[$4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 12 >> 2]);
         HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 16 >> 2];
         HEAP32[$4 + 8 >> 2] = jspeFunctionCall(HEAP32[$4 + 164 >> 2], 0, 0, 0, 2, $4);
         jsvUnLock(HEAP32[$4 >> 2]);
         break block7;
        }
        block8 : {
         if (jsvIsArray(HEAP32[$4 + 164 >> 2]) & 1) {
          HEAP32[$4 + 8 >> 2] = jsvGetArrayItem(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 12 >> 2]);
          break block8;
         }
         HEAP32[$4 + 8 >> 2] = jsvArrayBufferGet(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 12 >> 2]);
        }
       }
       jsvArrayBufferIteratorSetValue($4 + 28 | 0, HEAP32[$4 + 8 >> 2], 0);
       jsvUnLock(HEAP32[$4 + 8 >> 2]);
       break block9;
      }
      jsvArrayBufferIteratorSetIntegerValue($4 + 28 | 0, HEAP32[$4 + 12 >> 2]);
     }
     jsvUnLock(HEAP32[$4 + 16 >> 2]);
     jsvArrayBufferIteratorNext($4 + 28 | 0);
     continue;
    }
    break;
   };
   jsvArrayBufferIteratorFree($4 + 88 | 0);
   jsvArrayBufferIteratorFree($4 + 28 | 0);
  }
  __stack_pointer = $4 + 176 | 0;
 }
 
 function jswrap_espruino_lookupNoCase($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP8[$3 + 83 | 0] = $2;
  block : {
   if (!(jsvHasChildren(HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   if ((jsvGetString(HEAP32[$3 + 84 >> 2], $3 + 16 | 0, 64) | 0) == 64) {
    HEAP32[$3 >> 2] = 64;
    jsExceptionHere(1, 24588, $3);
   }
   if (HEAP8[$3 + 83 | 0] & 1) {
    HEAP32[$3 + 12 >> 2] = jsvFindChildFromStringI(HEAP32[$3 + 88 >> 2], $3 + 16 | 0);
    if (HEAP32[$3 + 12 >> 2]) {
     HEAP32[$3 + 92 >> 2] = jsvAsStringAndUnLock(HEAP32[$3 + 12 >> 2]);
     break block;
    }
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 92 >> 2] = jsvObjectGetChildI(HEAP32[$3 + 88 >> 2], $3 + 16 | 0);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_e_dumpStr() {
  var $0 = 0;
  $0 = __stack_pointer - 48 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 40 >> 2] = jsvNewFromEmptyString_1676();
  block : {
   if (!HEAP32[$0 + 40 >> 2]) {
    HEAP32[$0 + 44 >> 2] = 0;
    break block;
   }
   jsvStringIteratorNew($0, HEAP32[$0 + 40 >> 2], 0);
   jsiDumpState(2, $0);
   jsvStringIteratorFree_1667($0);
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 40 >> 2];
  }
  __stack_pointer = $0 + 48 | 0;
  return HEAP32[$0 + 44 >> 2];
 }
 
 function jswrap_espruino_CRC32($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  block : {
   if (!(jsvIsIterable(HEAP32[$1 + 72 >> 2]) & 1)) {
    HEAP32[$1 + 76 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($1 + 8 | 0, HEAP32[$1 + 72 >> 2], 1);
   HEAP32[$1 + 4 >> 2] = -1;
   while (1) {
    if (jsvIteratorHasElement($1 + 8 | 0) & 1) {
     HEAP32[$1 + 4 >> 2] = jsvIteratorGetIntegerValue($1 + 8 | 0) & 255 ^ HEAP32[$1 + 4 >> 2];
     HEAP32[$1 >> 2] = 0;
     while (1) {
      if (HEAP32[$1 >> 2] < 8) {
       HEAP32[$1 + 4 >> 2] = 0 - (HEAP32[$1 + 4 >> 2] & 1) & -306674912 ^ HEAP32[$1 + 4 >> 2] >>> 1;
       HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
       continue;
      }
      break;
     };
     jsvIteratorNext($1 + 8 | 0);
     continue;
    }
    break;
   };
   jsvIteratorFree($1 + 8 | 0);
   HEAP32[$1 + 76 >> 2] = jsvNewFromLongInteger(HEAP32[$1 + 4 >> 2] ^ -1, 0);
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jswrap_espruino_HSBtoRGB_int($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 80 | 0;
  HEAPF64[$3 + 64 >> 3] = $0;
  HEAPF64[$3 + 56 >> 3] = $1;
  HEAPF64[$3 + 48 >> 3] = $2;
  block : {
   if (HEAPF64[$3 + 48 >> 3] == 0.0) {
    HEAP32[$3 + 76 >> 2] = 0;
    break block;
   }
   if (HEAPF64[$3 + 56 >> 3] == 0.0) {
    $0 = HEAPF64[$3 + 48 >> 3] * 255.0;
    if (Math_abs($0) < 2147483647.0) {
     $4 = ~~$0
    } else {
     $4 = -2147483648
    }
    HEAP32[$3 + 44 >> 2] = $4;
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 44 >> 2] | (HEAP32[$3 + 44 >> 2] << 16 | HEAP32[$3 + 44 >> 2] << 8);
    break block;
   }
   HEAPF64[$3 + 64 >> 3] = (HEAPF64[$3 + 64 >> 3] - Math_floor(HEAPF64[$3 + 64 >> 3])) * 6.0;
   $0 = HEAPF64[$3 + 64 >> 3];
   if (Math_abs($0) < 2147483647.0) {
    $4 = ~~$0
   } else {
    $4 = -2147483648
   }
   HEAP32[$3 + 32 >> 2] = $4;
   HEAPF64[$3 + 8 >> 3] = HEAPF64[$3 + 64 >> 3] - +HEAP32[$3 + 32 >> 2];
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] % 6;
   HEAPF64[$3 + 48 >> 3] = HEAPF64[$3 + 48 >> 3] * 255.0;
   $0 = HEAPF64[$3 + 48 >> 3];
   if (Math_abs($0) < 2147483647.0) {
    $4 = ~~$0
   } else {
    $4 = -2147483648
   }
   HEAP32[$3 + 28 >> 2] = $4;
   $0 = (1.0 - HEAPF64[$3 + 56 >> 3]) * HEAPF64[$3 + 48 >> 3];
   if (Math_abs($0) < 2147483647.0) {
    $4 = ~~$0
   } else {
    $4 = -2147483648
   }
   HEAP32[$3 + 24 >> 2] = $4;
   $0 = (-HEAPF64[$3 + 56 >> 3] * HEAPF64[$3 + 8 >> 3] + 1.0) * HEAPF64[$3 + 48 >> 3];
   if (Math_abs($0) < 2147483647.0) {
    $4 = ~~$0
   } else {
    $4 = -2147483648
   }
   HEAP32[$3 + 20 >> 2] = $4;
   $0 = (-HEAPF64[$3 + 56 >> 3] * (1.0 - HEAPF64[$3 + 8 >> 3]) + 1.0) * HEAPF64[$3 + 48 >> 3];
   if (Math_abs($0) < 2147483647.0) {
    $4 = ~~$0
   } else {
    $4 = -2147483648
   }
   HEAP32[$3 + 16 >> 2] = $4;
   block1 : {
    if (!HEAP32[$3 + 32 >> 2]) {
     HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
     HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 16 >> 2];
     HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 24 >> 2];
     break block1;
    }
    block2 : {
     if (HEAP32[$3 + 32 >> 2] == 1) {
      HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 20 >> 2];
      HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 28 >> 2];
      HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 24 >> 2];
      break block2;
     }
     block3 : {
      if (HEAP32[$3 + 32 >> 2] == 2) {
       HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
       HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 28 >> 2];
       HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 16 >> 2];
       break block3;
      }
      block4 : {
       if (HEAP32[$3 + 32 >> 2] == 3) {
        HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
        HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 20 >> 2];
        HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 28 >> 2];
        break block4;
       }
       block5 : {
        if (HEAP32[$3 + 32 >> 2] == 4) {
         HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 16 >> 2];
         HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2];
         HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 28 >> 2];
         break block5;
        }
        block6 : {
         if (HEAP32[$3 + 32 >> 2] == 5) {
          HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
          HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2];
          HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 20 >> 2];
          break block6;
         }
         HEAP32[$3 + 44 >> 2] = 0;
         HEAP32[$3 + 40 >> 2] = 0;
         HEAP32[$3 + 36 >> 2] = 0;
        }
       }
      }
     }
    }
   }
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 44 >> 2] | (HEAP32[$3 + 36 >> 2] << 16 | HEAP32[$3 + 40 >> 2] << 8);
  }
  return HEAP32[$3 + 76 >> 2];
 }
 
 function jswrap_espruino_HSBtoRGB($0, $1, $2, $3) {
  $0 = +$0;
  $1 = +$1;
  $2 = +$2;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 80 | 0;
  __stack_pointer = $4;
  HEAPF64[$4 + 64 >> 3] = $0;
  HEAPF64[$4 + 56 >> 3] = $1;
  HEAPF64[$4 + 48 >> 3] = $2;
  HEAP32[$4 + 44 >> 2] = $3;
  HEAP32[$4 + 40 >> 2] = jswrap_espruino_HSBtoRGB_int(HEAPF64[$4 + 64 >> 3], HEAPF64[$4 + 56 >> 3], HEAPF64[$4 + 48 >> 3]);
  block1 : {
   if (!(HEAP32[$4 + 44 >> 2] != 24 ? HEAP32[$4 + 44 >> 2] : 0)) {
    HEAP32[$4 + 76 >> 2] = jsvNewFromInteger(HEAP32[$4 + 40 >> 2]);
    break block1;
   }
   HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 40 >> 2] & 255;
   HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 40 >> 2] >> 8 & 255;
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 40 >> 2] >> 16 & 255;
   if (HEAP32[$4 + 44 >> 2] == 16) {
    HEAP32[$4 + 76 >> 2] = jsvNewFromInteger(HEAP32[$4 + 32 >> 2] >> 2 << 5 | HEAP32[$4 + 28 >> 2] >> 3 | HEAP32[$4 + 36 >> 2] >> 3 << 11);
    break block1;
   }
   if (HEAP32[$4 + 44 >> 2] != 1) {
    jsExceptionHere(1, 22286, 0);
    HEAP32[$4 + 76 >> 2] = 0;
    break block1;
   }
   HEAP32[$4 + 16 >> 2] = jsvNewFromInteger(HEAP32[$4 + 36 >> 2]);
   HEAP32[$4 + 20 >> 2] = jsvNewFromInteger(HEAP32[$4 + 32 >> 2]);
   HEAP32[$4 + 24 >> 2] = jsvNewFromInteger(HEAP32[$4 + 28 >> 2]);
   HEAP32[$4 + 12 >> 2] = jsvNewArray($4 + 16 | 0, 3);
   jsvUnLockMany(3, $4 + 16 | 0);
   HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 12 >> 2];
  }
  __stack_pointer = $4 + 80 | 0;
  return HEAP32[$4 + 76 >> 2];
 }
 
 function jswrap_espruino_setPassword($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2])
  }
  jsvUnLock(jsvObjectSetChild(HEAP32[103308], 18349, HEAP32[$1 + 12 >> 2]));
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_espruino_lockConsole() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 18349);
  if (HEAP32[$0 + 12 >> 2]) {
   HEAP16[207230] = HEAPU16[207230] | 1024
  }
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jswrap_espruino_setTimeZone($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 8 >> 3] = $0;
  jswrap_espruino_setDST(0);
  $3 = HEAP32[103308];
  $0 = HEAPF64[$1 + 8 >> 3] * 60.0;
  if (Math_abs($0) < 2147483647.0) {
   $2 = ~~$0
  } else {
   $2 = -2147483648
  }
  jsvObjectSetChildAndUnLock($3, 3469, jsvNewFromInteger($2));
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_espruino_setDST($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
    jsvObjectRemoveChild(HEAP32[103308], 4484);
    break block;
   }
   block1 : {
    if (jsvIsArray(HEAP32[$1 + 12 >> 2]) & 1) {
     if ((jsvGetLength(HEAP32[$1 + 12 >> 2]) | 0) == 12) {
      break block1
     }
    }
    jsExceptionHere(1, 6789, 0);
    break block;
   }
   jsvObjectRemoveChild(HEAP32[103308], 3469);
   HEAP32[$1 + 8 >> 2] = jswrap_typedarray_constructor(18, HEAP32[$1 + 12 >> 2], 0, 0);
   jsvObjectSetChildAndUnLock(HEAP32[103308], 4484, HEAP32[$1 + 8 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_espruino_memoryMap($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
  $0 = jspExecuteJSFunctionCode(16003, 21750, 0, 0, 2, $2);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_espruino_asm($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jsExceptionHere(1, 19282, 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_espruino_compiledC($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsExceptionHere(1, 19358, 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_espruino_reboot() {
  jswrap_interface_reset(0);
 }
 
 function jswrap_espruino_getBattery() {
  return 0;
 }
 
 function jswrap_espruino_getPowerUsage() {
  var $0 = 0, $1 = 0.0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 24 >> 2] = jsvNewObject();
  block : {
   if (!HEAP32[$0 + 24 >> 2]) {
    HEAP32[$0 + 28 >> 2] = 0;
    break block;
   }
   jsvGetProcessorPowerUsage(HEAP32[$0 + 24 >> 2]);
   if (jshPinGetState(8) & 16) {
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 24 >> 2], 22488, jsvNewFromInteger(8e3))
   }
   jswGetPowerUsage(HEAP32[$0 + 24 >> 2]);
   HEAPF64[$0 + 16 >> 3] = 0;
   jsvObjectIteratorNew($0 + 12 | 0, HEAP32[$0 + 24 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1688($0 + 12 | 0) & 1) {
     $1 = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_1708($0 + 12 | 0));
     HEAPF64[$0 + 16 >> 3] = HEAPF64[$0 + 16 >> 3] + $1;
     jsvObjectIteratorNext($0 + 12 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1690($0 + 12 | 0);
   HEAP32[$0 + 8 >> 2] = jsvNewObject();
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 18331, HEAP32[$0 + 24 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 15914, jsvNewFromFloat(HEAPF64[$0 + 16 >> 3]));
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 8 >> 2];
  }
  __stack_pointer = $0 + 32 | 0;
  return HEAP32[$0 + 28 >> 2];
 }
 
 function jsvObjectIteratorGetValue_1708($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_espruino_decodeUTF8($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 128 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 120 >> 2] = $0;
  HEAP32[$3 + 116 >> 2] = $1;
  HEAP32[$3 + 112 >> 2] = $2;
  block : {
   if (!(jsvIsString(HEAP32[$3 + 120 >> 2]) & 1)) {
    jsExceptionHere(1, 16768, 0);
    HEAP32[$3 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 28 >> 2] = jsvNewFromEmptyString_1676();
   jsvStringIteratorNew($3 + 72 | 0, HEAP32[$3 + 120 >> 2], 0);
   jsvStringIteratorNew($3 + 32 | 0, HEAP32[$3 + 28 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1710($3 + 72 | 0) & 1) {
     HEAP8[$3 + 27 | 0] = jsvStringIteratorGetCharAndNext($3 + 72 | 0);
     HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0];
     HEAP32[$3 + 16 >> 2] = 0;
     if (HEAPU8[$3 + 27 | 0] > 127) {
      block1 : {
       if ((HEAPU8[$3 + 27 | 0] & 224) == 192) {
        HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0] & 31;
        HEAP32[$3 + 16 >> 2] = 1;
        break block1;
       }
       block2 : {
        if ((HEAPU8[$3 + 27 | 0] & 240) == 224) {
         HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0] & 15;
         HEAP32[$3 + 16 >> 2] = 2;
         break block2;
        }
        if ((HEAPU8[$3 + 27 | 0] & 248) == 240) {
         HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0] & 7;
         HEAP32[$3 + 16 >> 2] = 3;
        }
       }
      }
      while (1) {
       $0 = HEAP32[$3 + 16 >> 2];
       HEAP32[$3 + 16 >> 2] = $0 - 1;
       if ($0) {
        HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] << 6 | jsvStringIteratorGetCharAndNext($3 + 72 | 0) & 63;
        continue;
       }
       break;
      };
     }
     block3 : {
      if (HEAP32[$3 + 20 >> 2] <= 255) {
       jsvStringIteratorAppend($3 + 32 | 0, HEAP32[$3 + 20 >> 2] << 24 >> 24);
       break block3;
      }
      HEAP32[$3 + 12 >> 2] = 0;
      block4 : {
       if (jsvIsArray(HEAP32[$3 + 116 >> 2]) & 1) {
        HEAP32[$3 + 12 >> 2] = jsvGetArrayItem(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 20 >> 2]);
        break block4;
       }
       if (jsvIsObject(HEAP32[$3 + 116 >> 2]) & 1) {
        HEAP32[$3 + 8 >> 2] = jsvNewFromInteger(HEAP32[$3 + 20 >> 2]);
        HEAP32[$3 + 12 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 8 >> 2], 0));
        jsvUnLock(HEAP32[$3 + 8 >> 2]);
       }
      }
      block5 : {
       if (HEAP32[$3 + 12 >> 2]) {
        break block5
       }
       if (!(jsvIsFunction(HEAP32[$3 + 112 >> 2]) & 1)) {
        break block5
       }
       HEAP32[$3 + 4 >> 2] = jsvNewFromInteger(HEAP32[$3 + 20 >> 2]);
       HEAP32[$3 + 12 >> 2] = jspExecuteFunction(HEAP32[$3 + 112 >> 2], 0, 1, $3 + 4 | 0);
       jsvUnLock(HEAP32[$3 + 4 >> 2]);
      }
      block6 : {
       if (HEAP32[$3 + 12 >> 2]) {
        break block6
       }
       if (!(jsvIsString(HEAP32[$3 + 112 >> 2]) & 1)) {
        break block6
       }
       HEAP32[$3 + 12 >> 2] = jsvLockAgain(HEAP32[$3 + 112 >> 2]);
      }
      if (HEAP32[$3 + 12 >> 2]) {
       HEAP32[$3 + 12 >> 2] = jsvAsStringAndUnLock(HEAP32[$3 + 12 >> 2]);
       jsvStringIteratorAppendString($3 + 32 | 0, HEAP32[$3 + 12 >> 2], 0, 2147483647);
       jsvUnLock(HEAP32[$3 + 12 >> 2]);
      }
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1667($3 + 72 | 0);
   jsvStringIteratorFree_1667($3 + 32 | 0);
   HEAP32[$3 + 124 >> 2] = HEAP32[$3 + 28 >> 2];
  }
  __stack_pointer = $3 + 128 | 0;
  return HEAP32[$3 + 124 >> 2];
 }
 
 function jsvStringIteratorHasChar_1710($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jswrap_espruino_stopEventPropagation() {
  block : {
   if (HEAPU16[207230] & 8192) {
    HEAP16[207230] = HEAPU16[207230] | 16384;
    break block;
   }
   jsExceptionHere(1, 6689, 0);
  }
 }
 
 function jswrap_flash_getPage($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  block : {
   if (!(jshFlashGetPage(HEAP32[$1 + 24 >> 2], $1 + 20 | 0, $1 + 16 | 0) & 1)) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvNewObject();
   if (!HEAP32[$1 + 12 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 8391, jsvNewFromInteger(HEAP32[$1 + 20 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 16212, jsvNewFromInteger(HEAP32[$1 + 16 >> 2]));
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jswrap_flash_getFree() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jshFlashGetFree();
  if (!HEAP32[$0 + 12 >> 2]) {
   HEAP32[$0 + 12 >> 2] = jsvNewEmptyArray()
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_flash_erasePage($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  block : {
   if (!(jsvIsInt(HEAP32[$1 + 12 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
    jsExceptionHere(1, 5706, $1);
    break block;
   }
   jshFlashErasePage(jsvGetInteger(HEAP32[$1 + 12 >> 2]));
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_flash_write($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  $2 = $3;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  block : {
   if (jsvIsUndefined(HEAP32[$2 + 12 >> 2]) & 1) {
    jsExceptionHere(1, 19151, 0);
    break block;
   }
   HEAP32[$2 + 4 >> 2] = 0;
   HEAP32[$2 >> 2] = jsvGetDataPointer(HEAP32[$2 + 12 >> 2], $2 + 4 | 0);
   if (!(HEAP32[$2 >> 2] | !HEAP32[$2 + 12 >> 2])) {
    HEAP32[$2 + 4 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 12 >> 2]);
    block2 : {
     if (HEAP32[$2 + 4 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
      jsExceptionHere(1, 20608, 0);
      break block2;
     }
     $3 = $3 - (HEAP32[$2 + 4 >> 2] + 15 & -16) | 0;
     __stack_pointer = $3;
     HEAP32[$2 >> 2] = $3;
     jsvIterateCallbackToBytes(HEAP32[$2 + 12 >> 2], HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
    }
   }
   if (!HEAP32[$2 >> 2] | !HEAP32[$2 + 4 >> 2]) {
    break block
   }
   jshFlashWriteAligned(HEAP32[$2 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_flash_read($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP32[$2 + 68 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 72 >> 2] <= 0) {
    HEAP32[$2 + 76 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 64 >> 2] = jsvNewTypedArray(1, HEAP32[$2 + 72 >> 2]);
   if (!HEAP32[$2 + 64 >> 2]) {
    HEAP32[$2 + 76 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 56 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 64 >> 2], $2 + 60 | 0);
   if (HEAP32[$2 + 56 >> 2]) {
    jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 60 >> 2]);
    while (1) {
     $0 = 0;
     if (HEAP32[$2 + 72 >> 2] > 0) {
      $0 = jsvStringIteratorHasChar_1717($2 + 16 | 0)
     }
     if ($0 & 1) {
      HEAP32[$2 + 8 >> 2] = 0;
      jsvStringIteratorGetPtrAndNext($2 + 16 | 0, $2 + 12 | 0, $2 + 8 | 0);
      jshFlashRead(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 68 >> 2], HEAP32[$2 + 8 >> 2]);
      HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 68 >> 2];
      HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 72 >> 2] - HEAP32[$2 + 8 >> 2];
      continue;
     }
     break;
    };
    jsvStringIteratorFree_1718($2 + 16 | 0);
    jsvUnLock(HEAP32[$2 + 56 >> 2]);
   }
   HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 64 >> 2];
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAP32[$2 + 76 >> 2];
 }
 
 function jsvStringIteratorHasChar_1717($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorFree_1718($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_setBusyIndicator($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = HEAPU8[244433];
  HEAP8[244433] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
  if (HEAPU8[244433] != HEAPU8[$1 + 11 | 0]) {
   if (HEAPU8[$1 + 11 | 0] != 255) {
    jshPinOutput(HEAPU8[$1 + 11 | 0], 0)
   }
   if (HEAPU8[244433] != 255) {
    jshPinOutput(HEAPU8[244433], 1)
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_setSleepIndicator($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = HEAPU8[244434];
  HEAP8[244434] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
  if (HEAPU8[244434] != HEAPU8[$1 + 11 | 0]) {
   if (HEAPU8[$1 + 11 | 0] != 255) {
    jshPinOutput(HEAPU8[$1 + 11 | 0], 0)
   }
   if (HEAPU8[244434] != 255) {
    jshPinOutput(HEAPU8[244434], 1)
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_load($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP16[207230] = HEAPU16[207230] | 64;
  jsvObjectSetChild(HEAP32[103308], 19451, HEAP32[$1 + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_reset($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  HEAP16[207230] = HEAPU16[207230] | 128;
  if (HEAP8[$1 + 15 | 0] & 1) {
   jsfRemoveCodeFromFlash()
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_edit($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP32[$1 + 24 >> 2] = 0;
  block : {
   if (jsvIsString(HEAP32[$1 + 28 >> 2]) & 1) {
    HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 28 >> 2]);
    HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[103307], HEAP32[$1 + 28 >> 2], 0));
    break block;
   }
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
   HEAP32[$1 + 28 >> 2] = jsvGetPathTo(HEAP32[103307], HEAP32[$1 + 24 >> 2], 4, 0);
  }
  block2 : {
   if (jsvIsString(HEAP32[$1 + 28 >> 2]) & 1) {
    if (jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1) {
     HEAP32[$1 + 20 >> 2] = jsvFindChildFromString(HEAP32[$1 + 24 >> 2], 15114);
     HEAP32[$1 + 16 >> 2] = jsvGetIndexOf(HEAP32[103307], HEAP32[$1 + 24 >> 2], 1);
     $2 = HEAP32[$1 + 20 >> 2] ? $2 : HEAP32[$1 + 16 >> 2] != 0;
     HEAP8[$1 + 15 | 0] = $2;
     jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
     HEAP32[$1 + 8 >> 2] = jsvNewFromEmptyString_1724();
     if (HEAP32[$1 + 8 >> 2]) {
      HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
      block1 : {
       if (HEAP8[$1 + 15 | 0] & 1) {
        jsvAppendString(HEAP32[$1 + 8 >> 2], 27501);
        jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 28 >> 2]);
        jsvAppendStringVar(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2], 9, 2147483647);
        break block1;
       }
       jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 28 >> 2]);
       jsvAppendString(HEAP32[$1 + 8 >> 2], 27024);
       jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
       jsvAppendString(HEAP32[$1 + 8 >> 2], 22218);
      }
      jsvUnLock(HEAP32[$1 + 4 >> 2]);
      jsiReplaceInputLine(HEAP32[$1 + 8 >> 2]);
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
     }
     break block2;
    }
    jsExceptionHere(1, 15255, 0);
    break block2;
   }
   jsExceptionHere(1, 26024, 0);
  }
  jsvUnLock2(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 28 >> 2]);
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jsvNewFromEmptyString_1724() {
  return jsvNewWithFlags(29);
 }
 
 function jswrap_interface_echo($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP8[$1 + 15 | 0] = $0;
  block : {
   if (HEAP8[$1 + 15 | 0] & 1) {
    HEAP16[207230] = HEAPU16[207230] & -2;
    break block;
   }
   HEAP16[207230] = HEAPU16[207230] | 1;
  }
 }
 
 function jswrap_interactive_setTime($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAPF64[$1 + 24 >> 3] = $0;
  jshInterruptOff();
  $2 = jshGetTimeFromMilliseconds(HEAPF64[$1 + 24 >> 3] * 1.0e3);
  HEAP32[$1 + 16 >> 2] = $2;
  HEAP32[$1 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
  $2 = HEAP32[$1 + 20 >> 2];
  HEAP32[103632] = HEAP32[$1 + 16 >> 2];
  HEAP32[103633] = $2;
  $2 = jshGetSystemTime();
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
  $2 = HEAP32[$1 + 20 >> 2];
  jshSetSystemTime(HEAP32[$1 + 16 >> 2], $2);
  $2 = HEAP32[$1 + 16 >> 2];
  $3 = $2;
  $2 = HEAP32[$1 + 12 >> 2];
  $5 = $2;
  $4 = HEAP32[$1 + 8 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  jstSystemTimeChanged($3 - $4 | 0, $2 - (($3 >>> 0 < $4 >>> 0) + $5 | 0) | 0);
  jshInterruptOn();
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jswrap_interface_getSerial() {
  var $0 = 0;
  $0 = __stack_pointer + -64 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 8 >> 2] = jshGetSerialNumber($0 + 16 | 0, 32);
  HEAP32[$0 + 4 >> 2] = jsvNewFromEmptyString_1724();
  block : {
   if (!HEAP32[$0 + 4 >> 2]) {
    HEAP32[$0 + 60 >> 2] = 0;
    break block;
   }
   HEAP32[$0 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$0 + 12 >> 2] < HEAP32[$0 + 8 >> 2]) {
     if (!(!HEAP32[$0 + 12 >> 2] | HEAP32[$0 + 12 >> 2] & 3)) {
      jsvAppendString(HEAP32[$0 + 4 >> 2], 22779)
     }
     itostr_1728(HEAPU8[HEAP32[$0 + 12 >> 2] + ($0 + 16 | 0) | 0] | 256, $0 + 52 | 0, 16);
     jsvAppendString(HEAP32[$0 + 4 >> 2], $0 + 53 | 0);
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 4 >> 2];
  }
  __stack_pointer = $0 - -64 | 0;
  return HEAP32[$0 + 60 >> 2];
 }
 
 function itostr_1728($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function _jswrap_interface_setTimeoutOrInterval($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $4 = __stack_pointer + -64 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 56 >> 2] = $0;
  HEAPF64[$4 + 48 >> 3] = $1;
  HEAP32[$4 + 44 >> 2] = $2;
  HEAP8[$4 + 43 | 0] = $3;
  block1 : {
   block : {
    if (jsvIsFunction(HEAP32[$4 + 56 >> 2]) & 1) {
     break block
    }
    if (jsvIsString(HEAP32[$4 + 56 >> 2]) & 1) {
     break block
    }
    jsExceptionHere(1, 27375, 0);
    HEAP32[$4 + 60 >> 2] = 0;
    break block1;
   }
   $0 = __DOUBLE_BITS_1731(HEAPF64[$4 + 48 >> 3]);
   $3 = $0;
   $2 = i64toi32_i32$HIGH_BITS;
   $0 = $2 & 2147483647;
   $2 = $3;
   if (!(!(HEAPF64[$4 + 48 >> 3] < .1) & (!$2 & ($0 | 0) == 2146435072 | $0 >>> 0 < 2146435072))) {
    HEAPF64[$4 + 48 >> 3] = .1
   }
   if (HEAPF64[$4 + 48 >> 3] > 31536000001.0e3) {
    jsExceptionHere(1, 24664, 0);
    HEAP32[$4 + 60 >> 2] = 0;
    break block1;
   }
   HEAP32[$4 + 36 >> 2] = jsvNewObject();
   if (!HEAP32[$4 + 36 >> 2]) {
    HEAP32[$4 + 60 >> 2] = 0;
    break block1;
   }
   $2 = jshGetTimeFromMilliseconds(HEAPF64[$4 + 48 >> 3]);
   HEAP32[$4 + 24 >> 2] = $2;
   $0 = i64toi32_i32$HIGH_BITS;
   HEAP32[$4 + 28 >> 2] = $0;
   $8 = HEAP32[$4 + 36 >> 2];
   $0 = jshGetSystemTime();
   $7 = $0;
   $2 = i64toi32_i32$HIGH_BITS;
   $6 = $2;
   $0 = HEAP32[103633];
   $9 = $0;
   $2 = HEAP32[103632];
   $3 = $2;
   $5 = $7 - $2 | 0;
   $0 = $6;
   $2 = $9;
   $6 = $0 - ($2 + ($3 >>> 0 > $7 >>> 0) | 0) | 0;
   $0 = $5;
   $3 = HEAP32[$4 + 24 >> 2];
   $2 = $0 + $3 | 0;
   $5 = HEAP32[$4 + 28 >> 2] + $6 | 0;
   $5 = $2 >>> 0 < $3 >>> 0 ? $5 + 1 | 0 : $5;
   jsvObjectSetChildAndUnLock($8, 17804, jsvNewFromLongInteger($2, $5));
   if (!(HEAP8[$4 + 43 | 0] & 1)) {
    $5 = HEAP32[$4 + 24 >> 2];
    $0 = HEAP32[$4 + 28 >> 2];
    jsvObjectSetChildAndUnLock(HEAP32[$4 + 36 >> 2], 7687, jsvNewFromLongInteger($5, $0));
   }
   jsvObjectSetChild(HEAP32[$4 + 36 >> 2], 20492, HEAP32[$4 + 56 >> 2]);
   if (jsvGetArrayLength(HEAP32[$4 + 44 >> 2])) {
    jsvObjectSetChild(HEAP32[$4 + 36 >> 2], 7217, HEAP32[$4 + 44 >> 2])
   }
   HEAP32[$4 + 20 >> 2] = jsvNewFromInteger(jsiTimerAdd(HEAP32[$4 + 36 >> 2]));
   jsvUnLock(HEAP32[$4 + 36 >> 2]);
   jsiTimersChanged();
   HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 20 >> 2];
  }
  __stack_pointer = $4 - -64 | 0;
  return HEAP32[$4 + 60 >> 2];
 }
 
 function __DOUBLE_BITS_1731($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_interface_setInterval($0, $1, $2) {
  $0 = $0 | 0;
  $1 = +$1;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAPF64[$3 + 16 >> 3] = $1;
  HEAP32[$3 + 12 >> 2] = $2;
  $0 = _jswrap_interface_setTimeoutOrInterval(HEAP32[$3 + 28 >> 2], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2], 0);
  __stack_pointer = $3 + 32 | 0;
  return $0 | 0;
 }
 
 function jswrap_interface_setTimeout($0, $1, $2) {
  $0 = $0 | 0;
  $1 = +$1;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAPF64[$3 + 16 >> 3] = $1;
  HEAP32[$3 + 12 >> 2] = $2;
  $0 = _jswrap_interface_setTimeoutOrInterval(HEAP32[$3 + 28 >> 2], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2], 1);
  __stack_pointer = $3 + 32 | 0;
  return $0 | 0;
 }
 
 function _jswrap_interface_clearTimeoutOrInterval($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP8[$2 + 43 | 0] = $1;
  block2 : {
   block : {
    if (!(jsvIsUndefined(HEAP32[$2 + 44 >> 2]) & 1)) {
     if (jsvGetArrayLength(HEAP32[$2 + 44 >> 2])) {
      break block
     }
    }
    jsvObjectIteratorNew($2 + 36 | 0, HEAP32[103613]);
    while (1) {
     if (jsvObjectIteratorHasValue_1735($2 + 36 | 0) & 1) {
      HEAP32[$2 + 32 >> 2] = jsvObjectIteratorGetValue_1736($2 + 36 | 0);
      HEAP32[$2 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 32 >> 2], 16521);
      block1 : {
       if (!HEAP32[$2 + 28 >> 2]) {
        jsvObjectIteratorRemoveAndGotoNext($2 + 36 | 0, HEAP32[103613]);
        break block1;
       }
       jsvObjectIteratorNext($2 + 36 | 0);
      }
      jsvUnLock2(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 32 >> 2]);
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1737($2 + 36 | 0);
    break block2;
   }
   HEAP32[$2 + 24 >> 2] = jsvGetArrayItem(HEAP32[$2 + 44 >> 2], 0);
   block3 : {
    if (jsvIsUndefined(HEAP32[$2 + 24 >> 2]) & 1) {
     HEAP32[$2 + 20 >> 2] = HEAP8[$2 + 43 | 0] & 1 ? 4441 : 15900;
     $0 = HEAP32[$2 + 20 >> 2];
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 20 >> 2];
     HEAP32[$2 >> 2] = $0;
     jsExceptionHere(1, 19456, $2);
     break block3;
    }
    block4 : {
     if (jsvIsBasic(HEAP32[$2 + 24 >> 2]) & 1) {
      $0 = jsvFindChildFromVar(HEAP32[103613], HEAP32[$2 + 24 >> 2], 0);
      break block4;
     }
     $0 = 0;
    }
    HEAP32[$2 + 16 >> 2] = $0;
    if (HEAP32[$2 + 16 >> 2]) {
     jsvRemoveChildAndUnLock(HEAP32[103613], HEAP32[$2 + 16 >> 2])
    }
    jsvUnLock(HEAP32[$2 + 24 >> 2]);
   }
  }
  jsiTimersChanged();
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jsvObjectIteratorHasValue_1735($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1736($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1737($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_clearInterval($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  _jswrap_interface_clearTimeoutOrInterval(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_clearTimeout($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  _jswrap_interface_clearTimeoutOrInterval(HEAP32[$1 + 12 >> 2], 1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_interface_changeInterval($0, $1) {
  $0 = $0 | 0;
  $1 = +$1;
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAPF64[$2 + 16 >> 3] = $1;
  if (HEAPF64[$2 + 16 >> 3] < .1) {
   HEAPF64[$2 + 16 >> 3] = .1
  }
  block : {
   if (jsvIsBasic(HEAP32[$2 + 28 >> 2]) & 1) {
    $0 = jsvFindChildFromVar(HEAP32[103613], HEAP32[$2 + 28 >> 2], 0);
    break block;
   }
   $0 = 0;
  }
  HEAP32[$2 + 12 >> 2] = $0;
  block1 : {
   if (HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 8 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 12 >> 2]);
    HEAP32[$2 >> 2] = jshGetTimeFromMilliseconds(HEAPF64[$2 + 16 >> 3]);
    $0 = i64toi32_i32$HIGH_BITS;
    HEAP32[$2 + 4 >> 2] = $0;
    $0 = HEAP32[$2 >> 2];
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 7687, jsvNewFromLongInteger($0, HEAP32[$2 + 4 >> 2]));
    $7 = HEAP32[$2 + 8 >> 2];
    $6 = jshGetSystemTime();
    $0 = i64toi32_i32$HIGH_BITS;
    $5 = $0;
    $0 = HEAP32[103632];
    $4 = $0;
    $3 = $6 - $0 | 0;
    $0 = HEAP32[103633];
    $5 = $5 - ($0 + ($4 >>> 0 > $6 >>> 0) | 0) | 0;
    $4 = HEAP32[$2 >> 2];
    $0 = $4 + $3 | 0;
    $3 = HEAP32[$2 + 4 >> 2] + $5 | 0;
    $3 = $0 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
    jsvObjectSetChildAndUnLock($7, 17804, jsvNewFromLongInteger($0, $3));
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
    jsiTimersChanged();
    break block1;
   }
   jsExceptionHere(1, 15892, 0);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function _jswrap_io_peek($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (HEAP32[$2 + 4 >> 2] == 1) {
    HEAP32[$2 + 12 >> 2] = HEAPU8[HEAP32[$2 + 8 >> 2]];
    break block;
   }
   if (HEAP32[$2 + 4 >> 2] == 2) {
    HEAP32[$2 + 12 >> 2] = HEAPU8[HEAP32[$2 + 8 >> 2]] | HEAPU8[HEAP32[$2 + 8 >> 2] + 1 | 0] << 8;
    break block;
   }
   if (HEAP32[$2 + 4 >> 2] == 4) {
    HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 0;
  }
  return HEAP32[$2 + 12 >> 2];
 }
 
 function jswrap_io_peek($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  HEAP32[$3 + 76 >> 2] = jshFlashGetMemMapAddress(HEAP32[$3 + 88 >> 2]);
  block : {
   if (HEAP32[$3 + 84 >> 2] <= 1) {
    HEAP32[$3 + 92 >> 2] = jsvNewFromLongInteger(_jswrap_io_peek(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 80 >> 2]), 0);
    break block;
   }
   if (HEAP32[$3 + 80 >> 2] == 1) {
    HEAP8[$3 + 75 | 0] = 1
   }
   if (HEAP32[$3 + 80 >> 2] == 2) {
    HEAP8[$3 + 75 | 0] = 2
   }
   if (HEAP32[$3 + 80 >> 2] == 4) {
    HEAP8[$3 + 75 | 0] = 4
   }
   HEAP32[$3 + 68 >> 2] = jsvNewTypedArray(HEAPU8[$3 + 75 | 0], HEAP32[$3 + 84 >> 2]);
   if (!HEAP32[$3 + 68 >> 2]) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   jsvArrayBufferIteratorNew($3 + 8 | 0, HEAP32[$3 + 68 >> 2], 0);
   while (1) {
    if (jsvArrayBufferIteratorHasElement($3 + 8 | 0) & 1) {
     jsvArrayBufferIteratorSetIntegerValue($3 + 8 | 0, _jswrap_io_peek(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 80 >> 2]));
     HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 80 >> 2] + HEAP32[$3 + 76 >> 2];
     jsvArrayBufferIteratorNext($3 + 8 | 0);
     continue;
    }
    break;
   };
   jsvArrayBufferIteratorFree($3 + 8 | 0);
   HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 68 >> 2];
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function _jswrap_io_poke($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  block : {
   if (HEAP32[$3 + 4 >> 2] == 1) {
    HEAP8[HEAP32[$3 + 12 >> 2]] = HEAP32[$3 + 8 >> 2];
    break block;
   }
   block1 : {
    if (HEAP32[$3 + 4 >> 2] == 2) {
     HEAP16[HEAP32[$3 + 12 >> 2] >> 1] = HEAP32[$3 + 8 >> 2];
     break block1;
    }
    if (HEAP32[$3 + 4 >> 2] == 4) {
     HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 8 >> 2]
    }
   }
  }
 }
 
 function jswrap_io_poke($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 76 >> 2] = $0;
  HEAP32[$3 + 72 >> 2] = $1;
  HEAP32[$3 + 68 >> 2] = $2;
  block : {
   if (jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1) {
    _jswrap_io_poke(HEAP32[$3 + 76 >> 2], jsvGetInteger(HEAP32[$3 + 72 >> 2]), HEAP32[$3 + 68 >> 2]);
    break block;
   }
   if (jsvIsIterable(HEAP32[$3 + 72 >> 2]) & 1) {
    jsvIteratorNew($3 + 4 | 0, HEAP32[$3 + 72 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($3 + 4 | 0) & 1) {
      _jswrap_io_poke(HEAP32[$3 + 76 >> 2], jsvIteratorGetIntegerValue($3 + 4 | 0), HEAP32[$3 + 68 >> 2]);
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 76 >> 2];
      jsvIteratorNext($3 + 4 | 0);
      continue;
     }
     break;
    };
    jsvIteratorFree($3 + 4 | 0);
   }
  }
  __stack_pointer = $3 + 80 | 0;
 }
 
 function jswrap_io_analogWrite($0, $1, $2) {
  $0 = $0 | 0;
  $1 = +$1;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 47 | 0] = $0;
  HEAPF64[$3 + 32 >> 3] = $1;
  HEAP32[$3 + 28 >> 2] = $2;
  HEAPF64[$3 + 16 >> 3] = 0;
  HEAP32[$3 + 12 >> 2] = 0;
  if (jsvIsObject(HEAP32[$3 + 28 >> 2]) & 1) {
   HEAPF64[$3 + 16 >> 3] = jsvObjectGetFloatChild(HEAP32[$3 + 28 >> 2], 14634);
   block : {
    if (jsvObjectGetBoolChild(HEAP32[$3 + 28 >> 2], 4874) & 1) {
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] | 2;
     break block;
    }
    if (jsvObjectGetBoolChild(HEAP32[$3 + 28 >> 2], 4869) & 1) {
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] | 1
    }
   }
  }
  jshPinAnalogOutput(HEAPU8[$3 + 47 | 0], HEAPF64[$3 + 32 >> 3], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2]);
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jswrap_io_digitalPulse($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0;
  $3 = __stack_pointer - 176 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 175 | 0] = $0;
  HEAP8[$3 + 174 | 0] = $1;
  HEAP32[$3 + 168 >> 2] = $2;
  block : {
   if (!(jshIsPinValid(HEAPU8[$3 + 175 | 0]) & 1)) {
    jsExceptionHere(1, 15501, 0);
    break block;
   }
   HEAP32[$3 + 136 >> 2] = jstGetUtilTimerOffset();
   HEAP8[$3 + 135 | 0] = jstGetLastPinTimerTask(HEAPU8[$3 + 175 | 0], $3 + 143 | 0) & 1;
   if (!(HEAP8[$3 + 135 | 0] & 1)) {
    HEAP8[$3 + 143 | 0] = 0;
    HEAP8[$3 + 144 | 0] = 0;
    HEAP8[$3 + 145 | 0] = 0;
    HEAP8[$3 + 146 | 0] = 0;
   }
   if (!(HEAP8[$3 + 135 | 0] & 1)) {
    jshPinOutput(HEAPU8[$3 + 175 | 0], HEAP8[$3 + 174 | 0] & 1)
   }
   if (jsvIsNumeric(HEAP32[$3 + 168 >> 2]) & 1) {
    HEAPF64[$3 + 120 >> 3] = jsvGetFloat(HEAP32[$3 + 168 >> 2]);
    block3 : {
     block2 : {
      block1 : {
       if (HEAPF64[$3 + 120 >> 3] < 0.0) {
        break block1
       }
       $4 = __DOUBLE_BITS_1748(HEAPF64[$3 + 120 >> 3]);
       $1 = $4;
       $0 = i64toi32_i32$HIGH_BITS;
       $4 = $0 & 2147483647;
       $0 = $1;
       if (($4 | 0) == 2146435072 & ($0 | 0) != 0 | $4 >>> 0 > 2146435072) {
        break block1
       }
       break block2;
      }
      jsExceptionHere(1, 8342, 0);
      break block3;
     }
     block4 : {
      if (HEAPF64[$3 + 120 >> 3] > 0.0) {
       $0 = jshGetTimeFromMilliseconds(HEAPF64[$3 + 120 >> 3]);
       $2 = $0;
       $4 = i64toi32_i32$HIGH_BITS;
       $1 = $4;
       $4 = HEAPU8[$3 + 143 | 0] | HEAPU8[$3 + 144 | 0] << 8 | (HEAPU8[$3 + 145 | 0] << 16 | HEAPU8[$3 + 146 | 0] << 24);
       $0 = $4 >> 31;
       $2 = $4 + $2 | 0;
       $4 = $0;
       $0 = $1;
       HEAP8[$3 + 143 | 0] = $2;
       HEAP8[$3 + 144 | 0] = $2 >>> 8;
       HEAP8[$3 + 145 | 0] = $2 >>> 16;
       HEAP8[$3 + 146 | 0] = $2 >>> 24;
       $1 = HEAPU8[$3 + 143 | 0] | HEAPU8[$3 + 144 | 0] << 8 | (HEAPU8[$3 + 145 | 0] << 16 | HEAPU8[$3 + 146 | 0] << 24);
       $2 = $1 >> 31;
       jstPinOutputAtTime($1, $2, $3 + 136 | 0, $3 + 175 | 0, 1, (HEAPU8[$3 + 174 | 0] ^ -1) & 1);
       break block4;
      }
      jstUtilTimerWaitEmpty();
     }
    }
    break block;
   }
   block5 : {
    if (jsvIsIterable(HEAP32[$3 + 168 >> 2]) & 1) {
     jsvIteratorNew($3 + 56 | 0, HEAP32[$3 + 168 >> 2], 1);
     while (1) {
      if (jsvIteratorHasElement($3 + 56 | 0) & 1) {
       HEAPF64[$3 + 48 >> 3] = jsvIteratorGetFloatValue($3 + 56 | 0);
       $2 = __DOUBLE_BITS_1748(HEAPF64[$3 + 48 >> 3]);
       $0 = $2;
       $1 = i64toi32_i32$HIGH_BITS;
       $2 = $1 & 2147483647;
       $1 = $0;
       if ((!$1 & ($2 | 0) == 2146435072 | $2 >>> 0 < 2146435072) & HEAPF64[$3 + 48 >> 3] > 0.0) {
        $1 = jshGetTimeFromMilliseconds(HEAPF64[$3 + 48 >> 3]);
        $5 = $1;
        $2 = i64toi32_i32$HIGH_BITS;
        $4 = $2;
        $2 = HEAPU8[$3 + 143 | 0] | HEAPU8[$3 + 144 | 0] << 8 | (HEAPU8[$3 + 145 | 0] << 16 | HEAPU8[$3 + 146 | 0] << 24);
        $1 = $2 >> 31;
        $0 = $2;
        $2 = $1;
        $1 = $4;
        $2 = $2 + $1 | 0;
        $1 = $5;
        $4 = $0 + $1 | 0;
        HEAP8[$3 + 143 | 0] = $4;
        HEAP8[$3 + 144 | 0] = $4 >>> 8;
        HEAP8[$3 + 145 | 0] = $4 >>> 16;
        HEAP8[$3 + 146 | 0] = $4 >>> 24;
        $2 = HEAPU8[$3 + 143 | 0] | HEAPU8[$3 + 144 | 0] << 8 | (HEAPU8[$3 + 145 | 0] << 16 | HEAPU8[$3 + 146 | 0] << 24);
        $1 = $2 >> 31;
        jstPinOutputAtTime($2, $1, $3 + 136 | 0, $3 + 175 | 0, 1, (HEAPU8[$3 + 174 | 0] ^ -1) & 1);
       }
       HEAP8[$3 + 174 | 0] = (HEAPU8[$3 + 174 | 0] ^ -1) & 1;
       jsvIteratorNext($3 + 56 | 0);
       continue;
      }
      break;
     };
     jsvIteratorFree($3 + 56 | 0);
     break block5;
    }
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 168 >> 2];
    jsExceptionHere(1, 5354, $3 + 32 | 0);
   }
  }
  __stack_pointer = $3 + 176 | 0;
 }
 
 function __DOUBLE_BITS_1748($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_io_digitalWrite($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP32[$2 + 40 >> 2] = $1;
  block : {
   if (jsvIsBoolean(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP32[$2 + 36 >> 2] = jsvGetBool(HEAP32[$2 + 40 >> 2]) & 1 ? -1 : 0;
    break block;
   }
   HEAP32[$2 + 36 >> 2] = jsvGetInteger(HEAP32[$2 + 40 >> 2]);
  }
  block1 : {
   if (jsvIsArray(HEAP32[$2 + 44 >> 2]) & 1) {
    HEAP16[$2 + 34 >> 1] = jsvGetLastChild(HEAP32[$2 + 44 >> 2]);
    while (1) {
     if (HEAPU16[$2 + 34 >> 1]) {
      HEAP32[$2 + 28 >> 2] = jsvLock(HEAPU16[$2 + 34 >> 1]);
      HEAP32[$2 + 24 >> 2] = jsvSkipName(HEAP32[$2 + 28 >> 2]);
      jshPinOutput(jshGetPinFromVar(HEAP32[$2 + 24 >> 2]) & 255, HEAP32[$2 + 36 >> 2] & 1);
      jsvUnLock(HEAP32[$2 + 24 >> 2]);
      HEAP16[$2 + 34 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 28 >> 2]);
      jsvUnLock(HEAP32[$2 + 28 >> 2]);
      HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] >> 1;
      continue;
     }
     break;
    };
    break block1;
   }
   block3 : {
    if (jsvIsObject(HEAP32[$2 + 44 >> 2]) & 1) {
     HEAP32[$2 + 20 >> 2] = jspGetNamedField(HEAP32[$2 + 44 >> 2], 17522, 0);
     block2 : {
      if (jsvIsFunction(HEAP32[$2 + 20 >> 2]) & 1) {
       HEAP32[$2 + 16 >> 2] = jsvNewFromInteger(HEAP32[$2 + 36 >> 2]);
       jsvUnLock2(jspeFunctionCall(HEAP32[$2 + 20 >> 2], 0, HEAP32[$2 + 44 >> 2], 0, 1, $2 + 16 | 0), HEAP32[$2 + 16 >> 2]);
       break block2;
      }
      jsExceptionHere(1, 15501, 0);
     }
     jsvUnLock(HEAP32[$2 + 20 >> 2]);
     break block3;
    }
    HEAP8[$2 + 15 | 0] = jshGetPinFromVar(HEAP32[$2 + 44 >> 2]);
    jshPinOutput(HEAPU8[$2 + 15 | 0], HEAP32[$2 + 36 >> 2] != 0);
   }
  }
  __stack_pointer = $2 + 48 | 0;
 }
 
 function jswrap_io_digitalRead($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 40 >> 2] = $0;
  block : {
   if (jsvIsArray(HEAP32[$1 + 40 >> 2]) & 1) {
    HEAP32[$1 + 36 >> 2] = 0;
    HEAP32[$1 + 32 >> 2] = 0;
    jsvObjectIteratorNew($1 + 28 | 0, HEAP32[$1 + 40 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_1751($1 + 28 | 0) & 1) {
      HEAP32[$1 + 24 >> 2] = jsvObjectIteratorGetValue_1752($1 + 28 | 0);
      HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] << 1 | jshPinInput(jshGetPinFromVar(HEAP32[$1 + 24 >> 2]) & 255) & 1;
      jsvUnLock(HEAP32[$1 + 24 >> 2]);
      jsvObjectIteratorNext($1 + 28 | 0);
      HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 36 >> 2] + 1;
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1753($1 + 28 | 0);
    if (!HEAP32[$1 + 36 >> 2]) {
     HEAP32[$1 + 44 >> 2] = 0;
     break block;
    }
    HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 32 >> 2];
    break block;
   }
   if (jsvIsObject(HEAP32[$1 + 40 >> 2]) & 1) {
    HEAP32[$1 + 20 >> 2] = 0;
    HEAP32[$1 + 16 >> 2] = jspGetNamedField(HEAP32[$1 + 40 >> 2], 19570, 0);
    block1 : {
     if (jsvIsFunction(HEAP32[$1 + 16 >> 2]) & 1) {
      HEAP32[$1 + 20 >> 2] = jsvGetIntegerAndUnLock(jspeFunctionCall(HEAP32[$1 + 16 >> 2], 0, HEAP32[$1 + 40 >> 2], 0, 0, 0));
      break block1;
     }
     jsExceptionHere(1, 15501, 0);
    }
    jsvUnLock(HEAP32[$1 + 16 >> 2]);
    HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 20 >> 2];
    break block;
   }
   HEAP8[$1 + 15 | 0] = jshGetPinFromVar(HEAP32[$1 + 40 >> 2]);
   HEAP32[$1 + 44 >> 2] = jshPinInput(HEAPU8[$1 + 15 | 0]) & 1;
  }
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 44 >> 2];
 }
 
 function jsvObjectIteratorHasValue_1751($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1752($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jsvObjectIteratorFree_1753($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_io_pinMode($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 15 | 0] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  block : {
   if (!(jshIsPinValid(HEAPU8[$3 + 15 | 0]) & 1)) {
    jsExceptionHere(1, 15501, 0);
    break block;
   }
   HEAP8[$3 + 6 | 0] = 0;
   if (jsvIsString(HEAP32[$3 + 8 >> 2]) & 1) {
    block1 : {
     if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 16563) & 1) {
      HEAP8[$3 + 6 | 0] = 7;
      break block1;
     }
     block2 : {
      if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 4286) & 1) {
       HEAP8[$3 + 6 | 0] = 4;
       break block2;
      }
      block3 : {
       if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 14869) & 1) {
        HEAP8[$3 + 6 | 0] = 5;
        break block3;
       }
       block4 : {
        if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 15128) & 1) {
         HEAP8[$3 + 6 | 0] = 6;
         break block4;
        }
        block5 : {
         if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 4279) & 1) {
          HEAP8[$3 + 6 | 0] = 1;
          break block5;
         }
         block6 : {
          if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 15522) & 1) {
           HEAP8[$3 + 6 | 0] = 2;
           break block6;
          }
          block7 : {
           if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 14882) & 1) {
            HEAP8[$3 + 6 | 0] = 3;
            break block7;
           }
           block8 : {
            if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 4276) & 1) {
             HEAP8[$3 + 6 | 0] = 8;
             break block8;
            }
            if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 15519) & 1) {
             HEAP8[$3 + 6 | 0] = 9
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
   if (HEAPU8[$3 + 6 | 0]) {
    jshSetPinStateIsManual(HEAPU8[$3 + 15 | 0], (HEAPU8[$3 + 7 | 0] ^ -1) & 1);
    jshPinSetState(HEAPU8[$3 + 15 | 0], HEAPU8[$3 + 6 | 0]);
    break block;
   }
   jshSetPinStateIsManual(HEAPU8[$3 + 15 | 0], 0);
   block9 : {
    if (jsvIsUndefined(HEAP32[$3 + 8 >> 2]) & 1) {
     break block9
    }
    if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 15092) & 1) {
     break block9
    }
    jsExceptionHere(1, 18206, 0);
   }
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_io_getPinMode($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 11 | 0] = $0;
  block : {
   if (!(jshIsPinValid(HEAPU8[$1 + 11 | 0]) & 1)) {
    jsExceptionHere(1, 15501, 0);
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jshGetPinStateString(jshPinGetState(HEAPU8[$1 + 11 | 0]) & 255);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_io_shiftOutCallback($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2];
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2]) {
    HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2] - 1;
    while (1) {
     if (HEAP32[$2 + 16 >> 2] >= 0) {
      if (jshIsPinValid(HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2] | 0]) & 1) {
       jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2] | 0], HEAP32[$2 + 28 >> 2] & 1)
      }
      HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] >> 1;
      HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] - 1;
      continue;
     }
     break;
    };
    if (jshIsPinValid(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0]) & 1) {
     jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0], HEAP8[HEAP32[$2 + 20 >> 2] + 9 | 0] & 1);
     jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0], (HEAPU8[HEAP32[$2 + 20 >> 2] + 9 | 0] ^ -1) & 1);
    }
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_io_shiftOut($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 92 >> 2] = $0;
  HEAP32[$3 + 88 >> 2] = $1;
  HEAP32[$3 + 84 >> 2] = $2;
  HEAP32[$3 + 76 >> 2] = 0;
  HEAP8[$3 + 72 | 0] = 255;
  HEAP8[$3 + 73 | 0] = 0;
  HEAP32[$3 + 80 >> 2] = 1;
  HEAP32[$3 + 16 >> 2] = 15967;
  HEAP16[$3 + 20 >> 1] = 13;
  HEAP16[($3 + 16 | 0) + 6 >> 1] = 0;
  HEAP32[$3 + 24 >> 2] = $3 + 72;
  HEAP32[$3 + 28 >> 2] = 15748;
  HEAP16[$3 + 32 >> 1] = 12;
  HEAP16[($3 + 16 | 0) + 18 >> 1] = 0;
  HEAP32[$3 + 36 >> 2] = $3 + 73;
  HEAP32[$3 + 40 >> 2] = 5042;
  HEAP16[$3 + 44 >> 1] = 10;
  HEAP16[($3 + 16 | 0) + 30 >> 1] = 0;
  HEAP32[$3 + 48 >> 2] = $3 + 80;
  block : {
   if (!(jsvReadConfigObject(HEAP32[$3 + 88 >> 2], $3 + 16 | 0, 3) & 1)) {
    break block
   }
   HEAP8[$3 + 73 | 0] = HEAP8[$3 + 73 | 0] & 1;
   if (HEAP32[$3 + 80 >> 2] <= 0) {
    HEAP32[$3 + 80 >> 2] = 1
   }
   block1 : {
    if (jsvIsArray(HEAP32[$3 + 92 >> 2]) & 1) {
     jsvObjectIteratorNew($3 + 12 | 0, HEAP32[$3 + 92 >> 2]);
     while (1) {
      if (jsvObjectIteratorHasValue_1751($3 + 12 | 0) & 1) {
       if (HEAP32[$3 + 76 >> 2] >= 8) {
        HEAP32[$3 >> 2] = 8;
        jsExceptionHere(1, 15595, $3);
        break block;
       } else {
        $0 = jshGetPinFromVarAndUnLock(jsvObjectIteratorGetValue_1752($3 + 12 | 0));
        HEAP8[HEAP32[$3 + 76 >> 2] + ($3 - -64 | 0) | 0] = $0;
        HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
        jsvObjectIteratorNext($3 + 12 | 0);
        continue;
       }
      }
      break;
     };
     jsvObjectIteratorFree_1753($3 + 12 | 0);
     break block1;
    }
    $1 = jshGetPinFromVar(HEAP32[$3 + 92 >> 2]);
    $0 = HEAP32[$3 + 76 >> 2];
    HEAP32[$3 + 76 >> 2] = $0 + 1;
    HEAP8[($3 - -64 | 0) + $0 | 0] = $1;
   }
   HEAP32[$3 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 8 >> 2] < HEAP32[$3 + 76 >> 2]) {
     if (jshIsPinValid(HEAPU8[HEAP32[$3 + 8 >> 2] + ($3 - -64 | 0) | 0]) & 1) {
      if (!(jshGetPinStateIsManual(HEAPU8[HEAP32[$3 + 8 >> 2] + ($3 - -64 | 0) | 0]) & 1)) {
       jshPinSetState(HEAPU8[HEAP32[$3 + 8 >> 2] + ($3 - -64 | 0) | 0], 1)
      }
     }
     HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 1;
     continue;
    }
    break;
   };
   if (jshIsPinValid(HEAPU8[$3 + 72 | 0]) & 1) {
    jshPinSetState(HEAPU8[$3 + 72 | 0], 1)
   }
   jsvIterateCallback(HEAP32[$3 + 84 >> 2], 643, $3 - -64 | 0);
  }
  __stack_pointer = $3 + 96 | 0;
 }
 
 function jswrap_interface_setWatch($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 72 >> 2] = $0;
  HEAP8[$3 + 71 | 0] = $1;
  HEAP32[$3 + 64 >> 2] = $2;
  block : {
   if (!(jshIsPinValid(HEAPU8[$3 + 71 | 0]) & 1)) {
    jsError(15501, 0);
    HEAP32[$3 + 76 >> 2] = 0;
    break block;
   }
   block1 : {
    if (jsiIsWatchingPin(HEAPU8[$3 + 71 | 0]) & 1) {
     break block1
    }
    if (jshCanWatch(HEAPU8[$3 + 71 | 0]) & 1) {
     break block1
    }
    jsWarn(16392, 0);
    HEAP32[$3 + 76 >> 2] = 0;
    break block;
   }
   HEAP8[$3 + 63 | 0] = 0;
   HEAPF64[$3 + 48 >> 3] = 0;
   HEAP32[$3 + 44 >> 2] = 0;
   HEAP8[$3 + 43 | 0] = 0;
   HEAP8[$3 + 42 | 0] = 0;
   HEAP8[$3 + 41 | 0] = 255;
   if (HEAPU8[$3 + 71 | 0] == 17) {
    HEAP32[$3 + 44 >> 2] = 1;
    HEAPF64[$3 + 48 >> 3] = 25;
   }
   block7 : {
    if (jsvIsObject(HEAP32[$3 + 64 >> 2]) & 1) {
     HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 5042);
     if (HEAP32[$3 + 36 >> 2]) {
      HEAP8[$3 + 63 | 0] = jsvGetBoolAndUnLock(HEAP32[$3 + 36 >> 2]) & 1
     }
     HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 18264);
     if (HEAP32[$3 + 36 >> 2]) {
      HEAPF64[$3 + 48 >> 3] = jsvGetFloatAndUnLock(HEAP32[$3 + 36 >> 2])
     }
     $1 = __DOUBLE_BITS_1748(HEAPF64[$3 + 48 >> 3]);
     $0 = $1;
     $2 = i64toi32_i32$HIGH_BITS;
     $1 = $2 & 2147483647;
     $2 = $0;
     if (!(!(HEAPF64[$3 + 48 >> 3] < 0.0) & (!$2 & ($1 | 0) == 2146435072 | $1 >>> 0 < 2146435072))) {
      HEAPF64[$3 + 48 >> 3] = 0
     }
     HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 18082);
     if (!(jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1)) {
      block3 : {
       if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
        HEAP32[$3 + 32 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
        HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 32 >> 2] > 0 ? 1 : HEAP32[$3 + 32 >> 2] < 0 ? -1 : 0;
        break block3;
       }
       HEAP32[$3 + 44 >> 2] = -1e3;
       if (jsvIsString(HEAP32[$3 + 36 >> 2]) & 1) {
        block4 : {
         if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 16606) & 1) {
          HEAP32[$3 + 44 >> 2] = 1;
          break block4;
         }
         block5 : {
          if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 16995) & 1) {
           HEAP32[$3 + 44 >> 2] = -1;
           break block5;
          }
          if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 16174) & 1) {
           HEAP32[$3 + 44 >> 2] = 0
          }
         }
        }
       }
      }
     }
     jsvUnLock(HEAP32[$3 + 36 >> 2]);
     if (!(HEAP32[$3 + 44 >> 2] <= 1 & HEAP32[$3 + 44 >> 2] >= -1)) {
      jsExceptionHere(3, 27133, 0);
      HEAP32[$3 + 76 >> 2] = 0;
      break block;
     }
     HEAP8[$3 + 43 | 0] = jsvObjectGetBoolChild(HEAP32[$3 + 64 >> 2], 14630) & 1;
     HEAP8[$3 + 41 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 20636));
     break block7;
    }
    HEAP8[$3 + 63 | 0] = jsvGetBool(HEAP32[$3 + 64 >> 2]) & 1;
   }
   HEAP32[$3 + 28 >> 2] = -1;
   block9 : {
    block8 : {
     if (jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1) {
      break block8
     }
     if (jsvIsString(HEAP32[$3 + 72 >> 2]) & 1) {
      break block8
     }
     jsExceptionHere(1, 27375, 0);
     break block9;
    }
    HEAP32[$3 + 24 >> 2] = jsvNewObject();
    if (HEAP32[$3 + 24 >> 2]) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 15509, jsvNewFromPin(HEAPU8[$3 + 71 | 0]));
     if (HEAP8[$3 + 63 | 0] & 1) {
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 7677, jsvNewFromBool(HEAP8[$3 + 63 | 0] & 1))
     }
     if (HEAPF64[$3 + 48 >> 3] > 0.0) {
      $0 = HEAP32[$3 + 24 >> 2];
      $2 = jshGetTimeFromMilliseconds(HEAPF64[$3 + 48 >> 3]);
      jsvObjectSetChildAndUnLock($0, 18264, jsvNewFromInteger($2));
     }
     if (HEAP32[$3 + 44 >> 2]) {
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 18082, jsvNewFromInteger(HEAP32[$3 + 44 >> 2]))
     }
     jsvObjectSetChild(HEAP32[$3 + 24 >> 2], 20492, HEAP32[$3 + 72 >> 2]);
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 17546, jsvNewFromBool(jshPinInput(HEAPU8[$3 + 71 | 0]) & 1));
     if (HEAP8[$3 + 42 | 0] & 1) {
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 19262, jsvNewFromBool(1))
     }
    }
    HEAP8[$3 + 23 | 0] = 0;
    if (!(jsiIsWatchingPin(HEAPU8[$3 + 71 | 0]) & 1)) {
     HEAP8[$3 + 23 | 0] = jshPinWatch(HEAPU8[$3 + 71 | 0], 1, HEAP8[$3 + 42 | 0] & 1)
    }
    block12 : {
     if (HEAPU8[$3 + 23 | 0]) {
      jshSetEventCallback(HEAPU8[$3 + 23 | 0], 0);
      if (jshIsPinValid(HEAPU8[$3 + 41 | 0]) & 1) {
       jshSetEventDataPin(HEAPU8[$3 + 23 | 0], HEAPU8[$3 + 41 | 0])
      }
      if (HEAP8[$3 + 43 | 0] & 1) {
       block10 : {
        if (jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1) {
         jshSetEventCallback(HEAPU8[$3 + 23 | 0], jsvGetNativeFunctionPtr(HEAP32[$3 + 72 >> 2]));
         break block10;
        }
        block11 : {
         if (jshIsPinValid(HEAPU8[$3 + 41 | 0]) & 1) {
          jsExceptionHere(1, 17284, 0);
          break block11;
         }
         jsExceptionHere(1, 15203, 0);
        }
       }
      }
      break block12;
     }
     if (HEAP8[$3 + 43 | 0] & 1) {
      jsExceptionHere(1, 18935, 0)
     }
    }
    HEAP32[$3 + 28 >> 2] = jsvArrayAddToEnd(HEAP32[103614], HEAP32[$3 + 24 >> 2], 1) - 1;
    jsvUnLock(HEAP32[$3 + 24 >> 2]);
   }
   block13 : {
    if (HEAP32[$3 + 28 >> 2] >= 0) {
     $0 = jsvNewFromInteger(HEAP32[$3 + 28 >> 2]);
     break block13;
    }
    $0 = 0;
   }
   HEAP32[$3 + 76 >> 2] = $0;
  }
  __stack_pointer = $3 + 80 | 0;
  return HEAP32[$3 + 76 >> 2];
 }
 
 function jswrap_interface_clearWatch($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 44 >> 2] = $0;
  block1 : {
   block : {
    if (!(jsvIsUndefined(HEAP32[$1 + 44 >> 2]) & 1)) {
     if (jsvGetArrayLength(HEAP32[$1 + 44 >> 2])) {
      break block
     }
    }
    jsvObjectIteratorNew($1 + 40 | 0, HEAP32[103614]);
    while (1) {
     if (jsvObjectIteratorHasValue_1751($1 + 40 | 0) & 1) {
      HEAP32[$1 + 36 >> 2] = jsvObjectIteratorGetValue_1752($1 + 40 | 0);
      HEAP32[$1 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 36 >> 2], 15509);
      HEAP8[$1 + 31 | 0] = jshGetPinFromVar(HEAP32[$1 + 32 >> 2]);
      if (!(jshGetPinShouldStayWatched(HEAPU8[$1 + 31 | 0]) & 1)) {
       jshPinWatch(HEAPU8[$1 + 31 | 0], 0, 0)
      }
      jsvUnLock2(HEAP32[$1 + 32 >> 2], HEAP32[$1 + 36 >> 2]);
      jsvObjectIteratorNext($1 + 40 | 0);
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1753($1 + 40 | 0);
    jsvRemoveAllChildren(HEAP32[103614]);
    break block1;
   }
   HEAP32[$1 + 24 >> 2] = jsvGetArrayItem(HEAP32[$1 + 44 >> 2], 0);
   if (jsvIsUndefined(HEAP32[$1 + 24 >> 2]) & 1) {
    jsExceptionHere(1, 19510, 0);
    break block1;
   }
   HEAP32[$1 + 20 >> 2] = jsvFindChildFromVar(HEAP32[103614], HEAP32[$1 + 24 >> 2], 0);
   block2 : {
    if (HEAP32[$1 + 20 >> 2]) {
     HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 20 >> 2]);
     HEAP8[$1 + 15 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$1 + 16 >> 2], 15509));
     jsvUnLock(HEAP32[$1 + 16 >> 2]);
     jsvRemoveChildAndUnLock(HEAP32[103614], HEAP32[$1 + 20 >> 2]);
     if (!(jsiIsWatchingPin(HEAPU8[$1 + 15 | 0]) & 1)) {
      jshPinWatch(HEAPU8[$1 + 15 | 0], 0, 0)
     }
     break block2;
    }
    HEAP32[$1 >> 2] = HEAP32[$1 + 24 >> 2];
    jsExceptionHere(1, 4210, $1);
   }
   jsvUnLock(HEAP32[$1 + 24 >> 2]);
  }
  __stack_pointer = $1 + 48 | 0;
 }
 
 function jswrap_pin_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = jshGetPinFromVar(HEAP32[$1 + 8 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvNewFromPin(HEAPU8[$1 + 7 | 0]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_pin_read($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
  $0 = jshPinInput(HEAPU8[$1 + 11 | 0]);
  __stack_pointer = $1 + 16 | 0;
  return $0 & 1;
 }
 
 function jswrap_pin_set($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
  jshPinOutput(HEAPU8[$1 + 11 | 0], 1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_pin_reset($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
  jshPinOutput(HEAPU8[$1 + 11 | 0], 0);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_pin_write($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  HEAP8[$2 + 10 | 0] = jshGetPinFromVar(HEAP32[$2 + 12 >> 2]);
  jshPinOutput(HEAPU8[$2 + 10 | 0], HEAP8[$2 + 11 | 0] & 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_pin_getMode($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_io_getPinMode(jshGetPinFromVar(HEAP32[$1 + 12 >> 2]) & 255);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_pin_mode($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jswrap_io_pinMode(jshGetPinFromVar(HEAP32[$2 + 12 >> 2]) & 255, HEAP32[$2 + 8 >> 2], 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_pin_toggle($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = jshGetPinFromVar(HEAP32[$1 + 8 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 6 | 0] = ((jshPinGetState(HEAPU8[$1 + 7 | 0]) & 16) != 0 ^ -1) & 1;
   jshPinOutput(HEAPU8[$1 + 7 | 0], HEAP8[$1 + 6 | 0] & 1);
   HEAP8[$1 + 15 | 0] = HEAP8[$1 + 6 | 0] & 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jswrap_pin_pulse($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP8[$3 + 11 | 0] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  jswrap_io_digitalPulse(jshGetPinFromVar(HEAP32[$3 + 12 >> 2]) & 255, HEAP8[$3 + 11 | 0] & 1, HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_pin_analog($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0.0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = jshPinAnalog(jshGetPinFromVar(HEAP32[$1 + 12 >> 2]) & 255);
  __stack_pointer = $1 + 16 | 0;
  return +$2;
 }
 
 function jswrap_pin_pwm($0, $1, $2) {
  $0 = $0 | 0;
  $1 = +$1;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAPF64[$3 + 16 >> 3] = $1;
  HEAP32[$3 + 12 >> 2] = $2;
  jswrap_io_analogWrite(jshGetPinFromVar(HEAP32[$3 + 28 >> 2]) & 255, HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2]);
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jswrap_pin_getInfo($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 56 >> 2] = $0;
  HEAP8[$1 + 55 | 0] = jshGetPinFromVar(HEAP32[$1 + 56 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$1 + 55 | 0]) & 1)) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 48 >> 2] = Math_imul(HEAPU8[$1 + 55 | 0], 3) + 183520;
   HEAP32[$1 + 44 >> 2] = jsvNewObject();
   if (!HEAP32[$1 + 44 >> 2]) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   HEAP8[$1 + 42 | 0] = HEAPU8[HEAP32[$1 + 48 >> 2]] - -64;
   HEAP8[$1 + 43 | 0] = 0;
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 4493, jsvNewFromString($1 + 42 | 0));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 15591, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 1 | 0]));
   if (HEAPU8[HEAP32[$1 + 48 >> 2]] & 16) {
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 18927, jsvNewFromBool(1))
   }
   HEAP8[$1 + 41 | 0] = jshPinGetState(HEAPU8[$1 + 55 | 0]);
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 18218, jshGetPinStateString(HEAPU8[$1 + 41 | 0]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 4279, jsvNewFromInteger(!!(HEAPU8[$1 + 41 | 0] & 16)));
   if (HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0]) {
    HEAP32[$1 + 36 >> 2] = jsvNewObject();
    if (HEAP32[$1 + 36 >> 2]) {
     HEAP32[$1 + 32 >> 2] = jsvNewEmptyArray();
     if (HEAP32[$1 + 32 >> 2]) {
      HEAP32[$1 + 28 >> 2] = 0;
      while (1) {
       if (HEAP32[$1 + 28 >> 2] < 0) {
        if (HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 32 << HEAP32[$1 + 28 >> 2]) {
         jsvArrayPushAndUnLock(HEAP32[$1 + 32 >> 2], jsvNewFromInteger(HEAP32[$1 + 28 >> 2] + 1 | 0))
        }
        HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] + 1;
        continue;
       }
       break;
      };
      jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 7549, HEAP32[$1 + 32 >> 2]);
     }
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 15836, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 31));
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 15836, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 31));
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 16563, HEAP32[$1 + 36 >> 2]);
    }
   }
   HEAP32[$1 + 24 >> 2] = jsvNewObject();
   if (HEAP32[$1 + 24 >> 2]) {
    HEAP32[$1 + 20 >> 2] = 0;
    while (1) {
     if (HEAP32[$1 + 20 >> 2] < 0) {
      $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
      if (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) {
       HEAP32[$1 + 16 >> 2] = jsvNewObject();
       if (HEAP32[$1 + 16 >> 2]) {
        $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
        jshPinFunctionToString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8, 8, $1, 16);
        jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 17778, jsvNewFromString($1));
        $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
        jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 17125, jsvNewFromInteger((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) & 15));
        $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
        jshPinFunctionToString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8, 3, $1, 16);
        jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], $1, HEAP32[$1 + 16 >> 2]);
       }
      }
      HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
      continue;
     }
     break;
    };
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 7163, HEAP32[$1 + 24 >> 2]);
   }
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 44 >> 2];
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP32[$1 + 60 >> 2];
 }
 
 function jswrap_pipe_idle() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP8[$0 + 15 | 0] = 0;
  HEAP32[$0 + 8 >> 2] = pipeGetArray(0);
  if (HEAP32[$0 + 8 >> 2]) {
   jsvObjectIteratorNew($0 + 4 | 0, HEAP32[$0 + 8 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1774($0 + 4 | 0) & 1) {
     HEAP32[$0 >> 2] = jsvObjectIteratorGetValue_1775($0 + 4 | 0);
     HEAP8[$0 + 15 | 0] = handlePipe(HEAP32[$0 + 8 >> 2], $0 + 4 | 0, HEAP32[$0 >> 2]) & 1 | HEAP8[$0 + 15 | 0] & 1;
     jsvUnLock(HEAP32[$0 >> 2]);
     jsvObjectIteratorNext($0 + 4 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1777($0 + 4 | 0);
   jsvUnLock(HEAP32[$0 + 8 >> 2]);
  }
  __stack_pointer = $0 + 16 | 0;
  return HEAP8[$0 + 15 | 0] & 1;
 }
 
 function pipeGetArray($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  $0 = jsvObjectGetChild(HEAP32[103308], 7280, HEAP8[$1 + 15 | 0] & 1 ? 3 : 0);
  __stack_pointer = $1 + 16 | 0;
  return $0;
 }
 
 function jsvObjectIteratorHasValue_1774($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1775($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function handlePipe($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 56 >> 2] = $0;
  HEAP32[$3 + 52 >> 2] = $1;
  HEAP32[$3 + 48 >> 2] = $2;
  HEAP8[$3 + 47 | 0] = jsvObjectGetBoolChild(HEAP32[$3 + 48 >> 2], 4792) & 1;
  block : {
   if (HEAP8[$3 + 47 | 0] & 1) {
    HEAP8[$3 + 63 | 0] = 0;
    break block;
   }
   HEAP32[$3 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 17232);
   HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 18251);
   HEAP32[$3 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 15480);
   HEAP8[$3 + 31 | 0] = 0;
   if (!(!HEAP32[$3 + 40 >> 2] | (!HEAP32[$3 + 36 >> 2] | !HEAP32[$3 + 32 >> 2]))) {
    HEAP32[$3 + 24 >> 2] = jspGetNamedField(HEAP32[$3 + 36 >> 2], 19570, 0);
    HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 32 >> 2], 17522, 0);
    block4 : {
     block2 : {
      if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1)) {
       break block2
      }
      if (!(jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1)) {
       break block2
      }
      HEAP32[$3 + 16 >> 2] = jspExecuteFunction(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 36 >> 2], 1, $3 + 40 | 0);
      if (HEAP32[$3 + 16 >> 2]) {
       HEAP32[$3 + 12 >> 2] = jsvGetLength(HEAP32[$3 + 16 >> 2]);
       if (HEAP32[$3 + 12 >> 2] > 0) {
        HEAP32[$3 + 8 >> 2] = jspExecuteFunction(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 32 >> 2], 1, $3 + 16 | 0);
        block3 : {
         if (!(jsvIsBoolean(HEAP32[$3 + 8 >> 2]) & 1)) {
          break block3
         }
         if (jsvGetBool(HEAP32[$3 + 8 >> 2]) & 1) {
          break block3
         }
         jsvObjectSetChildAndUnLock(HEAP32[$3 + 48 >> 2], 4792, jsvNewFromBool(1));
        }
        jsvUnLock(HEAP32[$3 + 8 >> 2]);
       }
       jsvUnLock(HEAP32[$3 + 16 >> 2]);
       HEAP8[$3 + 31 | 0] = 1;
      }
      break block4;
     }
     if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1)) {
      jsExceptionHere(1, 18439, 0)
     }
     if (!(jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1)) {
      jsExceptionHere(1, 18367, 0)
     }
    }
    jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   }
   if (!(HEAP8[$3 + 31 | 0] & 1)) {
    handlePipeClose(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 52 >> 2], HEAP32[$3 + 48 >> 2])
   }
   jsvUnLock3(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 40 >> 2]);
   HEAP8[$3 + 63 | 0] = HEAP8[$3 + 31 | 0] & 1;
  }
  __stack_pointer = $3 - -64 | 0;
  return HEAP8[$3 + 63 | 0] & 1;
 }
 
 function jsvObjectIteratorFree_1777($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function handlePipeClose($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  jsiQueueObjectCallbacks(HEAP32[$3 + 36 >> 2], 17528, $3 + 36 | 0, 1);
  HEAP32[$3 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 18251);
  HEAP32[$3 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 15480);
  if (!(!HEAP32[$3 + 32 >> 2] | !HEAP32[$3 + 28 >> 2])) {
   HEAP32[$3 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 32 >> 2], 17070);
   block1 : {
    if (!HEAP32[$3 + 24 >> 2]) {
     break block1
    }
    if (!jsvGetStringLength(HEAP32[$3 + 24 >> 2])) {
     break block1
    }
    jsvObjectRemoveChild(HEAP32[$3 + 32 >> 2], 17070);
    HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 17522, 0);
    if (jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1) {
     jsvUnLock(jspExecuteFunction(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 28 >> 2], 1, $3 + 24 | 0))
    }
    jsvUnLock(HEAP32[$3 + 20 >> 2]);
   }
   jsvUnLock(HEAP32[$3 + 24 >> 2]);
  }
  if (jsvObjectGetBoolChild(HEAP32[$3 + 36 >> 2], 18684) & 1) {
   if (HEAP32[$3 + 28 >> 2]) {
    jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 28 >> 2], 15526);
    jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 28 >> 2], 17660);
    HEAP32[$3 + 16 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 18684, 0);
    if (jsvIsFunction(HEAP32[$3 + 16 >> 2]) & 1) {
     jsvUnLock(jspExecuteFunction(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 28 >> 2], 0, 0))
    }
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    HEAP32[$3 + 12 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 17660, 0);
    if (jsvIsFunction(HEAP32[$3 + 12 >> 2]) & 1) {
     jsvUnLock(jspExecuteFunction(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 28 >> 2], 0, 0))
    }
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
   }
   if (HEAP32[$3 + 32 >> 2]) {
    jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 32 >> 2], 17660);
    HEAP32[$3 + 8 >> 2] = jspGetNamedField(HEAP32[$3 + 32 >> 2], 17660, 0);
    if (jsvIsFunction(HEAP32[$3 + 8 >> 2]) & 1) {
     jsvUnLock(jspExecuteFunction(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 32 >> 2], 0, 0))
    }
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
   }
  }
  jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
  HEAP32[$3 + 4 >> 2] = jsvObjectIteratorGetKey_1785(HEAP32[$3 + 40 >> 2]);
  jsvRemoveChildAndUnLock(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 4 >> 2]);
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jswrap_pipe_kill() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = pipeGetArray(0);
  if (HEAP32[$0 + 12 >> 2]) {
   jsvRemoveAllChildren(HEAP32[$0 + 12 >> 2]);
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
  }
  __stack_pointer = $0 + 16 | 0;
 }
 
 function jswrap_pipe($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  if (!(!HEAP32[$3 + 44 >> 2] | !HEAP32[$3 + 40 >> 2])) {
   jsvLockAgain(HEAP32[$3 + 44 >> 2]);
   HEAP32[$3 + 32 >> 2] = jspNewObject(0, 17792);
   HEAP32[$3 + 28 >> 2] = pipeGetArray(1);
   if (!(!HEAP32[$3 + 32 >> 2] | !HEAP32[$3 + 28 >> 2])) {
    if (jsvIsString(HEAP32[$3 + 44 >> 2]) & 1) {
     HEAP32[$3 + 24 >> 2] = jspExecuteJSFunctionCode(7675, 1026, 0, 0, 1, $3 + 44 | 0);
     jsvUnLock(HEAP32[$3 + 44 >> 2]);
     HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
    }
    HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 44 >> 2], 19570, 0);
    HEAP32[$3 + 16 >> 2] = jspGetNamedField(HEAP32[$3 + 40 >> 2], 17522, 0);
    block5 : {
     if (jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1) {
      if (jsvIsFunction(HEAP32[$3 + 16 >> 2]) & 1) {
       HEAP32[$3 + 12 >> 2] = 64;
       HEAP8[$3 + 11 | 0] = 1;
       block4 : {
        if (jsvIsObject(HEAP32[$3 + 36 >> 2]) & 1) {
         HEAP32[$3 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 17531);
         if (HEAP32[$3 + 4 >> 2]) {
          jsvObjectSetChild(HEAP32[$3 + 32 >> 2], 17528, HEAP32[$3 + 4 >> 2]);
          jsvUnLock(HEAP32[$3 + 4 >> 2]);
         }
         HEAP32[$3 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 18684);
         if (HEAP32[$3 + 4 >> 2]) {
          HEAP8[$3 + 11 | 0] = jsvGetBoolAndUnLock(HEAP32[$3 + 4 >> 2]) & 1
         }
         HEAP32[$3 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 17232);
         if (HEAP32[$3 + 4 >> 2]) {
          block3 : {
           block2 : {
            if (!(jsvIsNumeric(HEAP32[$3 + 4 >> 2]) & 1)) {
             break block2
            }
            if ((jsvGetInteger(HEAP32[$3 + 4 >> 2]) | 0) <= 0) {
             break block2
            }
            HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 4 >> 2]);
            break block3;
           }
           jsExceptionHere(3, 22529, 0);
          }
          jsvUnLock(HEAP32[$3 + 4 >> 2]);
         }
         break block4;
        }
        if (!(jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1)) {
         jsExceptionHere(3, 19091, 0)
        }
       }
       jswrap_object_addEventListener(HEAP32[$3 + 44 >> 2], 17660, 644, 32768);
       jswrap_object_addEventListener(HEAP32[$3 + 40 >> 2], 15526, 645, 8);
       jswrap_object_addEventListener(HEAP32[$3 + 40 >> 2], 17660, 646, 32768);
       jsvObjectSetChildAndUnLock(HEAP32[$3 + 32 >> 2], 17232, jsvNewFromInteger(HEAP32[$3 + 12 >> 2]));
       jsvObjectSetChildAndUnLock(HEAP32[$3 + 32 >> 2], 18684, jsvNewFromBool(HEAP8[$3 + 11 | 0] & 1));
       jsvUnLock2(jsvAddNamedChild(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 44 >> 2], 18251), jsvAddNamedChild(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 40 >> 2], 15480));
       jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2]);
       break block5;
      }
      jsExceptionHere(1, 18505, 0);
      break block5;
     }
     jsExceptionHere(1, 18585, 0);
    }
    jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
   }
   jsvUnLock3(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 44 >> 2]);
  }
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jswrap_pipe_src_close_listener($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jswrap_pipe_close_listener(HEAP32[$1 + 12 >> 2], 18251);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_pipe_drain_listener($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  block : {
   if (!(jsvIsObject(HEAP32[$1 + 28 >> 2]) & 1)) {
    break block
   }
   HEAP32[$1 + 24 >> 2] = pipeGetArray(0);
   if (!HEAP32[$1 + 24 >> 2]) {
    break block
   }
   jsvObjectIteratorNew($1 + 20 | 0, HEAP32[$1 + 24 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1774($1 + 20 | 0) & 1) {
     HEAP32[$1 + 16 >> 2] = jsvObjectIteratorGetValue_1775($1 + 20 | 0);
     HEAP32[$1 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 16 >> 2], 15480);
     if (HEAP32[$1 + 12 >> 2] == HEAP32[$1 + 28 >> 2]) {
      jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 4792, jsvNewFromBool(0))
     }
     jsvUnLock2(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2]);
     jsvObjectIteratorNext($1 + 20 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1777($1 + 20 | 0);
   jsvUnLock(HEAP32[$1 + 24 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jswrap_pipe_dst_close_listener($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jswrap_pipe_close_listener(HEAP32[$1 + 12 >> 2], 15480);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_pipe_close_listener($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block : {
   if (!(jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1)) {
    break block
   }
   HEAP32[$2 + 20 >> 2] = pipeGetArray(0);
   if (!HEAP32[$2 + 20 >> 2]) {
    break block
   }
   jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 20 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1774($2 + 16 | 0) & 1) {
     HEAP32[$2 + 12 >> 2] = jsvObjectIteratorGetValue_1775($2 + 16 | 0);
     HEAP32[$2 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
     if (HEAP32[$2 + 8 >> 2] == HEAP32[$2 + 28 >> 2]) {
      handlePipeClose(HEAP32[$2 + 20 >> 2], $2 + 16 | 0, HEAP32[$2 + 12 >> 2])
     }
     jsvUnLock2(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
     jsvObjectIteratorNext($2 + 16 | 0);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1777($2 + 16 | 0);
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jsvObjectIteratorGetKey_1785($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_process_env() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 12 >> 2] = jsvNewObject();
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21213, jsvNewFromString(22253));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21068, jsvNewFromString(20513));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21565, jsvNewFromString(22407));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21270, jsvNewFromInteger(0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21481, jsvNewFromInteger(8388608));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21478, jsvNewFromInteger(8388608));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21211, jsvNewFromInteger(2));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21553, jsvNewFromInteger(8388608));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21344, jswrap_interface_getSerial());
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21537, jswrap_espruino_getConsole());
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21138, jsvNewFromString(jswGetBuiltInLibraryNames()));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 21146, jsvNewFromInteger(234240));
  __stack_pointer = $0 + 16 | 0;
  return HEAP32[$0 + 12 >> 2];
 }
 
 function jswrap_process_memory($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 44 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = -1;
  block : {
   if (!(jsvIsUndefined(HEAP32[$1 + 44 >> 2]) & 1)) {
    if (!(jsvGetBool(HEAP32[$1 + 44 >> 2]) & 1)) {
     break block
    }
   }
   HEAP32[$1 + 32 >> 2] = jshGetSystemTime();
   HEAP32[$1 + 36 >> 2] = i64toi32_i32$HIGH_BITS;
   HEAP32[$1 + 20 >> 2] = jsvGarbageCollect();
   HEAP32[$1 + 24 >> 2] = jshGetSystemTime();
   HEAP32[$1 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
  }
  HEAP32[$1 + 16 >> 2] = jsvNewObject();
  if (HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 3536);
   if (HEAP32[$1 + 8 >> 2]) {
    HEAP32[$1 + 12 >> 2] = jsvCountJsVarsUsed(HEAP32[$1 + 8 >> 2]);
    jsvUnLock(HEAP32[$1 + 8 >> 2]);
   }
   HEAP32[$1 + 4 >> 2] = jsvGetMemoryUsage() - HEAP32[$1 + 12 >> 2];
   HEAP32[$1 >> 2] = jsvGetMemoryTotal();
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 18152, jsvNewFromInteger(HEAP32[$1 >> 2] - HEAP32[$1 + 4 >> 2] | 0));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 18102, jsvNewFromInteger(HEAP32[$1 + 4 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 15914, jsvNewFromInteger(HEAP32[$1 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 3536, jsvNewFromInteger(HEAP32[$1 + 12 >> 2]));
   if (HEAP32[$1 + 20 >> 2] >= 0) {
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 20464, jsvNewFromInteger(HEAP32[$1 + 20 >> 2]));
    $0 = HEAP32[$1 + 24 >> 2];
    $2 = HEAP32[$1 + 32 >> 2];
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 17802, jsvNewFromFloat(jshGetMillisecondsFromTime($0 - $2 | 0, HEAP32[$1 + 28 >> 2] - (HEAP32[$1 + 36 >> 2] + ($0 >>> 0 < $2 >>> 0) | 0) | 0)));
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 17185, jsvNewFromInteger(14));
  }
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 16 >> 2];
 }
 
 function jswrap_onewire_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 11 | 0] = $0;
  HEAP32[$1 + 4 >> 2] = jspNewObject(0, 17718);
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 15509, jsvNewFromPin(HEAPU8[$1 + 11 | 0]));
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_onewire_reset($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = onewire_getpin(HEAP32[$1 + 8 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = OneWireReset(HEAPU8[$1 + 7 | 0]) & 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function onewire_getpin($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], 15509));
  __stack_pointer = $1 + 16 | 0;
  return $0 & 255;
 }
 
 function OneWireReset($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jshPinSetState(HEAPU8[$1 + 15 | 0], 3);
  jshPinSetValue(HEAPU8[$1 + 15 | 0], 0);
  jshDelayMicroseconds(500);
  jshPinSetValue(HEAPU8[$1 + 15 | 0], 1);
  jshDelayMicroseconds(80);
  HEAP8[$1 + 14 | 0] = (jshPinGetValue(HEAPU8[$1 + 15 | 0]) ^ -1) & 1;
  jshDelayMicroseconds(420);
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 14 | 0] & 1;
 }
 
 function jswrap_onewire_select($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 76 >> 2] = $0;
  HEAP32[$2 + 72 >> 2] = $1;
  HEAP8[$2 + 71 | 0] = onewire_getpin(HEAP32[$2 + 76 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$2 + 71 | 0]) & 1)) {
    break block
   }
   block1 : {
    if (jsvIsString(HEAP32[$2 + 72 >> 2]) & 1) {
     if ((jsvGetStringLength(HEAP32[$2 + 72 >> 2]) | 0) == 16) {
      break block1
     }
    }
    HEAP32[$2 >> 2] = HEAP32[$2 + 72 >> 2];
    jsExceptionHere(3, 14646, $2);
    break block;
   }
   OneWireReset(HEAPU8[$2 + 71 | 0]);
   HEAP32[$2 + 56 >> 2] = 0;
   HEAP32[$2 + 60 >> 2] = 0;
   jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 72 >> 2], 0);
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$2 + 12 >> 2] < 8) {
     HEAP8[$2 + 9 | 0] = jsvStringIteratorGetCharAndNext($2 + 16 | 0);
     HEAP8[$2 + 10 | 0] = jsvStringIteratorGetCharAndNext($2 + 16 | 0);
     HEAP8[$2 + 11 | 0] = 0;
     $1 = HEAP32[$2 + 56 >> 2];
     $5 = $1;
     $0 = HEAP32[$2 + 60 >> 2];
     $6 = $0;
     $0 = stringToIntWithRadix($2 + 9 | 0, 16, 0, 0);
     $1 = i64toi32_i32$HIGH_BITS;
     $3 = $0;
     $0 = HEAP32[$2 + 12 >> 2] << 3;
     $4 = $0 & 31;
     if (($0 & 63) >>> 0 >= 32) {
      $0 = $3 << $4;
      $4 = 0;
     } else {
      $0 = (1 << $4) - 1 & $3 >>> 32 - $4 | $1 << $4;
      $4 = $3 << $4;
     }
     $3 = $0;
     $1 = $5;
     $0 = $4 | $1;
     $1 = $2;
     HEAP32[$1 + 56 >> 2] = $0;
     $0 = $6;
     $3 = $0 | $3;
     HEAP32[$1 + 60 >> 2] = $3;
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1793($2 + 16 | 0);
   OneWireWrite(HEAPU8[$2 + 71 | 0], 8, 85, 0);
   $3 = HEAP32[$2 + 56 >> 2];
   $1 = HEAP32[$2 + 60 >> 2];
   OneWireWrite(HEAPU8[$2 + 71 | 0], 64, $3, $1);
  }
  __stack_pointer = $2 + 80 | 0;
 }
 
 function jsvStringIteratorFree_1793($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function OneWireWrite($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP8[$4 + 31 | 0] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 20 >> 2] = $3;
  jshPinSetState(HEAPU8[$4 + 31 | 0], 3);
  HEAP32[$4 + 8 >> 2] = 1;
  HEAP32[$4 + 12 >> 2] = 0;
  while (1) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 24 >> 2] = $0 - 1;
   if (($0 | 0) > 0) {
    $3 = HEAP32[$4 + 16 >> 2];
    $5 = $3;
    $0 = HEAP32[$4 + 20 >> 2];
    $2 = $0;
    $3 = HEAP32[$4 + 12 >> 2];
    $6 = $3;
    $0 = HEAP32[$4 + 8 >> 2];
    $1 = $0;
    $3 = $2;
    $0 = $6;
    $0 = $3 & $0;
    $3 = $1 & $5;
    block : {
     if ($3 | $0) {
      jshInterruptOff();
      jshPinSetValue(HEAPU8[$4 + 31 | 0], 0);
      jshDelayMicroseconds(10);
      jshPinSetValue(HEAPU8[$4 + 31 | 0], 1);
      jshInterruptOn();
      jshDelayMicroseconds(55);
      break block;
     }
     jshInterruptOff();
     jshPinSetValue(HEAPU8[$4 + 31 | 0], 0);
     jshDelayMicroseconds(65);
     jshPinSetValue(HEAPU8[$4 + 31 | 0], 1);
     jshInterruptOn();
     jshDelayMicroseconds(5);
    }
    $3 = HEAP32[$4 + 8 >> 2];
    $0 = HEAP32[$4 + 12 >> 2];
    $1 = $3;
    $3 = $0 << 1 | $3 >>> 31;
    $0 = $1 << 1;
    HEAP32[$4 + 8 >> 2] = $0;
    HEAP32[$4 + 12 >> 2] = $3;
    continue;
   }
   break;
  };
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jswrap_onewire_skip($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = onewire_getpin(HEAP32[$1 + 12 >> 2]);
  if (jshIsPinValid(HEAPU8[$1 + 11 | 0]) & 1) {
   OneWireWrite(HEAPU8[$1 + 11 | 0], 8, 204, 0)
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jswrap_onewire_write_cb($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  OneWireWrite(HEAPU8[HEAP32[$2 + 8 >> 2]], 8, HEAP32[$2 + 12 >> 2], 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_onewire_write($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  HEAP8[$3 + 6 | 0] = onewire_getpin(HEAP32[$3 + 12 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$3 + 6 | 0]) & 1)) {
    break block
   }
   jsvIterateCallback(HEAP32[$3 + 8 >> 2], 664, $3 + 6 | 0);
   if (HEAP8[$3 + 7 | 0] & 1) {
    jshPinSetValue(HEAPU8[$3 + 6 | 0], 1);
    jshPinSetState(HEAPU8[$3 + 6 | 0], 1);
    break block;
   }
   jshPinSetState(HEAPU8[$3 + 6 | 0], 4);
   jshPinSetValue(HEAPU8[$3 + 6 | 0], 1);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_onewire_read($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP32[$2 + 84 >> 2] = $1;
  HEAP8[$2 + 83 | 0] = onewire_getpin(HEAP32[$2 + 88 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$2 + 83 | 0]) & 1)) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   if (jsvIsNumeric(HEAP32[$2 + 84 >> 2]) & 1) {
    HEAP32[$2 + 76 >> 2] = jsvGetInteger(HEAP32[$2 + 84 >> 2]);
    HEAP32[$2 + 72 >> 2] = jsvNewTypedArray(1, HEAP32[$2 + 76 >> 2]);
    if (!HEAP32[$2 + 72 >> 2]) {
     HEAP32[$2 + 92 >> 2] = 0;
     break block;
    }
    jsvArrayBufferIteratorNew($2 + 12 | 0, HEAP32[$2 + 72 >> 2], 0);
    while (1) {
     $0 = HEAP32[$2 + 76 >> 2];
     HEAP32[$2 + 76 >> 2] = $0 - 1;
     if ($0) {
      jsvArrayBufferIteratorSetByteValue($2 + 12 | 0, OneWireRead(HEAPU8[$2 + 83 | 0], 8) << 24 >> 24);
      jsvArrayBufferIteratorNext($2 + 12 | 0);
      continue;
     }
     break;
    };
    jsvArrayBufferIteratorFree($2 + 12 | 0);
    HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 72 >> 2];
    break block;
   }
   HEAP32[$2 + 92 >> 2] = jsvNewFromInteger(OneWireRead(HEAPU8[$2 + 83 | 0], 8));
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function OneWireRead($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP8[$2 + 15 | 0] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jshPinSetState(HEAPU8[$2 + 15 | 0], 3);
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 >> 2] = 1;
  while (1) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 - 1;
   if (($0 | 0) > 0) {
    jshInterruptOff();
    jshPinSetValue(HEAPU8[$2 + 15 | 0], 0);
    jshDelayMicroseconds(3);
    jshPinSetValue(HEAPU8[$2 + 15 | 0], 1);
    jshDelayMicroseconds(10);
    if (jshPinGetValue(HEAPU8[$2 + 15 | 0]) & 1) {
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | HEAP32[$2 >> 2]
    }
    jshInterruptOn();
    jshDelayMicroseconds(53);
    HEAP32[$2 >> 2] = HEAP32[$2 >> 2] << 1;
    continue;
   }
   break;
  };
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 4 >> 2];
 }
 
 function jswrap_onewire_search($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP32[$2 + 84 >> 2] = $1;
  HEAP8[$2 + 83 | 0] = onewire_getpin(HEAP32[$2 + 88 >> 2]);
  block : {
   if (!(jshIsPinValid(HEAPU8[$2 + 83 | 0]) & 1)) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 76 >> 2] = jsvNewEmptyArray();
   if (!HEAP32[$2 + 76 >> 2]) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   if (!(HEAP32[$2 + 84 >> 2] <= 255 & HEAP32[$2 + 84 >> 2] > 0)) {
    HEAP32[$2 + 84 >> 2] = 240
   }
   HEAP32[$2 + 64 >> 2] = 0;
   HEAP32[$2 + 56 >> 2] = 0;
   HEAP32[$2 + 60 >> 2] = 0;
   HEAP32[$2 + 52 >> 2] = 1;
   while (1) {
    if (HEAP32[$2 + 52 >> 2]) {
     HEAP32[$2 + 48 >> 2] = 1;
     HEAP32[$2 + 44 >> 2] = 0;
     HEAP32[$2 + 40 >> 2] = 0;
     HEAP8[$2 + 37 | 0] = 1;
     HEAP32[$2 + 52 >> 2] = 0;
     if (!HEAP32[$2 + 56 >> 2]) {
      if (!(OneWireReset(HEAPU8[$2 + 83 | 0]) & 1)) {
       HEAP32[$2 + 64 >> 2] = 0;
       HEAP32[$2 + 56 >> 2] = 0;
       HEAP32[$2 + 60 >> 2] = 0;
       HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 76 >> 2];
       break block;
      }
      $0 = HEAP32[$2 + 84 >> 2];
      $1 = $0 >> 31;
      OneWireWrite(HEAPU8[$2 + 83 | 0], 8, $0, $1);
      while (1) {
       block3 : {
        HEAP8[$2 + 39 | 0] = OneWireRead(HEAPU8[$2 + 83 | 0], 1);
        HEAP8[$2 + 38 | 0] = OneWireRead(HEAPU8[$2 + 83 | 0], 1);
        if (!(HEAPU8[$2 + 39 | 0] != 1 | HEAPU8[$2 + 38 | 0] != 1)) {
         break block3
        }
        block4 : {
         if (HEAPU8[$2 + 39 | 0] != HEAPU8[$2 + 38 | 0]) {
          HEAP8[$2 + 36 | 0] = HEAPU8[$2 + 39 | 0];
          break block4;
         }
         block5 : {
          if (HEAP32[$2 + 48 >> 2] < HEAP32[$2 + 64 >> 2]) {
           HEAP8[$2 + 36 | 0] = (HEAPU8[HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0] & HEAPU8[$2 + 37 | 0]) != 0;
           break block5;
          }
          HEAP8[$2 + 36 | 0] = HEAP32[$2 + 48 >> 2] == HEAP32[$2 + 64 >> 2];
         }
         if (!HEAPU8[$2 + 36 | 0]) {
          HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 48 >> 2];
          if (HEAP32[$2 + 44 >> 2] < 9) {
           HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 44 >> 2]
          }
         }
        }
        block6 : {
         if (HEAPU8[$2 + 36 | 0] == 1) {
          $0 = HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0;
          HEAP8[$0 | 0] = HEAPU8[$2 + 37 | 0] | HEAPU8[$0 | 0];
          break block6;
         }
         $0 = HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0;
         HEAP8[$0 | 0] = HEAPU8[$0 | 0] & ((HEAPU8[$2 + 37 | 0] ^ -1) & 255);
        }
        $1 = HEAPU8[$2 + 36 | 0];
        OneWireWrite(HEAPU8[$2 + 83 | 0], 1, $1, 0);
        HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
        HEAP8[$2 + 37 | 0] = HEAPU8[$2 + 37 | 0] << 1;
        if (!HEAPU8[$2 + 37 | 0]) {
         HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 40 >> 2] + 1;
         HEAP8[$2 + 37 | 0] = 1;
        }
        if (HEAP32[$2 + 40 >> 2] < 8) {
         continue
        }
       }
       break;
      };
      if (HEAP32[$2 + 48 >> 2] >= 65) {
       HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 44 >> 2];
       if (!HEAP32[$2 + 64 >> 2]) {
        HEAP32[$2 + 56 >> 2] = 1
       }
       HEAP32[$2 + 52 >> 2] = 1;
      }
     }
     if (!(HEAPU8[$2 + 68 | 0] ? HEAP32[$2 + 52 >> 2] : 0)) {
      HEAP32[$2 + 64 >> 2] = 0;
      HEAP32[$2 + 56 >> 2] = 0;
      HEAP32[$2 + 60 >> 2] = 0;
      HEAP32[$2 + 52 >> 2] = 0;
     }
     if (HEAP32[$2 + 52 >> 2]) {
      HEAP32[$2 + 32 >> 2] = 0;
      while (1) {
       if (HEAP32[$2 + 32 >> 2] < 8) {
        $0 = itoch(HEAPU8[HEAP32[$2 + 32 >> 2] + ($2 + 68 | 0) | 0] >>> 4 | 0);
        HEAP8[(HEAP32[$2 + 32 >> 2] << 1) + $2 | 0] = $0;
        $0 = itoch(HEAPU8[HEAP32[$2 + 32 >> 2] + ($2 + 68 | 0) | 0] & 15);
        HEAP8[((HEAP32[$2 + 32 >> 2] << 1) + 1 | 0) + $2 | 0] = $0;
        HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
        continue;
       }
       break;
      };
      HEAP8[$2 + 16 | 0] = 0;
      jsvArrayPushString(HEAP32[$2 + 76 >> 2], $2);
     }
     continue;
    }
    break;
   };
   HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 76 >> 2];
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function jspromise_resolve($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  jspromise_resolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jspromise_resolve_or_reject($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  HEAP32[$3 >> 2] = jsvNewObject();
  if (HEAP32[$3 >> 2]) {
   jsvObjectSetChild(HEAP32[$3 >> 2], 15707, HEAP32[$3 + 12 >> 2]);
   _jswrap_prombox_queueresolve_or_reject(HEAP32[$3 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
   jsvUnLock(HEAP32[$3 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function _jswrap_prombox_queueresolve_or_reject($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP8[$3 + 7 | 0] = $2;
  HEAP32[$3 >> 2] = _jswrap_promise_native_with_prombox(HEAP8[$3 + 7 | 0] & 1 ? 665 : 666, HEAP32[$3 + 12 >> 2]);
  if (HEAP32[$3 >> 2]) {
   jsiQueueEvents(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], $3 + 8 | 0, 1);
   jsvUnLock(HEAP32[$3 >> 2]);
  }
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jspromise_create() {
  return jspNewObject(0, 17672);
 }
 
 function jswrap_promise_constructor($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 40 >> 2] = $0;
  block : {
   if (!HEAP32[$1 + 40 >> 2]) {
    jsExceptionHere(1, 7768, 0);
    HEAP32[$1 + 44 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 32 >> 2] = jspromise_create_prombox($1 + 36 | 0);
   if (!HEAP32[$1 + 32 >> 2]) {
    HEAP32[$1 + 44 >> 2] = 0;
    break block;
   }
   if (HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 28 >> 2] = _jswrap_promise_native_with_prombox(667, HEAP32[$1 + 32 >> 2]);
    HEAP32[$1 + 24 >> 2] = _jswrap_promise_native_with_prombox(668, HEAP32[$1 + 32 >> 2]);
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 28 >> 2];
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 24 >> 2];
    HEAP32[$1 + 12 >> 2] = HEAP32[103315];
    jsvUnLock(jspeFunctionCall(HEAP32[$1 + 40 >> 2], 0, HEAP32[$1 + 36 >> 2], 0, 2, $1 + 16 | 0));
    HEAP32[103315] = HEAP32[$1 + 12 >> 2];
    HEAP32[$1 + 8 >> 2] = jspGetException();
    if (HEAP32[$1 + 8 >> 2]) {
     _jswrap_prombox_queuereject(HEAP32[$1 + 32 >> 2], HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
    }
    jsvUnLock2(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 32 >> 2]);
   HEAP32[$1 + 44 >> 2] = jsvLockAgain(HEAP32[$1 + 36 >> 2]);
  }
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 44 >> 2];
 }
 
 function jspromise_create_prombox($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = jspromise_create();
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 >> 2] = jsvNewObject();
   if (!HEAP32[$1 >> 2]) {
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 17546, jsvNewFromInteger(0));
   jsvObjectSetChildAndUnLock(HEAP32[$1 >> 2], 15707, HEAP32[$1 + 4 >> 2]);
   HEAP32[HEAP32[$1 + 8 >> 2] >> 2] = HEAP32[$1 + 4 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function _jswrap_prombox_queueresolve($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  _jswrap_prombox_queueresolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function _jswrap_promise_native_with_prombox($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvNewNativeFunction(HEAP32[$2 + 12 >> 2], 32776);
  jsvObjectSetChild(HEAP32[$2 + 4 >> 2], 7212, HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 4 >> 2];
 }
 
 function _jswrap_prombox_queuereject($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  _jswrap_prombox_queueresolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_promise_all($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 56 >> 2] = $0;
  block : {
   if (!(jsvIsIterable(HEAP32[$1 + 56 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 56 >> 2];
    jsExceptionHere(3, 6084, $1);
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 48 >> 2] = jspromise_create_prombox($1 + 52 | 0);
   if (!HEAP32[$1 + 48 >> 2]) {
    HEAP32[$1 + 60 >> 2] = 0;
    break block;
   }
   if (HEAP32[$1 + 52 >> 2]) {
    HEAP32[$1 + 44 >> 2] = _jswrap_promise_native_with_prombox(669, HEAP32[$1 + 48 >> 2]);
    if (!HEAP32[$1 + 44 >> 2]) {
     HEAP32[$1 + 60 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 52 >> 2]);
     break block;
    }
    HEAP32[$1 + 40 >> 2] = jsvNewEmptyArray();
    HEAP32[$1 + 36 >> 2] = 0;
    HEAP32[$1 + 32 >> 2] = 0;
    jsvObjectIteratorNew($1 + 28 | 0, HEAP32[$1 + 56 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_1812($1 + 28 | 0) & 1) {
      HEAP32[$1 + 24 >> 2] = jsvObjectIteratorGetValue_1813($1 + 28 | 0);
      block1 : {
       if (_jswrap_promise_is_promise(HEAP32[$1 + 24 >> 2]) & 1) {
        HEAP32[$1 + 20 >> 2] = jsvNewNativeFunction(670, 32840);
        HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(HEAP32[$1 + 36 >> 2]);
        jsvAddFunctionParameter(HEAP32[$1 + 20 >> 2], 0, HEAP32[$1 + 16 >> 2]);
        jsvObjectSetChild(HEAP32[$1 + 20 >> 2], 7212, HEAP32[$1 + 48 >> 2]);
        jsvUnLock3(jswrap_promise_then(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 44 >> 2]), HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
        break block1;
       }
       jsvSetArrayItem(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 36 >> 2], HEAP32[$1 + 24 >> 2]);
       HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] + 1;
      }
      jsvUnLock(HEAP32[$1 + 24 >> 2]);
      HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 36 >> 2] + 1;
      jsvObjectIteratorNext($1 + 28 | 0);
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1817($1 + 28 | 0);
    block2 : {
     if (HEAP32[$1 + 32 >> 2] == HEAP32[$1 + 36 >> 2]) {
      HEAP32[$1 + 52 >> 2] = jswrap_promise_resolve(HEAP32[$1 + 40 >> 2]);
      jsvUnLock2(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 40 >> 2]);
      break block2;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 52 >> 2], 15125, jsvNewFromInteger(HEAP32[$1 + 36 >> 2] - HEAP32[$1 + 32 >> 2] | 0));
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 52 >> 2], 7275, HEAP32[$1 + 40 >> 2]);
    }
    jsvUnLock2(HEAP32[$1 + 44 >> 2], HEAP32[$1 + 48 >> 2]);
   }
   HEAP32[$1 + 60 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 52 >> 2]);
  }
  __stack_pointer = $1 - -64 | 0;
  return HEAP32[$1 + 60 >> 2];
 }
 
 function _jswrap_prombox_all_reject($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 15707);
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 4 >> 2], 7275);
   if (HEAP32[$2 >> 2]) {
    jsvUnLock(HEAP32[$2 >> 2]);
    jsvObjectRemoveChild(HEAP32[$2 + 4 >> 2], 7275);
    _jswrap_prombox_queuereject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvObjectIteratorHasValue_1812($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1813($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function _jswrap_promise_is_promise($0) {
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jspGetConstructor(HEAP32[$1 + 12 >> 2]);
  if (HEAP32[$1 + 8 >> 2]) {
   $0 = HEAP32[$1 + 8 >> 2];
   $2 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 20;
  }
  HEAP8[$1 + 7 | 0] = $2;
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 7 | 0] & 1;
 }
 
 function _jswrap_prombox_all_resolve($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 28 >> 2], 15707);
  if (HEAP32[$3 + 16 >> 2]) {
   HEAP32[$3 + 12 >> 2] = jsvObjectGetIntegerChild(HEAP32[$3 + 16 >> 2], 15125);
   HEAP32[$3 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 16 >> 2], 7275);
   if (HEAP32[$3 + 8 >> 2]) {
    jsvSetArrayItem(HEAP32[$3 + 8 >> 2], jsvGetInteger(HEAP32[$3 + 24 >> 2]), HEAP32[$3 + 20 >> 2]);
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] - 1;
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 16 >> 2], 15125, jsvNewFromInteger(HEAP32[$3 + 12 >> 2]));
    if (!HEAP32[$3 + 12 >> 2]) {
     _jswrap_prombox_queueresolve(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 8 >> 2])
    }
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jswrap_promise_then($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 40 >> 2] = $0;
  HEAP32[$3 + 36 >> 2] = $1;
  HEAP32[$3 + 32 >> 2] = $2;
  HEAP32[$3 + 24 >> 2] = jspromise_create_prombox($3 + 28 | 0);
  block : {
   if (!HEAP32[$3 + 24 >> 2]) {
    HEAP32[$3 + 44 >> 2] = 0;
    break block;
   }
   if (HEAP32[$3 + 28 >> 2]) {
    if (!(jsvIsFunction(HEAP32[$3 + 36 >> 2]) & 1)) {
     HEAP32[$3 + 36 >> 2] = 0
    }
    if (!(jsvIsFunction(HEAP32[$3 + 32 >> 2]) & 1)) {
     HEAP32[$3 + 32 >> 2] = 0
    }
    HEAP32[$3 + 20 >> 2] = jsvObjectGetIntegerChild(HEAP32[$3 + 40 >> 2], 17546);
    block1 : {
     if (!HEAP32[$3 + 20 >> 2]) {
      _jswrap_promise_add_reaction(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 36 >> 2], 1);
      _jswrap_promise_add_reaction(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2], 0);
      break block1;
     }
     if (HEAP32[$3 + 20 >> 2] == 2) {
      $0 = HEAP32[$3 + 36 >> 2]
     } else {
      $0 = HEAP32[$3 + 32 >> 2]
     }
     HEAP32[$3 + 16 >> 2] = $0;
     HEAP32[$3 + 12 >> 2] = _jswrap_promise_new_reaction(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
     if (HEAP32[$3 + 12 >> 2]) {
      HEAP32[$3 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 15857);
      _jswrap_promise_queue_reaction(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 0);
      jsvUnLock2(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2]);
     }
    }
   }
   jsvUnLock(HEAP32[$3 + 24 >> 2]);
   HEAP32[$3 + 44 >> 2] = jsvLockAgainSafe(HEAP32[$3 + 28 >> 2]);
  }
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 44 >> 2];
 }
 
 function jsvObjectIteratorFree_1817($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_promise_resolve($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = 0;
  block : {
   if (_jswrap_promise_is_promise(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
    break block;
   }
   if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP32[$1 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 24 >> 2], 15562);
    if (jsvIsFunction(HEAP32[$1 + 16 >> 2]) & 1) {
     HEAP32[$1 + 20 >> 2] = jswrap_promise_constructor(HEAP32[$1 + 16 >> 2])
    }
    jsvUnLock(HEAP32[$1 + 16 >> 2]);
    if (HEAP32[$1 + 20 >> 2]) {
     HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
     break block;
    }
   }
   HEAP32[$1 + 12 >> 2] = jspromise_create_prombox($1 + 20 | 0);
   if (!HEAP32[$1 + 12 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   if (HEAP32[$1 + 20 >> 2]) {
    _jswrap_prombox_queueresolve(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 24 >> 2])
   }
   jsvUnLock(HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 28 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 20 >> 2]);
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function _jswrap_promise_add_reaction($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP8[$4 + 19 | 0] = $3;
  HEAP32[$4 + 12 >> 2] = _jswrap_promise_new_reaction(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
  if (HEAP32[$4 + 12 >> 2]) {
   HEAP32[$4 + 8 >> 2] = HEAP8[$4 + 19 | 0] & 1 ? 15536 : 5049;
   HEAP32[$4 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2]);
   block : {
    if (jsvIsArray(HEAP32[$4 + 4 >> 2]) & 1) {
     jsvArrayPush(HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2]);
     break block;
    }
    jsvUnLock(HEAP32[$4 + 4 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2], jsvNewArray($4 + 12 | 0, 1));
   }
   jsvUnLock2(HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function _jswrap_promise_new_reaction($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = jsvNewObject();
  block : {
   if (!HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break block;
   }
   jsvObjectSetChild(HEAP32[$2 >> 2], 20492, HEAP32[$2 + 4 >> 2]);
   jsvObjectSetChild(HEAP32[$2 >> 2], 4271, HEAP32[$2 + 8 >> 2]);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function _jswrap_promise_queue_reaction($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP8[$4 + 35 | 0] = $3;
  HEAP32[$4 + 28 >> 2] = jsvNewNativeFunction(671, 33352);
  if (HEAP32[$4 + 28 >> 2]) {
   jsvObjectSetChild(HEAP32[$4 + 28 >> 2], 7212, HEAP32[$4 + 44 >> 2]);
   HEAP32[$4 + 24 >> 2] = jsvNewFromBool(HEAP8[$4 + 35 | 0] & 1);
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 40 >> 2];
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 24 >> 2];
   jsiQueueEvents(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 28 >> 2], $4 + 12 | 0, 3);
   jsvUnLock2(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
  }
  __stack_pointer = $4 + 48 | 0;
 }
 
 function jswrap_promise_reject($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 >> 2] = jspromise_create_prombox($1 + 4 | 0);
  block : {
   if (!HEAP32[$1 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   if (HEAP32[$1 + 4 >> 2]) {
    _jswrap_prombox_queuereject(HEAP32[$1 >> 2], HEAP32[$1 + 8 >> 2])
   }
   jsvUnLock(HEAP32[$1 >> 2]);
   HEAP32[$1 + 12 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 4 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function _jswrap_promise_reaction_call($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 48 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 40 >> 2] = $1;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP32[$4 + 32 >> 2] = $3;
  HEAP32[$4 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 40 >> 2], 4271);
  HEAP32[$4 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], 15707);
  if (HEAP32[$4 + 28 >> 2]) {
   if (HEAP32[$4 + 24 >> 2]) {
    HEAP8[$4 + 23 | 0] = 0;
    HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 40 >> 2], 20492);
    block : {
     if (HEAP32[$4 + 12 >> 2]) {
      HEAP32[$4 + 8 >> 2] = HEAP32[103315];
      HEAP32[$4 + 16 >> 2] = jspeFunctionCall(HEAP32[$4 + 12 >> 2], 0, HEAP32[$4 + 44 >> 2], 0, 1, $4 + 36 | 0);
      HEAP32[103315] = HEAP32[$4 + 8 >> 2];
      HEAP32[$4 + 4 >> 2] = jspGetException();
      if (HEAP32[$4 + 4 >> 2]) {
       HEAP8[$4 + 23 | 0] = 1;
       jsvUnLock(HEAP32[$4 + 16 >> 2]);
       HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 4 >> 2];
      }
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      break block;
     }
     if (!(jsvGetBool(HEAP32[$4 + 32 >> 2]) & 1)) {
      HEAP8[$4 + 23 | 0] = 1
     }
     HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
    }
    _jswrap_prombox_resolve_or_reject(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 16 >> 2], (HEAPU8[$4 + 23 | 0] ^ -1) & 1);
    if (HEAP32[$4 + 12 >> 2]) {
     jsvUnLock(HEAP32[$4 + 16 >> 2])
    }
    jsvUnLock(HEAP32[$4 + 24 >> 2]);
   }
   jsvUnLock(HEAP32[$4 + 28 >> 2]);
  }
  __stack_pointer = $4 + 48 | 0;
 }
 
 function jswrap_promise_catch($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_promise_then(HEAP32[$2 + 12 >> 2], 0, HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function _jswrap_prombox_resolve($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  _jswrap_prombox_resolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function _jswrap_prombox_reject($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  _jswrap_prombox_resolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function _jswrap_prombox_resolve_or_reject($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 60 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP8[$3 + 55 | 0] = $2;
  HEAP8[$3 + 54 | 0] = jsvObjectGetBoolChild(HEAP32[$3 + 60 >> 2], 15738) & 1;
  block : {
   if (HEAP8[$3 + 54 | 0] & 1) {
    break block
   }
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 60 >> 2], 15738, jsvNewFromBool(1));
   HEAP32[$3 + 48 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 60 >> 2], 15707);
   if (!HEAP32[$3 + 48 >> 2]) {
    break block
   }
   if (jsvIsEqual(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 48 >> 2]) & 1) {
    jsExceptionHere(1, 17094, 0);
    jsvUnLock(HEAP32[$3 + 48 >> 2]);
    break block;
   }
   jsvObjectSetChild(HEAP32[$3 + 48 >> 2], 15857, HEAP32[$3 + 56 >> 2]);
   block1 : {
    if (HEAP8[$3 + 55 | 0] & 1) {
     if (jsvIsObject(HEAP32[$3 + 56 >> 2]) & 1) {
      break block1
     }
    }
    _jswrap_promise_seal(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 56 >> 2], HEAP8[$3 + 55 | 0] & 1);
    jsvUnLock(HEAP32[$3 + 48 >> 2]);
    break block;
   }
   HEAP8[$3 + 47 | 0] = _jswrap_promise_is_promise(HEAP32[$3 + 56 >> 2]) & 1;
   HEAP8[$3 + 46 | 0] = 0;
   HEAP32[$3 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 56 >> 2], 15562);
   if (jsvIsFunction(HEAP32[$3 + 40 >> 2]) & 1) {
    HEAP8[$3 + 46 | 0] = 1
   }
   if (!(HEAP8[$3 + 46 | 0] & 1 | HEAP8[$3 + 47 | 0] & 1)) {
    _jswrap_promise_seal(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 56 >> 2], HEAP8[$3 + 55 | 0] & 1);
    jsvUnLock2(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 40 >> 2]);
    break block;
   }
   HEAP32[$3 + 36 >> 2] = jsvNewObject();
   HEAP32[$3 + 32 >> 2] = _jswrap_promise_native_with_prombox(665, HEAP32[$3 + 36 >> 2]);
   HEAP32[$3 + 28 >> 2] = _jswrap_promise_native_with_prombox(666, HEAP32[$3 + 36 >> 2]);
   if (HEAP32[$3 + 36 >> 2]) {
    jsvObjectSetChild(HEAP32[$3 + 36 >> 2], 15707, HEAP32[$3 + 48 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 36 >> 2], 15738, jsvNewFromBool(0));
    block3 : {
     if (HEAP8[$3 + 46 | 0] & 1) {
      HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 32 >> 2];
      HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 28 >> 2];
      HEAP32[$3 + 16 >> 2] = HEAP32[103315];
      jsvUnLock(jspeFunctionCall(HEAP32[$3 + 40 >> 2], 0, HEAP32[$3 + 56 >> 2], 0, 2, $3 + 20 | 0));
      HEAP32[103315] = HEAP32[$3 + 16 >> 2];
      HEAP32[$3 + 12 >> 2] = jspGetException();
      if (HEAP32[$3 + 12 >> 2]) {
       _jswrap_prombox_reject(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 12 >> 2]);
       jsvUnLock(HEAP32[$3 + 12 >> 2]);
      }
      break block3;
     }
     jsvUnLock(jswrap_promise_then(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]));
    }
    jsvUnLock3(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 36 >> 2]);
   }
   jsvUnLock2(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 40 >> 2]);
  }
  __stack_pointer = $3 - -64 | 0;
 }
 
 function _jswrap_promise_seal($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP8[$3 + 39 | 0] = $2;
  jsvObjectSetChildAndUnLock(HEAP32[$3 + 44 >> 2], 17546, jsvNewFromInteger(HEAP8[$3 + 39 | 0] & 1 ? 2 : 1));
  HEAP32[$3 + 32 >> 2] = HEAP8[$3 + 39 | 0] & 1 ? 15536 : 5049;
  HEAP32[$3 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2]);
  block1 : {
   if (!HEAP32[$3 + 28 >> 2]) {
    if (!(HEAP8[$3 + 39 | 0] & 1)) {
     HEAP32[$3 >> 2] = HEAP32[$3 + 40 >> 2];
     jsExceptionHere(1, 4234, $3);
     HEAP32[$3 + 24 >> 2] = 0;
     block : {
      if (!(jsvIsObject(HEAP32[$3 + 40 >> 2]) & 1)) {
       break block
      }
      $0 = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 15983);
      HEAP32[$3 + 24 >> 2] = $0;
      if (!$0) {
       break block
      }
      jsvObjectSetChildAndUnLock(HEAP32[103308], 18338, HEAP32[$3 + 24 >> 2]);
     }
    }
    break block1;
   }
   if (jsvIsArray(HEAP32[$3 + 28 >> 2]) & 1) {
    jsvObjectIteratorNew($3 + 20 | 0, HEAP32[$3 + 28 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_1812($3 + 20 | 0) & 1) {
      HEAP32[$3 + 16 >> 2] = jsvObjectIteratorGetValue_1813($3 + 20 | 0);
      _jswrap_promise_queue_reaction(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 40 >> 2], HEAP8[$3 + 39 | 0] & 1);
      jsvUnLock(HEAP32[$3 + 16 >> 2]);
      jsvObjectIteratorNext($3 + 20 | 0);
      continue;
     }
     break;
    };
    jsvObjectIteratorFree_1817($3 + 20 | 0);
   }
   jsvUnLock(HEAP32[$3 + 28 >> 2]);
  }
  __stack_pointer = $3 + 48 | 0;
 }
 
 function jswrap_serial_constructor() {
  return jspNewObject(0, 15938) | 0;
 }
 
 function jswrap_serial_setConsole($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  HEAP8[$2 + 10 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 12 >> 2]);
  block1 : {
   if (!(HEAPU8[$2 + 10 | 0] < 17 | HEAPU8[$2 + 10 | 0] > 22)) {
    jsiSetConsoleDevice(HEAPU8[$2 + 10 | 0], HEAP8[$2 + 11 | 0] & 1);
    break block1;
   }
   jsExceptionHere(1, 7462, 0);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_serial_setup($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (!(jsvIsObject(HEAP32[$3 + 28 >> 2]) & 1)) {
    break block
   }
   HEAP8[$3 + 19 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 28 >> 2]);
   block1 : {
    if (jsvIsUndefined(HEAP32[$3 + 20 >> 2]) & 1) {
     HEAP32[$3 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 28 >> 2], 7138);
     break block1;
    }
    jsvLockAgain(HEAP32[$3 + 20 >> 2]);
   }
   HEAP8[$3 + 5 | 0] = jsserialPopulateUSARTInfo($3 + 6 | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]) & 1;
   if (!(HEAP8[$3 + 5 | 0] & 1)) {
    jsvUnLock(HEAP32[$3 + 20 >> 2]);
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 28 >> 2], 17579, jsvNewFromInteger(HEAPU8[$3 + 6 | 0] | HEAPU8[$3 + 7 | 0] << 8 | (HEAPU8[$3 + 8 | 0] << 16 | HEAPU8[$3 + 9 | 0] << 24)));
   block2 : {
    if (HEAP32[$3 + 20 >> 2]) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 28 >> 2], 7138, HEAP32[$3 + 20 >> 2]);
     break block2;
    }
    jsvObjectRemoveChild(HEAP32[$3 + 28 >> 2], 7138);
   }
   if (!(HEAPU8[$3 + 19 | 0] < 17 | HEAPU8[$3 + 19 | 0] > 22)) {
    if (!(HEAPU8[$3 + 19 | 0] < 22 | HEAPU8[$3 + 19 | 0] > 22)) {
     jshUSARTSetup(HEAPU8[$3 + 19 | 0], $3 + 6 | 0)
    }
    break block;
   }
   if (!HEAPU8[$3 + 19 | 0]) {
    if (HEAPU8[$3 + 11 | 0] != 255) {
     jshPinSetState(HEAPU8[$3 + 11 | 0], 1);
     jshPinOutput(HEAPU8[$3 + 11 | 0], 1);
    }
    if (HEAPU8[$3 + 10 | 0] != 255) {
     jshPinSetState(HEAPU8[$3 + 10 | 0], 5);
     jsserialEventCallbackInit(HEAP32[$3 + 28 >> 2], $3 + 6 | 0);
    }
    if (HEAPU8[$3 + 12 | 0] != 255) {
     jsExceptionHere(1, 4927, 0)
    }
   }
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jswrap_serial_unsetup($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  block : {
   if (!(jsvIsObject(HEAP32[$1 + 28 >> 2]) & 1)) {
    break block
   }
   HEAP8[$1 + 27 | 0] = jsiGetDeviceFromClass(HEAP32[$1 + 28 >> 2]);
   HEAP32[$1 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 28 >> 2], 7138);
   HEAP32[$1 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 28 >> 2], 17579);
   if (HEAP32[$1 + 20 >> 2]) {
    jsserialPopulateUSARTInfo($1 + 3 | 0, HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
    if (HEAPU8[$1 + 9 | 0] != 255) {
     jshPinSetState(HEAPU8[$1 + 9 | 0], 0)
    }
    if (HEAPU8[$1 + 10 | 0] != 255) {
     jshPinSetState(HEAPU8[$1 + 10 | 0], 0)
    }
    if (HEAPU8[$1 + 7 | 0] != 255) {
     jshPinSetState(HEAPU8[$1 + 7 | 0], 0)
    }
    if (HEAPU8[$1 + 8 | 0] != 255) {
     jshPinSetState(HEAPU8[$1 + 8 | 0], 0)
    }
    if (!(HEAPU8[$1 + 27 | 0] <= 22 & HEAPU8[$1 + 27 | 0] >= 17)) {
     jsserialEventCallbackKill(HEAP32[$1 + 28 >> 2], $1 + 3 | 0)
    }
   }
   jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
   jsvObjectRemoveChild(HEAP32[$1 + 28 >> 2], 17579);
   jsvObjectRemoveChild(HEAP32[$1 + 28 >> 2], 7138);
   if (HEAPU8[$1 + 27 | 0] < 17 | HEAPU8[$1 + 27 | 0] > 22) {
    break block
   }
   jshUSARTUnSetup(HEAPU8[$1 + 27 | 0]);
   jshSetFlowControlEnabled(HEAPU8[$1 + 27 | 0], 0, 255);
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jswrap_serial_idle() {
  return jsserialEventCallbackIdle() & 1;
 }
 
 function _jswrap_serial_print($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP8[$4 + 23 | 0] = $2;
  HEAP8[$4 + 22 | 0] = $3;
  block : {
   if (!(jsserialGetSendFunction(HEAP32[$4 + 28 >> 2], $4 + 16 | 0, $4 + 3 | 0) & 1)) {
    break block
   }
   if (HEAP8[$4 + 23 | 0] & 1) {
    HEAP32[$4 + 24 >> 2] = jsvAsString(HEAP32[$4 + 24 >> 2])
   }
   jsvIterateCallback(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2], $4 + 3 | 0);
   if (HEAP8[$4 + 23 | 0] & 1) {
    jsvUnLock(HEAP32[$4 + 24 >> 2])
   }
   if (!(HEAP8[$4 + 22 | 0] & 1)) {
    break block
   }
   FUNCTION_TABLE[HEAP32[$4 + 16 >> 2]](13, $4 + 3 | 0);
   FUNCTION_TABLE[HEAP32[$4 + 16 >> 2]](10, $4 + 3 | 0);
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jswrap_serial_print($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1, 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_serial_println($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1, 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_serial_write($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 0);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_serial_inject($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP8[$2 + 7 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 12 >> 2]);
  if (!(HEAPU8[$2 + 7 | 0] < 17 | HEAPU8[$2 + 7 | 0] > 22)) {
   jsvIterateBufferCallback(HEAP32[$2 + 8 >> 2], 672, $2 + 7 | 0)
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function _jswrap_serial_inject_cb($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP8[$3 + 3 | 0] = HEAPU8[HEAP32[$3 + 4 >> 2]];
  jshPushIOCharEvents(HEAPU8[$3 + 3 | 0], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_serial_flush($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jsiGetDeviceFromClass(HEAP32[$1 + 12 >> 2]);
  if (HEAPU8[$1 + 11 | 0]) {
   jshTransmitFlushDevice(HEAPU8[$1 + 11 | 0])
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_serial_isConnected($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP8[$1 + 7 | 0] = jsiGetDeviceFromClass(HEAP32[$1 + 8 >> 2]);
  block1 : {
   if (!(HEAPU8[$1 + 7 | 0] != 17 & HEAPU8[$1 + 7 | 0] != 18)) {
    HEAP8[$1 + 15 | 0] = 1;
    break block1;
   }
   if (HEAPU8[$1 + 7 | 0] == 20) {
    HEAP8[$1 + 15 | 0] = 1;
    break block1;
   }
   if (HEAPU8[$1 + 7 | 0] == 21) {
    HEAP8[$1 + 15 | 0] = jshIsUSBSERIALConnected() & 1;
    break block1;
   }
   if (!(HEAPU8[$1 + 7 | 0] < 22 | HEAPU8[$1 + 7 | 0] > 22)) {
    HEAP8[$1 + 15 | 0] = jshIsDeviceInitialised(HEAPU8[$1 + 7 | 0]) & 1;
    break block1;
   }
   HEAP8[$1 + 15 | 0] = 0;
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function jswrap_storage_eraseAll() {
  jsfEraseAll();
 }
 
 function jswrap_storage_erase($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer + -64 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 60 >> 2] = $0;
  jsfNameFromVar($1 + 32 | 0, HEAP32[$1 + 60 >> 2]);
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 56 >> 2];
  $2 = HEAP32[$1 + 52 >> 2];
  $0 = HEAP32[$1 + 48 >> 2];
  HEAP32[$1 + 16 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = $2;
  $0 = HEAP32[$1 + 44 >> 2];
  $2 = HEAP32[$1 + 40 >> 2];
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = HEAP32[$1 + 36 >> 2];
  $0 = HEAP32[$1 + 32 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  jsfEraseFile($1);
  __stack_pointer = $1 - -64 | 0;
 }
 
 function jswrap_storage_read($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 80 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 76 >> 2] = $0;
  HEAP32[$3 + 72 >> 2] = $1;
  HEAP32[$3 + 68 >> 2] = $2;
  jsfNameFromVar($3 + 40 | 0, HEAP32[$3 + 76 >> 2]);
  $2 = HEAP32[$3 + 72 >> 2];
  $4 = HEAP32[$3 + 68 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 64 >> 2];
  $1 = HEAP32[$3 + 60 >> 2];
  $0 = HEAP32[$3 + 56 >> 2];
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 28 >> 2] = $1;
  $0 = HEAP32[$3 + 52 >> 2];
  $1 = HEAP32[$3 + 48 >> 2];
  HEAP32[$3 + 16 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $0;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$3 + 40 >> 2];
  HEAP32[$3 + 8 >> 2] = $0;
  HEAP32[$3 + 12 >> 2] = $1;
  $0 = jsfReadFile($3 + 8 | 0, $2, $4);
  __stack_pointer = $3 + 80 | 0;
  return $0 | 0;
 }
 
 function jswrap_storage_readJSON($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP8[$2 + 71 | 0] = $1;
  jsfNameFromVar($2 + 36 | 0, HEAP32[$2 + 72 >> 2]);
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 60 >> 2];
  $1 = HEAP32[$2 + 56 >> 2];
  $0 = HEAP32[$2 + 52 >> 2];
  HEAP32[$2 + 16 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  $0 = HEAP32[$2 + 48 >> 2];
  $1 = HEAP32[$2 + 44 >> 2];
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = $0;
  $1 = HEAP32[$2 + 40 >> 2];
  $0 = HEAP32[$2 + 36 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 64 >> 2] = jsfReadFile($2, 0, 0);
  block : {
   if (!HEAP32[$2 + 64 >> 2]) {
    HEAP32[$2 + 76 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 32 >> 2] = jswrap_json_parse_liberal(HEAP32[$2 + 64 >> 2], HEAP8[$2 + 71 | 0] & 1);
   jsvUnLock(HEAP32[$2 + 64 >> 2]);
   HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 32 >> 2];
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAP32[$2 + 76 >> 2];
 }
 
 function jswrap_storage_readArrayBuffer($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  jsfNameFromVar($1 + 40 | 0, HEAP32[$1 + 72 >> 2]);
  HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 64 >> 2];
  $2 = HEAP32[$1 + 60 >> 2];
  $0 = HEAP32[$1 + 56 >> 2];
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 28 >> 2] = $2;
  $0 = HEAP32[$1 + 52 >> 2];
  $2 = HEAP32[$1 + 48 >> 2];
  HEAP32[$1 + 16 >> 2] = $2;
  HEAP32[$1 + 20 >> 2] = $0;
  $2 = HEAP32[$1 + 44 >> 2];
  $0 = HEAP32[$1 + 40 >> 2];
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 12 >> 2] = $2;
  HEAP32[$1 + 68 >> 2] = jsfReadFile($1 + 8 | 0, 0, 0);
  block : {
   if (!HEAP32[$1 + 68 >> 2]) {
    HEAP32[$1 + 76 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 36 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 68 >> 2], 0);
   jsvUnLock(HEAP32[$1 + 68 >> 2]);
   HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 36 >> 2];
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jswrap_storage_write($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  $4 = __stack_pointer - 80 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 76 >> 2] = $0;
  HEAP32[$4 + 72 >> 2] = $1;
  HEAP32[$4 + 68 >> 2] = $2;
  HEAP32[$4 + 64 >> 2] = $3;
  block : {
   if (jsvIsObject(HEAP32[$4 + 72 >> 2]) & 1) {
    HEAP32[$4 + 60 >> 2] = jswrap_json_stringify(HEAP32[$4 + 72 >> 2], 0, 0);
    HEAP32[$4 + 68 >> 2] = 0;
    HEAP32[$4 + 64 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 60 >> 2] = jsvLockAgainSafe(HEAP32[$4 + 72 >> 2]);
  }
  jsfNameFromVar($4 + 28 | 0, HEAP32[$4 + 76 >> 2]);
  $2 = HEAP32[$4 + 60 >> 2];
  $3 = HEAP32[$4 + 68 >> 2];
  $5 = HEAP32[$4 + 64 >> 2];
  HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 52 >> 2];
  $1 = HEAP32[$4 + 48 >> 2];
  $0 = HEAP32[$4 + 44 >> 2];
  HEAP32[$4 + 16 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  $0 = HEAP32[$4 + 40 >> 2];
  $1 = HEAP32[$4 + 36 >> 2];
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 12 >> 2] = $0;
  $1 = HEAP32[$4 + 32 >> 2];
  $0 = HEAP32[$4 + 28 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP8[$4 + 59 | 0] = jsfWriteFile($4, $2, 0, $3, $5) & 1;
  jsvUnLock(HEAP32[$4 + 60 >> 2]);
  __stack_pointer = $4 + 80 | 0;
  return HEAP8[$4 + 59 | 0] & 1;
 }
 
 function jswrap_storage_writeJSON($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 80 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 72 >> 2] = $0;
  HEAP32[$2 + 68 >> 2] = $1;
  HEAP32[$2 + 64 >> 2] = jsvNewFromEmptyString_1849();
  block : {
   if (!HEAP32[$2 + 64 >> 2]) {
    HEAP8[$2 + 79 | 0] = 0;
    break block;
   }
   jsfGetJSON(HEAP32[$2 + 68 >> 2], HEAP32[$2 + 64 >> 2], 14032);
   jsfNameFromVar($2 + 32 | 0, HEAP32[$2 + 72 >> 2]);
   $3 = HEAP32[$2 + 64 >> 2];
   HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2];
   $1 = HEAP32[$2 + 52 >> 2];
   $0 = HEAP32[$2 + 48 >> 2];
   HEAP32[$2 + 16 >> 2] = $0;
   HEAP32[$2 + 20 >> 2] = $1;
   $0 = HEAP32[$2 + 44 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   HEAP32[$2 + 8 >> 2] = $1;
   HEAP32[$2 + 12 >> 2] = $0;
   $1 = HEAP32[$2 + 36 >> 2];
   $0 = HEAP32[$2 + 32 >> 2];
   HEAP32[$2 >> 2] = $0;
   HEAP32[$2 + 4 >> 2] = $1;
   HEAP8[$2 + 63 | 0] = jsfWriteFile($2, $3, 0, 0, 0) & 1;
   jsvUnLock(HEAP32[$2 + 64 >> 2]);
   HEAP8[$2 + 79 | 0] = HEAP8[$2 + 63 | 0] & 1;
  }
  __stack_pointer = $2 + 80 | 0;
  return HEAP8[$2 + 79 | 0] & 1;
 }
 
 function jsvNewFromEmptyString_1849() {
  return jsvNewWithFlags(29);
 }
 
 function jswrap_storage_list($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
   HEAP32[$2 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 24 >> 2], 17075);
   if (HEAP32[$2 + 12 >> 2]) {
    block : {
     if (jsvGetBoolAndUnLock(HEAP32[$2 + 12 >> 2]) & 1) {
      HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] | 64;
      break block;
     }
     HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] | 64;
    }
   }
  }
  $0 = jsfListFiles(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
  __stack_pointer = $2 + 32 | 0;
  return $0 | 0;
 }
 
 function jswrap_storage_hash($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jsfHashFiles(HEAP32[$1 + 12 >> 2], 0, 64);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_storage_compact($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 15 | 0] = $0;
  jsfCompact(HEAP8[$1 + 15 | 0] & 1);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_storage_getFree($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 47 | 0] = $0;
  HEAP32[$1 + 40 >> 2] = 0;
  jsfGetStorageStats($1 + 12 | 0, HEAP32[$1 + 40 >> 2], 1);
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 32 >> 2];
 }
 
 function jswrap_storage_getStats($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 40 >> 2] = $0;
  HEAP32[$1 + 36 >> 2] = jsvNewObject();
  block : {
   if (!HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 44 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 32 >> 2] = 134217728;
   jsfGetStorageStats($1 + 4 | 0, HEAP32[$1 + 32 >> 2], 1);
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 7233, jsvNewFromInteger(HEAP32[$1 + 20 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 7265, jsvNewFromInteger(HEAP32[$1 + 24 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 7255, jsvNewFromInteger(HEAP32[$1 + 4 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 4559, jsvNewFromInteger(HEAP32[$1 + 8 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 7244, jsvNewFromInteger(HEAP32[$1 + 12 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 4511, jsvNewFromInteger(HEAP32[$1 + 16 >> 2]));
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 36 >> 2];
  }
  __stack_pointer = $1 + 48 | 0;
  return HEAP32[$1 + 44 >> 2];
 }
 
 function jswrap_storage_optimise() {
  jsfCreateFileTable();
 }
 
 function jswrap_storage_open($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 256 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 248 >> 2] = $0;
  HEAP32[$2 + 244 >> 2] = $1;
  HEAP8[$2 + 243 | 0] = 0;
  block3 : {
   block : {
    if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 14628) & 1) {
     HEAP8[$2 + 243 | 0] = 114;
     break block;
    }
    block1 : {
     if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 4131) & 1) {
      HEAP8[$2 + 243 | 0] = 119;
      break block1;
     }
     block2 : {
      if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 20668) & 1) {
       HEAP8[$2 + 243 | 0] = 97;
       break block2;
      }
      HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 244 >> 2];
      jsExceptionHere(1, 16148, $2 - -64 | 0);
      HEAP32[$2 + 252 >> 2] = 0;
      break block3;
     }
    }
   }
   HEAP32[$2 + 236 >> 2] = jspNewObject(0, 17907);
   if (!HEAP32[$2 + 236 >> 2]) {
    HEAP32[$2 + 252 >> 2] = 0;
    break block3;
   }
   HEAP32[$2 + 232 >> 2] = 1;
   HEAP32[$2 + 228 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 248 >> 2], 0, 28);
   jsfNameFromVar($2 + 200 | 0, HEAP32[$2 + 228 >> 2]);
   HEAP32[$2 + 196 >> 2] = 27;
   while (1) {
    $0 = 0;
    $0 = HEAP32[$2 + 196 >> 2] ? !HEAPU8[(HEAP32[$2 + 196 >> 2] + $2 | 0) + 199 | 0] : $0;
    if ($0) {
     HEAP32[$2 + 196 >> 2] = HEAP32[$2 + 196 >> 2] - 1;
     continue;
    }
    break;
   };
   HEAP8[HEAP32[$2 + 196 >> 2] + ($2 + 200 | 0) | 0] = HEAP32[$2 + 232 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 17830, HEAP32[$2 + 228 >> 2]);
   HEAP32[$2 + 192 >> 2] = 0;
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 224 >> 2];
   $0 = HEAP32[$2 + 220 >> 2];
   $1 = HEAP32[$2 + 216 >> 2];
   HEAP32[$2 + 48 >> 2] = $1;
   HEAP32[$2 + 52 >> 2] = $0;
   $1 = HEAP32[$2 + 212 >> 2];
   $0 = HEAP32[$2 + 208 >> 2];
   HEAP32[$2 + 40 >> 2] = $0;
   HEAP32[$2 + 44 >> 2] = $1;
   $0 = HEAP32[$2 + 204 >> 2];
   $1 = HEAP32[$2 + 200 >> 2];
   HEAP32[$2 + 32 >> 2] = $1;
   HEAP32[$2 + 36 >> 2] = $0;
   HEAP32[$2 + 156 >> 2] = jsfFindFile($2 + 32 | 0, $2 + 160 | 0);
   if (HEAP32[$2 + 156 >> 2] ? HEAPU8[$2 + 243 | 0] == 119 : 0) {
    jswrap_storagefile_erase(HEAP32[$2 + 236 >> 2]);
    HEAP32[$2 + 156 >> 2] = 0;
   }
   block4 : {
    if (HEAP32[$2 + 156 >> 2]) {
     $0 = jsfGetFileSize($2 + 160 | 0);
     break block4;
    }
    $0 = 0;
   }
   HEAP32[$2 + 152 >> 2] = $0;
   if (HEAPU8[$2 + 243 | 0] == 97) {
    HEAP8[$2 + 151 | 0] = 255;
    if (HEAP32[$2 + 156 >> 2]) {
     jshFlashRead($2 + 151 | 0, (HEAP32[$2 + 156 >> 2] + jsfGetFileSize($2 + 160 | 0) | 0) - 1 | 0, 1)
    }
    while (1) {
     $0 = 0;
     block5 : {
      if (!HEAP32[$2 + 156 >> 2]) {
       break block5
      }
      $0 = 0;
      if (HEAPU8[$2 + 151 | 0] == 255) {
       break block5
      }
      $0 = HEAP32[$2 + 232 >> 2] < 255;
     }
     if ($0) {
      HEAP32[$2 + 232 >> 2] = HEAP32[$2 + 232 >> 2] + 1;
      HEAP8[HEAP32[$2 + 196 >> 2] + ($2 + 200 | 0) | 0] = HEAP32[$2 + 232 >> 2];
      HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 224 >> 2];
      $1 = HEAP32[$2 + 220 >> 2];
      $0 = HEAP32[$2 + 216 >> 2];
      HEAP32[$2 + 16 >> 2] = $0;
      HEAP32[$2 + 20 >> 2] = $1;
      $0 = HEAP32[$2 + 212 >> 2];
      $1 = HEAP32[$2 + 208 >> 2];
      HEAP32[$2 + 8 >> 2] = $1;
      HEAP32[$2 + 12 >> 2] = $0;
      $1 = HEAP32[$2 + 204 >> 2];
      $0 = HEAP32[$2 + 200 >> 2];
      HEAP32[$2 >> 2] = $0;
      HEAP32[$2 + 4 >> 2] = $1;
      HEAP32[$2 + 156 >> 2] = jsfFindFile($2, $2 + 160 | 0);
      block6 : {
       if (HEAP32[$2 + 156 >> 2]) {
        HEAP32[$2 + 152 >> 2] = jsfGetFileSize($2 + 160 | 0);
        jshFlashRead($2 + 151 | 0, (HEAP32[$2 + 156 >> 2] + HEAP32[$2 + 152 >> 2] | 0) - 1 | 0, 1);
        break block6;
       }
       HEAP32[$2 + 152 >> 2] = 0;
      }
      continue;
     }
     break;
    };
    if (HEAP32[$2 + 156 >> 2]) {
     HEAP8[$2 + 79 | 0] = 0;
     while (1) {
      block7 : {
       if (!((HEAPU8[$2 + 79 | 0] ^ -1) & 1)) {
        break block7
       }
       HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 152 >> 2] - HEAP32[$2 + 192 >> 2];
       if (HEAP32[$2 + 72 >> 2] <= 0) {
        HEAP8[$2 + 79 | 0] = 1;
        break block7;
       }
       if (HEAP32[$2 + 72 >> 2] > 64) {
        HEAP32[$2 + 72 >> 2] = 64
       }
       jshFlashRead($2 + 80 | 0, HEAP32[$2 + 156 >> 2] + HEAP32[$2 + 192 >> 2] | 0, HEAP32[$2 + 72 >> 2]);
       HEAP32[$2 + 68 >> 2] = 0;
       while (1) {
        if (HEAP32[$2 + 68 >> 2] < HEAP32[$2 + 72 >> 2]) {
         if (HEAPU8[HEAP32[$2 + 68 >> 2] + ($2 + 80 | 0) | 0] == 255) {
          HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 68 >> 2];
          HEAP8[$2 + 79 | 0] = 1;
         } else {
          HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 68 >> 2] + 1;
          continue;
         }
        }
        break;
       };
       HEAP32[$2 + 192 >> 2] = HEAP32[$2 + 72 >> 2] + HEAP32[$2 + 192 >> 2];
       continue;
      }
      break;
     };
    }
   }
   block8 : {
    if (HEAPU8[$2 + 243 | 0] != 114) {
     break block8
    }
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 15950, jsvNewFromInteger(HEAP32[$2 + 232 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 4966, jsvNewFromInteger(HEAP32[$2 + 192 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 18218, jsvNewFromInteger(HEAP8[$2 + 243 | 0] << 24 >> 24));
   HEAP32[$2 + 252 >> 2] = HEAP32[$2 + 236 >> 2];
  }
  __stack_pointer = $2 + 256 | 0;
  return HEAP32[$2 + 252 >> 2];
 }
 
 function jswrap_storagefile_erase($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 76 >> 2] = $0;
  jsfNameFromVarAndUnLock($1 + 48 | 0, jsvObjectGetChildIfExists(HEAP32[$1 + 76 >> 2], 17830));
  HEAP32[$1 + 44 >> 2] = 27;
  while (1) {
   $0 = 0;
   $0 = HEAP32[$1 + 44 >> 2] ? !HEAPU8[(HEAP32[$1 + 44 >> 2] + $1 | 0) + 47 | 0] : $0;
   if ($0) {
    HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 44 >> 2] - 1;
    continue;
   }
   break;
  };
  HEAP32[$1 + 40 >> 2] = 1;
  HEAP8[$1 + 39 | 0] = 1;
  while (1) {
   if (HEAP8[$1 + 39 | 0] & 1) {
    HEAP8[HEAP32[$1 + 44 >> 2] + ($1 + 48 | 0) | 0] = HEAP32[$1 + 40 >> 2];
    HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 72 >> 2];
    $2 = HEAP32[$1 + 68 >> 2];
    $0 = HEAP32[$1 + 64 >> 2];
    HEAP32[$1 + 24 >> 2] = $0;
    HEAP32[$1 + 28 >> 2] = $2;
    $0 = HEAP32[$1 + 60 >> 2];
    $2 = HEAP32[$1 + 56 >> 2];
    HEAP32[$1 + 16 >> 2] = $2;
    HEAP32[$1 + 20 >> 2] = $0;
    $2 = HEAP32[$1 + 52 >> 2];
    $0 = HEAP32[$1 + 48 >> 2];
    HEAP32[$1 + 8 >> 2] = $0;
    HEAP32[$1 + 12 >> 2] = $2;
    HEAP8[$1 + 39 | 0] = jsfEraseFile($1 + 8 | 0) & 1;
    HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 40 >> 2] + 1;
    continue;
   }
   break;
  };
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 15950, jsvNewFromInteger(1));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 4966, jsvNewFromInteger(0));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 18218, jsvNewFromInteger(0));
  __stack_pointer = $1 + 80 | 0;
 }
 
 function jswrap_storagefile_read_internal($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 224 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 216 >> 2] = $0;
  HEAP32[$2 + 212 >> 2] = $1;
  HEAP8[$2 + 211 | 0] = HEAP32[$2 + 212 >> 2] < 0;
  HEAP8[$2 + 210 | 0] = jsvObjectGetIntegerChild(HEAP32[$2 + 216 >> 2], 18218);
  block : {
   if (HEAPU8[$2 + 210 | 0] != 114) {
    jsExceptionHere(1, 18182, 0);
    HEAP32[$2 + 220 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 204 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 216 >> 2], 15950);
   jsfNameFromVarAndUnLock($2 + 176 | 0, jsvObjectGetChildIfExists(HEAP32[$2 + 216 >> 2], 17830));
   HEAP32[$2 + 172 >> 2] = 27;
   while (1) {
    $0 = 0;
    $0 = HEAP32[$2 + 172 >> 2] ? !HEAPU8[(HEAP32[$2 + 172 >> 2] + $2 | 0) + 175 | 0] : $0;
    if ($0) {
     HEAP32[$2 + 172 >> 2] = HEAP32[$2 + 172 >> 2] - 1;
     continue;
    }
    break;
   };
   HEAP8[HEAP32[$2 + 172 >> 2] + ($2 + 176 | 0) | 0] = HEAP32[$2 + 204 >> 2];
   HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 200 >> 2];
   $0 = HEAP32[$2 + 196 >> 2];
   $1 = HEAP32[$2 + 192 >> 2];
   HEAP32[$2 + 56 >> 2] = $1;
   HEAP32[$2 + 60 >> 2] = $0;
   $1 = HEAP32[$2 + 188 >> 2];
   $0 = HEAP32[$2 + 184 >> 2];
   HEAP32[$2 + 48 >> 2] = $0;
   HEAP32[$2 + 52 >> 2] = $1;
   $0 = HEAP32[$2 + 180 >> 2];
   $1 = HEAP32[$2 + 176 >> 2];
   HEAP32[$2 + 40 >> 2] = $1;
   HEAP32[$2 + 44 >> 2] = $0;
   HEAP32[$2 + 136 >> 2] = jsfFindFile($2 + 40 | 0, $2 + 140 | 0);
   if (!HEAP32[$2 + 136 >> 2]) {
    HEAP32[$2 + 220 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 132 >> 2] = jsfGetFileSize($2 + 140 | 0);
   HEAP32[$2 + 128 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 216 >> 2], 4966);
   HEAP32[$2 + 124 >> 2] = 0;
   if (HEAP8[$2 + 211 | 0] & 1) {
    HEAP32[$2 + 212 >> 2] = 32
   }
   while (1) {
    block1 : {
     if (!HEAP32[$2 + 212 >> 2]) {
      break block1
     }
     HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 132 >> 2] - HEAP32[$2 + 128 >> 2];
     if (HEAP32[$2 + 76 >> 2] <= 0) {
      HEAP32[$2 + 128 >> 2] = 0;
      block2 : {
       if (HEAP32[$2 + 204 >> 2] == 255) {
        HEAP32[$2 + 136 >> 2] = 0;
        break block2;
       }
       HEAP32[$2 + 204 >> 2] = HEAP32[$2 + 204 >> 2] + 1;
       HEAP8[HEAP32[$2 + 172 >> 2] + ($2 + 176 | 0) | 0] = HEAP32[$2 + 204 >> 2];
       HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 200 >> 2];
       $1 = HEAP32[$2 + 196 >> 2];
       $0 = HEAP32[$2 + 192 >> 2];
       HEAP32[$2 + 24 >> 2] = $0;
       HEAP32[$2 + 28 >> 2] = $1;
       $0 = HEAP32[$2 + 188 >> 2];
       $1 = HEAP32[$2 + 184 >> 2];
       HEAP32[$2 + 16 >> 2] = $1;
       HEAP32[$2 + 20 >> 2] = $0;
       $1 = HEAP32[$2 + 180 >> 2];
       $0 = HEAP32[$2 + 176 >> 2];
       HEAP32[$2 + 8 >> 2] = $0;
       HEAP32[$2 + 12 >> 2] = $1;
       HEAP32[$2 + 136 >> 2] = jsfFindFile($2 + 8 | 0, $2 + 140 | 0);
       HEAP32[$2 + 132 >> 2] = jsfGetFileSize($2 + 140 | 0);
      }
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 216 >> 2], 4966, jsvNewFromInteger(HEAP32[$2 + 128 >> 2]));
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 216 >> 2], 15950, jsvNewFromInteger(HEAP32[$2 + 204 >> 2]));
      HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 132 >> 2];
      if (!HEAP32[$2 + 136 >> 2]) {
       HEAP32[$2 + 220 >> 2] = HEAP32[$2 + 124 >> 2];
       break block;
      }
     }
     HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 212 >> 2];
     if (HEAP32[$2 + 72 >> 2] > 32) {
      HEAP32[$2 + 72 >> 2] = 32
     }
     if (HEAP32[$2 + 72 >> 2] > HEAP32[$2 + 76 >> 2]) {
      HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 76 >> 2]
     }
     jshFlashRead($2 + 80 | 0, HEAP32[$2 + 136 >> 2] + HEAP32[$2 + 128 >> 2] | 0, HEAP32[$2 + 72 >> 2]);
     HEAP32[$2 + 68 >> 2] = 0;
     while (1) {
      block3 : {
       if (HEAP32[$2 + 68 >> 2] >= HEAP32[$2 + 72 >> 2]) {
        break block3
       }
       if (HEAPU8[HEAP32[$2 + 68 >> 2] + ($2 + 80 | 0) | 0] == 255) {
        HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 68 >> 2];
        HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 72 >> 2];
        break block3;
       }
       if (!(HEAP8[$2 + 211 | 0] & 1) | HEAPU8[HEAP32[$2 + 68 >> 2] + ($2 + 80 | 0) | 0] != 10) {
        HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 68 >> 2] + 1;
        continue;
       } else {
        HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 68 >> 2] + 1;
        HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 72 >> 2];
        HEAP8[$2 + 211 | 0] = 0;
       }
      }
      break;
     };
     if (!HEAP32[$2 + 72 >> 2]) {
      break block1
     }
     if (!HEAP32[$2 + 124 >> 2]) {
      HEAP32[$2 + 124 >> 2] = jsvNewFromEmptyString_1849()
     }
     if (HEAP32[$2 + 124 >> 2]) {
      jsvAppendStringBuf(HEAP32[$2 + 124 >> 2], $2 + 80 | 0, HEAP32[$2 + 72 >> 2])
     }
     HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 212 >> 2] - HEAP32[$2 + 72 >> 2];
     HEAP32[$2 + 128 >> 2] = HEAP32[$2 + 72 >> 2] + HEAP32[$2 + 128 >> 2];
     if (HEAP8[$2 + 211 | 0] & 1) {
      HEAP32[$2 + 212 >> 2] = 32
     }
     continue;
    }
    break;
   };
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 216 >> 2], 4966, jsvNewFromInteger(HEAP32[$2 + 128 >> 2]));
   HEAP32[$2 + 220 >> 2] = HEAP32[$2 + 124 >> 2];
  }
  __stack_pointer = $2 + 224 | 0;
  return HEAP32[$2 + 220 >> 2];
 }
 
 function jswrap_storagefile_read($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  if (HEAP32[$2 + 8 >> 2] < 0) {
   HEAP32[$2 + 8 >> 2] = 0
  }
  $0 = jswrap_storagefile_read_internal(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_storagefile_readLine($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_storagefile_read_internal(HEAP32[$1 + 12 >> 2], -1);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_storagefile_getLength($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 240 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 236 >> 2] = $0;
  HEAP32[$1 + 232 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 236 >> 2], 17830);
  jsfNameFromVar($1 + 204 | 0, HEAP32[$1 + 232 >> 2]);
  jsvUnLock(HEAP32[$1 + 232 >> 2]);
  HEAP32[$1 + 200 >> 2] = 27;
  while (1) {
   $0 = 0;
   $0 = HEAP32[$1 + 200 >> 2] ? !HEAPU8[(HEAP32[$1 + 200 >> 2] + $1 | 0) + 203 | 0] : $0;
   if ($0) {
    HEAP32[$1 + 200 >> 2] = HEAP32[$1 + 200 >> 2] - 1;
    continue;
   }
   break;
  };
  HEAP32[$1 + 196 >> 2] = 1;
  HEAP8[HEAP32[$1 + 200 >> 2] + ($1 + 204 | 0) | 0] = HEAP32[$1 + 196 >> 2];
  HEAP32[$1 + 192 >> 2] = 0;
  HEAP32[$1 + 188 >> 2] = 0;
  HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 228 >> 2];
  $2 = HEAP32[$1 + 224 >> 2];
  $0 = HEAP32[$1 + 220 >> 2];
  HEAP32[$1 + 56 >> 2] = $0;
  HEAP32[$1 + 60 >> 2] = $2;
  $0 = HEAP32[$1 + 216 >> 2];
  $2 = HEAP32[$1 + 212 >> 2];
  HEAP32[$1 + 48 >> 2] = $2;
  HEAP32[$1 + 52 >> 2] = $0;
  $2 = HEAP32[$1 + 208 >> 2];
  $0 = HEAP32[$1 + 204 >> 2];
  HEAP32[$1 + 40 >> 2] = $0;
  HEAP32[$1 + 44 >> 2] = $2;
  HEAP32[$1 + 152 >> 2] = jsfFindFile($1 + 40 | 0, $1 + 156 | 0);
  HEAP8[$1 + 151 | 0] = 255;
  if (HEAP32[$1 + 152 >> 2]) {
   jshFlashRead($1 + 151 | 0, (HEAP32[$1 + 152 >> 2] + jsfGetFileSize($1 + 156 | 0) | 0) - 1 | 0, 1)
  }
  while (1) {
   $0 = 0;
   block : {
    if (!HEAP32[$1 + 152 >> 2]) {
     break block
    }
    $0 = 0;
    if (HEAPU8[$1 + 151 | 0] == 255) {
     break block
    }
    $0 = HEAP32[$1 + 196 >> 2] < 255;
   }
   if ($0) {
    HEAP32[$1 + 192 >> 2] = jsfGetFileSize($1 + 156 | 0) + HEAP32[$1 + 192 >> 2];
    HEAP32[$1 + 196 >> 2] = HEAP32[$1 + 196 >> 2] + 1;
    HEAP8[HEAP32[$1 + 200 >> 2] + ($1 + 204 | 0) | 0] = HEAP32[$1 + 196 >> 2];
    HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 228 >> 2];
    $0 = HEAP32[$1 + 224 >> 2];
    $2 = HEAP32[$1 + 220 >> 2];
    HEAP32[$1 + 24 >> 2] = $2;
    HEAP32[$1 + 28 >> 2] = $0;
    $2 = HEAP32[$1 + 216 >> 2];
    $0 = HEAP32[$1 + 212 >> 2];
    HEAP32[$1 + 16 >> 2] = $0;
    HEAP32[$1 + 20 >> 2] = $2;
    $0 = HEAP32[$1 + 208 >> 2];
    $2 = HEAP32[$1 + 204 >> 2];
    HEAP32[$1 + 8 >> 2] = $2;
    HEAP32[$1 + 12 >> 2] = $0;
    HEAP32[$1 + 152 >> 2] = jsfFindFile($1 + 8 | 0, $1 + 156 | 0);
    if (HEAP32[$1 + 152 >> 2]) {
     jshFlashRead($1 + 151 | 0, (HEAP32[$1 + 152 >> 2] + jsfGetFileSize($1 + 156 | 0) | 0) - 1 | 0, 1)
    }
    continue;
   }
   break;
  };
  if (HEAP32[$1 + 152 >> 2]) {
   HEAP8[$1 + 79 | 0] = 0;
   while (1) {
    block1 : {
     if (!((HEAPU8[$1 + 79 | 0] ^ -1) & 1)) {
      break block1
     }
     HEAP32[$1 + 72 >> 2] = jsfGetFileSize($1 + 156 | 0) - HEAP32[$1 + 188 >> 2];
     if (HEAP32[$1 + 72 >> 2] <= 0) {
      HEAP8[$1 + 79 | 0] = 1;
      break block1;
     }
     if (HEAP32[$1 + 72 >> 2] > 64) {
      HEAP32[$1 + 72 >> 2] = 64
     }
     jshFlashRead($1 + 80 | 0, HEAP32[$1 + 152 >> 2] + HEAP32[$1 + 188 >> 2] | 0, HEAP32[$1 + 72 >> 2]);
     HEAP32[$1 + 68 >> 2] = 0;
     while (1) {
      if (HEAP32[$1 + 68 >> 2] < HEAP32[$1 + 72 >> 2]) {
       if (HEAPU8[HEAP32[$1 + 68 >> 2] + ($1 + 80 | 0) | 0] == 255) {
        HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 68 >> 2];
        HEAP8[$1 + 79 | 0] = 1;
       } else {
        HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] + 1;
        continue;
       }
      }
      break;
     };
     HEAP32[$1 + 188 >> 2] = HEAP32[$1 + 72 >> 2] + HEAP32[$1 + 188 >> 2];
     continue;
    }
    break;
   };
  }
  HEAP32[$1 + 192 >> 2] = HEAP32[$1 + 188 >> 2] + HEAP32[$1 + 192 >> 2];
  __stack_pointer = $1 + 240 | 0;
  return HEAP32[$1 + 192 >> 2];
 }
 
 function jswrap_storagefile_write($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $2 = __stack_pointer - 240 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 236 >> 2] = $0;
  HEAP32[$2 + 232 >> 2] = $1;
  HEAP8[$2 + 231 | 0] = jsvObjectGetIntegerChild(HEAP32[$2 + 236 >> 2], 18218);
  block1 : {
   if (!(HEAPU8[$2 + 231 | 0] == 119 | HEAPU8[$2 + 231 | 0] == 97)) {
    jsExceptionHere(1, 18157, 0);
    break block1;
   }
   HEAP32[$2 + 224 >> 2] = jsvAsString(HEAP32[$2 + 232 >> 2]);
   if (!HEAP32[$2 + 224 >> 2]) {
    break block1
   }
   HEAP32[$2 + 220 >> 2] = jsvGetStringLength(HEAP32[$2 + 224 >> 2]);
   if (!HEAP32[$2 + 220 >> 2]) {
    jsvUnLock(HEAP32[$2 + 224 >> 2]);
    break block1;
   }
   HEAP32[$2 + 216 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 236 >> 2], 4966);
   HEAP32[$2 + 212 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 236 >> 2], 15950);
   jsfNameFromVarAndUnLock($2 + 184 | 0, jsvObjectGetChildIfExists(HEAP32[$2 + 236 >> 2], 17830));
   HEAP32[$2 + 180 >> 2] = 27;
   while (1) {
    $0 = 0;
    $0 = HEAP32[$2 + 180 >> 2] ? !HEAPU8[(HEAP32[$2 + 180 >> 2] + $2 | 0) + 183 | 0] : $0;
    if ($0) {
     HEAP32[$2 + 180 >> 2] = HEAP32[$2 + 180 >> 2] - 1;
     continue;
    }
    break;
   };
   HEAP8[HEAP32[$2 + 180 >> 2] + ($2 + 184 | 0) | 0] = HEAP32[$2 + 212 >> 2];
   HEAP32[$2 + 128 >> 2] = HEAP32[$2 + 208 >> 2];
   $0 = HEAP32[$2 + 204 >> 2];
   $1 = HEAP32[$2 + 200 >> 2];
   HEAP32[$2 + 120 >> 2] = $1;
   HEAP32[$2 + 124 >> 2] = $0;
   $1 = HEAP32[$2 + 196 >> 2];
   $0 = HEAP32[$2 + 192 >> 2];
   HEAP32[$2 + 112 >> 2] = $0;
   HEAP32[$2 + 116 >> 2] = $1;
   $0 = HEAP32[$2 + 188 >> 2];
   $1 = HEAP32[$2 + 184 >> 2];
   HEAP32[$2 + 104 >> 2] = $1;
   HEAP32[$2 + 108 >> 2] = $0;
   HEAP32[$2 + 144 >> 2] = jsfFindFile($2 + 104 | 0, $2 + 148 | 0);
   block2 : {
    if (HEAP32[$2 + 144 >> 2]) {
     $0 = jsfGetFileSize($2 + 148 | 0);
     break block2;
    }
    $0 = 0;
   }
   HEAP32[$2 + 140 >> 2] = $0;
   if (!HEAP32[$2 + 144 >> 2]) {
    $3 = HEAP32[$2 + 224 >> 2];
    HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 208 >> 2];
    $1 = HEAP32[$2 + 204 >> 2];
    $0 = HEAP32[$2 + 200 >> 2];
    HEAP32[$2 + 88 >> 2] = $0;
    HEAP32[$2 + 92 >> 2] = $1;
    $0 = HEAP32[$2 + 196 >> 2];
    $1 = HEAP32[$2 + 192 >> 2];
    HEAP32[$2 + 80 >> 2] = $1;
    HEAP32[$2 + 84 >> 2] = $0;
    $1 = HEAP32[$2 + 188 >> 2];
    $0 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 72 >> 2] = $0;
    HEAP32[$2 + 76 >> 2] = $1;
    block3 : {
     if (jsfWriteFile($2 + 72 | 0, $3, 64, 0, 40928) & 1) {
      HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 208 >> 2];
      $0 = HEAP32[$2 + 204 >> 2];
      $1 = HEAP32[$2 + 200 >> 2];
      HEAP32[$2 + 56 >> 2] = $1;
      HEAP32[$2 + 60 >> 2] = $0;
      $1 = HEAP32[$2 + 196 >> 2];
      $0 = HEAP32[$2 + 192 >> 2];
      HEAP32[$2 + 48 >> 2] = $0;
      HEAP32[$2 + 52 >> 2] = $1;
      $0 = HEAP32[$2 + 188 >> 2];
      $1 = HEAP32[$2 + 184 >> 2];
      HEAP32[$2 + 40 >> 2] = $1;
      HEAP32[$2 + 44 >> 2] = $0;
      HEAP32[$2 + 144 >> 2] = jsfFindFile($2 + 40 | 0, $2 + 148 | 0);
      HEAP32[$2 + 140 >> 2] = jsfGetFileSize($2 + 148 | 0);
      HEAP32[$2 + 216 >> 2] = HEAP32[$2 + 220 >> 2];
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 4966, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
      break block3;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 18218, jsvNewFromInteger(0));
    }
    jsvUnLock(HEAP32[$2 + 224 >> 2]);
    break block1;
   }
   HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 140 >> 2] - HEAP32[$2 + 216 >> 2];
   block4 : {
    if (HEAP32[$2 + 220 >> 2] < HEAP32[$2 + 136 >> 2]) {
     jswrap_flash_write(HEAP32[$2 + 224 >> 2], HEAP32[$2 + 144 >> 2] + HEAP32[$2 + 216 >> 2] | 0);
     HEAP32[$2 + 216 >> 2] = HEAP32[$2 + 220 >> 2] + HEAP32[$2 + 216 >> 2];
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 4966, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
     break block4;
    }
    HEAP32[$2 + 132 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 224 >> 2], 0, HEAP32[$2 + 136 >> 2]);
    jswrap_flash_write(HEAP32[$2 + 132 >> 2], HEAP32[$2 + 144 >> 2] + HEAP32[$2 + 216 >> 2] | 0);
    HEAP32[$2 + 216 >> 2] = HEAP32[$2 + 136 >> 2] + HEAP32[$2 + 216 >> 2];
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 4966, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
    jsvUnLock(HEAP32[$2 + 132 >> 2]);
    if (HEAP32[$2 + 212 >> 2] == 255) {
     jsExceptionHere(1, 27318, 0);
     jsvUnLock(HEAP32[$2 + 224 >> 2]);
     break block1;
    }
    HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 212 >> 2] + 1;
    HEAP8[HEAP32[$2 + 180 >> 2] + ($2 + 184 | 0) | 0] = HEAP32[$2 + 212 >> 2];
    HEAP32[$2 + 132 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 224 >> 2], HEAP32[$2 + 136 >> 2], 2147483647);
    $3 = HEAP32[$2 + 132 >> 2];
    HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 208 >> 2];
    $1 = HEAP32[$2 + 204 >> 2];
    $0 = HEAP32[$2 + 200 >> 2];
    HEAP32[$2 + 24 >> 2] = $0;
    HEAP32[$2 + 28 >> 2] = $1;
    $0 = HEAP32[$2 + 196 >> 2];
    $1 = HEAP32[$2 + 192 >> 2];
    HEAP32[$2 + 16 >> 2] = $1;
    HEAP32[$2 + 20 >> 2] = $0;
    $1 = HEAP32[$2 + 188 >> 2];
    $0 = HEAP32[$2 + 184 >> 2];
    HEAP32[$2 + 8 >> 2] = $0;
    HEAP32[$2 + 12 >> 2] = $1;
    block5 : {
     if (jsfWriteFile($2 + 8 | 0, $3, 64, 0, 40928) & 1) {
      HEAP32[$2 + 216 >> 2] = jsvGetStringLength(HEAP32[$2 + 132 >> 2]);
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 15950, jsvNewFromInteger(HEAP32[$2 + 212 >> 2]));
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 4966, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
      break block5;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 18218, jsvNewFromInteger(0));
    }
    jsvUnLock(HEAP32[$2 + 132 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 224 >> 2]);
  }
  __stack_pointer = $2 + 240 | 0;
 }
 
 function jswrap_spi_constructor() {
  return jspNewObject(0, 21461) | 0;
 }
 
 function jswrap_spi_setup($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block : {
   if (!(jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1)) {
    break block
   }
   HEAP8[$2 + 23 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 28 >> 2]);
   if (!(jsspiPopulateSPIInfo($2 + 9 | 0, HEAP32[$2 + 24 >> 2]) & 1)) {
    break block
   }
   block2 : {
    if (!(HEAPU8[$2 + 23 | 0] < 27 | HEAPU8[$2 + 23 | 0] > 27)) {
     jshSPISetup(HEAPU8[$2 + 23 | 0], $2 + 9 | 0);
     break block2;
    }
    if (HEAPU8[$2 + 23 | 0]) {
     break block
    }
    if (HEAPU8[$2 + 14 | 0] != 255) {
     jshPinSetState(HEAPU8[$2 + 14 | 0], 1)
    }
    if (HEAPU8[$2 + 15 | 0] != 255) {
     jshPinSetState(HEAPU8[$2 + 15 | 0], 4)
    }
    if (HEAPU8[$2 + 16 | 0] != 255) {
     jshPinSetState(HEAPU8[$2 + 16 | 0], 1)
    }
   }
   jsvObjectSetOrRemoveChild(HEAP32[$2 + 28 >> 2], 7138, HEAP32[$2 + 24 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function jswrap_spi_send_cb($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $0 = $3 - (HEAP32[$3 + 8 >> 2] + 15 & -16) | 0;
  __stack_pointer = $0;
  HEAP32[$3 >> 2] = $0;
  FUNCTION_TABLE[HEAP32[HEAP32[$3 + 4 >> 2] >> 2]](HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] + 4 | 0);
  $0 = HEAP32[$3 + 4 >> 2];
  HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 + 24 >> 2];
  $0 = HEAP32[$3 + 4 >> 2];
  HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 + 20 >> 2];
  while (1) {
   $0 = HEAP32[$3 + 8 >> 2];
   HEAP32[$3 + 8 >> 2] = $0 - 1;
   if ($0) {
    $1 = HEAP32[$3 + 4 >> 2];
    $0 = HEAP32[$3 >> 2];
    HEAP32[$3 >> 2] = $0 + 1;
    jsvArrayBufferIteratorSetByteValue($1 + 28 | 0, HEAP8[$0 | 0] << 24 >> 24);
    jsvArrayBufferIteratorNext(HEAP32[$3 + 4 >> 2] + 28 | 0);
    continue;
   }
   break;
  };
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_spi_send($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 304 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 296 >> 2] = $0;
  HEAP32[$3 + 292 >> 2] = $1;
  HEAP8[$3 + 291 | 0] = $2;
  block : {
   if (!(jsvIsObject(HEAP32[$3 + 296 >> 2]) & 1)) {
    HEAP32[$3 + 300 >> 2] = 0;
    break block;
   }
   HEAP8[$3 + 290 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 296 >> 2]);
   if (!(jsspiGetSendFunction(HEAP32[$3 + 296 >> 2], $3 + 200 | 0, $3 + 204 | 0) & 1)) {
    HEAP32[$3 + 300 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 196 >> 2] = 0;
   if (!(HEAPU8[$3 + 290 | 0] < 27 | HEAPU8[$3 + 290 | 0] > 27)) {
    jshSPISetReceive(HEAPU8[$3 + 290 | 0], 1)
   }
   if (HEAPU8[$3 + 291 | 0] != 255) {
    jshPinOutput(HEAPU8[$3 + 291 | 0], 0)
   }
   block2 : {
    if (jsvIsNumeric(HEAP32[$3 + 292 >> 2]) & 1) {
     HEAP8[$3 + 195 | 0] = jsvGetInteger(HEAP32[$3 + 292 >> 2]);
     $0 = $3 + 195 | 0;
     FUNCTION_TABLE[HEAP32[$3 + 200 >> 2]]($0, $0, 1, $3 + 204 | 0);
     HEAP32[$3 + 196 >> 2] = jsvNewFromInteger(HEAPU8[$3 + 195 | 0]);
     break block2;
    }
    block3 : {
     if (jsvIsString(HEAP32[$3 + 292 >> 2]) & 1) {
      HEAP32[$3 + 196 >> 2] = jsvNewFromEmptyString_1867();
      jsvStringIteratorNew($3 + 24 | 0, HEAP32[$3 + 292 >> 2], 0);
      while (1) {
       $0 = 0;
       if (jsvStringIteratorHasChar_1868($3 + 24 | 0) & 1) {
        $0 = jspIsInterrupted() ^ -1
       }
       if ($0 & 1) {
        jsvStringIteratorGetPtrAndNext($3 + 24 | 0, $3 + 20 | 0, $3 + 16 | 0);
        while (1) {
         if (HEAP32[$3 + 16 >> 2]) {
          HEAP32[$3 + 12 >> 2] = HEAPU32[$3 + 16 >> 2] > 128 ? 128 : HEAP32[$3 + 16 >> 2];
          FUNCTION_TABLE[HEAP32[$3 + 200 >> 2]](HEAP32[$3 + 20 >> 2], $3 - -64 | 0, HEAP32[$3 + 12 >> 2], $3 + 204 | 0);
          jsvAppendStringBuf(HEAP32[$3 + 196 >> 2], $3 - -64 | 0, HEAP32[$3 + 12 >> 2]);
          HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 12 >> 2];
          HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 20 >> 2];
          continue;
         }
         break;
        };
        continue;
       }
       break;
      };
      jsvStringIteratorFree_1869($3 + 24 | 0);
      break block3;
     }
     HEAP32[$3 + 8 >> 2] = jsvIterateCallbackCount(HEAP32[$3 + 292 >> 2]);
     HEAP32[$3 + 196 >> 2] = jsvNewTypedArray(1, HEAP32[$3 + 8 >> 2]);
     if (HEAP32[$3 + 196 >> 2]) {
      HEAP32[$3 + 224 >> 2] = 0;
      HEAP32[$3 + 220 >> 2] = 0;
      jsvArrayBufferIteratorNew($3 + 228 | 0, HEAP32[$3 + 196 >> 2], 0);
      jsvIterateBufferCallback(HEAP32[$3 + 292 >> 2], 673, $3 + 200 | 0);
      jsvArrayBufferIteratorFree($3 + 228 | 0);
     }
    }
   }
   if (HEAPU8[$3 + 291 | 0] != 255) {
    jshPinOutput(HEAPU8[$3 + 291 | 0], 1)
   }
   HEAP32[$3 + 300 >> 2] = HEAP32[$3 + 196 >> 2];
  }
  __stack_pointer = $3 + 304 | 0;
  return HEAP32[$3 + 300 >> 2];
 }
 
 function jsvNewFromEmptyString_1867() {
  return jsvNewWithFlags(29);
 }
 
 function jsvStringIteratorHasChar_1868($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jsvStringIteratorFree_1869($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_spi_write_cb($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  FUNCTION_TABLE[HEAP32[HEAP32[$3 + 4 >> 2] >> 2]](HEAP32[$3 + 12 >> 2], 0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] + 4 | 0);
  __stack_pointer = $3 + 16 | 0;
 }
 
 function jswrap_spi_write($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer + -64 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 60 >> 2] = $0;
  HEAP32[$2 + 56 >> 2] = $1;
  block : {
   if (!(jsvIsObject(HEAP32[$2 + 60 >> 2]) & 1)) {
    break block
   }
   HEAP8[$2 + 55 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 60 >> 2]);
   if (!(jsspiGetSendFunction(HEAP32[$2 + 60 >> 2], $2 + 48 | 0, $2 + 34 | 0) & 1)) {
    break block
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 48 >> 2];
   $0 = HEAPU8[$2 + 38 | 0] | HEAPU8[$2 + 39 | 0] << 8 | (HEAPU8[$2 + 40 | 0] << 16 | HEAPU8[$2 + 41 | 0] << 24);
   $1 = HEAPU8[$2 + 34 | 0] | HEAPU8[$2 + 35 | 0] << 8 | (HEAPU8[$2 + 36 | 0] << 16 | HEAPU8[$2 + 37 | 0] << 24);
   $3 = $1;
   $4 = $2 + 12 | 0;
   $1 = $4;
   HEAP8[$1 + 4 | 0] = $3;
   HEAP8[$1 + 5 | 0] = $3 >>> 8;
   HEAP8[$1 + 6 | 0] = $3 >>> 16;
   HEAP8[$1 + 7 | 0] = $3 >>> 24;
   HEAP8[$1 + 8 | 0] = $0;
   HEAP8[$1 + 9 | 0] = $0 >>> 8;
   HEAP8[$1 + 10 | 0] = $0 >>> 16;
   HEAP8[$1 + 11 | 0] = $0 >>> 24;
   $1 = HEAPU8[$2 + 44 | 0] | HEAPU8[$2 + 45 | 0] << 8 | (HEAPU8[$2 + 46 | 0] << 16 | HEAPU8[$2 + 47 | 0] << 24);
   $0 = HEAPU8[$2 + 40 | 0] | HEAPU8[$2 + 41 | 0] << 8 | (HEAPU8[$2 + 42 | 0] << 16 | HEAPU8[$2 + 43 | 0] << 24);
   $3 = $0;
   $0 = $4;
   HEAP8[$0 + 10 | 0] = $3;
   HEAP8[$0 + 11 | 0] = $3 >>> 8;
   HEAP8[$0 + 12 | 0] = $3 >>> 16;
   HEAP8[$0 + 13 | 0] = $3 >>> 24;
   HEAP8[$0 + 14 | 0] = $1;
   HEAP8[$0 + 15 | 0] = $1 >>> 8;
   HEAP8[$0 + 16 | 0] = $1 >>> 16;
   HEAP8[$0 + 17 | 0] = $1 >>> 24;
   HEAP8[$2 + 11 | 0] = 255;
   HEAP32[$2 + 4 >> 2] = jsvGetArrayLength(HEAP32[$2 + 56 >> 2]);
   if (HEAP32[$2 + 4 >> 2] > 0) {
    HEAP32[$2 >> 2] = jsvGetArrayItem(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 4 >> 2] - 1 | 0);
    if (jsvIsPin(HEAP32[$2 >> 2]) & 1) {
     HEAP8[$2 + 11 | 0] = jshGetPinFromVar(HEAP32[$2 >> 2]);
     jsvUnLock(jsvArrayPop(HEAP32[$2 + 56 >> 2]));
    }
    jsvUnLock(HEAP32[$2 >> 2]);
   }
   if (!(HEAPU8[$2 + 55 | 0] < 27 | HEAPU8[$2 + 55 | 0] > 27)) {
    jshSPISetReceive(HEAPU8[$2 + 55 | 0], 0)
   }
   if (HEAPU8[$2 + 11 | 0] != 255) {
    jshPinOutput(HEAPU8[$2 + 11 | 0], 0)
   }
   jsvIterateBufferCallback(HEAP32[$2 + 56 >> 2], 674, $2 + 12 | 0);
   if (!(HEAPU8[$2 + 55 | 0] < 27 | HEAPU8[$2 + 55 | 0] > 27)) {
    jshSPIWait(HEAPU8[$2 + 55 | 0])
   }
   if (HEAPU8[$2 + 11 | 0] == 255) {
    break block
   }
   jshPinOutput(HEAPU8[$2 + 11 | 0], 1);
  }
  __stack_pointer = $2 - -64 | 0;
 }
 
 function jswrap_spi_send4bit($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 112 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 108 >> 2] = $0;
  HEAP32[$5 + 104 >> 2] = $1;
  HEAP32[$5 + 100 >> 2] = $2;
  HEAP32[$5 + 96 >> 2] = $3;
  HEAP8[$5 + 95 | 0] = $4;
  block : {
   if (!(jsvIsObject(HEAP32[$5 + 108 >> 2]) & 1)) {
    break block
   }
   HEAP8[$5 + 94 | 0] = jsiGetDeviceFromClass(HEAP32[$5 + 108 >> 2]);
   if (!(HEAPU8[$5 + 94 | 0] <= 27 & HEAPU8[$5 + 94 | 0] >= 27)) {
    jsExceptionHere(1, 21425, 0);
    break block;
   }
   jshSPISet16(HEAPU8[$5 + 94 | 0], 1);
   if (!(HEAP32[$5 + 100 >> 2] | HEAP32[$5 + 96 >> 2])) {
    HEAP32[$5 + 100 >> 2] = 1;
    HEAP32[$5 + 96 >> 2] = 3;
   }
   HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 15;
   HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 96 >> 2] & 15;
   if (!(jshIsDeviceInitialised(HEAPU8[$5 + 94 | 0]) & 1)) {
    jshSPIInitInfo($5 + 80 | 0);
    jshSPISetup(HEAPU8[$5 + 94 | 0], $5 + 80 | 0);
   }
   jshSPISetReceive(HEAPU8[$5 + 94 | 0], 0);
   if (HEAPU8[$5 + 95 | 0] != 255) {
    jshPinOutput(HEAPU8[$5 + 95 | 0], 0)
   }
   block3 : {
    if (jsvIsNumeric(HEAP32[$5 + 104 >> 2]) & 1) {
     jsspiSend4bit(HEAPU8[$5 + 94 | 0], jsvGetInteger(HEAP32[$5 + 104 >> 2]) & 255, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
     break block3;
    }
    block4 : {
     if (jsvIsIterable(HEAP32[$5 + 104 >> 2]) & 1) {
      jshInterruptOff();
      jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 104 >> 2], 1);
      while (1) {
       if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
        HEAP8[$5 + 15 | 0] = jsvIteratorGetIntegerValue($5 + 16 | 0);
        jsspiSend4bit(HEAPU8[$5 + 94 | 0], HEAPU8[$5 + 15 | 0], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
        jsvIteratorNext($5 + 16 | 0);
        continue;
       }
       break;
      };
      jsvIteratorFree($5 + 16 | 0);
      jshInterruptOn();
      break block4;
     }
     HEAP32[$5 >> 2] = HEAP32[$5 + 104 >> 2];
     jsExceptionHere(1, 15430, $5);
    }
   }
   jshSPIWait(HEAPU8[$5 + 94 | 0]);
   if (HEAPU8[$5 + 95 | 0] != 255) {
    jshPinOutput(HEAPU8[$5 + 95 | 0], 1)
   }
   jshSPISet16(HEAPU8[$5 + 94 | 0], 0);
  }
  __stack_pointer = $5 + 112 | 0;
 }
 
 function jswrap_spi_send8bit($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 112 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 108 >> 2] = $0;
  HEAP32[$5 + 104 >> 2] = $1;
  HEAP32[$5 + 100 >> 2] = $2;
  HEAP32[$5 + 96 >> 2] = $3;
  HEAP8[$5 + 95 | 0] = $4;
  block : {
   if (!(jsvIsObject(HEAP32[$5 + 108 >> 2]) & 1)) {
    break block
   }
   HEAP8[$5 + 94 | 0] = jsiGetDeviceFromClass(HEAP32[$5 + 108 >> 2]);
   if (!(HEAPU8[$5 + 94 | 0] <= 27 & HEAPU8[$5 + 94 | 0] >= 27)) {
    jsExceptionHere(1, 21385, 0);
    break block;
   }
   jshSPISet16(HEAPU8[$5 + 94 | 0], 1);
   if (!(HEAP32[$5 + 100 >> 2] | HEAP32[$5 + 96 >> 2])) {
    HEAP32[$5 + 100 >> 2] = 3;
    HEAP32[$5 + 96 >> 2] = 15;
   }
   HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 255;
   HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 96 >> 2] & 255;
   if (!(jshIsDeviceInitialised(HEAPU8[$5 + 94 | 0]) & 1)) {
    jshSPIInitInfo($5 + 80 | 0);
    jshSPISetup(HEAPU8[$5 + 94 | 0], $5 + 80 | 0);
   }
   jshSPISetReceive(HEAPU8[$5 + 94 | 0], 0);
   if (HEAPU8[$5 + 95 | 0] != 255) {
    jshPinOutput(HEAPU8[$5 + 95 | 0], 0)
   }
   block3 : {
    if (jsvIsNumeric(HEAP32[$5 + 104 >> 2]) & 1) {
     jsspiSend8bit(HEAPU8[$5 + 94 | 0], jsvGetInteger(HEAP32[$5 + 104 >> 2]) & 255, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
     break block3;
    }
    block4 : {
     if (jsvIsIterable(HEAP32[$5 + 104 >> 2]) & 1) {
      jshInterruptOff();
      jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 104 >> 2], 1);
      while (1) {
       if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
        HEAP8[$5 + 15 | 0] = jsvIteratorGetIntegerValue($5 + 16 | 0);
        jsspiSend8bit(HEAPU8[$5 + 94 | 0], HEAPU8[$5 + 15 | 0], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
        jsvIteratorNext($5 + 16 | 0);
        continue;
       }
       break;
      };
      jsvIteratorFree($5 + 16 | 0);
      jshInterruptOn();
      break block4;
     }
     HEAP32[$5 >> 2] = HEAP32[$5 + 104 >> 2];
     jsExceptionHere(1, 15430, $5);
    }
   }
   jshSPIWait(HEAPU8[$5 + 94 | 0]);
   if (HEAPU8[$5 + 95 | 0] != 255) {
    jshPinOutput(HEAPU8[$5 + 95 | 0], 1)
   }
   jshSPISet16(HEAPU8[$5 + 94 | 0], 0);
  }
  __stack_pointer = $5 + 112 | 0;
 }
 
 function jswrap_i2c_constructor() {
  return jspNewObject(0, 21587) | 0;
 }
 
 function jswrap_i2c_setup($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 28 >> 2] = $0;
  HEAP32[$2 + 24 >> 2] = $1;
  block : {
   if (!(jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1)) {
    break block
   }
   HEAP8[$2 + 23 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 28 >> 2]);
   if (!(jsi2cPopulateI2CInfo($2 + 15 | 0, HEAP32[$2 + 24 >> 2]) & 1)) {
    break block
   }
   block2 : {
    if (!(HEAPU8[$2 + 23 | 0] < 28 | HEAPU8[$2 + 23 | 0] > 28)) {
     jshI2CSetup(HEAPU8[$2 + 23 | 0], $2 + 15 | 0);
     break block2;
    }
    if (!HEAPU8[$2 + 23 | 0]) {
     if (HEAPU8[$2 + 19 | 0] != 255) {
      jshPinSetValue(HEAPU8[$2 + 19 | 0], 1);
      jshPinSetState(HEAPU8[$2 + 19 | 0], 3);
     }
     if (HEAPU8[$2 + 20 | 0] != 255) {
      jshPinSetValue(HEAPU8[$2 + 20 | 0], 1);
      jshPinSetState(HEAPU8[$2 + 20 | 0], 3);
     }
    }
   }
   jsvObjectSetOrRemoveChild(HEAP32[$2 + 28 >> 2], 7138, HEAP32[$2 + 24 >> 2]);
  }
  __stack_pointer = $2 + 32 | 0;
 }
 
 function _jswrap_i2c_writeTo($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 48 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 44 >> 2] = $0;
  HEAP8[$6 + 43 | 0] = $1;
  HEAP32[$6 + 36 >> 2] = $2;
  HEAP8[$6 + 35 | 0] = $3;
  HEAP32[$6 + 28 >> 2] = $4;
  HEAP32[$6 + 24 >> 2] = $5;
  block1 : {
   if (!(HEAPU8[$6 + 43 | 0] < 28 | HEAPU8[$6 + 43 | 0] > 28)) {
    jshI2CWrite(HEAPU8[$6 + 43 | 0], HEAP32[$6 + 36 >> 2] & 255, HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP8[$6 + 35 | 0] & 1);
    break block1;
   }
   if (!HEAPU8[$6 + 43 | 0]) {
    HEAP32[$6 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$6 + 44 >> 2], 7138);
    if (jsi2cPopulateI2CInfo($6 + 16 | 0, HEAP32[$6 + 12 >> 2]) & 1) {
     HEAP8[$6 + 22 | 0] = jsvObjectGetBoolChild(HEAP32[$6 + 44 >> 2], 18910) & 1;
     jsi2cWrite($6 + 16 | 0, HEAP32[$6 + 36 >> 2] & 255, HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP8[$6 + 35 | 0] & 1);
    }
    jsvUnLock2(jsvObjectSetChild(HEAP32[$6 + 44 >> 2], 18910, jsvNewFromBool(HEAP8[$6 + 22 | 0] & 1)), HEAP32[$6 + 12 >> 2]);
   }
  }
  __stack_pointer = $6 + 48 | 0;
 }
 
 function jswrap_i2c_writeTo($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  $3 = $4;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  block : {
   if (!(jsvIsObject(HEAP32[$3 + 28 >> 2]) & 1)) {
    break block
   }
   HEAP8[$3 + 19 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 28 >> 2]);
   HEAP8[$3 + 18 | 0] = 1;
   HEAP32[$3 + 12 >> 2] = i2c_get_address(HEAP32[$3 + 24 >> 2], $3 + 18 | 0);
   HEAP32[$3 + 8 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = jsvGetDataPointer(HEAP32[$3 + 20 >> 2], $3 + 8 | 0);
   if (!(HEAP32[$3 + 4 >> 2] | !HEAP32[$3 + 20 >> 2])) {
    HEAP32[$3 + 8 >> 2] = jsvIterateCallbackCount(HEAP32[$3 + 20 >> 2]);
    block2 : {
     if (HEAP32[$3 + 8 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
      jsExceptionHere(1, 20608, 0);
      break block2;
     }
     $4 = $4 - (HEAP32[$3 + 8 >> 2] + 15 & -16) | 0;
     __stack_pointer = $4;
     HEAP32[$3 + 4 >> 2] = $4;
     jsvIterateCallbackToBytes(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2]);
    }
   }
   if (!HEAP32[$3 + 4 >> 2] | !HEAP32[$3 + 8 >> 2]) {
    break block
   }
   _jswrap_i2c_writeTo(HEAP32[$3 + 28 >> 2], HEAPU8[$3 + 19 | 0], HEAP32[$3 + 12 >> 2], HEAP8[$3 + 18 | 0] & 1, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function i2c_get_address($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP8[HEAP32[$2 + 4 >> 2]] = 1;
  block : {
   if (jsvIsObject(HEAP32[$2 + 8 >> 2]) & 1) {
    HEAP32[$2 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 14903);
    if (HEAP32[$2 >> 2]) {
     $0 = jsvGetBoolAndUnLock(HEAP32[$2 >> 2]);
     HEAP8[HEAP32[$2 + 4 >> 2]] = $0 & 1;
    }
    HEAP32[$2 + 12 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 8 >> 2], 6921);
    break block;
   }
   HEAP32[$2 + 12 >> 2] = jsvGetInteger(HEAP32[$2 + 8 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function _jswrap_i2c_readFrom($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  $6 = __stack_pointer - 112 | 0;
  $5 = $6;
  __stack_pointer = $5;
  HEAP32[$5 + 104 >> 2] = $0;
  HEAP8[$5 + 103 | 0] = $1;
  HEAP32[$5 + 96 >> 2] = $2;
  HEAP8[$5 + 95 | 0] = $3;
  HEAP32[$5 + 88 >> 2] = $4;
  block : {
   if (HEAP32[$5 + 88 >> 2] <= 0) {
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   if (HEAP32[$5 + 88 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
    jsExceptionHere(1, 20608, 0);
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   $6 = $6 - (HEAP32[$5 + 88 >> 2] + 15 & -16) | 0;
   __stack_pointer = $6;
   HEAP32[$5 + 84 >> 2] = $6;
   block2 : {
    if (!(HEAPU8[$5 + 103 | 0] < 28 | HEAPU8[$5 + 103 | 0] > 28)) {
     jshI2CRead(HEAPU8[$5 + 103 | 0], HEAP32[$5 + 96 >> 2] & 255, HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP8[$5 + 95 | 0] & 1);
     break block2;
    }
    block3 : {
     if (!HEAPU8[$5 + 103 | 0]) {
      HEAP32[$5 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$5 + 104 >> 2], 7138);
      if (jsi2cPopulateI2CInfo($5 + 76 | 0, HEAP32[$5 + 72 >> 2]) & 1) {
       HEAP8[$5 + 82 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 104 >> 2], 18910) & 1;
       jsi2cRead($5 + 76 | 0, HEAP32[$5 + 96 >> 2] & 255, HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP8[$5 + 95 | 0] & 1);
      }
      jsvUnLock2(jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 18910, jsvNewFromBool(HEAP8[$5 + 82 | 0] & 1)), HEAP32[$5 + 72 >> 2]);
      break block3;
     }
     HEAP32[$5 + 108 >> 2] = 0;
     break block;
    }
   }
   HEAP32[$5 + 68 >> 2] = jsvNewTypedArray(1, HEAP32[$5 + 88 >> 2]);
   if (HEAP32[$5 + 68 >> 2]) {
    jsvArrayBufferIteratorNew($5 + 8 | 0, HEAP32[$5 + 68 >> 2], 0);
    HEAP32[$5 + 4 >> 2] = 0;
    while (1) {
     if (HEAPU32[$5 + 4 >> 2] < HEAPU32[$5 + 88 >> 2]) {
      jsvArrayBufferIteratorSetByteValue($5 + 8 | 0, HEAP8[HEAP32[$5 + 84 >> 2] + HEAP32[$5 + 4 >> 2] | 0] << 24 >> 24);
      jsvArrayBufferIteratorNext($5 + 8 | 0);
      HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
      continue;
     }
     break;
    };
    jsvArrayBufferIteratorFree($5 + 8 | 0);
   }
   HEAP32[$5 + 108 >> 2] = HEAP32[$5 + 68 >> 2];
  }
  __stack_pointer = $5 + 112 | 0;
  return HEAP32[$5 + 108 >> 2];
 }
 
 function jswrap_i2c_readFrom($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  block : {
   if (!(jsvIsObject(HEAP32[$3 + 24 >> 2]) & 1)) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   HEAP8[$3 + 15 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 24 >> 2]);
   HEAP8[$3 + 14 | 0] = 1;
   HEAP32[$3 + 8 >> 2] = i2c_get_address(HEAP32[$3 + 20 >> 2], $3 + 14 | 0);
   HEAP32[$3 + 28 >> 2] = _jswrap_i2c_readFrom(HEAP32[$3 + 24 >> 2], HEAPU8[$3 + 15 | 0], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 14 | 0] & 1, HEAP32[$3 + 16 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jswrap_i2c_readReg($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  block : {
   if (!(jsvIsObject(HEAP32[$4 + 24 >> 2]) & 1)) {
    HEAP32[$4 + 28 >> 2] = 0;
    break block;
   }
   HEAP8[$4 + 11 | 0] = jsiGetDeviceFromClass(HEAP32[$4 + 24 >> 2]);
   HEAP8[$4 + 10 | 0] = HEAP32[$4 + 16 >> 2];
   _jswrap_i2c_writeTo(HEAP32[$4 + 24 >> 2], HEAPU8[$4 + 11 | 0], HEAP32[$4 + 20 >> 2], 0, 1, $4 + 10 | 0);
   HEAP32[$4 + 28 >> 2] = _jswrap_i2c_readFrom(HEAP32[$4 + 24 >> 2], HEAPU8[$4 + 11 | 0], HEAP32[$4 + 20 >> 2], 1, HEAP32[$4 + 12 >> 2]);
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP32[$4 + 28 >> 2];
 }
 
 function jswrap_stream_available($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 8 >> 2], 17070);
   HEAP32[$1 >> 2] = 0;
   if (jsvIsString(HEAP32[$1 + 4 >> 2]) & 1) {
    HEAP32[$1 >> 2] = jsvGetStringLength(HEAP32[$1 + 4 >> 2])
   }
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_stream_read($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block : {
   if (!(jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1)) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 24 >> 2], 17070);
   HEAP32[$2 + 12 >> 2] = 0;
   block3 : {
    if (jsvIsString(HEAP32[$2 + 16 >> 2]) & 1) {
     HEAP32[$2 + 8 >> 2] = jsvGetStringLength(HEAP32[$2 + 16 >> 2]);
     block2 : {
      if (!(HEAPU32[$2 + 20 >> 2] < HEAPU32[$2 + 8 >> 2] & HEAP32[$2 + 20 >> 2] > 0)) {
       HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 16 >> 2];
       HEAP32[$2 + 16 >> 2] = 0;
       jsvObjectRemoveChild(HEAP32[$2 + 24 >> 2], 17070);
       break block2;
      }
      HEAP32[$2 + 12 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 16 >> 2], 0, HEAP32[$2 + 20 >> 2]);
      HEAP32[$2 + 4 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], 2147483647);
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 17070, HEAP32[$2 + 4 >> 2]);
     }
     break block3;
    }
    HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_1884();
   }
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jsvNewFromEmptyString_1884() {
  return jsvNewWithFlags(29);
 }
 
 function jswrap_stream_pushData($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP8[$3 + 23 | 0] = $2;
  HEAP8[$3 + 22 | 0] = 1;
  HEAP32[$3 + 16 >> 2] = jsvFindChildFromString(HEAP32[$3 + 28 >> 2], 20544);
  block : {
   if (HEAP32[$3 + 16 >> 2]) {
    if (!(jsiExecuteEventCallback(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], 1, $3 + 24 | 0) & 1)) {
     jsError(22562, 0);
     HEAP8[413226] = HEAPU8[413226] | 4;
     jsvObjectRemoveChild(HEAP32[$3 + 28 >> 2], 20544);
    }
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    break block;
   }
   HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 28 >> 2], 17070);
   block1 : {
    if (!(jsvIsString(HEAP32[$3 + 12 >> 2]) & 1)) {
     jsvObjectSetChild(HEAP32[$3 + 28 >> 2], 17070, HEAP32[$3 + 24 >> 2]);
     break block1;
    }
    HEAP32[$3 + 8 >> 2] = jsvGetStringLength(HEAP32[$3 + 12 >> 2]);
    HEAP32[$3 + 4 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]);
    if (HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 4 >> 2] >>> 0 > 512) {
     if (HEAP8[$3 + 23 | 0] & 1) {
      HEAP8[413226] = HEAPU8[413226] | 2
     }
     HEAP8[$3 + 22 | 0] = 0;
    }
    if (!(!(HEAP8[$3 + 22 | 0] & 1 | HEAP8[$3 + 23 | 0] & 1) | HEAPU32[$3 + 8 >> 2] >= 512)) {
     jsvAppendStringVar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], 0, 512 - HEAP32[$3 + 8 >> 2] | 0)
    }
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
   }
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP8[$3 + 22 | 0] & 1;
 }
 
 function jswrap_waveform_kill() {
  var $0 = 0;
  $0 = __stack_pointer - 32 | 0;
  __stack_pointer = $0;
  HEAP32[$0 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[103308], 17269);
  if (HEAP32[$0 + 28 >> 2]) {
   jsvObjectIteratorNew($0 + 24 | 0, HEAP32[$0 + 28 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_1887($0 + 24 | 0) & 1) {
     HEAP32[$0 + 20 >> 2] = jsvObjectIteratorGetValue_1888($0 + 24 | 0);
     HEAP8[$0 + 19 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 20 >> 2], 16976) & 1;
     if (HEAP8[$0 + 19 | 0] & 1) {
      HEAP32[$0 + 12 >> 2] = jswrap_waveform_getBuffer(HEAP32[$0 + 20 >> 2], 0, 0);
      if (!(jstStopBufferTimerTask(HEAP32[$0 + 12 >> 2]) & 1)) {
       jsExceptionHere(1, 18975, 0)
      }
      jsvUnLock(HEAP32[$0 + 12 >> 2]);
     }
     jsvUnLock(HEAP32[$0 + 20 >> 2]);
     jsvObjectIteratorRemoveAndGotoNext($0 + 24 | 0, HEAP32[$0 + 28 >> 2]);
     continue;
    }
    break;
   };
   jsvObjectIteratorFree_1890($0 + 24 | 0);
   jsvUnLock(HEAP32[$0 + 28 >> 2]);
  }
  __stack_pointer = $0 + 32 | 0;
 }
 
 function jsvObjectIteratorHasValue_1887($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
 }
 
 function jsvObjectIteratorGetValue_1888($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_waveform_getBuffer($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 24 >> 2] = $0;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2] ? 22359 : 8164);
  block : {
   if (!HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break block;
   }
   if (HEAP32[$3 + 16 >> 2]) {
    HEAP8[HEAP32[$3 + 16 >> 2]] = 0;
    if (!(!(jsvIsArrayBuffer(HEAP32[$3 + 12 >> 2]) & 1) | (HEAPU8[HEAP32[$3 + 12 >> 2] + 5 | 0] & 15) != 2)) {
     HEAP8[HEAP32[$3 + 16 >> 2]] = 1
    }
   }
   HEAP32[$3 + 8 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 12 >> 2], 0);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
  }
  __stack_pointer = $3 + 32 | 0;
  return HEAP32[$3 + 28 >> 2];
 }
 
 function jsvObjectIteratorFree_1890($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_waveform_constructor($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  HEAP32[$2 + 32 >> 2] = 0;
  HEAP32[$2 + 28 >> 2] = 0;
  block : {
   block1 : {
    if (jsvIsIntegerish(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jsvGetInteger(HEAP32[$2 + 40 >> 2]);
     if (HEAP32[$2 + 32 >> 2] <= 0) {
      jsExceptionHere(1, 22498, 0);
      HEAP32[$2 + 44 >> 2] = 0;
      break block;
     }
     break block1;
    }
    block2 : {
     if (jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1) {
      HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 + 40 >> 2]);
      HEAP32[$2 + 32 >> 2] = jsvGetLength(HEAP32[$2 + 28 >> 2]);
      break block2;
     }
     jsExceptionHere(1, 8202, 0);
     HEAP32[$2 + 44 >> 2] = 0;
     break block;
    }
   }
   HEAP8[$2 + 27 | 0] = 0;
   HEAP8[$2 + 26 | 0] = 0;
   block4 : {
    if (jsvIsObject(HEAP32[$2 + 36 >> 2]) & 1) {
     HEAP8[$2 + 27 | 0] = jsvObjectGetBoolChild(HEAP32[$2 + 36 >> 2], 8281) & 1;
     HEAP32[$2 + 20 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 36 >> 2], 6912);
     if (!(!HEAP32[$2 + 20 >> 2] | HEAP32[$2 + 20 >> 2] == 8 | HEAP32[$2 + 20 >> 2] == 16)) {
      jsExceptionHere(1, 6894, 0);
      HEAP32[$2 + 44 >> 2] = 0;
      break block;
     }
     if (HEAP32[$2 + 20 >> 2] == 16) {
      HEAP8[$2 + 26 | 0] = 1
     }
     break block4;
    }
    if (!(jsvIsUndefined(HEAP32[$2 + 36 >> 2]) & 1)) {
     HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
     jsExceptionHere(1, 5094, $2);
    }
   }
   HEAP8[$2 + 19 | 0] = HEAP8[$2 + 26 | 0] & 1 ? 2 : 1;
   if (!HEAP32[$2 + 28 >> 2]) {
    HEAP32[$2 + 28 >> 2] = jsvNewTypedArray(HEAPU8[$2 + 19 | 0], HEAP32[$2 + 32 >> 2])
   }
   HEAP32[$2 + 12 >> 2] = 0;
   if (HEAP8[$2 + 27 | 0] & 1) {
    HEAP32[$2 + 12 >> 2] = jsvNewTypedArray(HEAPU8[$2 + 19 | 0], HEAP32[$2 + 32 >> 2])
   }
   HEAP32[$2 + 8 >> 2] = jspNewObject(0, 15621);
   if (HEAP32[$2 + 12 >> 2] | !(HEAP8[$2 + 27 | 0] & 1) ? !HEAP32[$2 + 8 >> 2] | !HEAP32[$2 + 28 >> 2] : 1) {
    jsvUnLock3(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2]);
    HEAP32[$2 + 44 >> 2] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 8164, HEAP32[$2 + 28 >> 2]);
   if (HEAP32[$2 + 12 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 22359, HEAP32[$2 + 12 >> 2])
   }
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 8 >> 2];
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP32[$2 + 44 >> 2];
 }
 
 function jswrap_waveform_startOutput($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = +$2;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP8[$4 + 27 | 0] = $1;
  HEAPF64[$4 + 16 >> 3] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  jswrap_waveform_start(HEAP32[$4 + 28 >> 2], HEAPU8[$4 + 27 | 0], HEAPF64[$4 + 16 >> 3], HEAP32[$4 + 12 >> 2], 1);
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jswrap_waveform_start($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $5 = __stack_pointer - 128 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 124 >> 2] = $0;
  HEAP8[$5 + 123 | 0] = $1;
  HEAPF64[$5 + 112 >> 3] = $2;
  HEAP32[$5 + 108 >> 2] = $3;
  HEAP8[$5 + 107 | 0] = $4;
  HEAP8[$5 + 106 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 124 >> 2], 16976) & 1;
  block : {
   if (HEAP8[$5 + 106 | 0] & 1) {
    jsExceptionHere(1, 16932, 0);
    break block;
   }
   if (!(jshIsPinValid(HEAPU8[$5 + 123 | 0]) & 1)) {
    jsExceptionHere(1, 15501, 0);
    break block;
   }
   $1 = __DOUBLE_BITS_1895(HEAPF64[$5 + 112 >> 3]);
   $0 = $1;
   $3 = i64toi32_i32$HIGH_BITS;
   $1 = $3 & 2147483647;
   block2 : {
    if (!(($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072)) {
     if (!(HEAPF64[$5 + 112 >> 3] < .001)) {
      break block2
     }
    }
    jsExceptionHere(1, 3472, 0);
    break block;
   }
   HEAP32[$5 + 96 >> 2] = 0;
   HEAP32[$5 + 100 >> 2] = 0;
   HEAP8[$5 + 95 | 0] = 0;
   HEAP8[$5 + 94 | 0] = 255;
   block4 : {
    if (jsvIsObject(HEAP32[$5 + 108 >> 2]) & 1) {
     HEAPF64[$5 + 80 >> 3] = jsvObjectGetFloatChild(HEAP32[$5 + 108 >> 2], 17804);
     $3 = __DOUBLE_BITS_1895(HEAPF64[$5 + 80 >> 3]);
     $4 = $3;
     $1 = i64toi32_i32$HIGH_BITS;
     $3 = $1 & 2147483647;
     if (!(!(HEAPF64[$5 + 80 >> 3] > 0.0) | (($3 | 0) == 2146435072 | $3 >>> 0 > 2146435072))) {
      $1 = jshGetTimeFromMilliseconds(HEAPF64[$5 + 80 >> 3] * 1.0e3);
      $0 = $1;
      $3 = i64toi32_i32$HIGH_BITS;
      $6 = $3;
      $3 = jshGetSystemTime();
      $1 = i64toi32_i32$HIGH_BITS;
      $7 = $1;
      $4 = $3;
      $8 = $0 - $3 | 0;
      $1 = $6;
      $3 = $7;
      $3 = $3 + ($0 >>> 0 < $4 >>> 0) | 0;
      $3 = $1 - $3 | 0;
      HEAP32[$5 + 96 >> 2] = $8;
      HEAP32[$5 + 100 >> 2] = $3;
     }
     HEAP8[$5 + 95 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 108 >> 2], 5042) & 1;
     HEAP8[$5 + 94 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$5 + 108 >> 2], 15496));
     break block4;
    }
    if (!(jsvIsUndefined(HEAP32[$5 + 108 >> 2]) & 1)) {
     HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 108 >> 2];
     jsExceptionHere(1, 5094, $5 + 16 | 0);
    }
   }
   HEAP8[$5 + 79 | 0] = 0;
   HEAP32[$5 + 72 >> 2] = jswrap_waveform_getBuffer(HEAP32[$5 + 124 >> 2], 0, $5 + 79 | 0);
   HEAP32[$5 + 68 >> 2] = jswrap_waveform_getBuffer(HEAP32[$5 + 124 >> 2], 1, 0);
   block5 : {
    if (HEAP8[$5 + 79 | 0] & 1) {
     HEAP8[$5 + 67 | 0] = HEAP8[$5 + 107 | 0] & 1 ? 6 : 7;
     break block5;
    }
    HEAP8[$5 + 67 | 0] = HEAP8[$5 + 107 | 0] & 1 ? 4 : 5;
   }
   $3 = HEAP32[$5 + 96 >> 2];
   $1 = $3;
   $0 = HEAP32[$5 + 100 >> 2];
   $4 = $0;
   $0 = jshGetTimeFromMilliseconds(1.0e3 / HEAPF64[$5 + 112 >> 3]);
   $3 = i64toi32_i32$HIGH_BITS;
   $6 = $3;
   $3 = $4;
   $4 = $0;
   $0 = $6;
   $6 = $0;
   $7 = HEAPU8[$5 + 123 | 0];
   $8 = HEAPU8[$5 + 94 | 0];
   $9 = HEAP32[$5 + 72 >> 2];
   if (HEAP8[$5 + 95 | 0] & 1) {
    if (HEAP32[$5 + 68 >> 2]) {
     $0 = HEAP32[$5 + 68 >> 2]
    } else {
     $0 = HEAP32[$5 + 72 >> 2]
    }
   } else {
    $0 = 0
   }
   HEAP32[$5 + 60 >> 2] = jstStartSignal($1, $3, $4, $6, $7, $8, $9, $0, HEAPU8[$5 + 67 | 0]);
   block8 : {
    if (HEAP32[$5 + 60 >> 2] < 0) {
     jsWarn(7947, 0);
     break block8;
    }
    jsvObjectSetChildAndUnLock(HEAP32[$5 + 124 >> 2], 14634, jsvNewFromInteger(HEAP32[$5 + 60 >> 2]));
   }
   jsvUnLock2(HEAP32[$5 + 72 >> 2], HEAP32[$5 + 68 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$5 + 124 >> 2], 16976, jsvNewFromBool(1));
   jsvObjectSetChildAndUnLock(HEAP32[$5 + 124 >> 2], 14634, jsvNewFromFloat(HEAPF64[$5 + 112 >> 3]));
   HEAP32[$5 + 56 >> 2] = jsvObjectGetChild(HEAP32[103308], 17269, 3);
   if (!HEAP32[$5 + 56 >> 2]) {
    break block
   }
   jsvSetArrayItem(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 60 >> 2], HEAP32[$5 + 124 >> 2]);
   jsvUnLock(HEAP32[$5 + 56 >> 2]);
  }
  __stack_pointer = $5 + 128 | 0;
 }
 
 function __DOUBLE_BITS_1895($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_waveform_startInput($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = +$2;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP8[$4 + 27 | 0] = $1;
  HEAPF64[$4 + 16 >> 3] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  if (!(jshPinAnalog(HEAPU8[$4 + 27 | 0]) < 0.0)) {
   jswrap_waveform_start(HEAP32[$4 + 28 >> 2], HEAPU8[$4 + 27 | 0], HEAPF64[$4 + 16 >> 3], HEAP32[$4 + 12 >> 2], 0)
  }
  __stack_pointer = $4 + 32 | 0;
 }
 
 function jswrap_waveform_stop($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP8[$1 + 11 | 0] = jsvObjectGetBoolChild(HEAP32[$1 + 12 >> 2], 16976) & 1;
  block : {
   if (!(HEAP8[$1 + 11 | 0] & 1)) {
    jsExceptionHere(1, 16960, 0);
    break block;
   }
   HEAP32[$1 + 4 >> 2] = jswrap_waveform_getBuffer(HEAP32[$1 + 12 >> 2], 0, 0);
   if (!(jstStopBufferTimerTask(HEAP32[$1 + 4 >> 2]) & 1)) {
    jsExceptionHere(1, 18975, 0)
   }
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jswrap_waveform_getById($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChild(HEAP32[103308], 17269, 3);
  block : {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvGetArrayItem(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
  }
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_waveform_eventHandler($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer + -64 | 0;
  __stack_pointer = $3;
  HEAP8[$3 + 63 | 0] = $0;
  HEAP32[$3 + 56 >> 2] = $1;
  HEAP32[$3 + 52 >> 2] = $2;
  HEAP16[$3 + 50 >> 1] = HEAPU16[HEAP32[$3 + 56 >> 2] >> 1];
  HEAP32[$3 + 44 >> 2] = HEAPU16[$3 + 50 >> 1] >>> 8;
  if ((HEAPU16[$3 + 50 >> 1] & 255) == 1) {
   HEAP32[$3 + 40 >> 2] = _jswrap_waveform_getById(HEAP32[$3 + 44 >> 2]);
   if (HEAP32[$3 + 40 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 40 >> 2], 16976, jsvNewFromBool(0));
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 8164);
    jsiQueueObjectCallbacks(HEAP32[$3 + 40 >> 2], 16253, $3 + 36 | 0, 1);
    jsvUnLock(HEAP32[$3 + 36 >> 2]);
    HEAP32[$3 + 32 >> 2] = jsvObjectGetChild(HEAP32[103308], 17269, 3);
    if (HEAP32[$3 + 32 >> 2]) {
     jsvRemoveArrayItem(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 44 >> 2])
    }
    jsvUnLock2(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 32 >> 2]);
   }
  }
  if ((HEAPU16[$3 + 50 >> 1] & 255) == 2) {
   HEAP32[$3 + 28 >> 2] = _jswrap_waveform_getById(HEAP32[$3 + 44 >> 2]);
   if (HEAP32[$3 + 28 >> 2]) {
    HEAP32[$3 + 24 >> 2] = Math_imul(HEAP32[$3 + 44 >> 2], 25) + 416192;
    $0 = HEAP32[$3 + 24 >> 2];
    block : {
     if (!(HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) {
      break block
     }
     $0 = HEAP32[$3 + 24 >> 2];
     $1 = HEAP32[$3 + 24 >> 2];
     if ((HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) == (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
      break block
     }
     HEAP32[$3 + 20 >> 2] = jswrap_waveform_getBuffer(HEAP32[$3 + 28 >> 2], 0, 0);
     $1 = jsvGetRef(HEAP32[$3 + 20 >> 2]) & 65535;
     $0 = HEAP32[$3 + 24 >> 2];
     HEAP32[$3 + 16 >> 2] = ($1 | 0) != (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
     jsvUnLock(HEAP32[$3 + 20 >> 2]);
     HEAP32[$3 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$3 + 28 >> 2], 8267, 10));
     if (HEAP32[$3 + 12 >> 2] != HEAP32[$3 + 16 >> 2]) {
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 28 >> 2], 8267, jsvNewFromInteger(HEAP32[$3 + 16 >> 2]));
      HEAP32[$3 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2] ? 8164 : 22359);
      jsiQueueObjectCallbacks(HEAP32[$3 + 28 >> 2], 8153, $3 + 8 | 0, 1);
      jsvUnLock(HEAP32[$3 + 8 >> 2]);
     }
    }
    jsvUnLock(HEAP32[$3 + 28 >> 2]);
   }
  }
  __stack_pointer = $3 - -64 | 0;
 }
 
 function jswrap_heatshrink_compress($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 128 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 120 >> 2] = $0;
  block : {
   if (!(jsvIsIterable(HEAP32[$1 + 120 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
    jsExceptionHere(3, 6084, $1);
    HEAP32[$1 + 124 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
   HEAP32[$1 + 12 >> 2] = heatshrink_encode_cb(578, $1 + 56 | 0, 0, 0);
   jsvIteratorFree($1 + 56 | 0);
   HEAP32[$1 + 8 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 12 >> 2], 0);
   if (!HEAP32[$1 + 8 >> 2]) {
    jsError(4741, 0);
    HEAP32[$1 + 124 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 8 >> 2], 0);
   heatshrink_encode_cb(578, $1 + 56 | 0, 675, $1 + 16 | 0);
   jsvStringIteratorFree_1901($1 + 16 | 0);
   jsvIteratorFree($1 + 56 | 0);
   HEAP32[$1 + 4 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 128 | 0;
  return HEAP32[$1 + 124 >> 2];
 }
 
 function jsvStringIteratorFree_1901($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_heatshrink_decompress($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 128 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 120 >> 2] = $0;
  block : {
   if (!(jsvIsIterable(HEAP32[$1 + 120 >> 2]) & 1)) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
    jsExceptionHere(3, 6084, $1);
    HEAP32[$1 + 124 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
   HEAP32[$1 + 12 >> 2] = heatshrink_decode(578, $1 + 56 | 0, 0);
   jsvIteratorFree($1 + 56 | 0);
   HEAP32[$1 + 8 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 12 >> 2], 0);
   if (!HEAP32[$1 + 8 >> 2]) {
    jsError(4741, 0);
    HEAP32[$1 + 124 >> 2] = 0;
    break block;
   }
   jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 8 >> 2], 0);
   heatshrink_decode_cb(578, $1 + 56 | 0, 675, $1 + 16 | 0);
   jsvStringIteratorFree_1901($1 + 16 | 0);
   jsvIteratorFree($1 + 56 | 0);
   HEAP32[$1 + 4 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 128 | 0;
  return HEAP32[$1 + 124 >> 2];
 }
 
 function _jswrap_graphics_freeImageInfo($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jswrap_graphics_parseImage_palette($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = 0;
  if (!(!(jsvIsArrayBuffer(HEAP32[$2 + 8 >> 2]) & 1) | HEAPU8[HEAP32[$2 + 8 >> 2] + 5 | 0] != 2)) {
   HEAP32[$2 + 4 >> 2] = 0;
   $0 = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
   HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = $0;
   block2 : {
    if (!(HEAP32[$2 + 4 >> 2] == 2 | HEAP32[$2 + 4 >> 2] == 4 | (HEAP32[$2 + 4 >> 2] == 8 | HEAP32[$2 + 4 >> 2] == 16))) {
     if (HEAP32[$2 + 4 >> 2] != 256) {
      break block2
     }
    }
    HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = HEAP32[$2 + 4 >> 2] - 1;
   }
  }
  if (!HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2]) {
   jsExceptionHere(1, 6810, 0)
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 8 >> 2];
 }
 
 function _jswrap_graphics_parseImage($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 176 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 168 >> 2] = $0;
  HEAP32[$4 + 164 >> 2] = $1;
  HEAP32[$4 + 160 >> 2] = $2;
  HEAP32[$4 + 156 >> 2] = $3;
  wasm2js_memory_fill(HEAP32[$4 + 156 >> 2], 0, 84);
  block : {
   block2 : {
    if (jsvIsObject(HEAP32[$4 + 164 >> 2]) & 1) {
     block1 : {
      if (jsvIsInstanceOf(HEAP32[$4 + 164 >> 2], 7540) & 1) {
       if (!(graphicsGetFromVar($4 + 84 | 0, HEAP32[$4 + 164 >> 2]) & 1)) {
        HEAP8[$4 + 175 | 0] = 0;
        break block;
       }
       if (HEAPU8[$4 + 88 | 0] | HEAPU8[$4 + 89 | 0] << 8 | (HEAPU8[$4 + 90 | 0] << 16 | HEAPU8[$4 + 91 | 0] << 24)) {
        HEAP8[$4 + 175 | 0] = 0;
        break block;
       }
       HEAP32[HEAP32[$4 + 156 >> 2] >> 2] = HEAPU8[$4 + 96 | 0] | HEAPU8[$4 + 97 | 0] << 8;
       HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] = HEAPU8[$4 + 98 | 0] | HEAPU8[$4 + 99 | 0] << 8;
       HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = HEAPU8[$4 + 100 | 0];
       break block1;
      }
      $0 = jsvObjectGetIntegerChild(HEAP32[$4 + 164 >> 2], 16247);
      HEAP32[HEAP32[$4 + 156 >> 2] >> 2] = $0;
      $0 = jsvObjectGetIntegerChild(HEAP32[$4 + 164 >> 2], 4847);
      HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] = $0;
      $0 = jsvObjectGetIntegerChild(HEAP32[$4 + 164 >> 2], 14899);
      HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = $0;
      if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] <= 0) {
       HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = 1
      }
     }
     HEAP32[$4 + 80 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 164 >> 2], 8164);
     $0 = jsvGetArrayBufferBackingString(HEAP32[$4 + 80 >> 2], HEAP32[$4 + 156 >> 2] + 24 | 0);
     HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2] = $0;
     jsvUnLock(HEAP32[$4 + 80 >> 2]);
     $0 = HEAP32[$4 + 156 >> 2];
     HEAP32[$0 + 24 >> 2] = HEAP32[$4 + 160 >> 2] + HEAP32[$0 + 24 >> 2];
     HEAP32[$4 + 76 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 164 >> 2], 4622);
     HEAP8[HEAP32[$4 + 156 >> 2] + 12 | 0] = HEAP32[$4 + 76 >> 2] != 0;
     $0 = jsvGetIntegerAndUnLock(HEAP32[$4 + 76 >> 2]);
     HEAP32[HEAP32[$4 + 156 >> 2] + 16 >> 2] = $0;
     HEAP32[$4 + 76 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 164 >> 2], 17485);
     if (HEAP32[$4 + 76 >> 2]) {
      jsvUnLock(_jswrap_graphics_parseImage_palette(HEAP32[$4 + 156 >> 2], HEAP32[$4 + 76 >> 2]));
      if (!HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2]) {
       HEAP8[$4 + 175 | 0] = 0;
       break block;
      }
     }
     break block2;
    }
    block8 : {
     block3 : {
      if (!(jsvIsString(HEAP32[$4 + 164 >> 2]) & 1)) {
       if (!(jsvIsArrayBuffer(HEAP32[$4 + 164 >> 2]) & 1)) {
        break block3
       }
      }
      block4 : {
       if (jsvIsArrayBuffer(HEAP32[$4 + 164 >> 2]) & 1) {
        $0 = jsvGetArrayBufferBackingString(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 156 >> 2] + 24 | 0);
        HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2] = $0;
        break block4;
       }
       $0 = jsvLockAgain(HEAP32[$4 + 164 >> 2]);
       HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2] = $0;
      }
      jsvStringIteratorNewUTF8($4 + 36 | 0, HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2], HEAP32[$4 + 160 >> 2]);
      $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 36 | 0);
      HEAP32[HEAP32[$4 + 156 >> 2] >> 2] = $0;
      $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 36 | 0);
      HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] = $0;
      $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 36 | 0);
      HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = $0;
      $0 = HEAP32[$4 + 156 >> 2];
      HEAP32[$0 + 24 >> 2] = HEAP32[$4 + 160 >> 2] + HEAP32[$0 + 24 >> 2];
      block5 : {
       if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 128) {
        HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 127;
        HEAP8[HEAP32[$4 + 156 >> 2] + 12 | 0] = 1;
        $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 36 | 0);
        HEAP32[HEAP32[$4 + 156 >> 2] + 16 >> 2] = $0;
        HEAP16[HEAP32[$4 + 156 >> 2] + 48 >> 1] = 4;
        break block5;
       }
       HEAP16[HEAP32[$4 + 156 >> 2] + 48 >> 1] = 3;
      }
      $0 = HEAP32[$4 + 156 >> 2];
      HEAP32[$0 + 24 >> 2] = HEAPU16[HEAP32[$4 + 156 >> 2] + 48 >> 1] + HEAP32[$0 + 24 >> 2];
      if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 64) {
       HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 63;
       if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] > 8) {
        jsExceptionHere(1, 7369, 0);
        _jswrap_graphics_freeImageInfo(HEAP32[$4 + 156 >> 2]);
        jsvStringIteratorFree_1906($4 + 36 | 0);
        HEAP8[$4 + 175 | 0] = 0;
        break block;
       }
       HEAP32[$4 + 32 >> 2] = 1 << HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2];
       HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = HEAP32[$4 + 32 >> 2] - 1;
       block6 : {
        if (HEAP32[$4 + 32 >> 2] << 1 >>> 0 <= 32) {
         HEAP32[$4 + 28 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 24 >> 2];
         HEAP32[$4 + 24 >> 2] = 0;
         while (1) {
          if (HEAPU32[$4 + 24 >> 2] < HEAPU32[$4 + 32 >> 2]) {
           $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 36 | 0) & 255;
           $1 = (jsvStringIteratorGetUTF8CharAndNext($4 + 36 | 0) & 255) << 8;
           HEAP16[(HEAP32[$4 + 156 >> 2] + 52 | 0) + (HEAP32[$4 + 24 >> 2] << 1) >> 1] = $0 | $1;
           HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] + 2;
           HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
           continue;
          }
          break;
         };
         HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 156 >> 2] + 52;
         break block6;
        }
        if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] <= 8) {
         HEAP32[$4 + 20 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 24 >> 2] + (HEAP32[$4 + 32 >> 2] << 1);
         HEAP32[$4 + 16 >> 2] = 0;
         HEAP32[$4 + 12 >> 2] = jsvGetDataPointer(HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2], $4 + 16 | 0);
         if (!(!HEAP32[$4 + 12 >> 2] | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] > 8 | HEAPU32[$4 + 20 >> 2] >= HEAPU32[$4 + 16 >> 2])) {
          HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = HEAP32[$4 + 32 >> 2] - 1;
          HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 12 >> 2] + (HEAP32[HEAP32[$4 + 156 >> 2] + 24 >> 2] + HEAPU16[HEAP32[$4 + 156 >> 2] + 48 >> 1] | 0);
         }
        }
       }
       if (!HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2]) {
        jsExceptionHere(1, 21668, 0);
        _jswrap_graphics_freeImageInfo(HEAP32[$4 + 156 >> 2]);
        jsvStringIteratorFree_1906($4 + 36 | 0);
        HEAP8[$4 + 175 | 0] = 0;
        break block;
       }
       $0 = HEAP32[$4 + 156 >> 2];
       HEAP16[$0 + 48 >> 1] = HEAPU16[$0 + 48 >> 1] + (HEAP32[$4 + 32 >> 2] << 1 & 65535);
       $0 = HEAP32[$4 + 156 >> 2];
       HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + (HEAP32[$4 + 32 >> 2] << 1 & 65535);
      }
      jsvStringIteratorFree_1906($4 + 36 | 0);
      break block8;
     }
     jsExceptionHere(1, 16711, 0);
     HEAP8[$4 + 175 | 0] = 0;
     break block;
    }
   }
   if (!(HEAP8[HEAP32[$4 + 156 >> 2] + 12 | 0] & 1)) {
    HEAP32[HEAP32[$4 + 156 >> 2] + 16 >> 2] = -1
   }
   if (!HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2]) {
    block9 : {
     if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] == 1) {
      $0 = HEAP32[$4 + 168 >> 2];
      HEAP16[HEAP32[$4 + 156 >> 2] + 52 >> 1] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
      $0 = HEAP32[$4 + 168 >> 2];
      HEAP16[HEAP32[$4 + 156 >> 2] + 54 >> 1] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
      HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 156 >> 2] + 52;
      HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 1;
      break block9;
     }
     block10 : {
      if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] == 2) {
       $0 = HEAP32[$4 + 168 >> 2];
       HEAP16[HEAP32[$4 + 156 >> 2] + 52 >> 1] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
       $0 = graphicsBlendGfxColor(HEAP32[$4 + 168 >> 2], 85);
       HEAP16[HEAP32[$4 + 156 >> 2] + 54 >> 1] = $0;
       $0 = graphicsBlendGfxColor(HEAP32[$4 + 168 >> 2], 171);
       HEAP16[HEAP32[$4 + 156 >> 2] + 56 >> 1] = $0;
       $0 = HEAP32[$4 + 168 >> 2];
       HEAP16[HEAP32[$4 + 156 >> 2] + 58 >> 1] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
       HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 156 >> 2] + 52;
       HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 3;
       break block10;
      }
      block12 : {
       if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 3)) {
        HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 234320;
        HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 7;
        break block12;
       }
       block14 : {
        if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 4)) {
         HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 234352;
         HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 15;
         break block14;
        }
        block16 : {
         if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 8)) {
          HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 234384;
          HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 255;
          break block16;
         }
         block18 : {
          if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 8 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 4)) {
           HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 234896;
           HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 15;
           break block18;
          }
          block20 : {
           if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 8 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 3)) {
            HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 234928;
            HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 7;
            break block20;
           }
           if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 4 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 3)) {
            HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 234944;
            HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 7;
           }
          }
         }
        }
       }
      }
     }
    }
   }
   block23 : {
    if (!(!(jsvIsString(HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2]) & 1) | HEAP32[HEAP32[$4 + 156 >> 2] >> 2] <= 0 | HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] <= 0)) {
     if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] <= 32) {
      break block23
     }
    }
    jsExceptionHere(1, 18130, 0);
    _jswrap_graphics_freeImageInfo(HEAP32[$4 + 156 >> 2]);
    HEAP8[$4 + 175 | 0] = 0;
    break block;
   }
   HEAP32[HEAP32[$4 + 156 >> 2] + 36 >> 2] = (1 << HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2]) - 1;
   $1 = HEAP32[$4 + 156 >> 2];
   if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] < 8) {
    $0 = (8 / HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] | 0) - 1 | 0
   } else {
    $0 = 0
   }
   HEAP32[$1 + 40 >> 2] = $0;
   HEAP32[HEAP32[$4 + 156 >> 2] + 44 >> 2] = Math_imul(HEAP32[HEAP32[$4 + 156 >> 2] >> 2], HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2]) + 7 >> 3;
   HEAP16[HEAP32[$4 + 156 >> 2] + 50 >> 1] = Math_imul(HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2], Math_imul(HEAP32[HEAP32[$4 + 156 >> 2] >> 2], HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2])) + 7 >> 3;
   HEAP8[$4 + 175 | 0] = 1;
  }
  __stack_pointer = $4 + 176 | 0;
  return HEAP8[$4 + 175 | 0] & 1;
 }
 
 function jsvStringIteratorFree_1906($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jswrap_drawImageLayerGetPixel($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 48 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 36 >> 2] = $1;
  HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 184 >> 2];
  HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 188 >> 2];
  block2 : {
   if (!(HEAP32[HEAP32[$2 + 40 >> 2] + 160 >> 2] <= (HEAP32[$2 + 32 >> 2] & -256) | HEAP32[HEAP32[$2 + 40 >> 2] + 164 >> 2] <= (HEAP32[$2 + 28 >> 2] & -256) | (HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 28 >> 2]) < 0)) {
    HEAP32[$2 + 24 >> 2] = 0;
    HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 32 >> 2] >> 8;
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 28 >> 2] >> 8;
    block1 : {
     if (HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2] == 8) {
      jsvStringIteratorGoto(HEAP32[$2 + 40 >> 2] + 120 | 0, HEAP32[HEAP32[$2 + 40 >> 2] + 56 >> 2], (HEAP32[HEAP32[$2 + 40 >> 2] + 60 >> 2] + HEAP32[$2 + 20 >> 2] | 0) + Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 80 >> 2]) | 0);
      HEAP32[$2 + 24 >> 2] = jsvStringIteratorGetChar_1908(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
      break block1;
     }
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 36 >> 2]);
     HEAP32[$2 + 8 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2]);
     jsvStringIteratorGoto(HEAP32[$2 + 40 >> 2] + 120 | 0, HEAP32[HEAP32[$2 + 40 >> 2] + 56 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 60 >> 2] + (HEAP32[$2 + 8 >> 2] >> 3) | 0);
     HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] & 7;
     HEAP32[$2 + 24 >> 2] = jsvStringIteratorGetChar_1908(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
     HEAP32[$2 + 4 >> 2] = 8 - (HEAP32[$2 + 8 >> 2] + HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2] | 0);
     while (1) {
      if (HEAP32[$2 + 4 >> 2] < 0) {
       jsvStringIteratorNext(HEAP32[$2 + 40 >> 2] + 120 | 0);
       HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] << 8 | jsvStringIteratorGetChar_1908(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
       HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 8;
       continue;
      }
      break;
     };
     HEAP32[$2 + 24 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 72 >> 2] & HEAP32[$2 + 24 >> 2] >>> HEAP32[$2 + 4 >> 2];
    }
    if (HEAP32[HEAP32[$2 + 40 >> 2] + 52 >> 2] != HEAP32[$2 + 24 >> 2]) {
     if (HEAP32[HEAP32[$2 + 40 >> 2] + 64 >> 2]) {
      HEAP32[$2 + 24 >> 2] = HEAPU16[HEAP32[HEAP32[$2 + 40 >> 2] + 64 >> 2] + ((HEAP32[$2 + 24 >> 2] & HEAP32[HEAP32[$2 + 40 >> 2] + 68 >> 2]) << 1) >> 1]
     }
     HEAP32[HEAP32[$2 + 36 >> 2] >> 2] = HEAP32[$2 + 24 >> 2];
     HEAP8[$2 + 47 | 0] = 1;
     break block2;
    }
   }
   HEAP8[$2 + 47 | 0] = 0;
  }
  __stack_pointer = $2 + 48 | 0;
  return HEAP8[$2 + 47 | 0] & 1;
 }
 
 function jsvStringIteratorGetChar_1908($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
  }
  return HEAP8[$1 + 15 | 0] << 24 >> 24;
 }
 
 function _jswrap_drawImageLayerInit($0) {
  var $1 = 0, $2 = 0.0, $3 = 0;
  $1 = __stack_pointer - 48 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 44 >> 2] = $0;
  HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] << 8;
  HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] << 8;
  HEAPF64[$1 + 32 >> 3] = jswrap_math_cos(HEAPF64[HEAP32[$1 + 44 >> 2] + 16 >> 3]);
  HEAPF64[$1 + 24 >> 3] = jswrap_math_sin(HEAPF64[HEAP32[$1 + 44 >> 2] + 16 >> 3]);
  $3 = HEAP32[$1 + 44 >> 2];
  $2 = HEAPF64[$1 + 32 >> 3] / HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * 256.0;
  if (Math_abs($2) < 2147483647.0) {
   $0 = ~~$2
  } else {
   $0 = -2147483648
  }
  HEAP32[$3 + 168 >> 2] = $0;
  $3 = HEAP32[$1 + 44 >> 2];
  $2 = HEAPF64[$1 + 24 >> 3] / HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * 256.0;
  if (Math_abs($2) < 2147483647.0) {
   $0 = ~~$2
  } else {
   $0 = -2147483648
  }
  HEAP32[$3 + 172 >> 2] = $0;
  $2 = HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * (+HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] * Math_abs(HEAPF64[$1 + 32 >> 3]) + +HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] * Math_abs(HEAPF64[$1 + 24 >> 3])) + .5;
  if (Math_abs($2) < 2147483647.0) {
   $0 = ~~$2
  } else {
   $0 = -2147483648
  }
  HEAP32[$1 + 20 >> 2] = $0;
  $2 = HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * (+HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] * Math_abs(HEAPF64[$1 + 24 >> 3]) + +HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] * Math_abs(HEAPF64[$1 + 32 >> 3])) + .5;
  if (Math_abs($2) < 2147483647.0) {
   $0 = ~~$2
  } else {
   $0 = -2147483648
  }
  HEAP32[$1 + 16 >> 2] = $0;
  if (HEAP8[HEAP32[$1 + 44 >> 2] + 32 | 0] & 1) {
   $0 = HEAP32[$1 + 44 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - (HEAP32[$1 + 20 >> 2] << 7);
   $0 = HEAP32[$1 + 44 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - (HEAP32[$1 + 16 >> 2] << 7);
  }
  HEAP32[HEAP32[$1 + 44 >> 2] + 8 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] >> 2] + (HEAP32[$1 + 20 >> 2] << 8);
  HEAP32[HEAP32[$1 + 44 >> 2] + 12 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 4 >> 2] + (HEAP32[$1 + 16 >> 2] << 8);
  HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] << 7;
  HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] << 7;
  HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] = HEAP32[$1 + 12 >> 2] - (((Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 168 >> 2], HEAP32[$1 + 20 >> 2]) + 1 | 0) + Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2], HEAP32[$1 + 16 >> 2]) | 0) / 2 | 0);
  HEAP32[HEAP32[$1 + 44 >> 2] + 180 >> 2] = HEAP32[$1 + 8 >> 2] - (((Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 168 >> 2], HEAP32[$1 + 16 >> 2]) + 1 | 0) - Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2], HEAP32[$1 + 20 >> 2]) | 0) / 2 | 0);
  if (HEAP8[HEAP32[$1 + 44 >> 2] + 33 | 0] & 1) {
   while (1) {
    if (HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] < 0) {
     $0 = HEAP32[$1 + 44 >> 2];
     HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2] + HEAP32[$0 + 176 >> 2];
     continue;
    }
    break;
   };
   while (1) {
    if (HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] >= HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2]) {
     $0 = HEAP32[$1 + 44 >> 2];
     HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] - HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2];
     continue;
    }
    break;
   };
   while (1) {
    if (HEAP32[HEAP32[$1 + 44 >> 2] + 180 >> 2] < 0) {
     $0 = HEAP32[$1 + 44 >> 2];
     HEAP32[$0 + 180 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2] + HEAP32[$0 + 180 >> 2];
     continue;
    }
    break;
   };
   while (1) {
    if (HEAP32[HEAP32[$1 + 44 >> 2] + 180 >> 2] >= HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2]) {
     $0 = HEAP32[$1 + 44 >> 2];
     HEAP32[$0 + 180 >> 2] = HEAP32[$0 + 180 >> 2] - HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2];
     continue;
    }
    break;
   };
  }
  __stack_pointer = $1 + 48 | 0;
 }
 
 function _jswrap_drawImageLayerSetStart($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 16 >> 2] = (HEAP32[$3 + 24 >> 2] << 8) - HEAP32[HEAP32[$3 + 28 >> 2] >> 2];
  HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 20 >> 2] << 8) - HEAP32[HEAP32[$3 + 28 >> 2] + 4 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] + (Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 168 >> 2], HEAP32[$3 + 16 >> 2]) + Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 172 >> 2], HEAP32[$3 + 12 >> 2]) >> 8);
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 + 180 >> 2] = HEAP32[$0 + 180 >> 2] + (Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 168 >> 2], HEAP32[$3 + 12 >> 2]) - Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 172 >> 2], HEAP32[$3 + 16 >> 2]) >> 8);
 }
 
 function _jswrap_drawImageLayerStartX($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2];
  HEAP32[HEAP32[$1 + 12 >> 2] + 188 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2];
 }
 
 function _jswrap_drawImageLayerNextX($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 184 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 168 >> 2] + HEAP32[$0 + 184 >> 2];
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 188 >> 2] = HEAP32[$0 + 188 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2];
 }
 
 function _jswrap_drawImageLayerNextXRepeat($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP8[HEAP32[$1 + 12 >> 2] + 33 | 0] & 1) {
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] < 0) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 184 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2] + HEAP32[$0 + 184 >> 2];
   }
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2]) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 184 >> 2] = HEAP32[$0 + 184 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2];
   }
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 188 >> 2] < 0) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 188 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2] + HEAP32[$0 + 188 >> 2];
   }
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 188 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2]) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 188 >> 2] = HEAP32[$0 + 188 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2];
   }
  }
 }
 
 function _jswrap_drawImageLayerNextY($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2] + HEAP32[$0 + 176 >> 2];
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 168 >> 2] + HEAP32[$0 + 180 >> 2];
  if (HEAP8[HEAP32[$1 + 12 >> 2] + 33 | 0] & 1) {
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2] < 0) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2] + HEAP32[$0 + 176 >> 2];
   }
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2]) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2];
   }
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] < 0) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2] + HEAP32[$0 + 180 >> 2];
   }
   if (HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2]) {
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 180 >> 2] = HEAP32[$0 + 180 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2];
   }
  }
 }
 
 function _jswrap_drawImageSimpleRow($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0;
  $8 = __stack_pointer - 48 | 0;
  __stack_pointer = $8;
  HEAP32[$8 + 44 >> 2] = $0;
  HEAP32[$8 + 40 >> 2] = $1;
  HEAP32[$8 + 36 >> 2] = $2;
  HEAP32[$8 + 32 >> 2] = $3;
  HEAP32[$8 + 28 >> 2] = $4;
  HEAP32[$8 + 24 >> 2] = $5;
  HEAP32[$8 + 20 >> 2] = $6;
  HEAP32[$8 + 16 >> 2] = $7;
  HEAP32[$8 + 12 >> 2] = HEAP32[HEAP32[$8 + 20 >> 2] >> 2];
  HEAP32[$8 + 8 >> 2] = HEAP32[HEAP32[$8 + 16 >> 2] >> 2];
  HEAP32[$8 + 4 >> 2] = HEAP32[$8 + 40 >> 2];
  while (1) {
   if (HEAP32[$8 + 4 >> 2] < (HEAP32[$8 + 40 >> 2] + HEAP32[HEAP32[$8 + 32 >> 2] >> 2] | 0)) {
    while (1) {
     if (HEAP32[$8 + 12 >> 2] < HEAP32[HEAP32[$8 + 32 >> 2] + 8 >> 2]) {
      HEAP32[$8 + 8 >> 2] = HEAP32[$8 + 8 >> 2] << 8 | jsvStringIteratorGetUTF8CharAndNext(HEAP32[$8 + 28 >> 2]) & 255;
      HEAP32[$8 + 12 >> 2] = HEAP32[$8 + 12 >> 2] + 8;
      continue;
     }
     break;
    };
    HEAP32[$8 >> 2] = HEAP32[HEAP32[$8 + 32 >> 2] + 36 >> 2] & HEAP32[$8 + 8 >> 2] >>> HEAP32[$8 + 12 >> 2] - HEAP32[HEAP32[$8 + 32 >> 2] + 8 >> 2];
    HEAP32[$8 + 12 >> 2] = HEAP32[$8 + 12 >> 2] - HEAP32[HEAP32[$8 + 32 >> 2] + 8 >> 2];
    if (HEAP32[HEAP32[$8 + 32 >> 2] + 16 >> 2] != HEAP32[$8 >> 2]) {
     if (HEAP32[HEAP32[$8 + 32 >> 2] + 28 >> 2]) {
      HEAP32[$8 >> 2] = HEAPU16[HEAP32[HEAP32[$8 + 32 >> 2] + 28 >> 2] + ((HEAP32[$8 >> 2] & HEAP32[HEAP32[$8 + 32 >> 2] + 32 >> 2]) << 1) >> 1]
     }
     FUNCTION_TABLE[HEAP32[$8 + 24 >> 2]](HEAP32[$8 + 44 >> 2], HEAP32[$8 + 4 >> 2], HEAP32[$8 + 36 >> 2], HEAP32[$8 >> 2]);
    }
    HEAP32[$8 + 4 >> 2] = HEAP32[$8 + 4 >> 2] + 1;
    continue;
   }
   break;
  };
  HEAP32[HEAP32[$8 + 20 >> 2] >> 2] = HEAP32[$8 + 12 >> 2];
  HEAP32[HEAP32[$8 + 16 >> 2] >> 2] = HEAP32[$8 + 8 >> 2];
  __stack_pointer = $8 + 48 | 0;
 }
 
 function _jswrap_drawImageSimple($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer + -64 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 60 >> 2] = $0;
  HEAP32[$6 + 56 >> 2] = $1;
  HEAP32[$6 + 52 >> 2] = $2;
  HEAP32[$6 + 48 >> 2] = $3;
  HEAP32[$6 + 44 >> 2] = $4;
  HEAP8[$6 + 43 | 0] = $5;
  HEAP32[$6 + 36 >> 2] = 0;
  HEAP32[$6 + 32 >> 2] = 0;
  HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 56 >> 2];
  HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 52 >> 2];
  HEAP32[$6 + 20 >> 2] = (HEAP32[$6 + 56 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] >> 2] | 0) - 1;
  HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 52 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] + 4 >> 2] | 0) - 1;
  block : {
   if (!(jsvStringIteratorHasChar_1917(HEAP32[$6 + 44 >> 2]) & 1)) {
    break block
   }
   $0 = HEAP32[$6 + 60 >> 2];
   if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16)) {
    graphicsSetModifiedAndClip(HEAP32[$6 + 60 >> 2], $6 + 28 | 0, $6 + 24 | 0, $6 + 20 | 0, $6 + 16 | 0, 1);
    if (!(HEAP32[$6 + 16 >> 2] >= HEAP32[$6 + 24 >> 2] & HEAP32[$6 + 20 >> 2] >= HEAP32[$6 + 28 >> 2])) {
     if (HEAP8[$6 + 43 | 0] & 1) {
      HEAP32[$6 + 36 >> 2] = 0 - Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] + 4 >> 2], Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] >> 2], HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2]));
      while (1) {
       if (HEAP32[$6 + 36 >> 2] < 0) {
        jsvStringIteratorNextUTF8(HEAP32[$6 + 44 >> 2]);
        HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 8;
        continue;
       }
       break;
      };
     }
     break block;
    }
    HEAP32[$6 + 36 >> 2] = 0 - Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] >> 2], Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2], HEAP32[$6 + 24 >> 2] - HEAP32[$6 + 52 >> 2] | 0));
   }
   HEAP32[$6 + 12 >> 2] = graphicsGetSetPixelUnclippedFn(HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2], HEAP32[$6 + 24 >> 2], (HEAP32[$6 + 56 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] >> 2] | 0) - 1 | 0, HEAP32[$6 + 16 >> 2], 1);
   HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 24 >> 2];
   while (1) {
    if (HEAP32[$6 + 8 >> 2] <= HEAP32[$6 + 16 >> 2]) {
     _jswrap_drawImageSimpleRow(HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2], HEAP32[$6 + 8 >> 2], HEAP32[$6 + 48 >> 2], HEAP32[$6 + 44 >> 2], HEAP32[$6 + 12 >> 2], $6 + 36 | 0, $6 + 32 | 0);
     HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 8 >> 2] + 1;
     continue;
    }
    break;
   };
   if (!(HEAP8[$6 + 43 | 0] & 1)) {
    break block
   }
   HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + (HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2] - Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] >> 2], Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2], HEAP32[$6 + 52 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] + 4 >> 2] - (HEAP32[$6 + 16 >> 2] + 1) | 0)) | 0);
   while (1) {
    if (HEAP32[$6 + 36 >> 2] < 0) {
     jsvStringIteratorNextUTF8(HEAP32[$6 + 44 >> 2]);
     HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 8;
     continue;
    }
    break;
   };
  }
  __stack_pointer = $6 - -64 | 0;
 }
 
 function jsvStringIteratorHasChar_1917($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 }
 
 function jswrap_graphics_idle() {
  graphicsIdle();
  return 0;
 }
 
 function jswrap_graphics_init() {
  HEAP8[416613] = 255;
  HEAP8[416614] = 255;
  HEAP8[416615] = 0;
  HEAP8[416616] = 0;
  HEAP8[416617] = 255;
  HEAP8[416618] = 255;
  HEAP8[416619] = 0;
  HEAP8[416620] = 0;
  HEAP8[416621] = 255;
  HEAP8[416622] = 255;
  HEAP8[416623] = 0;
  HEAP8[416624] = 0;
  HEAP8[416625] = 1;
 }
 
 function jswrap_graphics_getInstance() {
  return jsvObjectGetChildIfExists(HEAP32[103308], 3831) | 0;
 }
 
 function jswrap_graphics_createArrayBuffer($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 112 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 104 >> 2] = $0;
  HEAP32[$4 + 100 >> 2] = $1;
  HEAP32[$4 + 96 >> 2] = $2;
  HEAP32[$4 + 92 >> 2] = $3;
  block2 : {
   block1 : {
    if (!(HEAP32[$4 + 104 >> 2] <= 0 | HEAP32[$4 + 100 >> 2] <= 0 | HEAP32[$4 + 104 >> 2] > 32767)) {
     if (HEAP32[$4 + 100 >> 2] <= 32767) {
      break block1
     }
    }
    jsExceptionHere(1, 17242, 0);
    HEAP32[$4 + 108 >> 2] = 0;
    break block2;
   }
   if (!(isValidBPP(HEAP32[$4 + 96 >> 2]) & 1)) {
    jsExceptionHere(1, 21166, 0);
    HEAP32[$4 + 108 >> 2] = 0;
    break block2;
   }
   HEAP32[$4 + 88 >> 2] = jspNewObject(0, 7540);
   if (!HEAP32[$4 + 88 >> 2]) {
    HEAP32[$4 + 108 >> 2] = 0;
    break block2;
   }
   HEAP8[$4 + 20 | 0] = 0;
   HEAP8[$4 + 21 | 0] = 0;
   HEAP8[$4 + 22 | 0] = 0;
   HEAP8[$4 + 23 | 0] = 0;
   graphicsStructInit($4 + 16 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2], HEAP32[$4 + 96 >> 2]);
   HEAP8[$4 + 24 | 0] = 4;
   HEAP8[$4 + 25 | 0] = 0;
   HEAP8[$4 + 26 | 0] = 0;
   HEAP8[$4 + 27 | 0] = 0;
   $0 = HEAP32[$4 + 88 >> 2];
   HEAP8[$4 + 16 | 0] = $0;
   HEAP8[$4 + 17 | 0] = $0 >>> 8;
   HEAP8[$4 + 18 | 0] = $0 >>> 16;
   HEAP8[$4 + 19 | 0] = $0 >>> 24;
   HEAP32[$4 + 12 >> 2] = 0;
   if (jsvIsObject(HEAP32[$4 + 92 >> 2]) & 1) {
    if (jsvObjectGetBoolChild(HEAP32[$4 + 92 >> 2], 17031) & 1) {
     $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 1;
     HEAP8[$4 + 24 | 0] = $0;
     HEAP8[$4 + 25 | 0] = $0 >>> 8;
     HEAP8[$4 + 26 | 0] = $0 >>> 16;
     HEAP8[$4 + 27 | 0] = $0 >>> 24;
    }
    $0 = jsvObjectGetChildIfExists(HEAP32[$4 + 92 >> 2], 20471);
    HEAP32[$4 + 8 >> 2] = $0;
    if ($0) {
     if (!(jsvGetBoolAndUnLock(HEAP32[$4 + 8 >> 2]) & 1)) {
      $0 = (HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24)) & -5;
      HEAP8[$4 + 24 | 0] = $0;
      HEAP8[$4 + 25 | 0] = $0 >>> 8;
      HEAP8[$4 + 26 | 0] = $0 >>> 16;
      HEAP8[$4 + 27 | 0] = $0 >>> 24;
     }
    }
    if (jsvObjectGetBoolChild(HEAP32[$4 + 92 >> 2], 3835) & 1) {
     $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 8;
     HEAP8[$4 + 24 | 0] = $0;
     HEAP8[$4 + 25 | 0] = $0 >>> 8;
     HEAP8[$4 + 26 | 0] = $0 >>> 16;
     HEAP8[$4 + 27 | 0] = $0 >>> 24;
    }
    if (jsvObjectGetBoolChild(HEAP32[$4 + 92 >> 2], 17471) & 1) {
     block3 : {
      if (HEAPU8[$4 + 32 | 0] == 1) {
       $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 2;
       HEAP8[$4 + 24 | 0] = $0;
       HEAP8[$4 + 25 | 0] = $0 >>> 8;
       HEAP8[$4 + 26 | 0] = $0 >>> 16;
       HEAP8[$4 + 27 | 0] = $0 >>> 24;
       break block3;
      }
      jsExceptionHere(1, 7067, 0);
      HEAP32[$4 + 108 >> 2] = 0;
      break block2;
     }
     if ((HEAPU8[$4 + 30 | 0] | HEAPU8[$4 + 31 | 0] << 8) & 7) {
      jsExceptionHere(1, 17429, 0);
      HEAP32[$4 + 108 >> 2] = 0;
      break block2;
     }
    }
    HEAP32[$4 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 92 >> 2], 8294);
    if (HEAP32[$4 + 4 >> 2]) {
     if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 20488) & 1)) {
      block4 : {
       if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 16559) & 1)) {
        $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 128;
        HEAP8[$4 + 24 | 0] = $0;
        HEAP8[$4 + 25 | 0] = $0 >>> 8;
        HEAP8[$4 + 26 | 0] = $0 >>> 16;
        HEAP8[$4 + 27 | 0] = $0 >>> 24;
        break block4;
       }
       block5 : {
        if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 7904) & 1)) {
         $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 256;
         HEAP8[$4 + 24 | 0] = $0;
         HEAP8[$4 + 25 | 0] = $0 >>> 8;
         HEAP8[$4 + 26 | 0] = $0 >>> 16;
         HEAP8[$4 + 27 | 0] = $0 >>> 24;
         break block5;
        }
        block6 : {
         if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 8396) & 1)) {
          $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 384;
          HEAP8[$4 + 24 | 0] = $0;
          HEAP8[$4 + 25 | 0] = $0 >>> 8;
          HEAP8[$4 + 26 | 0] = $0 >>> 16;
          HEAP8[$4 + 27 | 0] = $0 >>> 24;
          break block6;
         }
         block7 : {
          if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 20479) & 1)) {
           $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 512;
           HEAP8[$4 + 24 | 0] = $0;
           HEAP8[$4 + 25 | 0] = $0 >>> 8;
           HEAP8[$4 + 26 | 0] = $0 >>> 16;
           HEAP8[$4 + 27 | 0] = $0 >>> 24;
           break block7;
          }
          block8 : {
           if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 17027) & 1)) {
            $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 640;
            HEAP8[$4 + 24 | 0] = $0;
            HEAP8[$4 + 25 | 0] = $0 >>> 8;
            HEAP8[$4 + 26 | 0] = $0 >>> 16;
            HEAP8[$4 + 27 | 0] = $0 >>> 24;
            break block8;
           }
           jsWarn(6985, 0);
          }
         }
        }
       }
      }
     }
     jsvUnLock(HEAP32[$4 + 4 >> 2]);
    }
    HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 92 >> 2], 8164);
    block9 : {
     if (!HEAP32[$4 + 12 >> 2]) {
      break block9
     }
     if (jsvIsArrayBuffer(HEAP32[$4 + 12 >> 2]) & 1) {
      break block9
     }
     HEAP32[$4 >> 2] = HEAP32[$4 + 12 >> 2];
     jsExceptionHere(1, 5773, $4);
     jsvUnLock(HEAP32[$4 + 12 >> 2]);
     HEAP32[$4 + 108 >> 2] = 0;
     break block2;
    }
   }
   lcdInit_ArrayBuffer($4 + 16 | 0, HEAP32[$4 + 12 >> 2]);
   jsvUnLock(HEAP32[$4 + 12 >> 2]);
   graphicsSetVarInitial($4 + 16 | 0);
   HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 88 >> 2];
  }
  __stack_pointer = $4 + 112 | 0;
  return HEAP32[$4 + 108 >> 2];
 }
 
 function isValidBPP($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = 1;
  block : {
   if (HEAP32[$1 + 12 >> 2] == 1) {
    break block
   }
   $0 = 1;
   if (HEAP32[$1 + 12 >> 2] == 2) {
    break block
   }
   $0 = 1;
   if (HEAP32[$1 + 12 >> 2] == 4) {
    break block
   }
   $0 = 1;
   if (HEAP32[$1 + 12 >> 2] == 8) {
    break block
   }
   $0 = 1;
   if (HEAP32[$1 + 12 >> 2] == 16) {
    break block
   }
   $0 = 1;
   if (HEAP32[$1 + 12 >> 2] == 24) {
    break block
   }
   $0 = HEAP32[$1 + 12 >> 2] == 32;
  }
  return $0;
 }
 
 function jswrap_graphics_createCallback($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 128 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 120 >> 2] = $0;
  HEAP32[$4 + 116 >> 2] = $1;
  HEAP32[$4 + 112 >> 2] = $2;
  HEAP32[$4 + 108 >> 2] = $3;
  block2 : {
   block1 : {
    if (!(HEAP32[$4 + 120 >> 2] <= 0 | HEAP32[$4 + 116 >> 2] <= 0 | HEAP32[$4 + 120 >> 2] > 32767)) {
     if (HEAP32[$4 + 116 >> 2] <= 32767) {
      break block1
     }
    }
    jsExceptionHere(1, 17242, 0);
    HEAP32[$4 + 124 >> 2] = 0;
    break block2;
   }
   if (!(isValidBPP(HEAP32[$4 + 112 >> 2]) & 1)) {
    jsExceptionHere(1, 21166, 0);
    HEAP32[$4 + 124 >> 2] = 0;
    break block2;
   }
   HEAP32[$4 + 104 >> 2] = 0;
   HEAP32[$4 + 100 >> 2] = 0;
   block3 : {
    if (jsvIsObject(HEAP32[$4 + 108 >> 2]) & 1) {
     jsvUnLock(HEAP32[$4 + 104 >> 2]);
     HEAP32[$4 + 104 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 108 >> 2], 15768);
     HEAP32[$4 + 100 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 108 >> 2], 5012);
     break block3;
    }
    HEAP32[$4 + 104 >> 2] = jsvLockAgain(HEAP32[$4 + 108 >> 2]);
   }
   if (!(jsvIsFunction(HEAP32[$4 + 104 >> 2]) & 1)) {
    HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 104 >> 2];
    jsExceptionHere(1, 5302, $4 + 16 | 0);
    jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
    HEAP32[$4 + 124 >> 2] = 0;
    break block2;
   }
   block4 : {
    if (jsvIsUndefined(HEAP32[$4 + 100 >> 2]) & 1) {
     break block4
    }
    if (jsvIsFunction(HEAP32[$4 + 100 >> 2]) & 1) {
     break block4
    }
    HEAP32[$4 >> 2] = HEAP32[$4 + 100 >> 2];
    jsExceptionHere(1, 5302, $4);
    jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
    HEAP32[$4 + 124 >> 2] = 0;
    break block2;
   }
   HEAP32[$4 + 96 >> 2] = jspNewObject(0, 7540);
   if (!HEAP32[$4 + 96 >> 2]) {
    HEAP32[$4 + 124 >> 2] = 0;
    break block2;
   }
   HEAP8[$4 + 28 | 0] = 1;
   HEAP8[$4 + 29 | 0] = 0;
   HEAP8[$4 + 30 | 0] = 0;
   HEAP8[$4 + 31 | 0] = 0;
   graphicsStructInit($4 + 24 | 0, HEAP32[$4 + 120 >> 2], HEAP32[$4 + 116 >> 2], HEAP32[$4 + 112 >> 2]);
   $0 = HEAP32[$4 + 96 >> 2];
   HEAP8[$4 + 24 | 0] = $0;
   HEAP8[$4 + 25 | 0] = $0 >>> 8;
   HEAP8[$4 + 26 | 0] = $0 >>> 16;
   HEAP8[$4 + 27 | 0] = $0 >>> 24;
   lcdInit_JS($4 + 24 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
   graphicsSetVarInitial($4 + 24 | 0);
   jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
   HEAP32[$4 + 124 >> 2] = HEAP32[$4 + 96 >> 2];
  }
  __stack_pointer = $4 + 128 | 0;
  return HEAP32[$4 + 124 >> 2];
 }
 
 function jswrap_graphics_createImage($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 88 >> 2] = $0;
  block : {
   if (!(jsvIsString(HEAP32[$1 + 88 >> 2]) & 1)) {
    jsExceptionHere(3, 16751, 0);
    HEAP32[$1 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 84 >> 2] = 0;
   HEAP32[$1 + 80 >> 2] = 0;
   HEAP32[$1 + 76 >> 2] = 0;
   HEAP32[$1 + 72 >> 2] = 0;
   HEAP32[$1 + 68 >> 2] = 0;
   jsvStringIteratorNew($1 + 28 | 0, HEAP32[$1 + 88 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1917($1 + 28 | 0) & 1) {
     HEAP8[$1 + 27 | 0] = jsvStringIteratorGetCharAndNext($1 + 28 | 0);
     block2 : {
      if (HEAPU8[$1 + 27 | 0] == 10) {
       if (!(HEAP32[$1 + 68 >> 2] | (HEAP32[$1 + 84 >> 2] | HEAP32[$1 + 80 >> 2]))) {
        HEAP32[$1 + 68 >> 2] = 1;
        break block2;
       }
       HEAP32[$1 + 84 >> 2] = 0;
       HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
       if (HEAP32[$1 + 72 >> 2] < (HEAP32[$1 + 80 >> 2] + 1 | 0)) {
        HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 80 >> 2] + 1
       }
       break block2;
      }
      HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
      if (HEAP32[$1 + 84 >> 2] > HEAP32[$1 + 76 >> 2]) {
       HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 84 >> 2]
      }
     }
     continue;
    }
    break;
   };
   if (!(!HEAP32[$1 + 72 >> 2] | HEAPU8[$1 + 27 | 0] != 10)) {
    HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 72 >> 2] - 1
   }
   jsvStringIteratorFree_1906($1 + 28 | 0);
   HEAP32[$1 + 20 >> 2] = jsvNewObject();
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 92 >> 2] = 0;
    break block;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 16247, jsvNewFromInteger(HEAP32[$1 + 76 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 4847, jsvNewFromInteger(HEAP32[$1 + 72 >> 2]));
   HEAP32[$1 + 16 >> 2] = Math_imul(HEAP32[$1 + 76 >> 2], HEAP32[$1 + 72 >> 2]) + 7 >> 3;
   HEAP32[$1 + 12 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 16 >> 2], 0);
   if (!HEAP32[$1 + 12 >> 2]) {
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 84 >> 2] = 0;
   HEAP32[$1 + 80 >> 2] = 0;
   jsvStringIteratorNew($1 + 28 | 0, HEAP32[$1 + 88 >> 2], HEAP32[$1 + 68 >> 2]);
   while (1) {
    if (jsvStringIteratorHasChar_1917($1 + 28 | 0) & 1) {
     HEAP8[$1 + 11 | 0] = jsvStringIteratorGetCharAndNext($1 + 28 | 0);
     block4 : {
      if (HEAPU8[$1 + 11 | 0] == 10) {
       HEAP32[$1 + 84 >> 2] = 0;
       HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
       break block4;
      }
      if (!(HEAPU8[$1 + 11 | 0] == 32 | HEAPU8[$1 + 11 | 0] == 46)) {
       HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 84 >> 2] + Math_imul(HEAP32[$1 + 80 >> 2], HEAP32[$1 + 76 >> 2]);
       jsvSetCharInString(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 4 >> 2] >>> 3 | 0, 128 >> (HEAP32[$1 + 4 >> 2] & 7) << 24 >> 24, 1);
      }
      HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1906($1 + 28 | 0);
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 8164, HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 20 >> 2];
  }
  __stack_pointer = $1 + 96 | 0;
  return HEAP32[$1 + 92 >> 2];
 }
 
 function jswrap_graphics_getWidthOrHeight($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP8[$2 + 87 | 0] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 15 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   block1 : {
    if (HEAP8[$2 + 87 | 0] & 1) {
     $0 = graphicsGetHeight($2 + 15 | 0) & 65535;
     break block1;
    }
    $0 = graphicsGetWidth($2 + 15 | 0) & 65535;
   }
   HEAP32[$2 + 92 >> 2] = $0;
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function jswrap_graphics_getBPP($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  block : {
   if (!(graphicsGetFromVar($1, HEAP32[$1 + 72 >> 2]) & 1)) {
    HEAP32[$1 + 76 >> 2] = 0;
    break block;
   }
   if ((HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24)) == 6) {
    HEAP32[$1 + 76 >> 2] = 3;
    break block;
   }
   HEAP32[$1 + 76 >> 2] = HEAPU8[$1 + 16 | 0];
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jswrap_graphics_reset($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 80 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 72 >> 2] = $0;
  block : {
   if (!(graphicsGetFromVar($1, HEAP32[$1 + 72 >> 2]) & 1)) {
    HEAP32[$1 + 76 >> 2] = 0;
    break block;
   }
   jsvUnLock(jswrap_graphics_setFontSizeX(HEAP32[$1 + 72 >> 2], 8193, 0));
   graphicsStructResetState($1);
   graphicsSetVar($1);
   HEAP32[$1 + 76 >> 2] = jswrap_graphics_setFontSizeX(HEAP32[$1 + 72 >> 2], 8193, 0);
  }
  __stack_pointer = $1 + 80 | 0;
  return HEAP32[$1 + 76 >> 2];
 }
 
 function jswrap_graphics_setFontSizeX($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP8[$3 + 83 | 0] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 11 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   if (HEAP8[$3 + 83 | 0] & 1) {
    if (HEAP32[$3 + 84 >> 2] <= 0) {
     HEAP32[$3 + 84 >> 2] = 1
    }
    if (HEAP32[$3 + 84 >> 2] > 8191) {
     HEAP32[$3 + 84 >> 2] = 8191
    }
   }
   if (!(!((HEAPU8[$3 + 36 | 0] | HEAPU8[$3 + 37 | 0] << 8) & 32768) | HEAP32[$3 + 84 >> 2] & 32768)) {
    jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 21591);
    jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 20960);
    jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 21465);
    jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 22439);
   }
   $0 = HEAP32[$3 + 84 >> 2];
   HEAP8[$3 + 36 | 0] = $0;
   HEAP8[$3 + 37 | 0] = $0 >>> 8;
   graphicsSetVar($3 + 11 | 0);
   HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_graphics_clear($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP8[$2 + 87 | 0] = $1;
  if (HEAP8[$2 + 87 | 0] & 1) {
   jsvUnLock(jswrap_graphics_reset(HEAP32[$2 + 88 >> 2]))
  }
  block : {
   if (!(graphicsGetFromVar($2 + 15 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   graphicsClear($2 + 15 | 0);
   graphicsSetVar($2 + 15 | 0);
   HEAP32[$2 + 92 >> 2] = jsvLockAgain(HEAP32[$2 + 88 >> 2]);
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function _jswrap_graphics_getRect($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 144 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 140 >> 2] = $0;
  HEAP32[$6 + 136 >> 2] = $1;
  HEAP32[$6 + 132 >> 2] = $2;
  HEAP32[$6 + 128 >> 2] = $3;
  HEAP32[$6 + 124 >> 2] = $4;
  HEAP32[$6 + 120 >> 2] = $5;
  HEAP32[HEAP32[$6 + 120 >> 2] >> 2] = 0;
  block : {
   if (jsvIsObject(HEAP32[$6 + 140 >> 2]) & 1) {
    HEAP32[$6 + 116 >> 2] = -1;
    HEAP32[$6 + 112 >> 2] = -1;
    HEAP32[$6 >> 2] = 3934;
    HEAP16[$6 + 4 >> 1] = 10;
    HEAP16[$6 + 6 >> 1] = 0;
    HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 136 >> 2];
    HEAP32[$6 + 12 >> 2] = 3805;
    HEAP16[$6 + 16 >> 1] = 10;
    HEAP16[$6 + 18 >> 1] = 0;
    HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 132 >> 2];
    HEAP32[$6 + 24 >> 2] = 22436;
    HEAP16[$6 + 28 >> 1] = 10;
    HEAP16[$6 + 30 >> 1] = 0;
    HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 136 >> 2];
    HEAP32[$6 + 36 >> 2] = 22433;
    HEAP16[$6 + 40 >> 1] = 10;
    HEAP16[$6 + 42 >> 1] = 0;
    HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 132 >> 2];
    HEAP32[$6 + 48 >> 2] = 22356;
    HEAP16[$6 + 52 >> 1] = 10;
    HEAP16[$6 + 54 >> 1] = 0;
    HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 128 >> 2];
    HEAP32[$6 + 60 >> 2] = 22353;
    HEAP16[$6 + 64 >> 1] = 10;
    HEAP16[$6 + 66 >> 1] = 0;
    HEAP32[$6 + 68 >> 2] = HEAP32[$6 + 124 >> 2];
    HEAP32[$6 + 72 >> 2] = 4131;
    HEAP16[$6 + 76 >> 1] = 10;
    HEAP16[$6 + 78 >> 1] = 0;
    HEAP32[$6 + 80 >> 2] = $6 + 116;
    HEAP32[$6 + 84 >> 2] = 16557;
    HEAP16[$6 + 88 >> 1] = 10;
    HEAP16[$6 + 90 >> 1] = 0;
    HEAP32[$6 + 92 >> 2] = $6 + 112;
    HEAP32[$6 + 96 >> 2] = 14628;
    HEAP16[$6 + 100 >> 1] = 10;
    HEAP16[$6 + 102 >> 1] = 0;
    HEAP32[$6 + 104 >> 2] = HEAP32[$6 + 120 >> 2];
    jsvReadConfigObject(HEAP32[$6 + 140 >> 2], $6, 9);
    if (HEAP32[$6 + 116 >> 2] >= 0) {
     HEAP32[HEAP32[$6 + 128 >> 2] >> 2] = HEAP32[HEAP32[$6 + 136 >> 2] >> 2] + HEAP32[$6 + 116 >> 2]
    }
    if (HEAP32[$6 + 112 >> 2] >= 0) {
     HEAP32[HEAP32[$6 + 124 >> 2] >> 2] = HEAP32[HEAP32[$6 + 132 >> 2] >> 2] + HEAP32[$6 + 112 >> 2]
    }
    break block;
   }
   $0 = jsvGetInteger(HEAP32[$6 + 140 >> 2]);
   HEAP32[HEAP32[$6 + 136 >> 2] >> 2] = $0;
  }
  __stack_pointer = $6 + 144 | 0;
 }
 
 function jswrap_graphics_fillRect($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 28 >> 2] = $0;
  HEAP32[$5 + 24 >> 2] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  $0 = _jswrap_graphics_fillRect_col(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], 1);
  __stack_pointer = $5 + 32 | 0;
  return $0 | 0;
 }
 
 function _jswrap_graphics_fillRect_col($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 160 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 152 >> 2] = $0;
  HEAP32[$6 + 148 >> 2] = $1;
  HEAP32[$6 + 144 >> 2] = $2;
  HEAP32[$6 + 140 >> 2] = $3;
  HEAP32[$6 + 136 >> 2] = $4;
  HEAP8[$6 + 135 | 0] = $5;
  _jswrap_graphics_getRect(HEAP32[$6 + 148 >> 2], $6 + 128 | 0, $6 + 144 | 0, $6 + 140 | 0, $6 + 136 | 0, $6 + 124 | 0);
  block : {
   if (!(graphicsGetFromVar($6 + 52 | 0, HEAP32[$6 + 152 >> 2]) & 1)) {
    HEAP32[$6 + 156 >> 2] = 0;
    break block;
   }
   if (HEAP8[$6 + 135 | 0] & 1) {
    $0 = HEAPU8[$6 + 69 | 0] | HEAPU8[$6 + 70 | 0] << 8 | (HEAPU8[$6 + 71 | 0] << 16 | HEAPU8[$6 + 72 | 0] << 24)
   } else {
    $0 = HEAPU8[$6 + 73 | 0] | HEAPU8[$6 + 74 | 0] << 8 | (HEAPU8[$6 + 75 | 0] << 16 | HEAPU8[$6 + 76 | 0] << 24)
   }
   HEAP32[$6 + 48 >> 2] = $0;
   block2 : {
    if (HEAP32[$6 + 124 >> 2] > 0) {
     _jswrap_graphics_roundedRect_helper($6 + 52 | 0, $6 + 128 | 0, $6 + 144 | 0, $6 + 140 | 0, $6 + 136 | 0, $6 + 124 | 0);
     HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 128 >> 2] + HEAP32[$6 + 124 >> 2];
     HEAP32[$6 + 40 >> 2] = HEAP32[$6 + 140 >> 2] - HEAP32[$6 + 124 >> 2];
     HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 144 >> 2] + HEAP32[$6 + 124 >> 2];
     HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 136 >> 2] - HEAP32[$6 + 124 >> 2];
     graphicsFillRectDevice($6 + 52 | 0, HEAP32[$6 + 128 >> 2], HEAP32[$6 + 36 >> 2], HEAP32[$6 + 140 >> 2], HEAP32[$6 + 32 >> 2], HEAP32[$6 + 48 >> 2]);
     HEAP32[$6 + 28 >> 2] = 0;
     HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 124 >> 2];
     HEAP32[$6 + 20 >> 2] = Math_imul(HEAP32[$6 + 124 >> 2], HEAP32[$6 + 124 >> 2]);
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2] - Math_imul(HEAP32[$6 + 20 >> 2], (HEAP32[$6 + 124 >> 2] << 1) - 1 | 0);
     HEAP8[$6 + 11 | 0] = 0;
     while (1) {
      HEAP8[$6 + 11 | 0] = 0;
      HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 16 >> 2] << 1;
      if (HEAP32[$6 + 12 >> 2] < (Math_imul(HEAP32[$6 + 20 >> 2], (HEAP32[$6 + 28 >> 2] << 1) + 1 | 0) | 0)) {
       HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
       HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + Math_imul(HEAP32[$6 + 20 >> 2], (HEAP32[$6 + 28 >> 2] << 1) + 1 | 0);
       HEAP8[$6 + 11 | 0] = 1;
      }
      if (HEAP32[$6 + 12 >> 2] > (Math_imul(HEAP32[$6 + 20 >> 2], 1 - (HEAP32[$6 + 24 >> 2] << 1) | 0) | 0)) {
       graphicsFillRectDevice($6 + 52 | 0, HEAP32[$6 + 44 >> 2] - HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 32 >> 2] + HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 40 >> 2] + HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 32 >> 2] + HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 48 >> 2]);
       graphicsFillRectDevice($6 + 52 | 0, HEAP32[$6 + 44 >> 2] - HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 36 >> 2] - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 40 >> 2] + HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 36 >> 2] - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 48 >> 2]);
       HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 24 >> 2] - 1;
       HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] - Math_imul(HEAP32[$6 + 20 >> 2], (HEAP32[$6 + 24 >> 2] << 1) - 1 | 0);
       HEAP8[$6 + 11 | 0] = 1;
      }
      $0 = 0;
      $0 = HEAP8[$6 + 11 | 0] & 1 ? HEAP32[$6 + 24 >> 2] >= 0 : $0;
      if ($0) {
       continue
      }
      break;
     };
     break block2;
    }
    graphicsFillRect($6 + 52 | 0, HEAP32[$6 + 128 >> 2], HEAP32[$6 + 144 >> 2], HEAP32[$6 + 140 >> 2], HEAP32[$6 + 136 >> 2], HEAP32[$6 + 48 >> 2]);
   }
   graphicsSetVar($6 + 52 | 0);
   HEAP32[$6 + 156 >> 2] = jsvLockAgain(HEAP32[$6 + 152 >> 2]);
  }
  __stack_pointer = $6 + 160 | 0;
  return HEAP32[$6 + 156 >> 2];
 }
 
 function _jswrap_graphics_roundedRect_helper($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 32 | 0;
  __stack_pointer = $6;
  HEAP32[$6 + 28 >> 2] = $0;
  HEAP32[$6 + 24 >> 2] = $1;
  HEAP32[$6 + 20 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 12 >> 2] = $4;
  HEAP32[$6 + 8 >> 2] = $5;
  graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2]);
  graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2]);
  if (HEAP32[HEAP32[$6 + 24 >> 2] >> 2] > HEAP32[HEAP32[$6 + 16 >> 2] >> 2]) {
   HEAP32[$6 + 4 >> 2] = HEAP32[HEAP32[$6 + 24 >> 2] >> 2];
   HEAP32[HEAP32[$6 + 24 >> 2] >> 2] = HEAP32[HEAP32[$6 + 16 >> 2] >> 2];
   HEAP32[HEAP32[$6 + 16 >> 2] >> 2] = HEAP32[$6 + 4 >> 2];
  }
  if (HEAP32[HEAP32[$6 + 20 >> 2] >> 2] > HEAP32[HEAP32[$6 + 12 >> 2] >> 2]) {
   HEAP32[$6 >> 2] = HEAP32[HEAP32[$6 + 20 >> 2] >> 2];
   HEAP32[HEAP32[$6 + 20 >> 2] >> 2] = HEAP32[HEAP32[$6 + 12 >> 2] >> 2];
   HEAP32[HEAP32[$6 + 12 >> 2] >> 2] = HEAP32[$6 >> 2];
  }
  HEAP32[$6 + 4 >> 2] = (HEAP32[HEAP32[$6 + 16 >> 2] >> 2] - HEAP32[HEAP32[$6 + 24 >> 2] >> 2] | 0) / 2;
  HEAP32[$6 >> 2] = (HEAP32[HEAP32[$6 + 12 >> 2] >> 2] - HEAP32[HEAP32[$6 + 20 >> 2] >> 2] | 0) / 2;
  if (HEAP32[$6 + 4 >> 2] < HEAP32[HEAP32[$6 + 8 >> 2] >> 2]) {
   HEAP32[HEAP32[$6 + 8 >> 2] >> 2] = HEAP32[$6 + 4 >> 2]
  }
  if (HEAP32[$6 >> 2] < HEAP32[HEAP32[$6 + 8 >> 2] >> 2]) {
   HEAP32[HEAP32[$6 + 8 >> 2] >> 2] = HEAP32[$6 >> 2]
  }
  __stack_pointer = $6 + 32 | 0;
 }
 
 function jswrap_graphics_clearRect($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 32 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 28 >> 2] = $0;
  HEAP32[$5 + 24 >> 2] = $1;
  HEAP32[$5 + 20 >> 2] = $2;
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  $0 = _jswrap_graphics_fillRect_col(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], 0);
  __stack_pointer = $5 + 32 | 0;
  return $0 | 0;
 }
 
 function jswrap_graphics_drawRect($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 128 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 120 >> 2] = $0;
  HEAP32[$5 + 116 >> 2] = $1;
  HEAP32[$5 + 112 >> 2] = $2;
  HEAP32[$5 + 108 >> 2] = $3;
  HEAP32[$5 + 104 >> 2] = $4;
  _jswrap_graphics_getRect(HEAP32[$5 + 116 >> 2], $5 + 100 | 0, $5 + 112 | 0, $5 + 108 | 0, $5 + 104 | 0, $5 + 96 | 0);
  block : {
   if (!(graphicsGetFromVar($5 + 24 | 0, HEAP32[$5 + 120 >> 2]) & 1)) {
    HEAP32[$5 + 124 >> 2] = 0;
    break block;
   }
   block1 : {
    if (HEAP32[$5 + 96 >> 2] > 0) {
     _jswrap_graphics_roundedRect_helper($5 + 24 | 0, $5 + 100 | 0, $5 + 112 | 0, $5 + 108 | 0, $5 + 104 | 0, $5 + 96 | 0);
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 100 >> 2] + HEAP32[$5 + 96 >> 2];
     HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 96 >> 2];
     HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 96 >> 2];
     HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 104 >> 2] - HEAP32[$5 + 96 >> 2];
     HEAP32[$5 + 4 >> 2] = HEAPU8[$5 + 41 | 0] | HEAPU8[$5 + 42 | 0] << 8 | (HEAPU8[$5 + 43 | 0] << 16 | HEAPU8[$5 + 44 | 0] << 24);
     graphicsFillRectDevice($5 + 24 | 0, HEAP32[$5 + 20 >> 2], HEAP32[$5 + 112 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 112 >> 2], HEAP32[$5 + 4 >> 2]);
     graphicsFillRectDevice($5 + 24 | 0, HEAP32[$5 + 20 >> 2], HEAP32[$5 + 104 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 104 >> 2], HEAP32[$5 + 4 >> 2]);
     graphicsFillRectDevice($5 + 24 | 0, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 4 >> 2]);
     graphicsFillRectDevice($5 + 24 | 0, HEAP32[$5 + 108 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 108 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 4 >> 2]);
     graphicsDrawEllipseInternal($5 + 24 | 0, HEAP32[$5 + 20 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 96 >> 2]);
     break block1;
    }
    graphicsDrawRect($5 + 24 | 0, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 112 >> 2], HEAP32[$5 + 108 >> 2], HEAP32[$5 + 104 >> 2]);
   }
   graphicsSetVar($5 + 24 | 0);
   HEAP32[$5 + 124 >> 2] = jsvLockAgain(HEAP32[$5 + 120 >> 2]);
  }
  __stack_pointer = $5 + 128 | 0;
  return HEAP32[$5 + 124 >> 2];
 }
 
 function jswrap_graphics_fillCircle($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = jswrap_graphics_fillEllipse(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 8 >> 2] + HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
  __stack_pointer = $4 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_graphics_fillEllipse($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 88 >> 2] = $0;
  HEAP32[$5 + 84 >> 2] = $1;
  HEAP32[$5 + 80 >> 2] = $2;
  HEAP32[$5 + 76 >> 2] = $3;
  HEAP32[$5 + 72 >> 2] = $4;
  block : {
   if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
    HEAP32[$5 + 92 >> 2] = 0;
    break block;
   }
   graphicsFillEllipse($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
   graphicsSetVar($5);
   HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
  }
  __stack_pointer = $5 + 96 | 0;
  return HEAP32[$5 + 92 >> 2];
 }
 
 function jswrap_graphics_drawCircle($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = jswrap_graphics_drawEllipse(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 8 >> 2] + HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
  __stack_pointer = $4 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_graphics_drawEllipse($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 88 >> 2] = $0;
  HEAP32[$5 + 84 >> 2] = $1;
  HEAP32[$5 + 80 >> 2] = $2;
  HEAP32[$5 + 76 >> 2] = $3;
  HEAP32[$5 + 72 >> 2] = $4;
  block : {
   if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
    HEAP32[$5 + 92 >> 2] = 0;
    break block;
   }
   graphicsDrawEllipse($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
   graphicsSetVar($5);
   HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
  }
  __stack_pointer = $5 + 96 | 0;
  return HEAP32[$5 + 92 >> 2];
 }
 
 function jswrap_graphics_drawCircleAA($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 88 >> 2] = $0;
  HEAP32[$4 + 84 >> 2] = $1;
  HEAP32[$4 + 80 >> 2] = $2;
  HEAP32[$4 + 76 >> 2] = $3;
  block : {
   if (!(graphicsGetFromVar($4 + 4 | 0, HEAP32[$4 + 88 >> 2]) & 1)) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   graphicsDrawCircleAA($4 + 4 | 0, HEAP32[$4 + 84 >> 2], HEAP32[$4 + 80 >> 2], HEAP32[$4 + 76 >> 2]);
   graphicsSetVar($4 + 4 | 0);
   HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
  }
  __stack_pointer = $4 + 96 | 0;
  return HEAP32[$4 + 92 >> 2];
 }
 
 function jswrap_graphics_getPixel($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 92 >> 2] = graphicsGetPixel($3 + 8 | 0, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_graphics_setPixel($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 88 >> 2] = $0;
  HEAP32[$4 + 84 >> 2] = $1;
  HEAP32[$4 + 80 >> 2] = $2;
  HEAP32[$4 + 76 >> 2] = $3;
  block : {
   if (!(graphicsGetFromVar($4 + 4 | 0, HEAP32[$4 + 88 >> 2]) & 1)) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$4 >> 2] = HEAPU8[$4 + 21 | 0] | HEAPU8[$4 + 22 | 0] << 8 | (HEAPU8[$4 + 23 | 0] << 16 | HEAPU8[$4 + 24 | 0] << 24);
   if (!(jsvIsUndefined(HEAP32[$4 + 76 >> 2]) & 1)) {
    HEAP32[$4 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 76 >> 2], 0, 0)
   }
   graphicsSetPixel($4 + 4 | 0, HEAP32[$4 + 84 >> 2], HEAP32[$4 + 80 >> 2], HEAP32[$4 >> 2]);
   $0 = HEAP32[$4 + 84 >> 2];
   HEAP8[$4 + 31 | 0] = $0;
   HEAP8[$4 + 32 | 0] = $0 >>> 8;
   $0 = HEAP32[$4 + 80 >> 2];
   HEAP8[$4 + 33 | 0] = $0;
   HEAP8[$4 + 34 | 0] = $0 >>> 8;
   graphicsSetVar($4 + 4 | 0);
   HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
  }
  __stack_pointer = $4 + 96 | 0;
  return HEAP32[$4 + 92 >> 2];
 }
 
 function jswrap_graphics_toColor($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0.0;
  $4 = __stack_pointer - 288 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 280 >> 2] = $0;
  HEAP32[$4 + 276 >> 2] = $1;
  HEAP32[$4 + 272 >> 2] = $2;
  HEAP32[$4 + 268 >> 2] = $3;
  block : {
   if (!(graphicsGetFromVar($4 + 196 | 0, HEAP32[$4 + 280 >> 2]) & 1)) {
    HEAP32[$4 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 192 >> 2] = 0;
   block4 : {
    if (jsvIsString(HEAP32[$4 + 276 >> 2]) & 1) {
     $1 = $4 + 159 | 0;
     HEAP8[$1 | 0] = 0;
     HEAP8[$1 + 1 | 0] = 0;
     HEAP8[$1 + 2 | 0] = 0;
     HEAP8[$1 + 3 | 0] = 0;
     HEAP8[$1 + 4 | 0] = 0;
     HEAP8[$1 + 5 | 0] = 0;
     HEAP8[$1 + 6 | 0] = 0;
     HEAP8[$1 + 7 | 0] = 0;
     HEAP8[$1 + 8 | 0] = 0;
     jsvGetString(HEAP32[$4 + 276 >> 2], $4 + 159 | 0, 9);
     block1 : {
      if (!HEAPU8[$4 + 163 | 0]) {
       HEAPF64[$4 + 184 >> 3] = +(chtod(HEAP8[$4 + 160 | 0] << 24 >> 24) | 0) / 15.0;
       HEAPF64[$4 + 176 >> 3] = +(chtod(HEAP8[$4 + 161 | 0] << 24 >> 24) | 0) / 15.0;
       HEAPF64[$4 + 168 >> 3] = +(chtod(HEAP8[$4 + 162 | 0] << 24 >> 24) | 0) / 15.0;
       break block1;
      }
      HEAPF64[$4 + 184 >> 3] = +(hexToByte(HEAP8[$4 + 160 | 0] << 24 >> 24, HEAP8[$4 + 161 | 0] << 24 >> 24) | 0) / 255.0;
      HEAPF64[$4 + 176 >> 3] = +(hexToByte(HEAP8[$4 + 162 | 0] << 24 >> 24, HEAP8[$4 + 163 | 0] << 24 >> 24) | 0) / 255.0;
      HEAPF64[$4 + 168 >> 3] = +(hexToByte(HEAP8[$4 + 164 | 0] << 24 >> 24, HEAP8[$4 + 165 | 0] << 24 >> 24) | 0) / 255.0;
     }
     block3 : {
      if (!(HEAPF64[$4 + 184 >> 3] < 0.0 | HEAPF64[$4 + 176 >> 3] < 0.0 | HEAPF64[$4 + 168 >> 3] < 0.0)) {
       if (!HEAPU8[$4 + 166 | 0]) {
        break block3
       }
      }
      jsExceptionHere(1, 27237, 0);
      HEAP32[$4 + 284 >> 2] = 0;
      break block;
     }
     break block4;
    }
    HEAPF64[$4 + 184 >> 3] = jsvGetFloat(HEAP32[$4 + 276 >> 2]);
    HEAPF64[$4 + 176 >> 3] = jsvGetFloat(HEAP32[$4 + 272 >> 2]);
    HEAPF64[$4 + 168 >> 3] = jsvGetFloat(HEAP32[$4 + 268 >> 2]);
   }
   $1 = __DOUBLE_BITS_1945(HEAPF64[$4 + 184 >> 3]);
   $0 = $1;
   $1 = i64toi32_i32$HIGH_BITS;
   $1 = $1 & 2147483647;
   block16 : {
    block5 : {
     if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
      break block5
     }
     $1 = __DOUBLE_BITS_1945(HEAPF64[$4 + 176 >> 3]);
     $0 = $1;
     $1 = i64toi32_i32$HIGH_BITS;
     $1 = $1 & 2147483647;
     if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
      break block5
     }
     $1 = __DOUBLE_BITS_1945(HEAPF64[$4 + 168 >> 3]);
     $0 = $1;
     $1 = i64toi32_i32$HIGH_BITS;
     $1 = $1 & 2147483647;
     if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
      break block5
     }
     $5 = HEAPF64[$4 + 184 >> 3] * 256.0;
     if (Math_abs($5) < 2147483647.0) {
      $0 = ~~$5
     } else {
      $0 = -2147483648
     }
     HEAP32[$4 + 152 >> 2] = $0;
     $5 = HEAPF64[$4 + 176 >> 3] * 256.0;
     if (Math_abs($5) < 2147483647.0) {
      $0 = ~~$5
     } else {
      $0 = -2147483648
     }
     HEAP32[$4 + 148 >> 2] = $0;
     $5 = HEAPF64[$4 + 168 >> 3] * 256.0;
     if (Math_abs($5) < 2147483647.0) {
      $0 = ~~$5
     } else {
      $0 = -2147483648
     }
     HEAP32[$4 + 144 >> 2] = $0;
     if (HEAP32[$4 + 152 >> 2] > 255) {
      HEAP32[$4 + 152 >> 2] = 255
     }
     if (HEAP32[$4 + 148 >> 2] > 255) {
      HEAP32[$4 + 148 >> 2] = 255
     }
     if (HEAP32[$4 + 144 >> 2] > 255) {
      HEAP32[$4 + 144 >> 2] = 255
     }
     if (HEAP32[$4 + 152 >> 2] < 0) {
      HEAP32[$4 + 152 >> 2] = 0
     }
     if (HEAP32[$4 + 148 >> 2] < 0) {
      HEAP32[$4 + 148 >> 2] = 0
     }
     if (HEAP32[$4 + 144 >> 2] < 0) {
      HEAP32[$4 + 144 >> 2] = 0
     }
     HEAP32[$4 + 140 >> 2] = (HEAPU8[$4 + 204 | 0] | HEAPU8[$4 + 205 | 0] << 8 | (HEAPU8[$4 + 206 | 0] << 16 | HEAPU8[$4 + 207 | 0] << 24)) & 896;
     if (HEAP32[$4 + 140 >> 2]) {
      HEAP32[$4 + 136 >> 2] = HEAP32[$4 + 152 >> 2];
      HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 148 >> 2];
      HEAP32[$4 + 128 >> 2] = HEAP32[$4 + 144 >> 2];
      block10 : {
       block9 : {
        block8 : {
         block7 : {
          block6 : {
           $0 = HEAP32[$4 + 140 >> 2];
           if (($0 | 0) != 128) {
            if (($0 | 0) == 256) {
             break block6
            }
            if (($0 | 0) == 384) {
             break block7
            }
            if (($0 | 0) == 512) {
             break block8
            }
            if (($0 | 0) == 640) {
             break block9
            }
            break block10;
           }
           HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 128 >> 2];
           HEAP32[$4 + 148 >> 2] = HEAP32[$4 + 136 >> 2];
           HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 132 >> 2];
           break block10;
          }
          HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 128 >> 2];
          HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 136 >> 2];
          break block10;
         }
         HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 132 >> 2];
         HEAP32[$4 + 148 >> 2] = HEAP32[$4 + 128 >> 2];
         HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 136 >> 2];
         break block10;
        }
        HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 132 >> 2];
        HEAP32[$4 + 148 >> 2] = HEAP32[$4 + 136 >> 2];
        break block10;
       }
       HEAP32[$4 + 148 >> 2] = HEAP32[$4 + 128 >> 2];
       HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 132 >> 2];
      }
     }
     block11 : {
      if (HEAPU8[$4 + 212 | 0] == 16) {
       HEAP32[$4 + 192 >> 2] = HEAP32[$4 + 148 >> 2] >> 2 << 5 | HEAP32[$4 + 144 >> 2] >> 3 | HEAP32[$4 + 152 >> 2] >> 3 << 11;
       break block11;
      }
      block12 : {
       if (HEAPU8[$4 + 212 | 0] == 32) {
        HEAP32[$4 + 192 >> 2] = HEAP32[$4 + 144 >> 2] | HEAP32[$4 + 148 >> 2] << 8 | HEAP32[$4 + 152 >> 2] << 16 | -16777216;
        break block12;
       }
       block13 : {
        if (HEAPU8[$4 + 212 | 0] == 24) {
         HEAP32[$4 + 192 >> 2] = HEAP32[$4 + 144 >> 2] | HEAP32[$4 + 148 >> 2] << 8 | HEAP32[$4 + 152 >> 2] << 16;
         break block13;
        }
        block14 : {
         if (HEAPU8[$4 + 212 | 0] == 4) {
          HEAP32[$4 + 124 >> 2] = 2147483647;
          HEAP32[$4 + 192 >> 2] = 0;
          HEAP32[$4 + 120 >> 2] = 0;
          while (1) {
           if (HEAPU32[$4 + 120 >> 2] < 16) {
            HEAP32[$4 + 116 >> 2] = HEAPU16[(HEAP32[$4 + 120 >> 2] << 1) + 234352 >> 1];
            HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 116 >> 2] >> 8 & 248;
            HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 116 >> 2] >> 3 & 252;
            HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 116 >> 2] << 3 & 248;
            HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 112 >> 2] | HEAP32[$4 + 112 >> 2] >> 5;
            HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 108 >> 2] | HEAP32[$4 + 104 >> 2] >> 6;
            HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] | HEAP32[$4 + 104 >> 2] >> 5;
            HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 112 >> 2] - HEAP32[$4 + 152 >> 2];
            HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 108 >> 2] - HEAP32[$4 + 148 >> 2];
            HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 104 >> 2] - HEAP32[$4 + 144 >> 2];
            HEAP32[$4 + 88 >> 2] = (Math_imul(HEAP32[$4 + 100 >> 2], HEAP32[$4 + 100 >> 2]) + Math_imul(HEAP32[$4 + 96 >> 2], HEAP32[$4 + 96 >> 2]) | 0) + Math_imul(HEAP32[$4 + 92 >> 2], HEAP32[$4 + 92 >> 2]);
            if (HEAP32[$4 + 88 >> 2] < HEAP32[$4 + 124 >> 2]) {
             HEAP32[$4 + 124 >> 2] = HEAP32[$4 + 88 >> 2];
             HEAP32[$4 + 192 >> 2] = HEAP32[$4 + 120 >> 2];
            }
            HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 120 >> 2] + 1;
            continue;
           }
           break;
          };
          break block14;
         }
         block15 : {
          if (HEAPU8[$4 + 212 | 0] == 8) {
           HEAP32[$4 + 84 >> 2] = 2147483647;
           HEAP32[$4 + 192 >> 2] = 0;
           HEAP32[$4 + 80 >> 2] = 0;
           while (1) {
            if (HEAP32[$4 + 80 >> 2] < 255) {
             HEAP32[$4 + 76 >> 2] = HEAPU16[(HEAP32[$4 + 80 >> 2] << 1) + 234384 >> 1];
             HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 76 >> 2] >> 8 & 248;
             HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 76 >> 2] >> 3 & 252;
             HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 76 >> 2] << 3 & 248;
             HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 72 >> 2] | HEAP32[$4 + 72 >> 2] >> 5;
             HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 68 >> 2] | HEAP32[$4 + 64 >> 2] >> 6;
             HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] | HEAP32[$4 + 64 >> 2] >> 5;
             HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 152 >> 2];
             HEAP32[$4 + 56 >> 2] = HEAP32[$4 + 68 >> 2] - HEAP32[$4 + 148 >> 2];
             HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 64 >> 2] - HEAP32[$4 + 144 >> 2];
             HEAP32[$4 + 48 >> 2] = (Math_imul(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 60 >> 2]) + Math_imul(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 56 >> 2]) | 0) + Math_imul(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 52 >> 2]);
             if (HEAP32[$4 + 48 >> 2] < HEAP32[$4 + 84 >> 2]) {
              HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 48 >> 2];
              HEAP32[$4 + 192 >> 2] = HEAP32[$4 + 80 >> 2];
             }
             HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + 1;
             continue;
            }
            break;
           };
           break block15;
          }
          HEAP32[$4 + 192 >> 2] = (HEAP32[$4 + 144 >> 2] + (HEAP32[$4 + 152 >> 2] + HEAP32[$4 + 148 >> 2] | 0) | 0) >= 384 ? -1 : 0;
         }
        }
       }
      }
     }
     break block16;
    }
    HEAP32[$4 + 192 >> 2] = jsvGetInteger(HEAP32[$4 + 276 >> 2]) & (1 << HEAPU8[$4 + 212 | 0]) - 1;
   }
   HEAP32[$4 + 284 >> 2] = HEAP32[$4 + 192 >> 2];
  }
  __stack_pointer = $4 + 288 | 0;
  return HEAP32[$4 + 284 >> 2];
 }
 
 function __DOUBLE_BITS_1945($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
  i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
  return HEAP32[$1 >> 2];
 }
 
 function jswrap_graphics_blendColor($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0.0;
  $4 = __stack_pointer - 112 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 104 >> 2] = $0;
  HEAP32[$4 + 100 >> 2] = $1;
  HEAP32[$4 + 96 >> 2] = $2;
  HEAP32[$4 + 92 >> 2] = $3;
  block : {
   if (!(graphicsGetFromVar($4 + 20 | 0, HEAP32[$4 + 104 >> 2]) & 1)) {
    HEAP32[$4 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 16 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2], 0, 0);
   HEAP32[$4 + 12 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 96 >> 2], 0, 0);
   $1 = $4 + 20 | 0;
   $2 = HEAP32[$4 + 12 >> 2];
   $3 = HEAP32[$4 + 16 >> 2];
   $5 = jsvGetFloat(HEAP32[$4 + 92 >> 2]) * 256.0;
   if (Math_abs($5) < 2147483647.0) {
    $0 = ~~$5
   } else {
    $0 = -2147483648
   }
   HEAP32[$4 + 108 >> 2] = graphicsBlendColor($1, $2, $3, $0);
  }
  __stack_pointer = $4 + 112 | 0;
  return HEAP32[$4 + 108 >> 2];
 }
 
 function jswrap_graphics_setColorX($0, $1, $2, $3, $4) {
  var $5 = 0;
  $5 = __stack_pointer - 112 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 104 >> 2] = $0;
  HEAP32[$5 + 100 >> 2] = $1;
  HEAP32[$5 + 96 >> 2] = $2;
  HEAP32[$5 + 92 >> 2] = $3;
  HEAP8[$5 + 91 | 0] = $4;
  block : {
   if (!(graphicsGetFromVar($5 + 19 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$5 + 12 >> 2] = jswrap_graphics_toColor(HEAP32[$5 + 104 >> 2], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 92 >> 2]);
   block1 : {
    if (HEAP8[$5 + 91 | 0] & 1) {
     $0 = HEAP32[$5 + 12 >> 2];
     HEAP8[$5 + 36 | 0] = $0;
     HEAP8[$5 + 37 | 0] = $0 >>> 8;
     HEAP8[$5 + 38 | 0] = $0 >>> 16;
     HEAP8[$5 + 39 | 0] = $0 >>> 24;
     break block1;
    }
    $0 = HEAP32[$5 + 12 >> 2];
    HEAP8[$5 + 40 | 0] = $0;
    HEAP8[$5 + 41 | 0] = $0 >>> 8;
    HEAP8[$5 + 42 | 0] = $0 >>> 16;
    HEAP8[$5 + 43 | 0] = $0 >>> 24;
   }
   graphicsSetVar($5 + 19 | 0);
   HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
  }
  __stack_pointer = $5 + 112 | 0;
  return HEAP32[$5 + 108 >> 2];
 }
 
 function jswrap_graphics_getColorX($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP8[$2 + 87 | 0] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 15 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   if (HEAP8[$2 + 87 | 0] & 1) {
    $0 = HEAPU8[$2 + 32 | 0] | HEAPU8[$2 + 33 | 0] << 8 | (HEAPU8[$2 + 34 | 0] << 16 | HEAPU8[$2 + 35 | 0] << 24)
   } else {
    $0 = HEAPU8[$2 + 36 | 0] | HEAPU8[$2 + 37 | 0] << 8 | (HEAPU8[$2 + 38 | 0] << 16 | HEAPU8[$2 + 39 | 0] << 24)
   }
   HEAP32[$2 + 92 >> 2] = $0 & (1 << HEAPU8[$2 + 31 | 0]) - 1;
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function jswrap_graphics_setClipRect($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 112 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 104 >> 2] = $0;
  HEAP32[$5 + 100 >> 2] = $1;
  HEAP32[$5 + 96 >> 2] = $2;
  HEAP32[$5 + 92 >> 2] = $3;
  HEAP32[$5 + 88 >> 2] = $4;
  block : {
   if (!(graphicsGetFromVar($5 + 16 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   graphicsToDeviceCoordinates($5 + 16 | 0, $5 + 100 | 0, $5 + 96 | 0);
   graphicsToDeviceCoordinates($5 + 16 | 0, $5 + 92 | 0, $5 + 88 | 0);
   if (HEAP32[$5 + 100 >> 2] < 0) {
    HEAP32[$5 + 100 >> 2] = 0
   }
   if (HEAP32[$5 + 96 >> 2] < 0) {
    HEAP32[$5 + 96 >> 2] = 0
   }
   if (HEAP32[$5 + 92 >> 2] < 0) {
    HEAP32[$5 + 92 >> 2] = 0
   }
   if (HEAP32[$5 + 88 >> 2] < 0) {
    HEAP32[$5 + 88 >> 2] = 0
   }
   if (HEAP32[$5 + 100 >> 2] >= (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8)) {
    HEAP32[$5 + 100 >> 2] = (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8) - 1
   }
   if (HEAP32[$5 + 96 >> 2] >= (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8)) {
    HEAP32[$5 + 96 >> 2] = (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8) - 1
   }
   if (HEAP32[$5 + 92 >> 2] >= (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8)) {
    HEAP32[$5 + 92 >> 2] = (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8) - 1
   }
   if (HEAP32[$5 + 88 >> 2] >= (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8)) {
    HEAP32[$5 + 88 >> 2] = (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8) - 1
   }
   if (HEAP32[$5 + 100 >> 2] > HEAP32[$5 + 92 >> 2]) {
    HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 100 >> 2];
    HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 92 >> 2];
    HEAP32[$5 + 92 >> 2] = HEAP32[$5 + 12 >> 2];
   }
   if (HEAP32[$5 + 96 >> 2] > HEAP32[$5 + 88 >> 2]) {
    HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 96 >> 2];
    HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 88 >> 2];
    HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 8 >> 2];
   }
   $0 = HEAP32[$5 + 100 >> 2];
   HEAP8[$5 + 48 | 0] = $0;
   HEAP8[$5 + 49 | 0] = $0 >>> 8;
   $0 = HEAP32[$5 + 96 >> 2];
   HEAP8[$5 + 50 | 0] = $0;
   HEAP8[$5 + 51 | 0] = $0 >>> 8;
   $0 = HEAP32[$5 + 92 >> 2];
   HEAP8[$5 + 52 | 0] = $0;
   HEAP8[$5 + 53 | 0] = $0 >>> 8;
   $0 = HEAP32[$5 + 88 >> 2];
   HEAP8[$5 + 54 | 0] = $0;
   HEAP8[$5 + 55 | 0] = $0 >>> 8;
   graphicsSetVar($5 + 16 | 0);
   HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
  }
  __stack_pointer = $5 + 112 | 0;
  return HEAP32[$5 + 108 >> 2];
 }
 
 function jswrap_graphics_setFontCustom($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 112 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 104 >> 2] = $0;
  HEAP32[$5 + 100 >> 2] = $1;
  HEAP32[$5 + 96 >> 2] = $2;
  HEAP32[$5 + 92 >> 2] = $3;
  HEAP32[$5 + 88 >> 2] = $4;
  block : {
   if (!(graphicsGetFromVar($5 + 16 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   if (!(jsvIsString(HEAP32[$5 + 100 >> 2]) & 1)) {
    jsExceptionHere(1, 16867, 0);
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   if (!(HEAP32[$5 + 96 >> 2] <= 255 & HEAP32[$5 + 96 >> 2] >= 0)) {
    jsExceptionHere(1, 18053, 0);
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   block2 : {
    if (jsvIsString(HEAP32[$5 + 92 >> 2]) & 1) {
     break block2
    }
    if (jsvIsInt(HEAP32[$5 + 92 >> 2]) & 1) {
     break block2
    }
    jsExceptionHere(1, 8103, 0);
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 88 >> 2] >> 8 & 255;
   if (HEAP32[$5 + 12 >> 2] <= 0) {
    HEAP32[$5 + 12 >> 2] = 1
   }
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 88 >> 2] >> 16;
   if (HEAP32[$5 + 8 >> 2] <= 0) {
    HEAP32[$5 + 8 >> 2] = 1
   }
   block3 : {
    if (HEAP32[$5 + 8 >> 2] == 1) {
     HEAP32[$5 + 4 >> 2] = 32768;
     break block3;
    }
    block4 : {
     if (HEAP32[$5 + 8 >> 2] == 2) {
      HEAP32[$5 + 4 >> 2] = 40960;
      break block4;
     }
     block5 : {
      if (HEAP32[$5 + 8 >> 2] == 4) {
       HEAP32[$5 + 4 >> 2] = 49152;
       break block5;
      }
      jsExceptionHere(1, 18880, 0);
      HEAP32[$5 + 108 >> 2] = 0;
      break block;
     }
    }
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] & 255;
   jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 21591, HEAP32[$5 + 100 >> 2]);
   jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 20960, HEAP32[$5 + 92 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$5 + 104 >> 2], 21465, jsvNewFromInteger(HEAP32[$5 + 88 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$5 + 104 >> 2], 22439, jsvNewFromInteger(HEAP32[$5 + 96 >> 2]));
   $0 = HEAP32[$5 + 12 >> 2] + HEAP32[$5 + 4 >> 2] | 0;
   HEAP8[$5 + 41 | 0] = $0;
   HEAP8[$5 + 42 | 0] = $0 >>> 8;
   graphicsSetVar($5 + 16 | 0);
   HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
  }
  __stack_pointer = $5 + 112 | 0;
  return HEAP32[$5 + 108 >> 2];
 }
 
 function jswrap_graphics_setFontPBF($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   if (!(jsvIsString(HEAP32[$3 + 84 >> 2]) & 1)) {
    jsExceptionHere(1, 16845, 0);
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   if (HEAP32[$3 + 80 >> 2] <= 0) {
    HEAP32[$3 + 80 >> 2] = 1
   }
   jsvObjectSetChild(HEAP32[$3 + 88 >> 2], 21591, HEAP32[$3 + 84 >> 2]);
   $0 = HEAP32[$3 + 80 >> 2] | 57344;
   HEAP8[$3 + 33 | 0] = $0;
   HEAP8[$3 + 34 | 0] = $0 >>> 8;
   graphicsSetVar($3 + 8 | 0);
   HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_graphics_setFontAlign($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 96 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 88 >> 2] = $0;
  HEAP32[$4 + 84 >> 2] = $1;
  HEAP32[$4 + 80 >> 2] = $2;
  HEAP32[$4 + 76 >> 2] = $3;
  block : {
   if (!(graphicsGetFromVar($4 + 4 | 0, HEAP32[$4 + 88 >> 2]) & 1)) {
    HEAP32[$4 + 92 >> 2] = 0;
    break block;
   }
   if (HEAP32[$4 + 84 >> 2] < -1) {
    HEAP32[$4 + 84 >> 2] = -1
   }
   if (HEAP32[$4 + 84 >> 2] > 1) {
    HEAP32[$4 + 84 >> 2] = 1
   }
   if (HEAP32[$4 + 80 >> 2] < -1) {
    HEAP32[$4 + 80 >> 2] = -1
   }
   if (HEAP32[$4 + 80 >> 2] > 1) {
    HEAP32[$4 + 80 >> 2] = 1
   }
   if (HEAP32[$4 + 76 >> 2] < 0) {
    HEAP32[$4 + 76 >> 2] = 0
   }
   if (HEAP32[$4 + 76 >> 2] > 3) {
    HEAP32[$4 + 76 >> 2] = 3
   }
   HEAP8[$4 + 35 | 0] = HEAPU8[$4 + 84 | 0] & 3 | HEAPU8[$4 + 35 | 0] & 252;
   HEAP8[$4 + 35 | 0] = HEAPU8[$4 + 35 | 0] & 243 | (HEAPU8[$4 + 80 | 0] & 3) << 2;
   HEAP8[$4 + 35 | 0] = HEAPU8[$4 + 35 | 0] & -49 | (HEAPU8[$4 + 76 | 0] & 3) << 4;
   graphicsSetVar($4 + 4 | 0);
   HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
  }
  __stack_pointer = $4 + 96 | 0;
  return HEAP32[$4 + 92 >> 2];
 }
 
 function jswrap_graphics_setFont($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 160 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 152 >> 2] = $0;
  HEAP32[$3 + 148 >> 2] = $1;
  HEAP32[$3 + 144 >> 2] = $2;
  block : {
   if (!(jsvIsString(HEAP32[$3 + 148 >> 2]) & 1)) {
    HEAP32[$3 + 156 >> 2] = 0;
    break block;
   }
   HEAP8[$3 + 143 | 0] = 0;
   HEAP32[$3 + 136 >> 2] = -1;
   if (jsvIsStringEqualOrStartsWith(HEAP32[$3 + 148 >> 2], 7809, 1) & 1) {
    if (jsvGetStringLength(HEAP32[$3 + 148 >> 2]) >>> 0 > 6) {
     HEAP32[$3 + 136 >> 2] = 6
    }
    HEAP8[$3 + 143 | 0] = 1;
   }
   HEAP32[$3 + 132 >> 2] = jsvGetStringIndexOf(HEAP32[$3 + 148 >> 2], 58);
   if (HEAP32[$3 + 132 >> 2] >= 0) {
    HEAP32[$3 + 136 >> 2] = HEAP32[$3 + 132 >> 2] + 1
   }
   block3 : {
    if (HEAP32[$3 + 136 >> 2] >= 0) {
     HEAP32[$3 + 124 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 148 >> 2], HEAP32[$3 + 136 >> 2], 2147483647);
     HEAP32[$3 + 120 >> 2] = jsvGetStringIndexOf(HEAP32[$3 + 124 >> 2], 120);
     block1 : {
      if (HEAP32[$3 + 120 >> 2] >= 0) {
       HEAP32[$3 + 116 >> 2] = jsvGetIntegerAndUnLock(jsvNewFromStringVar(HEAP32[$3 + 124 >> 2], 0, HEAP32[$3 + 120 >> 2]));
       HEAP32[$3 + 112 >> 2] = jsvGetIntegerAndUnLock(jsvNewFromStringVar(HEAP32[$3 + 124 >> 2], HEAP32[$3 + 120 >> 2] + 1 | 0, 2147483647));
       if (HEAP32[$3 + 116 >> 2] < 0) {
        HEAP32[$3 + 116 >> 2] = 0
       }
       if (HEAP32[$3 + 112 >> 2] < 0) {
        HEAP32[$3 + 112 >> 2] = 0
       }
       if (HEAP32[$3 + 116 >> 2] > 63) {
        HEAP32[$3 + 116 >> 2] = 63
       }
       if (HEAP32[$3 + 112 >> 2] > 63) {
        HEAP32[$3 + 112 >> 2] = 63
       }
       HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 116 >> 2] | HEAP32[$3 + 112 >> 2] << 6 | 4096;
       break block1;
      }
      HEAP32[$3 + 144 >> 2] = jsvGetInteger(HEAP32[$3 + 124 >> 2]);
     }
     jsvUnLock(HEAP32[$3 + 124 >> 2]);
     $1 = HEAP32[$3 + 148 >> 2];
     if (HEAP32[$3 + 136 >> 2] > 0) {
      $0 = HEAP32[$3 + 136 >> 2] - 1 | 0
     } else {
      $0 = 0
     }
     HEAP32[$3 + 128 >> 2] = jsvNewFromStringVar($1, 0, $0);
     break block3;
    }
    HEAP32[$3 + 128 >> 2] = jsvLockAgain(HEAP32[$3 + 148 >> 2]);
   }
   if (HEAP32[$3 + 144 >> 2] <= 0) {
    HEAP32[$3 + 144 >> 2] = 1
   }
   if (HEAP32[$3 + 144 >> 2] > 8191) {
    HEAP32[$3 + 144 >> 2] = 8191
   }
   HEAP16[$3 + 110 >> 1] = 65535;
   block4 : {
    if (HEAP8[$3 + 143 | 0] & 1) {
     HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2];
     break block4;
    }
    block6 : {
     block5 : {
      if (jsvIsUndefined(HEAP32[$3 + 128 >> 2]) & 1) {
       break block5
      }
      if (jsvIsEmptyString(HEAP32[$3 + 128 >> 2]) & 1) {
       break block5
      }
      if (!(jsvIsStringEqual(HEAP32[$3 + 128 >> 2], 22267) & 1)) {
       break block6
      }
     }
     HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2] - -8192;
    }
   }
   if (jsvIsStringEqual(HEAP32[$3 + 128 >> 2], 22241) & 1) {
    HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2] + 16384
   }
   if (HEAPU16[$3 + 110 >> 1] == 65535) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 128 >> 2];
    HEAP32[$3 + 104 >> 2] = jsvVarPrintf(4151, $3 + 16 | 0);
    HEAP32[$3 + 100 >> 2] = jspGetVarNamedField(HEAP32[$3 + 152 >> 2], HEAP32[$3 + 104 >> 2], 0);
    if (HEAP32[$3 + 100 >> 2]) {
     jsvUnLock(jspExecuteFunction(HEAP32[$3 + 100 >> 2], HEAP32[$3 + 152 >> 2], 0, 0));
     graphicsGetFromVar($3 + 28 | 0, HEAP32[$3 + 152 >> 2]);
     HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2] | (HEAPU8[$3 + 53 | 0] | HEAPU8[$3 + 54 | 0] << 8) & 57344;
    }
    jsvUnLock2(HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
   }
   if (HEAPU16[$3 + 110 >> 1] == 65535) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 128 >> 2];
    jsExceptionHere(1, 16110, $3);
   }
   jsvUnLock(HEAP32[$3 + 128 >> 2]);
   HEAP32[$3 + 156 >> 2] = jswrap_graphics_setFontSizeX(HEAP32[$3 + 152 >> 2], HEAPU16[$3 + 110 >> 1], HEAP8[$3 + 143 | 0] & 1);
  }
  __stack_pointer = $3 + 160 | 0;
  return HEAP32[$3 + 156 >> 2];
 }
 
 function jswrap_graphics_getFont($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 128 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 120 >> 2] = $0;
  block : {
   if (!(graphicsGetFromVar($1 + 48 | 0, HEAP32[$1 + 120 >> 2]) & 1)) {
    HEAP32[$1 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 44 >> 2] = (HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8) & 57344;
   HEAP32[$1 + 40 >> 2] = 0;
   if (!HEAP32[$1 + 44 >> 2]) {
    HEAP32[$1 + 40 >> 2] = 7809
   }
   if (HEAP32[$1 + 44 >> 2] == 8192) {
    HEAP32[$1 + 40 >> 2] = 22267
   }
   if (HEAP32[$1 + 44 >> 2] == 16384) {
    HEAP32[$1 + 40 >> 2] = 22241
   }
   if (HEAP32[$1 + 44 >> 2] & 32768) {
    HEAP32[$1 + 40 >> 2] = 15700
   }
   if (HEAP32[$1 + 40 >> 2]) {
    HEAP32[$1 + 36 >> 2] = (HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8) & 8191;
    if (HEAP32[$1 + 36 >> 2] & 4096) {
     $0 = HEAP32[$1 + 40 >> 2];
     $2 = HEAP32[$1 + 36 >> 2];
     HEAP32[$1 + 8 >> 2] = (HEAP32[$1 + 36 >> 2] & 4032) >>> 6;
     HEAP32[$1 + 4 >> 2] = $2 & 63;
     HEAP32[$1 >> 2] = $0;
     HEAP32[$1 + 124 >> 2] = jsvVarPrintf(19660, $1);
     break block;
    }
    if (HEAP32[$1 + 36 >> 2] > 1) {
     $0 = HEAP32[$1 + 40 >> 2];
     HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 36 >> 2];
     HEAP32[$1 + 16 >> 2] = $0;
     HEAP32[$1 + 124 >> 2] = jsvVarPrintf(19669, $1 + 16 | 0);
     break block;
    }
    HEAP32[$1 + 124 >> 2] = jsvNewFromString(HEAP32[$1 + 40 >> 2]);
    break block;
   }
   HEAP32[$1 + 124 >> 2] = jsvNewFromInteger(HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8);
  }
  __stack_pointer = $1 + 128 | 0;
  return HEAP32[$1 + 124 >> 2];
 }
 
 function jswrap_graphics_getFonts_callback($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
  block : {
   if (jsvGetStringLength(HEAP32[$2 + 8 >> 2]) >>> 0 <= 7) {
    break block
   }
   if (!(jsvIsStringEqualOrStartsWith(HEAP32[$2 + 8 >> 2], 4604, 1) & 1)) {
    break block
   }
   if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 15039) & 1) {
    break block
   }
   if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 15541) & 1) {
    break block
   }
   if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 21517) & 1) {
    break block
   }
   if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 15693) & 1) {
    break block
   }
   HEAP32[$2 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 8 >> 2], 7, 2147483647);
   jsvArrayPush(HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]);
   jsvUnLock(HEAP32[$2 >> 2]);
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_graphics_getFonts($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 96 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 88 >> 2] = $0;
  block : {
   if (!(graphicsGetFromVar($1 + 16 | 0, HEAP32[$1 + 88 >> 2]) & 1)) {
    HEAP32[$1 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 12 >> 2] = jsvNewEmptyArray();
   if (!HEAP32[$1 + 12 >> 2]) {
    HEAP32[$1 + 92 >> 2] = 0;
    break block;
   }
   jsvArrayPushString(HEAP32[$1 + 12 >> 2], 22267);
   jsvArrayPushString(HEAP32[$1 + 12 >> 2], 22241);
   jswrap_object_keys_or_property_names_cb(HEAP32[$1 + 88 >> 2], 3, 676, HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 12 >> 2];
  }
  __stack_pointer = $1 + 96 | 0;
  return HEAP32[$1 + 92 >> 2];
 }
 
 function jswrap_graphics_getFontHeight($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 176 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 168 >> 2] = $0;
  block : {
   if (!(graphicsGetFromVar($1 + 96 | 0, HEAP32[$1 + 168 >> 2]) & 1)) {
    HEAP32[$1 + 172 >> 2] = 0;
    break block;
   }
   _jswrap_graphics_getFontInfo($1 + 96 | 0, $1 + 8 | 0);
   HEAP32[$1 + 4 >> 2] = _jswrap_graphics_getFontHeightInternal($1 + 96 | 0, $1 + 8 | 0);
   _jswrap_graphics_freeFontInfo($1 + 8 | 0);
   HEAP32[$1 + 172 >> 2] = HEAP32[$1 + 4 >> 2];
  }
  __stack_pointer = $1 + 176 | 0;
  return HEAP32[$1 + 172 >> 2];
 }
 
 function _jswrap_graphics_getFontInfo($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[HEAP32[$2 + 8 >> 2] >> 2] = (HEAPU8[$0 + 25 | 0] | HEAPU8[$0 + 26 | 0] << 8) & 57344;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP16[HEAP32[$2 + 8 >> 2] + 4 >> 1] = (HEAPU8[$0 + 25 | 0] | HEAPU8[$0 + 26 | 0] << 8) & 8191;
  HEAP16[HEAP32[$2 + 8 >> 2] + 6 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1];
  HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1];
  if (HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 4096) {
   HEAP16[HEAP32[$2 + 8 >> 2] + 6 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 63;
   HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = (HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 4032) >>> 6;
  }
  block : {
   if (HEAP32[HEAP32[$2 + 8 >> 2] >> 2] & 32768) {
    $0 = HEAP32[$2 + 12 >> 2];
    $0 = jsvGetIntegerAndUnLock(jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 22439));
    HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = $0;
    $0 = HEAP32[$2 + 12 >> 2];
    $0 = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 20960);
    HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2] = $0;
    $0 = HEAP32[$2 + 12 >> 2];
    $0 = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 21591);
    HEAP32[HEAP32[$2 + 8 >> 2] + 16 >> 2] = $0;
    if ((HEAP32[HEAP32[$2 + 8 >> 2] >> 2] & 57344) == 57344) {
     jspbfFontNew(HEAP32[$2 + 8 >> 2] + 20 | 0, HEAP32[HEAP32[$2 + 8 >> 2] + 16 >> 2])
    }
    break block;
   }
   HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 0;
  }
  __stack_pointer = $2 + 16 | 0;
 }
 
 function _jswrap_graphics_getFontHeightInternal($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  block : {
   if (!HEAP32[HEAP32[$2 + 4 >> 2] >> 2]) {
    HEAP32[$2 + 12 >> 2] = HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1];
    break block;
   }
   if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] == 8192) {
    HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1], 6);
    break block;
   }
   if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] == 16384) {
    HEAP32[$2 + 12 >> 2] = HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1] << 3;
    break block;
   }
   if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] & 32768) {
    if ((HEAP32[HEAP32[$2 + 4 >> 2] >> 2] & 57344) == 57344) {
     HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1], HEAPU8[HEAP32[$2 + 4 >> 2] + 65 | 0]);
     break block;
    }
    $0 = HEAP32[$2 + 8 >> 2];
    HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1], jsvGetIntegerAndUnLock(jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 21465)));
    break block;
   }
   HEAP32[$2 + 12 >> 2] = 0;
  }
  __stack_pointer = $2 + 16 | 0;
  return HEAP32[$2 + 12 >> 2];
 }
 
 function _jswrap_graphics_freeFontInfo($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  if (HEAP32[HEAP32[$1 + 12 >> 2] >> 2] & 32768) {
   jsvUnLock2(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2], HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2]);
   if ((HEAP32[HEAP32[$1 + 12 >> 2] >> 2] & 57344) == 57344) {
    jspbfFontFree(HEAP32[$1 + 12 >> 2] + 20 | 0)
   }
  }
  __stack_pointer = $1 + 16 | 0;
 }
 
 function _jswrap_graphics_stringMetrics($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 272 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 268 >> 2] = $0;
  HEAP32[$4 + 264 >> 2] = $1;
  HEAP32[$4 + 260 >> 2] = $2;
  HEAP32[$4 + 256 >> 2] = $3;
  _jswrap_graphics_getFontInfo(HEAP32[$4 + 268 >> 2], $4 + 168 | 0);
  $0 = HEAP32[$4 + 256 >> 2];
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$4 + 164 >> 2] = _jswrap_graphics_getFontHeightInternal(HEAP32[$4 + 268 >> 2], $4 + 168 | 0);
  HEAP32[HEAP32[$4 + 256 >> 2] + 8 >> 2] = HEAP32[$4 + 164 >> 2];
  HEAP32[$4 + 160 >> 2] = jsvAsString(HEAP32[$4 + 264 >> 2]);
  jsvStringIteratorNewUTF8($4 + 120 | 0, HEAP32[$4 + 160 >> 2], HEAP32[$4 + 260 >> 2] >= 0 ? HEAP32[$4 + 260 >> 2] : 0);
  HEAP32[$4 + 116 >> 2] = 0;
  HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 164 >> 2];
  HEAP32[$4 + 108 >> 2] = 0;
  while (1) {
   block : {
    if (!(jsvStringIteratorHasChar_1917($4 + 120 | 0) & 1)) {
     break block
    }
    HEAP32[$4 + 104 >> 2] = jsvStringIteratorGetUTF8CharAndNext($4 + 120 | 0);
    block1 : {
     if (HEAP32[$4 + 104 >> 2] == 10) {
      if (HEAP32[$4 + 116 >> 2] > HEAP32[$4 + 108 >> 2]) {
       HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 116 >> 2]
      }
      HEAP32[$4 + 116 >> 2] = 0;
      HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 164 >> 2] + HEAP32[$4 + 112 >> 2];
      if (HEAP32[$4 + 260 >> 2] >= 0) {
       break block
      }
      break block1;
     }
     block2 : {
      if (!HEAP32[$4 + 104 >> 2]) {
       $0 = HEAP32[$4 + 256 >> 2];
       HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
       HEAP32[$4 + 16 >> 2] = jsvConvertToUTF8Index(HEAP32[$4 + 160 >> 2], jsvStringIteratorGetIndex_1962($4 + 120 | 0));
       if (_jswrap_graphics_parseImage(HEAP32[$4 + 268 >> 2], HEAP32[$4 + 160 >> 2], HEAP32[$4 + 16 >> 2], $4 + 20 | 0) & 1) {
        jsvStringIteratorGotoUTF8($4 + 120 | 0, HEAP32[$4 + 160 >> 2], HEAPU16[$4 + 70 >> 1] + (HEAP32[$4 + 16 >> 2] + HEAPU16[$4 + 68 >> 1] | 0) | 0);
        _jswrap_graphics_freeImageInfo($4 + 20 | 0);
        HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 20 >> 2] + HEAP32[$4 + 116 >> 2];
        if (HEAP32[$4 + 24 >> 2] > HEAP32[HEAP32[$4 + 256 >> 2] + 20 >> 2]) {
         HEAP32[HEAP32[$4 + 256 >> 2] + 20 >> 2] = HEAP32[$4 + 24 >> 2]
        }
       }
       break block2;
      }
      HEAP32[$4 + 12 >> 2] = _jswrap_graphics_getCharWidth($4 + 168 | 0, HEAP32[$4 + 104 >> 2]);
      HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 12 >> 2] + HEAP32[$4 + 116 >> 2];
      if (!HEAP32[$4 + 12 >> 2]) {
       HEAP8[HEAP32[$4 + 256 >> 2] + 12 | 0] = 1
      }
     }
    }
    continue;
   }
   break;
  };
  jsvStringIteratorFree_1906($4 + 120 | 0);
  jsvUnLock(HEAP32[$4 + 160 >> 2]);
  $1 = HEAP32[$4 + 256 >> 2];
  if (HEAP32[$4 + 116 >> 2] > HEAP32[$4 + 108 >> 2]) {
   $0 = HEAP32[$4 + 116 >> 2]
  } else {
   $0 = HEAP32[$4 + 108 >> 2]
  }
  HEAP32[$1 >> 2] = $0;
  HEAP32[HEAP32[$4 + 256 >> 2] + 4 >> 2] = HEAP32[$4 + 112 >> 2];
  _jswrap_graphics_freeFontInfo($4 + 168 | 0);
  __stack_pointer = $4 + 272 | 0;
 }
 
 function jsvStringIteratorGetIndex_1962($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
 }
 
 function _jswrap_graphics_getCharWidth($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 32 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  block1 : {
   if (!(HEAP32[HEAP32[$2 + 24 >> 2] >> 2] | HEAP32[$2 + 20 >> 2] >= 256)) {
    HEAP32[$2 + 28 >> 2] = graphicsVectorCharWidth(HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1], HEAP32[$2 + 20 >> 2] << 24 >> 24);
    break block1;
   }
   if (!(HEAP32[HEAP32[$2 + 24 >> 2] >> 2] != 8192 | HEAP32[$2 + 20 >> 2] >= 256)) {
    HEAP32[$2 + 28 >> 2] = HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1] << 2;
    break block1;
   }
   if (!(HEAP32[HEAP32[$2 + 24 >> 2] >> 2] != 16384 | HEAP32[$2 + 20 >> 2] >= 256)) {
    HEAP32[$2 + 28 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1], 6);
    break block1;
   }
   if (HEAP32[HEAP32[$2 + 24 >> 2] >> 2] & 32768) {
    if ((HEAP32[HEAP32[$2 + 24 >> 2] >> 2] & 57344) == 57344) {
     if (jspbfFontFindGlyph(HEAP32[$2 + 24 >> 2] + 20 | 0, HEAP32[$2 + 20 >> 2], $2 + 14 | 0) & 1) {
      HEAP32[$2 + 28 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1], HEAP8[$2 + 18 | 0] << 24 >> 24);
      break block1;
     }
     HEAP32[$2 + 28 >> 2] = 0;
     break block1;
    }
    HEAP32[$2 + 8 >> 2] = 0;
    if (HEAP32[$2 + 20 >> 2] < 256) {
     block4 : {
      if (jsvIsString(HEAP32[HEAP32[$2 + 24 >> 2] + 12 >> 2]) & 1) {
       if (HEAP32[$2 + 20 >> 2] >= HEAPU8[HEAP32[$2 + 24 >> 2] + 10 | 0]) {
        HEAP32[$2 + 8 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1], jsvGetCharInString(HEAP32[HEAP32[$2 + 24 >> 2] + 12 >> 2], HEAP32[$2 + 20 >> 2] - HEAPU8[HEAP32[$2 + 24 >> 2] + 10 | 0] | 0) & 255)
       }
       break block4;
      }
      HEAP32[$2 + 8 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1], jsvGetInteger(HEAP32[HEAP32[$2 + 24 >> 2] + 12 >> 2]));
     }
    }
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
    break block1;
   }
   HEAP32[$2 + 28 >> 2] = 0;
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function _jswrap_graphics_stringWidth($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 48 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 44 >> 2] = $0;
  HEAP32[$3 + 40 >> 2] = $1;
  HEAP32[$3 + 36 >> 2] = $2;
  _jswrap_graphics_stringMetrics(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2], $3 + 12 | 0);
  __stack_pointer = $3 + 48 | 0;
  return HEAP32[$3 + 12 >> 2];
 }
 
 function jswrap_graphics_stringWidth($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP32[$2 + 84 >> 2] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 12 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 92 >> 2] = _jswrap_graphics_stringWidth($2 + 12 | 0, HEAP32[$2 + 84 >> 2], -1);
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function jswrap_graphics_stringMetrics($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 112 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 104 >> 2] = $0;
  HEAP32[$2 + 100 >> 2] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 28 | 0, HEAP32[$2 + 104 >> 2]) & 1)) {
    HEAP32[$2 + 108 >> 2] = 0;
    break block;
   }
   HEAP32[$2 >> 2] = jsvNewObject();
   if (HEAP32[$2 >> 2]) {
    _jswrap_graphics_stringMetrics($2 + 28 | 0, HEAP32[$2 + 100 >> 2], -1, $2 + 4 | 0);
    jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 16247, jsvNewFromInteger(HEAP32[$2 + 4 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 4847, jsvNewFromInteger(HEAP32[$2 + 8 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 7114, jsvNewFromBool(HEAP8[$2 + 16 | 0] & 1));
    jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 4582, jsvNewFromInteger(HEAP32[$2 + 20 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 4854, jsvNewFromInteger(HEAP32[$2 + 24 >> 2]));
   }
   HEAP32[$2 + 108 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 112 | 0;
  return HEAP32[$2 + 108 >> 2];
 }
 
 function jswrap_graphics_wrapString($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 400 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 392 >> 2] = $0;
  HEAP32[$3 + 388 >> 2] = $1;
  HEAP32[$3 + 384 >> 2] = $2;
  block : {
   if (!HEAP32[$3 + 388 >> 2]) {
    HEAP32[$3 + 396 >> 2] = jsvNewEmptyArray();
    break block;
   }
   if (HEAP32[$3 + 384 >> 2] <= 0) {
    HEAP32[$3 + 396 >> 2] = 0;
    break block;
   }
   if (!(graphicsGetFromVar($3 + 312 | 0, HEAP32[$3 + 392 >> 2]) & 1)) {
    HEAP32[$3 + 396 >> 2] = 0;
    break block;
   }
   _jswrap_graphics_getFontInfo($3 + 312 | 0, $3 + 224 | 0);
   HEAP32[$3 + 388 >> 2] = jsvAsString(HEAP32[$3 + 388 >> 2]);
   HEAP32[$3 + 220 >> 2] = jsvNewEmptyArray();
   HEAP32[$3 + 216 >> 2] = jsvNewFromEmptyString_1968();
   if (jsvIsUTF8String(HEAP32[$3 + 388 >> 2]) & 1) {
    HEAP32[$3 + 216 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$3 + 216 >> 2])
   }
   HEAP32[$3 + 212 >> 2] = _jswrap_graphics_getCharWidth($3 + 224 | 0, 32);
   HEAP32[$3 + 208 >> 2] = 0;
   HEAP32[$3 + 204 >> 2] = 0;
   HEAP8[$3 + 203 | 0] = 0;
   HEAP8[$3 + 202 | 0] = 0;
   HEAP32[$3 + 196 >> 2] = 0;
   HEAP8[$3 + 195 | 0] = 0;
   HEAP8[$3 + 194 | 0] = 0;
   jsvStringIteratorNewUTF8($3 + 152 | 0, HEAP32[$3 + 388 >> 2], 0);
   while (1) {
    block2 : {
     block1 : {
      if (!(jsvStringIteratorHasChar_1917($3 + 152 | 0) & 1)) {
       $0 = 0;
       if (!(HEAP8[$3 + 195 | 0] & 1)) {
        break block1
       }
      }
      $0 = jspIsInterrupted() ^ -1;
     }
     if (!($0 & 1)) {
      break block2
     }
     HEAP32[$3 + 148 >> 2] = jsvStringIteratorGetUTF8CharAndNext($3 + 152 | 0);
     $0 = 1;
     block3 : {
      if (HEAP8[$3 + 195 | 0] & 1) {
       break block3
      }
      $0 = 1;
      if (HEAP32[$3 + 148 >> 2] == 10) {
       break block3
      }
      $0 = HEAP32[$3 + 148 >> 2] == 32;
     }
     HEAP8[$3 + 147 | 0] = $0;
     if (HEAP8[$3 + 147 | 0] & 1 | HEAP8[$3 + 203 | 0] & 1) {
      HEAP32[$3 + 140 >> 2] = jsvStringIteratorGetIndex_1962($3 + 152 | 0);
      block8 : {
       if (!(HEAP8[$3 + 194 | 0] & 1 | HEAP32[$3 + 384 >> 2] < (HEAP32[$3 + 208 >> 2] + (HEAP32[$3 + 204 >> 2] + HEAP32[$3 + 212 >> 2] | 0) | 0))) {
        block7 : {
         if (!(!HEAPU8[$3 + 202 | 0] | !HEAP32[$3 + 204 >> 2] & HEAPU8[$3 + 202 | 0] == 32)) {
          jsvAppendCharacter_1969(HEAP32[$3 + 216 >> 2], HEAP8[$3 + 202 | 0] << 24 >> 24);
          HEAP32[$3 + 204 >> 2] = HEAP32[$3 + 212 >> 2] + HEAP32[$3 + 204 >> 2];
          break block7;
         }
         if (HEAP8[$3 + 203 | 0] & 1) {
          HEAP32[$3 + 208 >> 2] = _jswrap_graphics_getCharWidth($3 + 224 | 0, HEAP32[$3 + 148 >> 2]) + HEAP32[$3 + 208 >> 2]
         }
        }
        jsvAppendStringVar(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 388 >> 2], HEAP32[$3 + 196 >> 2], HEAP32[$3 + 140 >> 2] - (HEAP32[$3 + 196 >> 2] + 1 | 0) | 0);
        HEAP32[$3 + 204 >> 2] = HEAP32[$3 + 208 >> 2] + HEAP32[$3 + 204 >> 2];
        break block8;
       }
       HEAP32[$3 + 204 >> 2] = HEAP32[$3 + 208 >> 2];
       if (!(jsvIsEmptyString(HEAP32[$3 + 216 >> 2]) & 1 & !(HEAP8[$3 + 194 | 0] & 1))) {
        jsvArrayPush(HEAP32[$3 + 220 >> 2], HEAP32[$3 + 216 >> 2])
       }
       jsvUnLock(HEAP32[$3 + 216 >> 2]);
       HEAP32[$3 + 216 >> 2] = 0;
       while (1) {
        if (HEAP32[$3 + 208 >> 2] > HEAP32[$3 + 384 >> 2]) {
         HEAP32[$3 + 136 >> 2] = 0;
         HEAP32[$3 + 216 >> 2] = jsvNewFromEmptyString_1968();
         jsvStringIteratorNew($3 + 96 | 0, HEAP32[$3 + 388 >> 2], HEAP32[$3 + 196 >> 2]);
         while (1) {
          block10 : {
           if (jsvStringIteratorGetIndex_1962($3 + 96 | 0) >>> 0 >= HEAPU32[$3 + 140 >> 2]) {
            break block10
           }
           HEAP32[$3 + 92 >> 2] = jsvStringIteratorGetUTF8CharAndNext($3 + 96 | 0);
           if (!HEAP32[$3 + 92 >> 2]) {
            jsvAppendStringVar(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 388 >> 2], HEAP32[$3 + 196 >> 2], HEAP32[$3 + 140 >> 2] - (HEAP32[$3 + 196 >> 2] + 1 | 0) | 0);
            HEAP32[$3 + 204 >> 2] = HEAP32[$3 + 208 >> 2] + HEAP32[$3 + 204 >> 2];
            HEAP32[$3 + 208 >> 2] = 0;
            HEAP32[$3 + 196 >> 2] = HEAP32[$3 + 140 >> 2] - 1;
            break block10;
           }
           HEAP32[$3 + 88 >> 2] = _jswrap_graphics_getCharWidth($3 + 224 | 0, HEAP32[$3 + 92 >> 2]);
           if (HEAP32[$3 + 136 >> 2] ? HEAP32[$3 + 384 >> 2] <= (HEAP32[$3 + 136 >> 2] + HEAP32[$3 + 88 >> 2] | 0) : 0) {
            break block10
           }
           HEAP32[$3 + 208 >> 2] = HEAP32[$3 + 208 >> 2] - HEAP32[$3 + 88 >> 2];
           HEAP32[$3 + 204 >> 2] = HEAP32[$3 + 204 >> 2] - HEAP32[$3 + 88 >> 2];
           HEAP32[$3 + 136 >> 2] = HEAP32[$3 + 88 >> 2] + HEAP32[$3 + 136 >> 2];
           HEAP32[$3 + 196 >> 2] = jsvStringIteratorGetIndex_1962($3 + 96 | 0);
           block11 : {
            if (jsvIsUTF8String(HEAP32[$3 + 388 >> 2]) & 1) {
             jsvAppendUTF8Character(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 92 >> 2]);
             break block11;
            }
            jsvAppendCharacter_1969(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 92 >> 2] << 24 >> 24);
           }
           continue;
          }
          break;
         };
         jsvStringIteratorFree_1906($3 + 96 | 0);
         if (jsvIsUTF8String(HEAP32[$3 + 388 >> 2]) & 1) {
          HEAP32[$3 + 216 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$3 + 216 >> 2])
         }
         jsvArrayPush(HEAP32[$3 + 220 >> 2], HEAP32[$3 + 216 >> 2]);
         jsvUnLock(HEAP32[$3 + 216 >> 2]);
         continue;
        }
        break;
       };
       HEAP32[$3 + 216 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$3 + 388 >> 2], HEAP32[$3 + 196 >> 2], HEAP32[$3 + 140 >> 2] - (HEAP32[$3 + 196 >> 2] + 1 | 0) | 0);
       block12 : {
        if (!(jsvIsUTF8String(HEAP32[$3 + 388 >> 2]) & 1)) {
         break block12
        }
        if (jsvIsUTF8String(HEAP32[$3 + 216 >> 2]) & 1) {
         break block12
        }
        HEAP32[$3 + 216 >> 2] = jsvNewUTF8StringAndUnLock(HEAP32[$3 + 216 >> 2]);
       }
       if (HEAP8[$3 + 194 | 0] & 1) {
        HEAP8[$3 + 202 | 0] = 32
       }
      }
      HEAP8[$3 + 202 | 0] = 0;
      if (!(!(HEAP8[$3 + 203 | 0] & 1) | HEAP8[$3 + 147 | 0] & 1)) {
       HEAP32[$3 + 140 >> 2] = HEAP32[$3 + 140 >> 2] - 1
      }
      if (!(!(HEAP8[$3 + 147 | 0] & 1) | HEAP32[$3 + 148 >> 2] <= 0)) {
       HEAP8[$3 + 202 | 0] = HEAP32[$3 + 148 >> 2]
      }
      HEAP32[$3 + 208 >> 2] = 0;
      HEAP32[$3 + 196 >> 2] = HEAP32[$3 + 140 >> 2];
      HEAP8[$3 + 194 | 0] = HEAP32[$3 + 148 >> 2] == 10;
      HEAP8[$3 + 203 | 0] = !HEAP32[$3 + 148 >> 2];
      if (HEAP8[$3 + 195 | 0] & 1) {
       break block2
      }
      if (HEAP32[$3 + 148 >> 2]) {
       if (!(jsvStringIteratorHasChar_1917($3 + 152 | 0) & 1)) {
        HEAP8[$3 + 195 | 0] = 1
       }
       continue;
      }
     }
     HEAP8[$3 + 203 | 0] = 0;
     if (!HEAP32[$3 + 148 >> 2]) {
      HEAP32[$3 >> 2] = jsvConvertToUTF8Index(HEAP32[$3 + 388 >> 2], jsvStringIteratorGetIndex_1962($3 + 152 | 0));
      if (_jswrap_graphics_parseImage($3 + 312 | 0, HEAP32[$3 + 388 >> 2], HEAP32[$3 >> 2], $3 + 4 | 0) & 1) {
       jsvStringIteratorGotoUTF8($3 + 152 | 0, HEAP32[$3 + 388 >> 2], HEAPU16[$3 + 54 >> 1] + (HEAP32[$3 >> 2] + HEAPU16[$3 + 52 >> 1] | 0) | 0);
       _jswrap_graphics_freeImageInfo($3 + 4 | 0);
       HEAP32[$3 + 208 >> 2] = HEAP32[$3 + 4 >> 2] + HEAP32[$3 + 208 >> 2];
       HEAP8[$3 + 203 | 0] = 1;
       if (!(jsvStringIteratorHasChar_1917($3 + 152 | 0) & 1)) {
        HEAP8[$3 + 195 | 0] = 1
       }
      }
      continue;
     }
     HEAP32[$3 + 208 >> 2] = _jswrap_graphics_getCharWidth($3 + 224 | 0, HEAP32[$3 + 148 >> 2]) + HEAP32[$3 + 208 >> 2];
     block16 : {
      block15 : {
       if (HEAP32[$3 + 148 >> 2] == 44 | HEAP32[$3 + 148 >> 2] == 46 | (HEAP32[$3 + 148 >> 2] == 45 | HEAP32[$3 + 148 >> 2] == 47)) {
        break block15
       }
       if (HEAP32[$3 + 148 >> 2] == 92) {
        break block15
       }
       if (HEAP32[$3 + 148 >> 2] != 58) {
        break block16
       }
      }
      HEAP8[$3 + 203 | 0] = 1;
     }
     if (!(jsvStringIteratorHasChar_1917($3 + 152 | 0) & 1)) {
      HEAP8[$3 + 195 | 0] = 1
     }
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1906($3 + 152 | 0);
   if (!(jsvIsEmptyString(HEAP32[$3 + 216 >> 2]) & 1)) {
    jsvArrayPush(HEAP32[$3 + 220 >> 2], HEAP32[$3 + 216 >> 2])
   }
   jsvUnLock2(HEAP32[$3 + 388 >> 2], HEAP32[$3 + 216 >> 2]);
   _jswrap_graphics_freeFontInfo($3 + 224 | 0);
   HEAP32[$3 + 396 >> 2] = HEAP32[$3 + 220 >> 2];
  }
  __stack_pointer = $3 + 400 | 0;
  return HEAP32[$3 + 396 >> 2];
 }
 
 function jsvNewFromEmptyString_1968() {
  return jsvNewWithFlags(29);
 }
 
 function jsvAppendCharacter_1969($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 11 | 0] = $1;
  jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 11 | 0, 1);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jsvAppendUTF8Character($0, $1) {
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 >> 2] = jsUTF8Encode(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
  jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 4 | 0, HEAP32[$2 >> 2]);
  __stack_pointer = $2 + 16 | 0;
 }
 
 function jswrap_graphics_setFont6x8($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_graphics_setFontSizeX(HEAP32[$2 + 12 >> 2], 16385, 0);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_graphics_setFont4x6($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  $0 = jswrap_graphics_setFontSizeX(HEAP32[$2 + 12 >> 2], 8193, 0);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_graphics_findFont($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 336 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 328 >> 2] = $0;
  HEAP32[$3 + 324 >> 2] = $1;
  HEAP32[$3 + 320 >> 2] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 248 | 0, HEAP32[$3 + 328 >> 2]) & 1)) {
    HEAP32[$3 + 332 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 244 >> 2] = HEAPU8[$3 + 260 | 0] | HEAPU8[$3 + 261 | 0] << 8;
   HEAP32[$3 + 240 >> 2] = HEAPU8[$3 + 262 | 0] | HEAPU8[$3 + 263 | 0] << 8;
   HEAP32[$3 + 236 >> 2] = 4;
   HEAP32[$3 + 232 >> 2] = 100;
   HEAP8[$3 + 231 | 0] = 0;
   HEAP8[$3 + 230 | 0] = 0;
   HEAP32[$3 + 224 >> 2] = jsvNewObject();
   HEAP32[$3 + 324 >> 2] = jsvAsString(HEAP32[$3 + 324 >> 2]);
   if (!(HEAP32[$3 + 324 >> 2] ? HEAP32[$3 + 224 >> 2] : 0)) {
    HEAP32[$3 + 332 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 144 >> 2] = 4131;
   HEAP16[$3 + 148 >> 1] = 10;
   HEAP16[($3 + 144 | 0) + 6 >> 1] = 0;
   HEAP32[$3 + 152 >> 2] = $3 + 244;
   HEAP32[$3 + 156 >> 2] = 16557;
   HEAP16[$3 + 160 >> 1] = 10;
   HEAP16[($3 + 144 | 0) + 18 >> 1] = 0;
   HEAP32[$3 + 164 >> 2] = $3 + 240;
   HEAP32[$3 + 168 >> 2] = 15515;
   HEAP16[$3 + 172 >> 1] = 10;
   HEAP16[($3 + 144 | 0) + 30 >> 1] = 0;
   HEAP32[$3 + 176 >> 2] = $3 + 236;
   HEAP32[$3 + 180 >> 2] = 3877;
   HEAP16[$3 + 184 >> 1] = 10;
   HEAP16[($3 + 144 | 0) + 42 >> 1] = 0;
   HEAP32[$3 + 188 >> 2] = $3 + 232;
   HEAP32[$3 + 192 >> 2] = 15034;
   HEAP16[$3 + 196 >> 1] = 12;
   HEAP16[($3 + 144 | 0) + 54 >> 1] = 0;
   HEAP32[$3 + 200 >> 2] = $3 + 231;
   HEAP32[$3 + 204 >> 2] = 15712;
   HEAP16[$3 + 208 >> 1] = 12;
   HEAP16[($3 + 144 | 0) + 66 >> 1] = 0;
   HEAP32[$3 + 212 >> 2] = $3 + 230;
   if (!(jsvReadConfigObject(HEAP32[$3 + 320 >> 2], $3 + 144 | 0, 6) & 1)) {
    jsvUnLock2(HEAP32[$3 + 224 >> 2], HEAP32[$3 + 324 >> 2]);
    HEAP32[$3 + 332 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 140 >> 2] = 6;
   wasm2js_memory_copy($3 - -64 | 0, 234960, 72);
   HEAP32[$3 + 60 >> 2] = 0;
   while (1) {
    $0 = 0;
    if (HEAP32[$3 + 60 >> 2] < 5) {
     $0 = HEAPU8[(($3 - -64 | 0) + Math_imul(HEAP32[$3 + 60 >> 2], 12) | 0) + 4 | 0] > HEAP32[$3 + 232 >> 2]
    }
    if ($0) {
     HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 60 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$3 + 32 >> 2] = jsvLockAgain(HEAP32[$3 + 324 >> 2]);
   HEAP32[$3 + 28 >> 2] = 0;
   HEAP32[$3 + 24 >> 2] = jsvNewFromString(28752);
   while (1) {
    block2 : {
     if (HEAP32[$3 + 60 >> 2] >= 5) {
      break block2
     }
     jsvUnLock(FUNCTION_TABLE[HEAP32[(($3 - -64 | 0) + Math_imul(HEAP32[$3 + 60 >> 2], 12) | 0) + 8 >> 2]](HEAP32[$3 + 328 >> 2], HEAPU8[(($3 - -64 | 0) + Math_imul(HEAP32[$3 + 60 >> 2], 12) | 0) + 5 | 0]) | 0);
     graphicsGetFromVar($3 + 248 | 0, HEAP32[$3 + 328 >> 2]);
     if (HEAP8[$3 + 231 | 0] & 1) {
      jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
      HEAP32[$3 + 28 >> 2] = jswrap_graphics_wrapString(HEAP32[$3 + 328 >> 2], HEAP32[$3 + 324 >> 2], HEAP32[$3 + 244 >> 2]);
      HEAP32[$3 + 32 >> 2] = jsvArrayJoin(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], 1);
     }
     _jswrap_graphics_stringMetrics($3 + 248 | 0, HEAP32[$3 + 32 >> 2], -1, $3 + 36 | 0);
     if (HEAP32[$3 + 36 >> 2] <= HEAP32[$3 + 244 >> 2] & HEAP32[$3 + 40 >> 2] <= HEAP32[$3 + 240 >> 2] | HEAP32[$3 + 60 >> 2] == 5 | HEAPU8[((Math_imul(HEAP32[$3 + 60 >> 2], 12) + $3 | 0) + 76 | 0) + 4 | 0] < HEAP32[$3 + 236 >> 2]) {
      break block2
     }
     HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 60 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$3 + 20 >> 2] = HEAP32[($3 - -64 | 0) + Math_imul(HEAP32[$3 + 60 >> 2], 12) >> 2];
   if (HEAP8[$3 + 48 | 0] & 1) {
    HEAP32[$3 + 16 >> 2] = jspGetNamedField(HEAP32[$3 + 328 >> 2], 15726, 0);
    if (HEAP32[$3 + 16 >> 2]) {
     HEAP32[$3 + 20 >> 2] = 22423;
     jsvUnLock(jspExecuteFunction(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 328 >> 2], 0, 0));
     graphicsGetFromVar($3 + 248 | 0, HEAP32[$3 + 328 >> 2]);
     $0 = (HEAPU8[$3 + 273 | 0] | HEAPU8[$3 + 274 | 0] << 8) & -8192 | 2;
     HEAP8[$3 + 273 | 0] = $0;
     HEAP8[$3 + 274 | 0] = $0 >>> 8;
     if (HEAP8[$3 + 231 | 0] & 1) {
      jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
      HEAP32[$3 + 28 >> 2] = jswrap_graphics_wrapString(HEAP32[$3 + 328 >> 2], HEAP32[$3 + 324 >> 2], HEAP32[$3 + 244 >> 2]);
      HEAP32[$3 + 32 >> 2] = jsvArrayJoin(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], 1);
     }
     _jswrap_graphics_stringMetrics($3 + 248 | 0, HEAP32[$3 + 32 >> 2], -1, $3 + 36 | 0);
     if (!(HEAP32[$3 + 36 >> 2] <= HEAP32[$3 + 244 >> 2] & HEAP32[$3 + 40 >> 2] <= HEAP32[$3 + 240 >> 2] | HEAP32[$3 + 44 >> 2] < HEAP32[$3 + 236 >> 2] << 1)) {
      HEAP32[$3 + 20 >> 2] = 15733;
      $0 = (HEAPU8[$3 + 273 | 0] | HEAPU8[$3 + 274 | 0] << 8) & -8192 | 1;
      HEAP8[$3 + 273 | 0] = $0;
      HEAP8[$3 + 274 | 0] = $0 >>> 8;
      if (HEAP8[$3 + 231 | 0] & 1) {
       jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
       HEAP32[$3 + 28 >> 2] = jswrap_graphics_wrapString(HEAP32[$3 + 328 >> 2], HEAP32[$3 + 324 >> 2], HEAP32[$3 + 244 >> 2]);
       HEAP32[$3 + 32 >> 2] = jsvArrayJoin(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], 1);
      }
      _jswrap_graphics_stringMetrics($3 + 248 | 0, HEAP32[$3 + 32 >> 2], -1, $3 + 36 | 0);
     }
     graphicsSetVar($3 + 248 | 0);
     jsvUnLock(HEAP32[$3 + 16 >> 2]);
    }
   }
   if (!(!(HEAP8[$3 + 230 | 0] & 1) | HEAP32[$3 + 40 >> 2] <= HEAP32[$3 + 240 >> 2])) {
    HEAP32[$3 + 12 >> 2] = jsvNewFromInteger(HEAP32[$3 + 240 >> 2] / HEAP32[$3 + 44 >> 2] | 0);
    if (!HEAP32[$3 + 28 >> 2]) {
     HEAP32[$3 + 28 >> 2] = jswrap_string_split(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 24 >> 2])
    }
    HEAP32[$3 + 8 >> 2] = jswrap_array_slice(HEAP32[$3 + 28 >> 2], 0, HEAP32[$3 + 12 >> 2]);
    jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 12 >> 2]);
    HEAP32[$3 + 32 >> 2] = jsvArrayJoin(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 24 >> 2], 1);
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
    jsvAppendString(HEAP32[$3 + 32 >> 2], 22775);
    _jswrap_graphics_stringMetrics($3 + 248 | 0, HEAP32[$3 + 32 >> 2], -1, $3 + 36 | 0);
   }
   jsvUnLock3(HEAP32[$3 + 324 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 28 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 224 >> 2], 4266, HEAP32[$3 + 32 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 224 >> 2], 4599, jsvNewFromString(HEAP32[$3 + 20 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 224 >> 2], 4131, jsvNewFromInteger(HEAP32[$3 + 36 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 224 >> 2], 16557, jsvNewFromInteger(HEAP32[$3 + 40 >> 2]));
   HEAP32[$3 + 332 >> 2] = HEAP32[$3 + 224 >> 2];
  }
  __stack_pointer = $3 + 336 | 0;
  return HEAP32[$3 + 332 >> 2];
 }
 
 function jswrap_graphics_drawString($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 528 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 520 >> 2] = $0;
  HEAP32[$5 + 516 >> 2] = $1;
  HEAP32[$5 + 512 >> 2] = $2;
  HEAP32[$5 + 508 >> 2] = $3;
  HEAP8[$5 + 507 | 0] = $4;
  block : {
   if (!(graphicsGetFromVar($5 + 435 | 0, HEAP32[$5 + 520 >> 2]) & 1)) {
    HEAP32[$5 + 524 >> 2] = 0;
    break block;
   }
   _jswrap_graphics_getFontInfo($5 + 435 | 0, $5 + 344 | 0);
   HEAP32[$5 + 340 >> 2] = _jswrap_graphics_getFontHeightInternal($5 + 435 | 0, $5 + 344 | 0);
   HEAP32[$5 + 336 >> 2] = 1;
   if (HEAP32[$5 + 344 >> 2] & 32768) {
    if ((HEAP32[$5 + 344 >> 2] & 57344) == 40960) {
     HEAP32[$5 + 336 >> 2] = 2
    }
    if ((HEAP32[$5 + 344 >> 2] & 57344) == 49152) {
     HEAP32[$5 + 336 >> 2] = 4
    }
   }
   HEAP32[$5 + 332 >> 2] = HEAPU8[$5 + 443 | 0] | HEAPU8[$5 + 444 | 0] << 8 | (HEAPU8[$5 + 445 | 0] << 16 | HEAPU8[$5 + 446 | 0] << 24);
   block1 : {
    if ((HEAPU8[$5 + 466 | 0] >>> 4 & 3) == 1) {
     $0 = (HEAPU8[$5 + 443 | 0] | HEAPU8[$5 + 444 | 0] << 8 | (HEAPU8[$5 + 445 | 0] << 16 | HEAPU8[$5 + 446 | 0] << 24)) ^ 48;
     HEAP8[$5 + 443 | 0] = $0;
     HEAP8[$5 + 444 | 0] = $0 >>> 8;
     HEAP8[$5 + 445 | 0] = $0 >>> 16;
     HEAP8[$5 + 446 | 0] = $0 >>> 24;
     HEAP32[$5 + 328 >> 2] = (HEAPU8[$5 + 447 | 0] | HEAPU8[$5 + 448 | 0] << 8) - (HEAP32[$5 + 512 >> 2] + 1 | 0);
     HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 508 >> 2];
     HEAP32[$5 + 508 >> 2] = HEAP32[$5 + 328 >> 2];
     break block1;
    }
    block2 : {
     if ((HEAPU8[$5 + 466 | 0] >>> 4 & 3) == 2) {
      $0 = (HEAPU8[$5 + 443 | 0] | HEAPU8[$5 + 444 | 0] << 8 | (HEAPU8[$5 + 445 | 0] << 16 | HEAPU8[$5 + 446 | 0] << 24)) ^ 96;
      HEAP8[$5 + 443 | 0] = $0;
      HEAP8[$5 + 444 | 0] = $0 >>> 8;
      HEAP8[$5 + 445 | 0] = $0 >>> 16;
      HEAP8[$5 + 446 | 0] = $0 >>> 24;
      HEAP32[$5 + 512 >> 2] = (HEAPU8[$5 + 447 | 0] | HEAPU8[$5 + 448 | 0] << 8) - (HEAP32[$5 + 512 >> 2] + 1 | 0);
      HEAP32[$5 + 508 >> 2] = (HEAPU8[$5 + 449 | 0] | HEAPU8[$5 + 450 | 0] << 8) - (HEAP32[$5 + 508 >> 2] + 1 | 0);
      break block2;
     }
     if ((HEAPU8[$5 + 466 | 0] >>> 4 & 3) == 3) {
      $0 = (HEAPU8[$5 + 443 | 0] | HEAPU8[$5 + 444 | 0] << 8 | (HEAPU8[$5 + 445 | 0] << 16 | HEAPU8[$5 + 446 | 0] << 24)) ^ 80;
      HEAP8[$5 + 443 | 0] = $0;
      HEAP8[$5 + 444 | 0] = $0 >>> 8;
      HEAP8[$5 + 445 | 0] = $0 >>> 16;
      HEAP8[$5 + 446 | 0] = $0 >>> 24;
      HEAP32[$5 + 324 >> 2] = (HEAPU8[$5 + 449 | 0] | HEAPU8[$5 + 450 | 0] << 8) - (HEAP32[$5 + 508 >> 2] + 1 | 0);
      HEAP32[$5 + 508 >> 2] = HEAP32[$5 + 512 >> 2];
      HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 324 >> 2];
     }
    }
   }
   HEAP32[$5 + 320 >> 2] = jsvAsString(HEAP32[$5 + 516 >> 2]);
   HEAP32[$5 + 316 >> 2] = HEAP32[$5 + 512 >> 2];
   if ((HEAPU8[$5 + 466 | 0] & 3) >>> 0 < 2) {
    HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 316 >> 2] - ((Math_imul(_jswrap_graphics_stringWidth($5 + 435 | 0, HEAP32[$5 + 320 >> 2], 0), (HEAPU8[$5 + 466 | 0] & 3) + 1 | 0) | 0) / 2 | 0)
   }
   if ((HEAPU8[$5 + 466 | 0] >>> 2 & 3) >>> 0 < 2) {
    _jswrap_graphics_stringMetrics($5 + 435 | 0, HEAP32[$5 + 320 >> 2], -1, $5 + 292 | 0);
    HEAP32[$5 + 508 >> 2] = HEAP32[$5 + 508 >> 2] - ((Math_imul(HEAP32[$5 + 296 >> 2], (HEAPU8[$5 + 466 | 0] >>> 2 & 3) + 1 | 0) | 0) / 2 | 0);
   }
   HEAP32[$5 + 288 >> 2] = HEAPU8[$5 + 467 | 0] | HEAPU8[$5 + 468 | 0] << 8;
   HEAP32[$5 + 284 >> 2] = HEAPU8[$5 + 469 | 0] | HEAPU8[$5 + 470 | 0] << 8;
   HEAP32[$5 + 280 >> 2] = HEAPU8[$5 + 471 | 0] | HEAPU8[$5 + 472 | 0] << 8;
   HEAP32[$5 + 276 >> 2] = HEAPU8[$5 + 473 | 0] | HEAPU8[$5 + 474 | 0] << 8;
   deviceToGraphicsCoordinates($5 + 435 | 0, $5 + 288 | 0, $5 + 284 | 0);
   deviceToGraphicsCoordinates($5 + 435 | 0, $5 + 280 | 0, $5 + 276 | 0);
   if (HEAP32[$5 + 280 >> 2] < HEAP32[$5 + 288 >> 2]) {
    HEAP32[$5 + 272 >> 2] = HEAP32[$5 + 288 >> 2];
    HEAP32[$5 + 288 >> 2] = HEAP32[$5 + 280 >> 2];
    HEAP32[$5 + 280 >> 2] = HEAP32[$5 + 272 >> 2];
   }
   if (HEAP32[$5 + 276 >> 2] < HEAP32[$5 + 284 >> 2]) {
    HEAP32[$5 + 268 >> 2] = HEAP32[$5 + 284 >> 2];
    HEAP32[$5 + 284 >> 2] = HEAP32[$5 + 276 >> 2];
    HEAP32[$5 + 276 >> 2] = HEAP32[$5 + 268 >> 2];
   }
   jsvStringIteratorNewUTF8($5 + 228 | 0, HEAP32[$5 + 320 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1917($5 + 228 | 0) & 1) {
     HEAP32[$5 + 224 >> 2] = jsvStringIteratorGetUTF8CharAndNext($5 + 228 | 0);
     if (HEAP32[$5 + 224 >> 2] == 10) {
      HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 316 >> 2];
      if ((HEAPU8[$5 + 466 | 0] & 3) >>> 0 < 2) {
       $0 = HEAP32[$5 + 320 >> 2];
       HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 316 >> 2] - ((Math_imul(_jswrap_graphics_stringWidth($5 + 435 | 0, $0, jsvConvertToUTF8Index($0, jsvStringIteratorGetIndex_1962($5 + 228 | 0))), (HEAPU8[$5 + 466 | 0] & 3) + 1 | 0) | 0) / 2 | 0);
      }
      HEAP32[$5 + 508 >> 2] = HEAP32[$5 + 340 >> 2] + HEAP32[$5 + 508 >> 2];
      continue;
     }
     if (!HEAP32[$5 + 224 >> 2]) {
      HEAP32[$5 + 136 >> 2] = jsvConvertToUTF8Index(HEAP32[$5 + 320 >> 2], jsvStringIteratorGetIndex_1962($5 + 228 | 0));
      if (_jswrap_graphics_parseImage($5 + 435 | 0, HEAP32[$5 + 320 >> 2], HEAP32[$5 + 136 >> 2], $5 + 140 | 0) & 1) {
       jsvStringIteratorGotoUTF8($5 + 228 | 0, HEAP32[$5 + 320 >> 2], HEAP32[$5 + 136 >> 2] + HEAPU16[$5 + 188 >> 1] | 0);
       _jswrap_drawImageSimple($5 + 435 | 0, HEAP32[$5 + 512 >> 2], HEAP32[$5 + 508 >> 2] + ((HEAP32[$5 + 340 >> 2] - HEAP32[$5 + 144 >> 2] | 0) / 2 | 0) | 0, $5 + 140 | 0, $5 + 228 | 0, 1);
       _jswrap_graphics_freeImageInfo($5 + 140 | 0);
       HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 140 >> 2] + HEAP32[$5 + 512 >> 2];
      }
      continue;
     }
     block5 : {
      if (!(HEAP32[$5 + 344 >> 2] | HEAP32[$5 + 224 >> 2] >= 256)) {
       HEAP32[$5 + 132 >> 2] = graphicsVectorCharWidth(HEAPU16[$5 + 350 >> 1], HEAP32[$5 + 224 >> 2] << 24 >> 24);
       if (!(HEAP32[$5 + 512 >> 2] <= (HEAP32[$5 + 288 >> 2] - HEAP32[$5 + 132 >> 2] | 0) | HEAP32[$5 + 512 >> 2] >= HEAP32[$5 + 280 >> 2] | (HEAP32[$5 + 508 >> 2] <= (HEAP32[$5 + 284 >> 2] - HEAP32[$5 + 340 >> 2] | 0) | HEAP32[$5 + 508 >> 2] > HEAP32[$5 + 276 >> 2]))) {
        if (HEAP8[$5 + 507 | 0] & 1) {
         graphicsFillRect($5 + 435 | 0, HEAP32[$5 + 512 >> 2], HEAP32[$5 + 508 >> 2], (HEAP32[$5 + 512 >> 2] + HEAP32[$5 + 132 >> 2] | 0) - 1 | 0, (HEAP32[$5 + 508 >> 2] + HEAP32[$5 + 340 >> 2] | 0) - 1 | 0, HEAPU8[$5 + 456 | 0] | HEAPU8[$5 + 457 | 0] << 8 | (HEAPU8[$5 + 458 | 0] << 16 | HEAPU8[$5 + 459 | 0] << 24))
        }
        graphicsGetVectorChar(677, $5 + 435 | 0, HEAP32[$5 + 512 >> 2], HEAP32[$5 + 508 >> 2], HEAPU16[$5 + 350 >> 1], HEAPU16[$5 + 352 >> 1], HEAP32[$5 + 224 >> 2] << 24 >> 24);
       }
       HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 132 >> 2] + HEAP32[$5 + 512 >> 2];
       break block5;
      }
      block8 : {
       if (!(HEAP32[$5 + 344 >> 2] != 8192 | HEAP32[$5 + 224 >> 2] >= 256)) {
        if (!(HEAP32[$5 + 512 >> 2] <= (HEAP32[$5 + 288 >> 2] - (HEAPU16[$5 + 350 >> 1] << 2) | 0) | HEAP32[$5 + 512 >> 2] >= HEAP32[$5 + 280 >> 2] | (HEAP32[$5 + 508 >> 2] <= (HEAP32[$5 + 284 >> 2] - HEAP32[$5 + 340 >> 2] | 0) | HEAP32[$5 + 508 >> 2] > HEAP32[$5 + 276 >> 2]))) {
         graphicsDrawChar4x6($5 + 435 | 0, HEAP32[$5 + 512 >> 2], HEAP32[$5 + 508 >> 2], HEAP32[$5 + 224 >> 2] << 24 >> 24, HEAPU16[$5 + 350 >> 1], HEAPU16[$5 + 352 >> 1], HEAP8[$5 + 507 | 0] & 1)
        }
        HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 512 >> 2] + (HEAPU16[$5 + 350 >> 1] << 2);
        break block8;
       }
       block10 : {
        if (HEAP32[$5 + 344 >> 2] == 16384) {
         if (!(HEAP32[$5 + 512 >> 2] <= (HEAP32[$5 + 288 >> 2] - Math_imul(HEAPU16[$5 + 350 >> 1], 6) | 0) | HEAP32[$5 + 512 >> 2] >= HEAP32[$5 + 280 >> 2] | (HEAP32[$5 + 508 >> 2] <= (HEAP32[$5 + 284 >> 2] - HEAP32[$5 + 340 >> 2] | 0) | HEAP32[$5 + 508 >> 2] > HEAP32[$5 + 276 >> 2]))) {
          graphicsDrawChar6x8($5 + 435 | 0, HEAP32[$5 + 512 >> 2], HEAP32[$5 + 508 >> 2], HEAP32[$5 + 224 >> 2] << 24 >> 24, HEAPU16[$5 + 350 >> 1], HEAPU16[$5 + 352 >> 1], HEAP8[$5 + 507 | 0] & 1)
         }
         HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 512 >> 2] + Math_imul(HEAPU16[$5 + 350 >> 1], 6);
         break block10;
        }
        block11 : {
         if ((HEAP32[$5 + 344 >> 2] & 57344) == 57344) {
          if (jspbfFontFindGlyph($5 + 364 | 0, HEAP32[$5 + 224 >> 2], $5 + 126 | 0) & 1) {
           jspbfFontRenderGlyph($5 + 364 | 0, $5 + 126 | 0, $5 + 435 | 0, HEAP32[$5 + 512 >> 2] + Math_imul(HEAPU16[$5 + 350 >> 1], HEAP8[$5 + 128 | 0] << 24 >> 24) | 0, HEAP32[$5 + 508 >> 2] + Math_imul(HEAPU16[$5 + 352 >> 1], HEAP8[$5 + 129 | 0] << 24 >> 24) | 0, HEAP8[$5 + 507 | 0] & 1, HEAPU16[$5 + 350 >> 1], HEAPU16[$5 + 352 >> 1]);
           HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 512 >> 2] + Math_imul(HEAPU16[$5 + 350 >> 1], HEAP8[$5 + 130 | 0] << 24 >> 24);
          }
          break block11;
         }
         if (!(!(HEAP32[$5 + 344 >> 2] & 32768) | HEAP32[$5 + 224 >> 2] >= 256)) {
          HEAP32[$5 + 120 >> 2] = (1 << HEAP32[$5 + 336 >> 2]) - 1;
          HEAP32[$5 + 116 >> 2] = 0;
          HEAP32[$5 + 112 >> 2] = 0;
          block13 : {
           if (jsvIsString(HEAP32[$5 + 356 >> 2]) & 1) {
            if (HEAP32[$5 + 224 >> 2] >= HEAPU8[$5 + 354 | 0]) {
             jsvStringIteratorNew($5 + 72 | 0, HEAP32[$5 + 356 >> 2], 0);
             while (1) {
              $0 = 0;
              if (jsvStringIteratorHasChar_1917($5 + 72 | 0) & 1) {
               $0 = (jsvStringIteratorGetIndex_1962($5 + 72 | 0) | 0) < (HEAP32[$5 + 224 >> 2] - HEAPU8[$5 + 354 | 0] | 0)
              }
              if ($0) {
               HEAP32[$5 + 112 >> 2] = (jsvStringIteratorGetCharAndNext($5 + 72 | 0) & 255) + HEAP32[$5 + 112 >> 2];
               continue;
              }
              break;
             };
             HEAP32[$5 + 116 >> 2] = jsvStringIteratorGetChar_1908($5 + 72 | 0) & 255;
             jsvStringIteratorFree_1906($5 + 72 | 0);
            }
            break block13;
           }
           HEAP32[$5 + 116 >> 2] = jsvGetInteger(HEAP32[$5 + 356 >> 2]);
           HEAP32[$5 + 112 >> 2] = Math_imul(HEAP32[$5 + 116 >> 2], HEAP32[$5 + 224 >> 2] - HEAPU8[$5 + 354 | 0] | 0);
          }
          block14 : {
           if (HEAP32[$5 + 224 >> 2] < HEAPU8[$5 + 354 | 0] | HEAP32[$5 + 512 >> 2] <= (HEAP32[$5 + 288 >> 2] - Math_imul(HEAP32[$5 + 116 >> 2], HEAPU16[$5 + 350 >> 1]) | 0) | (HEAP32[$5 + 508 >> 2] <= (HEAP32[$5 + 284 >> 2] - HEAP32[$5 + 340 >> 2] | 0) | HEAP32[$5 + 512 >> 2] >= HEAP32[$5 + 280 >> 2])) {
            break block14
           }
           if (HEAP32[$5 + 508 >> 2] > HEAP32[$5 + 276 >> 2]) {
            break block14
           }
           HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 340 >> 2] / HEAPU16[$5 + 352 >> 1];
           HEAP32[$5 + 112 >> 2] = Math_imul(HEAP32[$5 + 112 >> 2], Math_imul(HEAP32[$5 + 68 >> 2], HEAP32[$5 + 336 >> 2]));
           jsvStringIteratorNew($5 + 28 | 0, HEAP32[$5 + 360 >> 2], HEAP32[$5 + 112 >> 2] >> 3);
           HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 112 >> 2] & 7;
           HEAP32[$5 + 16 >> 2] = jsvStringIteratorGetChar_1908($5 + 28 | 0) << 24 >> 24;
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] << Math_imul(HEAP32[$5 + 336 >> 2], HEAP32[$5 + 112 >> 2]);
           HEAP32[$5 + 24 >> 2] = 0;
           while (1) {
            if (HEAP32[$5 + 24 >> 2] < HEAP32[$5 + 116 >> 2]) {
             HEAP32[$5 + 20 >> 2] = 0;
             while (1) {
              if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 68 >> 2]) {
               HEAP32[$5 + 12 >> 2] = (HEAP32[$5 + 16 >> 2] & 255) >> 8 - HEAP32[$5 + 336 >> 2];
               if (HEAP8[$5 + 507 | 0] & 1 | HEAP32[$5 + 12 >> 2]) {
                graphicsFillRect($5 + 435 | 0, HEAP32[$5 + 512 >> 2] + Math_imul(HEAP32[$5 + 24 >> 2], HEAPU16[$5 + 350 >> 1]) | 0, HEAP32[$5 + 508 >> 2] + Math_imul(HEAP32[$5 + 20 >> 2], HEAPU16[$5 + 352 >> 1]) | 0, (HEAPU16[$5 + 350 >> 1] + (HEAP32[$5 + 512 >> 2] + Math_imul(HEAP32[$5 + 24 >> 2], HEAPU16[$5 + 350 >> 1]) | 0) | 0) - 1 | 0, (HEAPU16[$5 + 352 >> 1] + (HEAP32[$5 + 508 >> 2] + Math_imul(HEAP32[$5 + 20 >> 2], HEAPU16[$5 + 352 >> 1]) | 0) | 0) - 1 | 0, graphicsBlendGfxColor($5 + 435 | 0, (HEAP32[$5 + 12 >> 2] << 8) / HEAP32[$5 + 120 >> 2] | 0))
               }
               HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 336 >> 2] + HEAP32[$5 + 112 >> 2];
               HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] << HEAP32[$5 + 336 >> 2];
               if (HEAP32[$5 + 112 >> 2] >= 8) {
                HEAP32[$5 + 112 >> 2] = 0;
                jsvStringIteratorNext($5 + 28 | 0);
                HEAP32[$5 + 16 >> 2] = jsvStringIteratorGetChar_1908($5 + 28 | 0) << 24 >> 24;
               }
               HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
               continue;
              }
              break;
             };
             HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
             continue;
            }
            break;
           };
           jsvStringIteratorFree_1906($5 + 28 | 0);
          }
          HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 512 >> 2] + Math_imul(HEAP32[$5 + 116 >> 2], HEAPU16[$5 + 350 >> 1]);
         }
        }
       }
      }
     }
     if (!(jspIsInterrupted() & 1)) {
      continue
     }
    }
    break;
   };
   jsvStringIteratorFree_1906($5 + 228 | 0);
   jsvUnLock(HEAP32[$5 + 320 >> 2]);
   $0 = HEAP32[$5 + 332 >> 2];
   HEAP8[$5 + 443 | 0] = $0;
   HEAP8[$5 + 444 | 0] = $0 >>> 8;
   HEAP8[$5 + 445 | 0] = $0 >>> 16;
   HEAP8[$5 + 446 | 0] = $0 >>> 24;
   graphicsSetVar($5 + 435 | 0);
   _jswrap_graphics_freeFontInfo($5 + 344 | 0);
   HEAP32[$5 + 524 >> 2] = jsvLockAgain(HEAP32[$5 + 520 >> 2]);
  }
  __stack_pointer = $5 + 528 | 0;
  return HEAP32[$5 + 524 >> 2];
 }
 
 function jswrap_graphics_drawCString($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 28 >> 2] = $0;
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = jsvNewFromString(HEAP32[$4 + 16 >> 2]);
  $0 = HEAP32[$4 + 28 >> 2];
  jsvUnLock2(jswrap_graphics_drawString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], 0), HEAP32[$4 + 12 >> 2]);
  __stack_pointer = $4 + 32 | 0;
 }
 
 function _jswrap_graphics_getVectorFontPolys_cb($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $2;
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 28 >> 2];
  block : {
   if (!HEAP32[$3 + 16 >> 2]) {
    break block
   }
   HEAP32[$3 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 24 >> 2] << 1) {
     HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] << 1) >> 1] = (HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] << 1) >> 1] << 16 >> 16) + 8 << 16 >> 16 >> 4;
     HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] + 1 << 1) >> 1] = (HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] + 1 << 1) >> 1] << 16 >> 16) + 8 << 16 >> 16 >> 4;
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 2;
     continue;
    }
    break;
   };
   HEAP32[$3 + 8 >> 2] = jsvNewTypedArray(18, HEAP32[$3 + 24 >> 2] << 1);
   if (!HEAP32[$3 + 8 >> 2]) {
    break block
   }
   HEAP32[$3 + 4 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 8 >> 2], 0);
   if (HEAP32[$3 + 4 >> 2]) {
    jsvSetString(HEAP32[$3 + 4 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2] << 2);
    jsvUnLock(HEAP32[$3 + 4 >> 2]);
   }
   jsvArrayPushAndUnLock(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 8 >> 2]);
  }
  __stack_pointer = $3 + 32 | 0;
 }
 
 function jswrap_graphics_getVectorFontPolys($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 128 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 124 >> 2] = $0;
  HEAP32[$3 + 120 >> 2] = $1;
  HEAP32[$3 + 116 >> 2] = $2;
  HEAP32[$3 + 112 >> 2] = 0;
  HEAP32[$3 + 108 >> 2] = 0;
  HEAP32[$3 + 104 >> 2] = 256;
  HEAP32[$3 + 100 >> 2] = 256;
  HEAP32[$3 + 48 >> 2] = 3934;
  HEAP16[$3 + 52 >> 1] = 10;
  HEAP16[($3 + 48 | 0) + 6 >> 1] = 0;
  HEAP32[$3 + 56 >> 2] = $3 + 112;
  HEAP32[$3 + 60 >> 2] = 3805;
  HEAP16[$3 + 64 >> 1] = 10;
  HEAP16[($3 + 48 | 0) + 18 >> 1] = 0;
  HEAP32[$3 + 68 >> 2] = $3 + 108;
  HEAP32[$3 + 72 >> 2] = 4131;
  HEAP16[$3 + 76 >> 1] = 10;
  HEAP16[($3 + 48 | 0) + 30 >> 1] = 0;
  HEAP32[$3 + 80 >> 2] = $3 + 104;
  HEAP32[$3 + 84 >> 2] = 16557;
  HEAP16[$3 + 88 >> 1] = 10;
  HEAP16[($3 + 48 | 0) + 42 >> 1] = 0;
  HEAP32[$3 + 92 >> 2] = $3 + 100;
  jsvReadConfigObject(HEAP32[$3 + 116 >> 2], $3 + 48 | 0, 4);
  HEAP32[$3 + 120 >> 2] = jsvAsString(HEAP32[$3 + 120 >> 2]);
  HEAP32[$3 + 44 >> 2] = jsvNewEmptyArray();
  jsvStringIteratorNew($3 + 4 | 0, HEAP32[$3 + 120 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_1917($3 + 4 | 0) & 1) {
    HEAP8[$3 + 3 | 0] = jsvStringIteratorGetCharAndNext($3 + 4 | 0);
    HEAP32[$3 + 112 >> 2] = graphicsGetVectorChar(678, HEAP32[$3 + 44 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], HEAP8[$3 + 3 | 0] << 24 >> 24) + HEAP32[$3 + 112 >> 2];
    continue;
   }
   break;
  };
  jsvStringIteratorFree_1906($3 + 4 | 0);
  jsvUnLock(HEAP32[$3 + 120 >> 2]);
  __stack_pointer = $3 + 128 | 0;
  return HEAP32[$3 + 44 >> 2];
 }
 
 function jswrap_graphics_drawLine($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  $5 = __stack_pointer - 96 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 88 >> 2] = $0;
  HEAP32[$5 + 84 >> 2] = $1;
  HEAP32[$5 + 80 >> 2] = $2;
  HEAP32[$5 + 76 >> 2] = $3;
  HEAP32[$5 + 72 >> 2] = $4;
  block : {
   if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
    HEAP32[$5 + 92 >> 2] = 0;
    break block;
   }
   graphicsDrawLine($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
   graphicsSetVar($5);
   HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
  }
  __stack_pointer = $5 + 96 | 0;
  return HEAP32[$5 + 92 >> 2];
 }
 
 function jswrap_graphics_drawLineAA($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = +$1;
  $2 = +$2;
  $3 = +$3;
  $4 = +$4;
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $5 = __stack_pointer - 112 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 104 >> 2] = $0;
  HEAPF64[$5 + 96 >> 3] = $1;
  HEAPF64[$5 + 88 >> 3] = $2;
  HEAPF64[$5 + 80 >> 3] = $3;
  HEAPF64[$5 + 72 >> 3] = $4;
  block : {
   if (!(graphicsGetFromVar($5, HEAP32[$5 + 104 >> 2]) & 1)) {
    HEAP32[$5 + 108 >> 2] = 0;
    break block;
   }
   $1 = HEAPF64[$5 + 96 >> 3] * 16.0 + .5;
   if (Math_abs($1) < 2147483647.0) {
    $6 = ~~$1
   } else {
    $6 = -2147483648
   }
   $1 = HEAPF64[$5 + 88 >> 3] * 16.0 + .5;
   if (Math_abs($1) < 2147483647.0) {
    $7 = ~~$1
   } else {
    $7 = -2147483648
   }
   $1 = HEAPF64[$5 + 80 >> 3] * 16.0 + .5;
   if (Math_abs($1) < 2147483647.0) {
    $0 = ~~$1
   } else {
    $0 = -2147483648
   }
   $1 = HEAPF64[$5 + 72 >> 3] * 16.0 + .5;
   if (Math_abs($1) < 2147483647.0) {
    $8 = ~~$1
   } else {
    $8 = -2147483648
   }
   graphicsDrawLineAA($5, $6, $7, $0, $8);
   graphicsSetVar($5);
   HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
  }
  __stack_pointer = $5 + 112 | 0;
  return HEAP32[$5 + 108 >> 2];
 }
 
 function jswrap_graphics_lineTo($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   graphicsDrawLine($3 + 8 | 0, (HEAPU8[$3 + 35 | 0] | HEAPU8[$3 + 36 | 0] << 8) << 16 >> 16, (HEAPU8[$3 + 37 | 0] | HEAPU8[$3 + 38 | 0] << 8) << 16 >> 16, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
   $0 = HEAP32[$3 + 84 >> 2];
   HEAP8[$3 + 35 | 0] = $0;
   HEAP8[$3 + 36 | 0] = $0 >>> 8;
   $0 = HEAP32[$3 + 80 >> 2];
   HEAP8[$3 + 37 | 0] = $0;
   HEAP8[$3 + 38 | 0] = $0 >>> 8;
   graphicsSetVar($3 + 8 | 0);
   HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_graphics_moveTo($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$3 + 84 >> 2];
   HEAP8[$3 + 35 | 0] = $0;
   HEAP8[$3 + 36 | 0] = $0 >>> 8;
   $0 = HEAP32[$3 + 80 >> 2];
   HEAP8[$3 + 37 | 0] = $0;
   HEAP8[$3 + 38 | 0] = $0 >>> 8;
   graphicsSetVar($3 + 8 | 0);
   HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_graphics_drawPoly_X($0, $1, $2, $3) {
  var $4 = 0, $5 = 0.0;
  $4 = __stack_pointer - 192 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 184 >> 2] = $0;
  HEAP32[$4 + 180 >> 2] = $1;
  HEAP8[$4 + 179 | 0] = $2;
  HEAP8[$4 + 178 | 0] = $3;
  block : {
   if (!(graphicsGetFromVar($4 + 106 | 0, HEAP32[$4 + 184 >> 2]) & 1)) {
    HEAP32[$4 + 188 >> 2] = 0;
    break block;
   }
   if (!(jsvIsIterable(HEAP32[$4 + 180 >> 2]) & 1)) {
    HEAP32[$4 + 188 >> 2] = 0;
    break block;
   }
   block1 : {
    if (HEAP8[$4 + 178 | 0] & 1) {
     HEAP32[$4 + 100 >> 2] = 16;
     HEAP32[$4 + 96 >> 2] = 679;
     break block1;
    }
    HEAP32[$4 + 100 >> 2] = 1;
    HEAP32[$4 + 96 >> 2] = 680;
   }
   HEAP32[$4 + 76 >> 2] = 0;
   jsvIteratorNew($4 + 12 | 0, HEAP32[$4 + 180 >> 2], 1);
   while (1) {
    block2 : {
     if (!(jsvIteratorHasElement($4 + 12 | 0) & 1)) {
      break block2
     }
     $5 = jsvIteratorGetFloatValue($4 + 12 | 0) * +HEAP32[$4 + 100 >> 2] + .5;
     if (Math_abs($5) < 2147483647.0) {
      $0 = ~~$5
     } else {
      $0 = -2147483648
     }
     HEAP32[$4 + 8 >> 2] = $0;
     jsvIteratorNext($4 + 12 | 0);
     if (!(jsvIteratorHasElement($4 + 12 | 0) & 1)) {
      break block2
     }
     $5 = jsvIteratorGetFloatValue($4 + 12 | 0) * +HEAP32[$4 + 100 >> 2] + .5;
     if (Math_abs($5) < 2147483647.0) {
      $0 = ~~$5
     } else {
      $0 = -2147483648
     }
     HEAP32[$4 + 4 >> 2] = $0;
     jsvIteratorNext($4 + 12 | 0);
     block3 : {
      if (!HEAP32[$4 + 76 >> 2]) {
       HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 8 >> 2];
       HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 4 >> 2];
       break block3;
      }
      FUNCTION_TABLE[HEAP32[$4 + 96 >> 2]]($4 + 106 | 0, HEAP32[$4 + 92 >> 2], HEAP32[$4 + 88 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2]);
     }
     HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 8 >> 2];
     HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 4 >> 2];
     HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] + 1;
     continue;
    }
    break;
   };
   jsvIteratorFree($4 + 12 | 0);
   $0 = HEAP32[$4 + 92 >> 2] / HEAP32[$4 + 100 >> 2] | 0;
   HEAP8[$4 + 133 | 0] = $0;
   HEAP8[$4 + 134 | 0] = $0 >>> 8;
   $0 = HEAP32[$4 + 88 >> 2] / HEAP32[$4 + 100 >> 2] | 0;
   HEAP8[$4 + 135 | 0] = $0;
   HEAP8[$4 + 136 | 0] = $0 >>> 8;
   if (HEAP8[$4 + 179 | 0] & 1) {
    FUNCTION_TABLE[HEAP32[$4 + 96 >> 2]]($4 + 106 | 0, HEAP32[$4 + 92 >> 2], HEAP32[$4 + 88 >> 2], HEAP32[$4 + 84 >> 2], HEAP32[$4 + 80 >> 2])
   }
   graphicsSetVar($4 + 106 | 0);
   HEAP32[$4 + 188 >> 2] = jsvLockAgain(HEAP32[$4 + 184 >> 2]);
  }
  __stack_pointer = $4 + 192 | 0;
  return HEAP32[$4 + 188 >> 2];
 }
 
 function jswrap_graphics_fillPoly_X($0, $1, $2) {
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer - 192 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 184 >> 2] = $0;
  HEAP32[$3 + 180 >> 2] = $1;
  HEAP8[$3 + 179 | 0] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 107 | 0, HEAP32[$3 + 184 >> 2]) & 1)) {
    HEAP32[$3 + 188 >> 2] = 0;
    break block;
   }
   if (!(jsvIsIterable(HEAP32[$3 + 180 >> 2]) & 1)) {
    HEAP32[$3 + 188 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 100 >> 2] = 128;
   HEAP32[$3 + 96 >> 2] = $3;
   $0 = $3 - 256 | 0;
   __stack_pointer = $0;
   HEAP32[$3 + 92 >> 2] = 0;
   jsvIteratorNew($3 + 28 | 0, HEAP32[$3 + 180 >> 2], 1);
   while (1) {
    $1 = 0;
    if (jsvIteratorHasElement($3 + 28 | 0) & 1) {
     $1 = HEAP32[$3 + 92 >> 2] < 128
    }
    if ($1) {
     $4 = jsvIteratorGetFloatValue($3 + 28 | 0) * 16.0 + .5;
     if (Math_abs($4) < 2147483647.0) {
      $1 = ~~$4
     } else {
      $1 = -2147483648
     }
     HEAP32[$3 + 24 >> 2] = $1;
     if (HEAP32[$3 + 24 >> 2] < -32768) {
      HEAP32[$3 + 24 >> 2] = -32768
     }
     if (HEAP32[$3 + 24 >> 2] > 32767) {
      HEAP32[$3 + 24 >> 2] = 32767
     }
     $1 = HEAP32[$3 + 24 >> 2];
     $2 = HEAP32[$3 + 92 >> 2];
     HEAP32[$3 + 92 >> 2] = $2 + 1;
     HEAP16[($2 << 1) + $0 >> 1] = $1;
     jsvIteratorNext($3 + 28 | 0);
     continue;
    }
    break;
   };
   if (jsvIteratorHasElement($3 + 28 | 0) & 1) {
    HEAP32[$3 >> 2] = 64;
    jsExceptionHere(1, 3562, $3);
   }
   jsvIteratorFree($3 + 28 | 0);
   if (HEAP8[$3 + 179 | 0] & 1) {
    HEAP32[$3 + 20 >> 2] = HEAP16[(HEAP32[$3 + 92 >> 2] - 2 << 1) + $0 >> 1] << 16 >> 16;
    HEAP32[$3 + 16 >> 2] = HEAP16[(HEAP32[$3 + 92 >> 2] - 1 << 1) + $0 >> 1] << 16 >> 16;
    HEAP32[$3 + 12 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 92 >> 2]) {
      HEAP32[$3 + 8 >> 2] = HEAP16[(HEAP32[$3 + 12 >> 2] << 1) + $0 >> 1] << 16 >> 16;
      HEAP32[$3 + 4 >> 2] = HEAP16[(HEAP32[$3 + 12 >> 2] + 1 << 1) + $0 >> 1] << 16 >> 16;
      graphicsDrawLineAA($3 + 107 | 0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
      HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 8 >> 2];
      HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 4 >> 2];
      HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 2;
      continue;
     }
     break;
    };
   }
   graphicsFillPoly($3 + 107 | 0, HEAP32[$3 + 92 >> 2] / 2 | 0, $0);
   graphicsSetVar($3 + 107 | 0);
   HEAP32[$3 + 188 >> 2] = jsvLockAgain(HEAP32[$3 + 184 >> 2]);
  }
  __stack_pointer = $3 + 192 | 0;
  return HEAP32[$3 + 188 >> 2];
 }
 
 function jswrap_graphics_setRotation($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP8[$3 + 83 | 0] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 11 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   $0 = (HEAPU8[$3 + 19 | 0] | HEAPU8[$3 + 20 | 0] << 8 | (HEAPU8[$3 + 21 | 0] << 16 | HEAPU8[$3 + 22 | 0] << 24)) & -113;
   HEAP8[$3 + 19 | 0] = $0;
   HEAP8[$3 + 20 | 0] = $0 >>> 8;
   HEAP8[$3 + 21 | 0] = $0 >>> 16;
   HEAP8[$3 + 22 | 0] = $0 >>> 24;
   block4 : {
    block3 : {
     switch (HEAP32[$3 + 84 >> 2] - 1 | 0) {
     case 0:
      $0 = HEAPU8[$3 + 19 | 0] | HEAPU8[$3 + 20 | 0] << 8 | (HEAPU8[$3 + 21 | 0] << 16 | HEAPU8[$3 + 22 | 0] << 24) | 48;
      HEAP8[$3 + 19 | 0] = $0;
      HEAP8[$3 + 20 | 0] = $0 >>> 8;
      HEAP8[$3 + 21 | 0] = $0 >>> 16;
      HEAP8[$3 + 22 | 0] = $0 >>> 24;
      break block4;
     case 1:
      $0 = HEAPU8[$3 + 19 | 0] | HEAPU8[$3 + 20 | 0] << 8 | (HEAPU8[$3 + 21 | 0] << 16 | HEAPU8[$3 + 22 | 0] << 24) | 96;
      HEAP8[$3 + 19 | 0] = $0;
      HEAP8[$3 + 20 | 0] = $0 >>> 8;
      HEAP8[$3 + 21 | 0] = $0 >>> 16;
      HEAP8[$3 + 22 | 0] = $0 >>> 24;
      break block4;
     case 2:
      break block3;
     default:
      break block4;
     };
    }
    $0 = HEAPU8[$3 + 19 | 0] | HEAPU8[$3 + 20 | 0] << 8 | (HEAPU8[$3 + 21 | 0] << 16 | HEAPU8[$3 + 22 | 0] << 24) | 80;
    HEAP8[$3 + 19 | 0] = $0;
    HEAP8[$3 + 20 | 0] = $0 >>> 8;
    HEAP8[$3 + 21 | 0] = $0 >>> 16;
    HEAP8[$3 + 22 | 0] = $0 >>> 24;
   }
   if (HEAP8[$3 + 83 | 0] & 1) {
    block5 : {
     if ((HEAPU8[$3 + 19 | 0] | HEAPU8[$3 + 20 | 0] << 8 | (HEAPU8[$3 + 21 | 0] << 16 | HEAPU8[$3 + 22 | 0] << 24)) & 16) {
      $0 = (HEAPU8[$3 + 19 | 0] | HEAPU8[$3 + 20 | 0] << 8 | (HEAPU8[$3 + 21 | 0] << 16 | HEAPU8[$3 + 22 | 0] << 24)) ^ 64;
      HEAP8[$3 + 19 | 0] = $0;
      HEAP8[$3 + 20 | 0] = $0 >>> 8;
      HEAP8[$3 + 21 | 0] = $0 >>> 16;
      HEAP8[$3 + 22 | 0] = $0 >>> 24;
      break block5;
     }
     $0 = (HEAPU8[$3 + 19 | 0] | HEAPU8[$3 + 20 | 0] << 8 | (HEAPU8[$3 + 21 | 0] << 16 | HEAPU8[$3 + 22 | 0] << 24)) ^ 32;
     HEAP8[$3 + 19 | 0] = $0;
     HEAP8[$3 + 20 | 0] = $0 >>> 8;
     HEAP8[$3 + 21 | 0] = $0 >>> 16;
     HEAP8[$3 + 22 | 0] = $0 >>> 24;
    }
   }
   graphicsSetVar($3 + 11 | 0);
   HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_graphics_imageMetrics($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 192 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 184 >> 2] = $0;
  HEAP32[$2 + 180 >> 2] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 108 | 0, HEAP32[$2 + 184 >> 2]) & 1)) {
    HEAP32[$2 + 188 >> 2] = 0;
    break block;
   }
   if (!(_jswrap_graphics_parseImage($2 + 108 | 0, HEAP32[$2 + 180 >> 2], 0, $2 + 24 | 0) & 1)) {
    HEAP32[$2 + 188 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 20 >> 2] = jsvGetLength(HEAP32[$2 + 44 >> 2]) - HEAP32[$2 + 48 >> 2];
   _jswrap_graphics_freeImageInfo($2 + 24 | 0);
   HEAP32[$2 + 16 >> 2] = jsvNewObject();
   if (HEAP32[$2 + 16 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 16247, jsvNewFromInteger(HEAP32[$2 + 24 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 4847, jsvNewFromInteger(HEAP32[$2 + 28 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 14899, jsvNewFromInteger(HEAP32[$2 + 32 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 4622, jsvNewFromBool(HEAP8[$2 + 36 | 0] & 1));
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] / HEAPU16[$2 + 74 >> 1];
    if (HEAP32[$2 + 12 >> 2] > 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], 7286, jsvNewFromInteger(HEAP32[$2 + 12 >> 2]))
    }
   }
   HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 16 >> 2];
  }
  __stack_pointer = $2 + 192 | 0;
  return HEAP32[$2 + 188 >> 2];
 }
 
 function jswrap_graphics_drawImage($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0, $6 = 0.0;
  $5 = __stack_pointer - 816 | 0;
  __stack_pointer = $5;
  HEAP32[$5 + 808 >> 2] = $0;
  HEAP32[$5 + 804 >> 2] = $1;
  HEAP32[$5 + 800 >> 2] = $2;
  HEAP32[$5 + 796 >> 2] = $3;
  HEAP32[$5 + 792 >> 2] = $4;
  block : {
   if (!(graphicsGetFromVar($5 + 720 | 0, HEAP32[$5 + 808 >> 2]) & 1)) {
    HEAP32[$5 + 812 >> 2] = 0;
    break block;
   }
   if (!(_jswrap_graphics_parseImage($5 + 720 | 0, HEAP32[$5 + 804 >> 2], 0, $5 + 636 | 0) & 1)) {
    HEAP32[$5 + 812 >> 2] = 0;
    break block;
   }
   HEAPF64[$5 + 624 >> 3] = 1;
   HEAPF64[$5 + 616 >> 3] = 0;
   HEAP8[$5 + 615 | 0] = 0;
   HEAP8[$5 + 614 | 0] = 0;
   if (jsvIsObject(HEAP32[$5 + 792 >> 2]) & 1) {
    HEAP32[$5 + 608 >> 2] = jsvObjectGetIntegerChild(HEAP32[$5 + 792 >> 2], 17824);
    if (HEAP32[$5 + 608 >> 2] > 0) {
     HEAP32[$5 + 660 >> 2] = HEAP32[$5 + 660 >> 2] + Math_imul(HEAPU16[$5 + 686 >> 1], HEAP32[$5 + 608 >> 2])
    }
    HEAPF64[$5 + 624 >> 3] = jsvObjectGetFloatChild(HEAP32[$5 + 792 >> 2], 18030);
    $0 = __DOUBLE_BITS_1945(HEAPF64[$5 + 624 >> 3]);
    $2 = $0;
    $1 = i64toi32_i32$HIGH_BITS;
    $0 = $1 & 2147483647;
    block2 : {
     if (!(($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072)) {
      if (!(HEAPF64[$5 + 624 >> 3] <= 0.0)) {
       break block2
      }
     }
     HEAPF64[$5 + 624 >> 3] = 1;
    }
    HEAPF64[$5 + 616 >> 3] = jsvObjectGetFloatChild(HEAP32[$5 + 792 >> 2], 17552);
    $1 = __DOUBLE_BITS_1945(HEAPF64[$5 + 616 >> 3]);
    $2 = $1;
    $0 = i64toi32_i32$HIGH_BITS;
    $1 = $0 & 2147483647;
    HEAP8[$5 + 615 | 0] = $1 >>> 0 < 2146435072;
    if (!(HEAP8[$5 + 615 | 0] & 1)) {
     HEAPF64[$5 + 616 >> 3] = 0
    }
    HEAP8[$5 + 614 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 792 >> 2], 7935) & 1;
   }
   HEAP32[$5 + 604 >> 2] = 0;
   HEAP32[$5 + 600 >> 2] = 0;
   HEAP32[$5 + 596 >> 2] = 0;
   jsvStringIteratorNew($5 + 552 | 0, HEAP32[$5 + 656 >> 2], HEAP32[$5 + 660 >> 2]);
   block4 : {
    if (!(HEAP8[$5 + 615 | 0] & 1 | (HEAPF64[$5 + 624 >> 3] != 1.0 | HEAPF64[$5 + 616 >> 3] != 0.0))) {
     _jswrap_drawImageSimple($5 + 720 | 0, HEAP32[$5 + 800 >> 2], HEAP32[$5 + 796 >> 2], $5 + 636 | 0, $5 + 552 | 0, 0);
     break block4;
    }
    $0 = 0;
    block5 : {
     if (HEAP8[$5 + 615 | 0] & 1) {
      break block5
     }
     $0 = 0;
     if (HEAPF64[$5 + 624 >> 3] - Math_floor(HEAPF64[$5 + 624 >> 3]) != 0.0) {
      break block5
     }
     $0 = !((HEAPU8[$5 + 728 | 0] | HEAPU8[$5 + 729 | 0] << 8 | (HEAPU8[$5 + 730 | 0] << 16 | HEAPU8[$5 + 731 | 0] << 24)) & 112);
    }
    HEAP8[$5 + 551 | 0] = $0;
    block9 : {
     if (HEAP8[$5 + 551 | 0] & 1) {
      $6 = HEAPF64[$5 + 624 >> 3];
      if (Math_abs($6) < 2147483647.0) {
       $0 = ~~$6
      } else {
       $0 = -2147483648
      }
      HEAP32[$5 + 544 >> 2] = $0;
      HEAP32[$5 + 540 >> 2] = 0;
      HEAP32[$5 + 536 >> 2] = HEAP32[$5 + 796 >> 2];
      HEAP32[$5 + 600 >> 2] = 0;
      while (1) {
       if (HEAP32[$5 + 600 >> 2] < HEAP32[$5 + 640 >> 2]) {
        HEAP32[$5 + 532 >> 2] = jsvStringIteratorGetIndex_1962($5 + 552 | 0);
        HEAP32[$5 + 528 >> 2] = HEAP32[$5 + 540 >> 2];
        HEAP32[$5 + 524 >> 2] = HEAP32[$5 + 596 >> 2];
        HEAP32[$5 + 520 >> 2] = 0;
        while (1) {
         if (HEAP32[$5 + 520 >> 2] < HEAP32[$5 + 544 >> 2]) {
          if (HEAP32[$5 + 520 >> 2]) {
           jsvStringIteratorGoto($5 + 552 | 0, HEAP32[$5 + 656 >> 2], HEAP32[$5 + 532 >> 2]);
           HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 528 >> 2];
           HEAP32[$5 + 596 >> 2] = HEAP32[$5 + 524 >> 2];
          }
          HEAP32[$5 + 516 >> 2] = HEAP32[$5 + 800 >> 2];
          HEAP32[$5 + 604 >> 2] = 0;
          while (1) {
           if (HEAP32[$5 + 604 >> 2] < HEAP32[$5 + 636 >> 2]) {
            while (1) {
             if (HEAP32[$5 + 540 >> 2] < HEAP32[$5 + 644 >> 2]) {
              HEAP32[$5 + 596 >> 2] = HEAP32[$5 + 596 >> 2] << 8 | jsvStringIteratorGetCharAndNext($5 + 552 | 0) & 255;
              HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 540 >> 2] + 8;
              continue;
             }
             break;
            };
            HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 672 >> 2] & HEAP32[$5 + 596 >> 2] >>> HEAP32[$5 + 540 >> 2] - HEAP32[$5 + 644 >> 2];
            HEAP32[$5 + 540 >> 2] = HEAP32[$5 + 540 >> 2] - HEAP32[$5 + 644 >> 2];
            block8 : {
             if (!(HEAP32[$5 + 652 >> 2] == HEAP32[$5 + 512 >> 2] | HEAP32[$5 + 536 >> 2] < (HEAPU8[$5 + 754 | 0] | HEAPU8[$5 + 755 | 0] << 8) | HEAP32[$5 + 536 >> 2] > (HEAPU8[$5 + 758 | 0] | HEAPU8[$5 + 759 | 0] << 8))) {
              if (HEAP32[$5 + 664 >> 2]) {
               HEAP32[$5 + 512 >> 2] = HEAPU16[HEAP32[$5 + 664 >> 2] + ((HEAP32[$5 + 512 >> 2] & HEAP32[$5 + 668 >> 2]) << 1) >> 1]
              }
              HEAP32[$5 + 508 >> 2] = 0;
              while (1) {
               if (HEAP32[$5 + 508 >> 2] < HEAP32[$5 + 544 >> 2]) {
                if (!(HEAP32[$5 + 516 >> 2] < (HEAPU8[$5 + 752 | 0] | HEAPU8[$5 + 753 | 0] << 8) | HEAP32[$5 + 516 >> 2] > (HEAPU8[$5 + 756 | 0] | HEAPU8[$5 + 757 | 0] << 8))) {
                 FUNCTION_TABLE[HEAPU8[$5 + 772 | 0] | HEAPU8[$5 + 773 | 0] << 8 | (HEAPU8[$5 + 774 | 0] << 16 | HEAPU8[$5 + 775 | 0] << 24)]($5 + 720 | 0, HEAP32[$5 + 516 >> 2], HEAP32[$5 + 536 >> 2], HEAP32[$5 + 512 >> 2])
                }
                HEAP32[$5 + 516 >> 2] = HEAP32[$5 + 516 >> 2] + 1;
                HEAP32[$5 + 508 >> 2] = HEAP32[$5 + 508 >> 2] + 1;
                continue;
               }
               break;
              };
              break block8;
             }
             HEAP32[$5 + 516 >> 2] = HEAP32[$5 + 544 >> 2] + HEAP32[$5 + 516 >> 2];
            }
            HEAP32[$5 + 604 >> 2] = HEAP32[$5 + 604 >> 2] + 1;
            continue;
           }
           break;
          };
          HEAP32[$5 + 536 >> 2] = HEAP32[$5 + 536 >> 2] + 1;
          HEAP32[$5 + 520 >> 2] = HEAP32[$5 + 520 >> 2] + 1;
          continue;
         }
         break;
        };
        HEAP32[$5 + 600 >> 2] = HEAP32[$5 + 600 >> 2] + 1;
        continue;
       }
       break;
      };
      HEAP32[$5 + 504 >> 2] = HEAP32[$5 + 800 >> 2];
      HEAP32[$5 + 500 >> 2] = HEAP32[$5 + 796 >> 2];
      HEAP32[$5 + 496 >> 2] = HEAP32[$5 + 800 >> 2] + Math_imul(HEAP32[$5 + 544 >> 2], HEAP32[$5 + 636 >> 2]);
      HEAP32[$5 + 492 >> 2] = HEAP32[$5 + 796 >> 2] + Math_imul(HEAP32[$5 + 544 >> 2], HEAP32[$5 + 640 >> 2]);
      graphicsSetModifiedAndClip($5 + 720 | 0, $5 + 504 | 0, $5 + 500 | 0, $5 + 496 | 0, $5 + 492 | 0, 0);
      break block9;
     }
     HEAP32[$5 + 288 >> 2] = HEAP32[$5 + 800 >> 2] << 8;
     HEAP32[$5 + 292 >> 2] = HEAP32[$5 + 796 >> 2] << 8;
     wasm2js_memory_copy($5 + 324 | 0, $5 + 636 | 0, 84);
     $1 = HEAP32[$5 + 556 >> 2];
     $0 = HEAP32[$5 + 552 >> 2];
     $3 = $0;
     $2 = $5 + 288 | 0;
     $0 = $2;
     HEAP32[$0 + 120 >> 2] = $3;
     HEAP32[$0 + 124 >> 2] = $1;
     $0 = HEAP32[$5 + 588 >> 2];
     $1 = HEAP32[$5 + 584 >> 2];
     $3 = $1;
     $1 = $2;
     HEAP32[$1 + 152 >> 2] = $3;
     HEAP32[$1 + 156 >> 2] = $0;
     $1 = HEAP32[$5 + 580 >> 2];
     $0 = HEAP32[$5 + 576 >> 2];
     $3 = $0;
     $0 = $2;
     HEAP32[$0 + 144 >> 2] = $3;
     HEAP32[$0 + 148 >> 2] = $1;
     $0 = HEAP32[$5 + 572 >> 2];
     $1 = HEAP32[$5 + 568 >> 2];
     $3 = $1;
     $1 = $2;
     HEAP32[$1 + 136 >> 2] = $3;
     HEAP32[$1 + 140 >> 2] = $0;
     $1 = HEAP32[$5 + 564 >> 2];
     $0 = HEAP32[$5 + 560 >> 2];
     $3 = $0;
     $0 = $2;
     HEAP32[$0 + 128 >> 2] = $3;
     HEAP32[$0 + 132 >> 2] = $1;
     HEAPF64[$5 + 304 >> 3] = HEAPF64[$5 + 616 >> 3];
     HEAPF64[$5 + 312 >> 3] = HEAPF64[$5 + 624 >> 3];
     HEAP8[$5 + 320 | 0] = HEAP8[$5 + 615 | 0] & 1;
     HEAP8[$5 + 321 | 0] = 0;
     _jswrap_drawImageLayerInit($5 + 288 | 0);
     HEAP32[$5 + 284 >> 2] = HEAP32[$5 + 288 >> 2] >> 8;
     HEAP32[$5 + 280 >> 2] = HEAP32[$5 + 292 >> 2] >> 8;
     HEAP32[$5 + 276 >> 2] = (HEAP32[$5 + 296 >> 2] >> 8) - 1;
     HEAP32[$5 + 272 >> 2] = (HEAP32[$5 + 300 >> 2] >> 8) - 1;
     graphicsSetModifiedAndClip($5 + 720 | 0, $5 + 284 | 0, $5 + 280 | 0, $5 + 276 | 0, $5 + 272 | 0, 0);
     _jswrap_drawImageLayerSetStart($5 + 288 | 0, HEAP32[$5 + 284 >> 2], HEAP32[$5 + 280 >> 2]);
     HEAP32[$5 + 268 >> 2] = graphicsGetSetPixelFn($5 + 720 | 0);
     block11 : {
      if (!(!(HEAP8[$5 + 614 | 0] & 1) | !(HEAPF64[$5 + 624 >> 3] < .75))) {
       $6 = +HEAP32[$5 + 456 >> 2] * HEAPF64[$5 + 624 >> 3];
       if (Math_abs($6) < 2147483647.0) {
        $0 = ~~$6
       } else {
        $0 = -2147483648
       }
       HEAP32[$5 + 264 >> 2] = $0;
       $6 = +HEAP32[$5 + 460 >> 2] * HEAPF64[$5 + 624 >> 3];
       if (Math_abs($6) < 2147483647.0) {
        $0 = ~~$6
       } else {
        $0 = -2147483648
       }
       HEAP32[$5 + 260 >> 2] = $0;
       HEAP32[$5 + 256 >> 2] = HEAP32[$5 + 456 >> 2] - HEAP32[$5 + 264 >> 2];
       HEAP32[$5 + 252 >> 2] = HEAP32[$5 + 460 >> 2] - HEAP32[$5 + 260 >> 2];
       wasm2js_memory_copy($5 + 48 | 0, $5 + 288 | 0, 200);
       jsvStringIteratorNew($5 + 168 | 0, HEAP32[$5 + 104 >> 2], 0);
       HEAP32[$5 + 224 >> 2] = HEAP32[$5 + 260 >> 2] + HEAP32[$5 + 224 >> 2];
       HEAP32[$5 + 228 >> 2] = HEAP32[$5 + 264 >> 2] + HEAP32[$5 + 228 >> 2];
       _jswrap_drawImageLayerNextY($5 + 48 | 0);
       HEAP32[$5 + 600 >> 2] = HEAP32[$5 + 280 >> 2];
       while (1) {
        if (HEAP32[$5 + 600 >> 2] <= HEAP32[$5 + 272 >> 2]) {
         _jswrap_drawImageLayerStartX($5 + 288 | 0);
         _jswrap_drawImageLayerStartX($5 + 48 | 0);
         HEAP32[$5 + 604 >> 2] = HEAP32[$5 + 284 >> 2];
         while (1) {
          if (HEAP32[$5 + 604 >> 2] <= HEAP32[$5 + 276 >> 2]) {
           HEAP8[$5 + 31 | 0] = 1;
           HEAP8[$5 + 31 | 0] = _jswrap_drawImageLayerGetPixel($5 + 288 | 0, $5 + 44 | 0) & 1 & (HEAP8[$5 + 31 | 0] & 1);
           HEAP32[$5 + 472 >> 2] = HEAP32[$5 + 264 >> 2] + HEAP32[$5 + 472 >> 2];
           HEAP32[$5 + 476 >> 2] = HEAP32[$5 + 476 >> 2] - HEAP32[$5 + 260 >> 2];
           HEAP8[$5 + 31 | 0] = _jswrap_drawImageLayerGetPixel($5 + 288 | 0, $5 + 40 | 0) & 1 & (HEAP8[$5 + 31 | 0] & 1);
           HEAP32[$5 + 472 >> 2] = HEAP32[$5 + 256 >> 2] + HEAP32[$5 + 472 >> 2];
           HEAP32[$5 + 476 >> 2] = HEAP32[$5 + 476 >> 2] - HEAP32[$5 + 252 >> 2];
           HEAP8[$5 + 31 | 0] = _jswrap_drawImageLayerGetPixel($5 + 48 | 0, $5 + 36 | 0) & 1 & (HEAP8[$5 + 31 | 0] & 1);
           HEAP32[$5 + 232 >> 2] = HEAP32[$5 + 264 >> 2] + HEAP32[$5 + 232 >> 2];
           HEAP32[$5 + 236 >> 2] = HEAP32[$5 + 236 >> 2] - HEAP32[$5 + 260 >> 2];
           HEAP8[$5 + 31 | 0] = _jswrap_drawImageLayerGetPixel($5 + 48 | 0, $5 + 32 | 0) & 1 & (HEAP8[$5 + 31 | 0] & 1);
           HEAP32[$5 + 232 >> 2] = HEAP32[$5 + 256 >> 2] + HEAP32[$5 + 232 >> 2];
           HEAP32[$5 + 236 >> 2] = HEAP32[$5 + 236 >> 2] - HEAP32[$5 + 252 >> 2];
           HEAP32[$5 + 44 >> 2] = graphicsBlendColor($5 + 720 | 0, HEAP32[$5 + 44 >> 2], HEAP32[$5 + 40 >> 2], 128);
           HEAP32[$5 + 36 >> 2] = graphicsBlendColor($5 + 720 | 0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2], 128);
           HEAP32[$5 + 596 >> 2] = graphicsBlendColor($5 + 720 | 0, HEAP32[$5 + 44 >> 2], HEAP32[$5 + 36 >> 2], 128);
           FUNCTION_TABLE[HEAP32[$5 + 268 >> 2]]($5 + 720 | 0, HEAP32[$5 + 604 >> 2], HEAP32[$5 + 600 >> 2], HEAP32[$5 + 596 >> 2]);
           HEAP32[$5 + 604 >> 2] = HEAP32[$5 + 604 >> 2] + 1;
           continue;
          }
          break;
         };
         _jswrap_drawImageLayerNextY($5 + 288 | 0);
         _jswrap_drawImageLayerNextY($5 + 48 | 0);
         HEAP32[$5 + 600 >> 2] = HEAP32[$5 + 600 >> 2] + 1;
         continue;
        }
        break;
       };
       jsvStringIteratorFree_1906($5 + 168 | 0);
       break block11;
      }
      HEAP32[$5 + 600 >> 2] = HEAP32[$5 + 280 >> 2];
      while (1) {
       if (HEAP32[$5 + 600 >> 2] <= HEAP32[$5 + 272 >> 2]) {
        _jswrap_drawImageLayerStartX($5 + 288 | 0);
        HEAP32[$5 + 604 >> 2] = HEAP32[$5 + 284 >> 2];
        while (1) {
         if (HEAP32[$5 + 604 >> 2] <= HEAP32[$5 + 276 >> 2]) {
          if (_jswrap_drawImageLayerGetPixel($5 + 288 | 0, $5 + 596 | 0) & 1) {
           FUNCTION_TABLE[HEAP32[$5 + 268 >> 2]]($5 + 720 | 0, HEAP32[$5 + 604 >> 2], HEAP32[$5 + 600 >> 2], HEAP32[$5 + 596 >> 2])
          }
          _jswrap_drawImageLayerNextX($5 + 288 | 0);
          HEAP32[$5 + 604 >> 2] = HEAP32[$5 + 604 >> 2] + 1;
          continue;
         }
         break;
        };
        _jswrap_drawImageLayerNextY($5 + 288 | 0);
        HEAP32[$5 + 600 >> 2] = HEAP32[$5 + 600 >> 2] + 1;
        continue;
       }
       break;
      };
     }
     $2 = $5 + 288 | 0;
     $1 = HEAP32[$2 + 152 >> 2];
     $0 = HEAP32[$2 + 156 >> 2];
     HEAP32[$5 + 584 >> 2] = $1;
     HEAP32[$5 + 588 >> 2] = $0;
     $1 = HEAP32[$2 + 148 >> 2];
     $0 = HEAP32[$2 + 144 >> 2];
     HEAP32[$5 + 576 >> 2] = $0;
     HEAP32[$5 + 580 >> 2] = $1;
     $0 = HEAP32[$2 + 140 >> 2];
     $1 = HEAP32[$2 + 136 >> 2];
     HEAP32[$5 + 568 >> 2] = $1;
     HEAP32[$5 + 572 >> 2] = $0;
     $1 = HEAP32[$2 + 132 >> 2];
     $0 = HEAP32[$2 + 128 >> 2];
     HEAP32[$5 + 560 >> 2] = $0;
     HEAP32[$5 + 564 >> 2] = $1;
     $0 = HEAP32[$2 + 124 >> 2];
     $1 = HEAP32[$2 + 120 >> 2];
     HEAP32[$5 + 552 >> 2] = $1;
     HEAP32[$5 + 556 >> 2] = $0;
    }
   }
   jsvStringIteratorFree_1906($5 + 552 | 0);
   _jswrap_graphics_freeImageInfo($5 + 636 | 0);
   graphicsSetVar($5 + 720 | 0);
   HEAP32[$5 + 812 >> 2] = jsvLockAgain(HEAP32[$5 + 808 >> 2]);
  }
  __stack_pointer = $5 + 816 | 0;
  return HEAP32[$5 + 812 >> 2];
 }
 
 function jswrap_graphics_drawImages($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer - 288 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 280 >> 2] = $0;
  HEAP32[$3 + 276 >> 2] = $1;
  HEAP32[$3 + 272 >> 2] = $2;
  HEAP32[$3 + 268 >> 2] = 4;
  block : {
   if (!(graphicsGetFromVar($3 + 196 | 0, HEAP32[$3 + 280 >> 2]) & 1)) {
    HEAP32[$3 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 192 >> 2] = $3;
   $2 = $3 - 800 | 0;
   __stack_pointer = $2;
   block2 : {
    block1 : {
     if (jsvIsArray(HEAP32[$3 + 276 >> 2]) & 1) {
      $0 = jsvGetArrayLength(HEAP32[$3 + 276 >> 2]);
      HEAP32[$3 + 184 >> 2] = $0;
      if (($0 | 0) <= 4) {
       break block1
      }
     }
     HEAP32[$3 + 48 >> 2] = 4;
     jsExceptionHere(3, 7309, $3 + 48 | 0);
     HEAP32[$3 + 284 >> 2] = 0;
     break block2;
    }
    HEAP32[$3 + 176 >> 2] = 1e4;
    HEAP32[$3 + 172 >> 2] = 1e4;
    HEAP32[$3 + 168 >> 2] = 1e4;
    HEAP32[$3 + 164 >> 2] = 1e4;
    HEAP8[$3 + 163 | 0] = 1;
    HEAP32[$3 + 188 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 184 >> 2]) {
      HEAP32[$3 + 156 >> 2] = jsvGetArrayItem(HEAP32[$3 + 276 >> 2], HEAP32[$3 + 188 >> 2]);
      block11 : {
       if (jsvIsObject(HEAP32[$3 + 156 >> 2]) & 1) {
        HEAP32[$3 + 152 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 156 >> 2], 18124);
        block10 : {
         if (_jswrap_graphics_parseImage($3 + 196 | 0, HEAP32[$3 + 152 >> 2], 0, (Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 36 | 0) & 1) {
          $4 = jsvObjectGetFloatChild(HEAP32[$3 + 156 >> 2], 3934) * 256.0;
          if (Math_abs($4) < 2147483647.0) {
           $0 = ~~$4
          } else {
           $0 = -2147483648
          }
          HEAP32[Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 >> 2] = $0;
          $4 = jsvObjectGetFloatChild(HEAP32[$3 + 156 >> 2], 3805) * 256.0;
          if (Math_abs($4) < 2147483647.0) {
           $0 = ~~$4
          } else {
           $0 = -2147483648
          }
          HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 4 >> 2] = $0;
          $4 = jsvObjectGetFloatChild(HEAP32[$3 + 156 >> 2], 18030);
          HEAPF64[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 24 >> 3] = $4;
          $0 = __DOUBLE_BITS_1945(HEAPF64[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 24 >> 3]);
          $1 = $0;
          $0 = i64toi32_i32$HIGH_BITS;
          $0 = $0 & 2147483647;
          block4 : {
           if (!(($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072)) {
            if (!(HEAPF64[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 24 >> 3] <= 0.0)) {
             break block4
            }
           }
           HEAPF64[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 24 >> 3] = 1;
          }
          $4 = jsvObjectGetFloatChild(HEAP32[$3 + 156 >> 2], 17552);
          HEAPF64[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 16 >> 3] = $4;
          $0 = __DOUBLE_BITS_1945(HEAPF64[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 16 >> 3]);
          $1 = $0;
          $0 = i64toi32_i32$HIGH_BITS;
          $0 = $0 & 2147483647;
          if (($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072) {
           HEAPF64[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 16 >> 3] = 0
          }
          $0 = jsvObjectGetBoolChild(HEAP32[$3 + 156 >> 2], 7920);
          HEAP8[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 32 | 0] = $0 & 1;
          $0 = jsvObjectGetBoolChild(HEAP32[$3 + 156 >> 2], 5042);
          HEAP8[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 33 | 0] = $0 & 1;
          _jswrap_drawImageLayerInit(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0);
          if (!(jsvObjectGetBoolChild(HEAP32[$3 + 156 >> 2], 7505) & 1)) {
           if (HEAP32[$3 + 176 >> 2] > HEAP32[Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 >> 2] >> 8) {
            HEAP32[$3 + 176 >> 2] = HEAP32[Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 >> 2] >> 8
           }
           if (HEAP32[$3 + 172 >> 2] > HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 4 >> 2] >> 8) {
            HEAP32[$3 + 172 >> 2] = HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 4 >> 2] >> 8
           }
           if ((HEAP32[$3 + 176 >> 2] + HEAP32[$3 + 168 >> 2] | 0) < HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 8 >> 2] + 255 >> 8) {
            HEAP32[$3 + 168 >> 2] = (HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 8 >> 2] + 255 >> 8) - HEAP32[$3 + 176 >> 2]
           }
           if ((HEAP32[$3 + 172 >> 2] + HEAP32[$3 + 164 >> 2] | 0) < HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 12 >> 2] + 255 >> 8) {
            HEAP32[$3 + 164 >> 2] = (HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 12 >> 2] + 255 >> 8) - HEAP32[$3 + 172 >> 2]
           }
          }
          HEAP32[$3 + 148 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 156 >> 2], 17485);
          if (HEAP32[$3 + 148 >> 2]) {
           jsvUnLock(_jswrap_graphics_parseImage_palette((Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 36 | 0, HEAP32[$3 + 148 >> 2]));
           if (!HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 64 >> 2]) {
            HEAP8[$3 + 163 | 0] = 0
           }
          }
          HEAP32[$3 + 144 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 156 >> 2], 17652);
          HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 192 >> 2] = 0;
          block6 : {
           block5 : {
            if (HEAP32[$3 + 144 >> 2]) {
             if (!(jsvIsEmptyString(HEAP32[$3 + 144 >> 2]) & 1)) {
              break block5
             }
            }
            HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 192 >> 2] = 0;
            break block6;
           }
           block7 : {
            if (jsvIsStringEqual(HEAP32[$3 + 144 >> 2], 19274) & 1) {
             HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 192 >> 2] = 1;
             break block7;
            }
            block8 : {
             if (jsvIsStringEqual(HEAP32[$3 + 144 >> 2], 7897) & 1) {
              HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 192 >> 2] = 2;
              break block8;
             }
             block9 : {
              if (jsvIsStringEqual(HEAP32[$3 + 144 >> 2], 7705) & 1) {
               HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 192 >> 2] = 3;
               break block9;
              }
              HEAP32[$3 >> 2] = HEAP32[$3 + 144 >> 2];
              jsExceptionHere(1, 14724, $3);
              HEAP8[$3 + 163 | 0] = 0;
             }
            }
           }
          }
          jsvUnLock(HEAP32[$3 + 144 >> 2]);
          break block10;
         }
         HEAP8[$3 + 163 | 0] = 0;
        }
        jsvUnLock(HEAP32[$3 + 152 >> 2]);
        break block11;
       }
       HEAP8[$3 + 163 | 0] = 0;
      }
      jsvUnLock(HEAP32[$3 + 156 >> 2]);
      HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$3 + 96 >> 2] = 3934;
    HEAP16[$3 + 100 >> 1] = 10;
    HEAP16[($3 + 96 | 0) + 6 >> 1] = 0;
    HEAP32[$3 + 104 >> 2] = $3 + 176;
    HEAP32[$3 + 108 >> 2] = 3805;
    HEAP16[$3 + 112 >> 1] = 10;
    HEAP16[($3 + 96 | 0) + 18 >> 1] = 0;
    HEAP32[$3 + 116 >> 2] = $3 + 172;
    HEAP32[$3 + 120 >> 2] = 16247;
    HEAP16[$3 + 124 >> 1] = 10;
    HEAP16[($3 + 96 | 0) + 30 >> 1] = 0;
    HEAP32[$3 + 128 >> 2] = $3 + 168;
    HEAP32[$3 + 132 >> 2] = 4847;
    HEAP16[$3 + 136 >> 1] = 10;
    HEAP16[($3 + 96 | 0) + 42 >> 1] = 0;
    HEAP32[$3 + 140 >> 2] = $3 + 164;
    if (!(jsvReadConfigObject(HEAP32[$3 + 272 >> 2], $3 + 96 | 0, 4) & 1)) {
     HEAP8[$3 + 163 | 0] = 0
    }
    HEAP32[$3 + 92 >> 2] = (HEAP32[$3 + 176 >> 2] + HEAP32[$3 + 168 >> 2] | 0) - 1;
    HEAP32[$3 + 88 >> 2] = (HEAP32[$3 + 172 >> 2] + HEAP32[$3 + 164 >> 2] | 0) - 1;
    graphicsSetModifiedAndClip($3 + 196 | 0, $3 + 176 | 0, $3 + 172 | 0, $3 + 92 | 0, $3 + 88 | 0, 0);
    HEAP32[$3 + 84 >> 2] = graphicsGetSetPixelFn($3 + 196 | 0);
    if (HEAP8[$3 + 163 | 0] & 1) {
     HEAP32[$3 + 80 >> 2] = (1 << HEAPU8[$3 + 212 | 0]) - 1;
     HEAP32[$3 + 188 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 184 >> 2]) {
       jsvStringIteratorNew((Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 120 | 0, HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 56 >> 2], HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 60 >> 2]);
       _jswrap_drawImageLayerSetStart(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0, HEAP32[$3 + 176 >> 2], HEAP32[$3 + 172 >> 2]);
       HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 172 >> 2];
     while (1) {
      if (HEAP32[$3 + 76 >> 2] <= HEAP32[$3 + 88 >> 2]) {
       HEAP32[$3 + 188 >> 2] = 0;
       while (1) {
        if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 184 >> 2]) {
         _jswrap_drawImageLayerStartX(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0);
         HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
         continue;
        }
        break;
       };
       HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 176 >> 2];
       while (1) {
        if (HEAP32[$3 + 72 >> 2] <= HEAP32[$3 + 92 >> 2]) {
         HEAP8[$3 + 71 | 0] = 0;
         HEAP32[$3 + 64 >> 2] = 0;
         HEAP32[$3 + 188 >> 2] = 0;
         while (1) {
          if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 184 >> 2]) {
           if (_jswrap_drawImageLayerGetPixel(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0, $3 + 60 | 0) & 1) {
            HEAP8[$3 + 71 | 0] = 1;
            if (!(HEAP32[$3 + 188 >> 2] | !HEAP32[$2 + 192 >> 2])) {
             HEAP32[$3 + 64 >> 2] = graphicsGetPixel($3 + 196 | 0, HEAP32[$3 + 72 >> 2], HEAP32[$3 + 76 >> 2])
            }
            block17 : {
             block16 : {
              switch (HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 192 >> 2]) {
              case 0:
               HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2];
               break block17;
              case 1:
               HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 64 >> 2];
               if (HEAPU32[$3 + 64 >> 2] > HEAPU32[$3 + 80 >> 2]) {
                HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 80 >> 2]
               }
               break block17;
              case 2:
               HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2] | HEAP32[$3 + 64 >> 2];
               break block17;
              case 3:
               break block16;
              default:
               break block17;
              };
             }
             HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2] ^ HEAP32[$3 + 64 >> 2];
            }
           }
           _jswrap_drawImageLayerNextX(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0);
           _jswrap_drawImageLayerNextXRepeat(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0);
           HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
           continue;
          }
          break;
         };
         if (HEAP8[$3 + 71 | 0] & 1) {
          FUNCTION_TABLE[HEAP32[$3 + 84 >> 2]]($3 + 196 | 0, HEAP32[$3 + 72 >> 2], HEAP32[$3 + 76 >> 2], HEAP32[$3 + 64 >> 2])
         }
         HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 72 >> 2] + 1;
         continue;
        }
        break;
       };
       HEAP32[$3 + 188 >> 2] = 0;
       while (1) {
        if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 184 >> 2]) {
         _jswrap_drawImageLayerNextY(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0);
         HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
         continue;
        }
        break;
       };
       HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP32[$3 + 188 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 184 >> 2]) {
       jsvStringIteratorFree_1906((Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 120 | 0);
       HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
       continue;
      }
      break;
     };
    }
    HEAP32[$3 + 188 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 188 >> 2] < HEAP32[$3 + 184 >> 2]) {
      jsvUnLock(HEAP32[(Math_imul(HEAP32[$3 + 188 >> 2], 200) + $2 | 0) + 56 >> 2]);
      HEAP32[$3 + 188 >> 2] = HEAP32[$3 + 188 >> 2] + 1;
      continue;
     }
     break;
    };
    HEAP32[$3 + 284 >> 2] = jsvLockAgain(HEAP32[$3 + 280 >> 2]);
   }
   HEAP32[$3 + 180 >> 2] = 1;
  }
  __stack_pointer = $3 + 288 | 0;
  return HEAP32[$3 + 284 >> 2];
 }
 
 function jswrap_graphics_asImage($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 288 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 280 >> 2] = $0;
  HEAP32[$2 + 276 >> 2] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 204 | 0, HEAP32[$2 + 280 >> 2]) & 1)) {
    HEAP32[$2 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 196 >> 2] = jswrap_graphics_getWidthOrHeight(HEAP32[$2 + 280 >> 2], 0);
   HEAP32[$2 + 192 >> 2] = jswrap_graphics_getWidthOrHeight(HEAP32[$2 + 280 >> 2], 1);
   HEAP32[$2 + 188 >> 2] = 0;
   HEAP32[$2 + 184 >> 2] = 0;
   HEAP32[$2 + 180 >> 2] = HEAP32[$2 + 196 >> 2];
   HEAP32[$2 + 176 >> 2] = HEAP32[$2 + 192 >> 2];
   block1 : {
    if (jsvIsObject(HEAP32[$2 + 276 >> 2]) & 1) {
     HEAP32[$2 + 172 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 276 >> 2], 17778);
     HEAP32[$2 + 188 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 276 >> 2], 3934);
     HEAP32[$2 + 184 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 276 >> 2], 3805);
     HEAP32[$2 + 168 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 276 >> 2], 4131);
     if (HEAP32[$2 + 168 >> 2]) {
      HEAP32[$2 + 180 >> 2] = HEAP32[$2 + 168 >> 2]
     }
     HEAP32[$2 + 168 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 276 >> 2], 16557);
     if (HEAP32[$2 + 168 >> 2]) {
      HEAP32[$2 + 176 >> 2] = HEAP32[$2 + 168 >> 2]
     }
     break block1;
    }
    HEAP32[$2 + 172 >> 2] = jsvLockAgainSafe(HEAP32[$2 + 276 >> 2]);
   }
   block3 : {
    block2 : {
     if (!(jsvIsUndefined(HEAP32[$2 + 172 >> 2]) & 1)) {
      if (!(jsvIsStringEqual(HEAP32[$2 + 172 >> 2], 4998) & 1)) {
       break block2
      }
     }
     HEAP8[$2 + 203 | 0] = 1;
     break block3;
    }
    block4 : {
     if (jsvIsStringEqual(HEAP32[$2 + 172 >> 2], 16684) & 1) {
      HEAP8[$2 + 203 | 0] = 0;
      break block4;
     }
     HEAP32[$2 >> 2] = HEAP32[$2 + 172 >> 2];
     jsExceptionHere(1, 16126, $2);
     jsvUnLock(HEAP32[$2 + 172 >> 2]);
     HEAP32[$2 + 284 >> 2] = 0;
     break block;
    }
   }
   jsvUnLock(HEAP32[$2 + 172 >> 2]);
   HEAP32[$2 + 164 >> 2] = HEAPU8[$2 + 220 | 0];
   HEAP32[$2 + 160 >> 2] = 1 << HEAP32[$2 + 164 >> 2];
   if ((HEAPU8[$2 + 208 | 0] | HEAPU8[$2 + 209 | 0] << 8 | (HEAPU8[$2 + 210 | 0] << 16 | HEAPU8[$2 + 211 | 0] << 24)) == 6) {
    HEAP32[$2 + 164 >> 2] = 3
   }
   HEAP32[$2 + 156 >> 2] = Math_imul(HEAP32[$2 + 164 >> 2], Math_imul(HEAP32[$2 + 180 >> 2], HEAP32[$2 + 176 >> 2])) + 7 >> 3;
   HEAP32[$2 + 152 >> 2] = -1;
   HEAP32[$2 + 148 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 280 >> 2], 4622);
   if (HEAP32[$2 + 148 >> 2]) {
    HEAP32[$2 + 152 >> 2] = jsvGetIntegerAndUnLock(HEAP32[$2 + 148 >> 2])
   }
   HEAP32[$2 + 144 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 280 >> 2], 17485);
   block5 : {
    if (jsvIsArray(HEAP32[$2 + 144 >> 2]) & 1) {
     break block5
    }
    if (jsvIsArrayBuffer(HEAP32[$2 + 144 >> 2]) & 1) {
     break block5
    }
    jsvUnLock(HEAP32[$2 + 144 >> 2]);
    HEAP32[$2 + 144 >> 2] = 0;
   }
   HEAP32[$2 + 140 >> 2] = 0;
   block7 : {
    if (HEAP8[$2 + 203 | 0] & 1) {
     HEAP32[$2 + 140 >> 2] = jsvNewObject();
     if (!HEAP32[$2 + 140 >> 2]) {
      HEAP32[$2 + 284 >> 2] = 0;
      break block;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 140 >> 2], 16247, jsvNewFromInteger(HEAP32[$2 + 180 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 140 >> 2], 4847, jsvNewFromInteger(HEAP32[$2 + 176 >> 2]));
     if (HEAP32[$2 + 164 >> 2] != 1) {
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 140 >> 2], 14899, jsvNewFromInteger(HEAP32[$2 + 164 >> 2]))
     }
     block6 : {
      if (HEAP32[$2 + 188 >> 2] | (HEAPU8[$2 + 208 | 0] | HEAPU8[$2 + 209 | 0] << 8 | (HEAPU8[$2 + 210 | 0] << 16 | HEAPU8[$2 + 211 | 0] << 24)) | (HEAP32[$2 + 184 >> 2] | HEAP32[$2 + 180 >> 2] != HEAP32[$2 + 196 >> 2])) {
       break block6
      }
      if (HEAP32[$2 + 176 >> 2] != HEAP32[$2 + 192 >> 2]) {
       break block6
      }
      if (HEAP32[$2 + 164 >> 2] != 8) {
       if (!((HEAPU8[$2 + 212 | 0] | HEAPU8[$2 + 213 | 0] << 8 | (HEAPU8[$2 + 214 | 0] << 16 | HEAPU8[$2 + 215 | 0] << 24)) & 4) | (HEAPU8[$2 + 212 | 0] | HEAPU8[$2 + 213 | 0] << 8 | (HEAPU8[$2 + 214 | 0] << 16 | HEAPU8[$2 + 215 | 0] << 24)) & 11) {
        break block6
       }
      }
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 140 >> 2], 8164, jsvObjectGetChildIfExists(HEAPU8[$2 + 204 | 0] | HEAPU8[$2 + 205 | 0] << 8 | (HEAPU8[$2 + 206 | 0] << 16 | HEAPU8[$2 + 207 | 0] << 24), 8164));
      HEAP32[$2 + 284 >> 2] = HEAP32[$2 + 140 >> 2];
      break block;
     }
     if (HEAP32[$2 + 152 >> 2] >= 0) {
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 140 >> 2], 4622, jsvNewFromInteger(HEAP32[$2 + 152 >> 2]))
     }
     if (HEAP32[$2 + 144 >> 2]) {
      jsvObjectSetChild(HEAP32[$2 + 140 >> 2], 17485, HEAP32[$2 + 144 >> 2])
     }
     break block7;
    }
    $1 = HEAP32[$2 + 156 >> 2];
    if (HEAP32[$2 + 144 >> 2]) {
     $0 = HEAP32[$2 + 160 >> 2] << 1
    } else {
     $0 = 0
    }
    HEAP32[$2 + 156 >> 2] = $1 + ($0 + (HEAP32[$2 + 152 >> 2] >= 0 ? 4 : 3) | 0);
   }
   HEAP32[$2 + 136 >> 2] = jsvNewStringOfLength(HEAP32[$2 + 156 >> 2], 0);
   if (!HEAP32[$2 + 136 >> 2]) {
    jsvUnLock(HEAP32[$2 + 140 >> 2]);
    HEAP32[$2 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 132 >> 2] = 0;
   HEAP32[$2 + 128 >> 2] = 0;
   HEAP32[$2 + 124 >> 2] = 0;
   HEAP32[$2 + 120 >> 2] = 0;
   jsvStringIteratorNew($2 + 80 | 0, HEAP32[$2 + 136 >> 2], 0);
   if (!(HEAP8[$2 + 203 | 0] & 1)) {
    jsvStringIteratorSetCharAndNext($2 + 80 | 0, HEAP32[$2 + 180 >> 2] << 24 >> 24);
    jsvStringIteratorSetCharAndNext($2 + 80 | 0, HEAP32[$2 + 176 >> 2] << 24 >> 24);
    jsvStringIteratorSetCharAndNext($2 + 80 | 0, ((HEAP32[$2 + 164 >> 2] | (HEAP32[$2 + 152 >> 2] >= 0 ? 128 : 0)) << 24 >> 24 | (HEAP32[$2 + 144 >> 2] ? 64 : 0)) << 24 >> 24);
    if (HEAP32[$2 + 152 >> 2] >= 0) {
     jsvStringIteratorSetCharAndNext($2 + 80 | 0, HEAP32[$2 + 152 >> 2] << 24 >> 24)
    }
    if (HEAP32[$2 + 144 >> 2]) {
     HEAP32[$2 + 12 >> 2] = 0;
     jsvIteratorNew($2 + 16 | 0, HEAP32[$2 + 144 >> 2], 1);
     while (1) {
      if (jsvIteratorHasElement($2 + 16 | 0) & 1) {
       HEAP32[$2 + 8 >> 2] = jsvIteratorGetIntegerValue($2 + 16 | 0);
       if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 160 >> 2]) {
        jsvStringIteratorSetCharAndNext($2 + 80 | 0, HEAP32[$2 + 8 >> 2] << 24 >> 24);
        jsvStringIteratorSetCharAndNext($2 + 80 | 0, HEAP32[$2 + 8 >> 2] >> 8 << 24 >> 24);
       }
       jsvIteratorNext($2 + 16 | 0);
       HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
       continue;
      }
      break;
     };
     jsvIteratorFree($2 + 16 | 0);
     while (1) {
      if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 160 >> 2]) {
       jsvStringIteratorSetCharAndNext($2 + 80 | 0, 0);
       jsvStringIteratorSetCharAndNext($2 + 80 | 0, 0);
       HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
       continue;
      }
      break;
     };
    }
   }
   while (1) {
    if (jsvStringIteratorHasChar_1917($2 + 80 | 0) & 1) {
     HEAP32[$2 + 4 >> 2] = graphicsGetPixel($2 + 204 | 0, HEAP32[$2 + 132 >> 2] + HEAP32[$2 + 188 >> 2] | 0, HEAP32[$2 + 128 >> 2] + HEAP32[$2 + 184 >> 2] | 0);
     if ((HEAPU8[$2 + 208 | 0] | HEAPU8[$2 + 209 | 0] << 8 | (HEAPU8[$2 + 210 | 0] << 16 | HEAPU8[$2 + 211 | 0] << 24)) == 6) {
      HEAP32[$2 + 4 >> 2] = !!(HEAP32[$2 + 4 >> 2] & 16) | ((HEAP32[$2 + 4 >> 2] & 32768 ? 4 : 0) | (HEAP32[$2 + 4 >> 2] & 1024 ? 2 : 0))
     }
     HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 4 >> 2] | HEAP32[$2 + 124 >> 2] << HEAP32[$2 + 164 >> 2];
     HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 164 >> 2] + HEAP32[$2 + 120 >> 2];
     HEAP32[$2 + 132 >> 2] = HEAP32[$2 + 132 >> 2] + 1;
     if (HEAP32[$2 + 132 >> 2] >= HEAP32[$2 + 180 >> 2]) {
      HEAP32[$2 + 132 >> 2] = 0;
      HEAP32[$2 + 128 >> 2] = HEAP32[$2 + 128 >> 2] + 1;
     }
     while (1) {
      if (HEAPU32[$2 + 120 >> 2] >= 8) {
       jsvStringIteratorSetCharAndNext($2 + 80 | 0, HEAP32[$2 + 124 >> 2] >>> HEAP32[$2 + 120 >> 2] - 8 << 24 >> 24);
       HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 120 >> 2] - 8;
       continue;
      }
      break;
     };
     continue;
    }
    break;
   };
   jsvStringIteratorFree_1906($2 + 80 | 0);
   jsvUnLock(HEAP32[$2 + 144 >> 2]);
   if (HEAP8[$2 + 203 | 0] & 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 140 >> 2], 8164, HEAP32[$2 + 136 >> 2]);
    HEAP32[$2 + 284 >> 2] = HEAP32[$2 + 140 >> 2];
    break block;
   }
   HEAP32[$2 + 284 >> 2] = HEAP32[$2 + 136 >> 2];
  }
  __stack_pointer = $2 + 288 | 0;
  return HEAP32[$2 + 284 >> 2];
 }
 
 function jswrap_graphics_getModified($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 96 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 88 >> 2] = $0;
  HEAP8[$2 + 87 | 0] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 15 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
    HEAP32[$2 + 92 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 8 >> 2] = 0;
   if ((HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) << 16 >> 16 <= (HEAPU8[$2 + 59 | 0] | HEAPU8[$2 + 60 | 0] << 8) << 16 >> 16) {
    HEAP32[$2 + 8 >> 2] = jsvNewObject();
    if (HEAP32[$2 + 8 >> 2]) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 22436, jsvNewFromInteger((HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) << 16 >> 16));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 22433, jsvNewFromInteger((HEAPU8[$2 + 57 | 0] | HEAPU8[$2 + 58 | 0] << 8) << 16 >> 16));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 22356, jsvNewFromInteger((HEAPU8[$2 + 59 | 0] | HEAPU8[$2 + 60 | 0] << 8) << 16 >> 16));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 22353, jsvNewFromInteger((HEAPU8[$2 + 61 | 0] | HEAPU8[$2 + 62 | 0] << 8) << 16 >> 16));
    }
   }
   if (HEAP8[$2 + 87 | 0] & 1) {
    HEAP8[$2 + 59 | 0] = 0;
    HEAP8[$2 + 60 | 0] = 128;
    HEAP8[$2 + 61 | 0] = 0;
    HEAP8[$2 + 62 | 0] = 128;
    HEAP8[$2 + 55 | 0] = 255;
    HEAP8[$2 + 56 | 0] = 127;
    HEAP8[$2 + 57 | 0] = 255;
    HEAP8[$2 + 58 | 0] = 127;
    graphicsSetVar($2 + 15 | 0);
   }
   HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 8 >> 2];
  }
  __stack_pointer = $2 + 96 | 0;
  return HEAP32[$2 + 92 >> 2];
 }
 
 function jswrap_graphics_scroll($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 96 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 88 >> 2] = $0;
  HEAP32[$3 + 84 >> 2] = $1;
  HEAP32[$3 + 80 >> 2] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
    HEAP32[$3 + 92 >> 2] = 0;
    break block;
   }
   graphicsScroll($3 + 8 | 0, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
   graphicsSetVar($3 + 8 | 0);
   HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
  }
  __stack_pointer = $3 + 96 | 0;
  return HEAP32[$3 + 92 >> 2];
 }
 
 function jswrap_graphics_blit($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 224 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 216 >> 2] = $0;
  HEAP32[$2 + 212 >> 2] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 140 | 0, HEAP32[$2 + 216 >> 2]) & 1)) {
    HEAP32[$2 + 220 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 136 >> 2] = HEAPU8[$2 + 152 | 0] | HEAPU8[$2 + 153 | 0] << 8;
   HEAP32[$2 + 132 >> 2] = HEAPU8[$2 + 154 | 0] | HEAPU8[$2 + 155 | 0] << 8;
   HEAP32[$2 + 128 >> 2] = 0;
   HEAP32[$2 + 124 >> 2] = 0;
   HEAP32[$2 + 120 >> 2] = 0;
   HEAP32[$2 + 116 >> 2] = 0;
   HEAP32[$2 + 112 >> 2] = 0;
   HEAP32[$2 + 108 >> 2] = 0;
   HEAP8[$2 + 107 | 0] = 0;
   HEAP32[$2 + 16 >> 2] = 22436;
   HEAP16[$2 + 20 >> 1] = 10;
   HEAP16[($2 + 16 | 0) + 6 >> 1] = 0;
   HEAP32[$2 + 24 >> 2] = $2 + 128;
   HEAP32[$2 + 28 >> 2] = 22433;
   HEAP16[$2 + 32 >> 1] = 10;
   HEAP16[($2 + 16 | 0) + 18 >> 1] = 0;
   HEAP32[$2 + 36 >> 2] = $2 + 124;
   HEAP32[$2 + 40 >> 2] = 4131;
   HEAP16[$2 + 44 >> 1] = 10;
   HEAP16[($2 + 16 | 0) + 30 >> 1] = 0;
   HEAP32[$2 + 48 >> 2] = $2 + 120;
   HEAP32[$2 + 52 >> 2] = 16557;
   HEAP16[$2 + 56 >> 1] = 10;
   HEAP16[($2 + 16 | 0) + 42 >> 1] = 0;
   HEAP32[$2 + 60 >> 2] = $2 + 116;
   HEAP32[$2 + 64 >> 2] = 22356;
   HEAP16[$2 + 68 >> 1] = 10;
   HEAP16[($2 + 16 | 0) + 54 >> 1] = 0;
   HEAP32[$2 + 72 >> 2] = $2 + 112;
   HEAP32[$2 + 76 >> 2] = 22353;
   HEAP16[$2 + 80 >> 1] = 10;
   HEAP16[($2 + 16 | 0) + 66 >> 1] = 0;
   HEAP32[$2 + 84 >> 2] = $2 + 108;
   HEAP32[$2 + 88 >> 2] = 19232;
   HEAP16[$2 + 92 >> 1] = 12;
   HEAP16[($2 + 16 | 0) + 78 >> 1] = 0;
   HEAP32[$2 + 96 >> 2] = $2 + 107;
   block1 : {
    if (jsvIsObject(HEAP32[$2 + 212 >> 2]) & 1) {
     if (jsvReadConfigObject(HEAP32[$2 + 212 >> 2], $2 + 16 | 0, 7) & 1) {
      break block1
     }
    }
    jsExceptionHere(1, 7147, 0);
    HEAP32[$2 + 220 >> 2] = 0;
    break block;
   }
   if (HEAP32[$2 + 128 >> 2] < 0) {
    HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 112 >> 2] - HEAP32[$2 + 128 >> 2];
    HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 128 >> 2] + HEAP32[$2 + 120 >> 2];
    HEAP32[$2 + 128 >> 2] = 0;
   }
   if (HEAP32[$2 + 124 >> 2] < 0) {
    HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 108 >> 2] - HEAP32[$2 + 124 >> 2];
    HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 124 >> 2] + HEAP32[$2 + 116 >> 2];
    HEAP32[$2 + 124 >> 2] = 0;
   }
   HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 128 >> 2] + HEAP32[$2 + 120 >> 2] | 0) - HEAP32[$2 + 136 >> 2];
   if (HEAP32[$2 + 12 >> 2] > 0) {
    HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 120 >> 2] - HEAP32[$2 + 12 >> 2]
   }
   HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 124 >> 2] + HEAP32[$2 + 116 >> 2] | 0) - HEAP32[$2 + 132 >> 2];
   if (HEAP32[$2 + 12 >> 2] > 0) {
    HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 116 >> 2] - HEAP32[$2 + 12 >> 2]
   }
   if (HEAP32[$2 + 112 >> 2] < 0) {
    HEAP32[$2 + 128 >> 2] = HEAP32[$2 + 128 >> 2] - HEAP32[$2 + 112 >> 2];
    HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 112 >> 2] + HEAP32[$2 + 120 >> 2];
    HEAP32[$2 + 112 >> 2] = 0;
   }
   if (HEAP32[$2 + 108 >> 2] < 0) {
    HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 124 >> 2] - HEAP32[$2 + 108 >> 2];
    HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2];
    HEAP32[$2 + 108 >> 2] = 0;
   }
   HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 112 >> 2] + HEAP32[$2 + 120 >> 2] | 0) - HEAP32[$2 + 136 >> 2];
   if (HEAP32[$2 + 12 >> 2] > 0) {
    HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 120 >> 2] - HEAP32[$2 + 12 >> 2]
   }
   HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2] | 0) - HEAP32[$2 + 132 >> 2];
   if (HEAP32[$2 + 12 >> 2] > 0) {
    HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 116 >> 2] - HEAP32[$2 + 12 >> 2]
   }
   if (!(HEAP32[$2 + 120 >> 2] <= 0 & HEAP32[$2 + 116 >> 2] <= 0)) {
    FUNCTION_TABLE[HEAPU8[$2 + 204 | 0] | HEAPU8[$2 + 205 | 0] << 8 | (HEAPU8[$2 + 206 | 0] << 16 | HEAPU8[$2 + 207 | 0] << 24)]($2 + 140 | 0, HEAP32[$2 + 128 >> 2], HEAP32[$2 + 124 >> 2], HEAP32[$2 + 120 >> 2], HEAP32[$2 + 116 >> 2], HEAP32[$2 + 112 >> 2], HEAP32[$2 + 108 >> 2]);
    if (HEAP8[$2 + 107 | 0] & 1) {
     graphicsSetModified($2 + 140 | 0, HEAP32[$2 + 112 >> 2], HEAP32[$2 + 108 >> 2], HEAP32[$2 + 112 >> 2] + HEAP32[$2 + 120 >> 2] | 0, HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2] | 0);
     graphicsSetVar($2 + 140 | 0);
    }
   }
   HEAP32[$2 + 220 >> 2] = jsvLockAgain(HEAP32[$2 + 216 >> 2]);
  }
  __stack_pointer = $2 + 224 | 0;
  return HEAP32[$2 + 220 >> 2];
 }
 
 function jswrap_graphics_asBMP_X($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer - 240 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 232 >> 2] = $0;
  HEAP8[$2 + 231 | 0] = $1;
  block : {
   if (!(graphicsGetFromVar($2 + 159 | 0, HEAP32[$2 + 232 >> 2]) & 1)) {
    HEAP32[$2 + 236 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 152 >> 2] = graphicsGetWidth($2 + 159 | 0) & 65535;
   HEAP32[$2 + 148 >> 2] = graphicsGetHeight($2 + 159 | 0) & 65535;
   HEAP32[$2 + 144 >> 2] = HEAPU8[$2 + 175 | 0];
   if ((HEAPU8[$2 + 163 | 0] | HEAPU8[$2 + 164 | 0] << 8 | (HEAPU8[$2 + 165 | 0] << 16 | HEAPU8[$2 + 166 | 0] << 24)) == 6) {
    HEAP32[$2 + 144 >> 2] = 3
   }
   HEAP32[$2 + 140 >> 2] = HEAP32[$2 + 144 >> 2];
   block2 : {
    if (!(HEAP32[$2 + 140 >> 2] <= 1 | HEAP32[$2 + 140 >> 2] >= 4)) {
     HEAP32[$2 + 140 >> 2] = 4;
     break block2;
    }
    if (!(HEAP32[$2 + 140 >> 2] <= 4 | HEAP32[$2 + 140 >> 2] >= 8)) {
     HEAP32[$2 + 140 >> 2] = 8
    }
   }
   HEAP8[$2 + 139 | 0] = HEAP32[$2 + 140 >> 2] <= 8;
   HEAP32[$2 + 132 >> 2] = Math_imul(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 140 >> 2]) + 31 >> 5 << 2;
   if (HEAP8[$2 + 139 | 0] & 1) {
    $0 = 1 << HEAP32[$2 + 140 >> 2]
   } else {
    $0 = 0
   }
   HEAP32[$2 + 128 >> 2] = $0;
   block5 : {
    if (HEAP32[$2 + 140 >> 2] == 16) {
     HEAP32[$2 + 124 >> 2] = 70;
     break block5;
    }
    HEAP32[$2 + 124 >> 2] = Math_imul(HEAP32[$2 + 128 >> 2], 3) + 26;
   }
   HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 124 >> 2] + Math_imul(HEAP32[$2 + 148 >> 2], HEAP32[$2 + 132 >> 2]);
   if (HEAP8[$2 + 231 | 0] & 1) {
    $0 = HEAP32[$2 + 124 >> 2] + HEAP32[$2 + 132 >> 2] | 0
   } else {
    $0 = HEAP32[$2 + 120 >> 2]
   }
   HEAP32[$2 + 116 >> 2] = $0;
   HEAP32[$2 + 112 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 116 >> 2]);
   if (!HEAP32[$2 + 112 >> 2]) {
    HEAP32[$2 + 236 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 108 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 112 >> 2]);
   if (!HEAP32[$2 + 108 >> 2]) {
    HEAP32[$2 + 236 >> 2] = 0;
    break block;
   }
   HEAP8[HEAP32[$2 + 108 >> 2]] = 66;
   HEAP8[HEAP32[$2 + 108 >> 2] + 1 | 0] = 77;
   HEAP8[HEAP32[$2 + 108 >> 2] + 2 | 0] = HEAP32[$2 + 120 >> 2];
   HEAP8[HEAP32[$2 + 108 >> 2] + 3 | 0] = HEAP32[$2 + 120 >> 2] >> 8;
   HEAP8[HEAP32[$2 + 108 >> 2] + 4 | 0] = HEAP32[$2 + 120 >> 2] >> 16;
   HEAP8[HEAP32[$2 + 108 >> 2] + 5 | 0] = HEAP32[$2 + 120 >> 2] >> 24;
   HEAP8[HEAP32[$2 + 108 >> 2] + 10 | 0] = HEAP32[$2 + 124 >> 2];
   HEAP8[HEAP32[$2 + 108 >> 2] + 18 | 0] = HEAP32[$2 + 152 >> 2];
   HEAP8[HEAP32[$2 + 108 >> 2] + 19 | 0] = HEAP32[$2 + 152 >> 2] >> 8;
   block7 : {
    if (HEAP32[$2 + 140 >> 2] == 16) {
     HEAP32[$2 + 104 >> 2] = 14;
     HEAP8[HEAP32[$2 + 108 >> 2] + 14 | 0] = 56;
     HEAP8[HEAP32[$2 + 108 >> 2] + 22 | 0] = HEAP32[$2 + 148 >> 2];
     HEAP8[HEAP32[$2 + 108 >> 2] + 23 | 0] = HEAP32[$2 + 148 >> 2] >> 8;
     HEAP8[HEAP32[$2 + 108 >> 2] + 26 | 0] = 1;
     HEAP8[HEAP32[$2 + 108 >> 2] + 28 | 0] = 16;
     HEAP8[HEAP32[$2 + 108 >> 2] + 30 | 0] = 3;
     HEAP32[$2 + 100 >> 2] = Math_imul(HEAP32[$2 + 148 >> 2], HEAP32[$2 + 132 >> 2]);
     HEAP8[HEAP32[$2 + 108 >> 2] + 34 | 0] = HEAP32[$2 + 100 >> 2];
     HEAP8[HEAP32[$2 + 108 >> 2] + 35 | 0] = HEAP32[$2 + 100 >> 2] >>> 8;
     HEAP8[HEAP32[$2 + 108 >> 2] + 36 | 0] = HEAP32[$2 + 100 >> 2] >>> 16;
     HEAP8[HEAP32[$2 + 108 >> 2] + 37 | 0] = HEAP32[$2 + 100 >> 2] >>> 24;
     HEAP8[HEAP32[$2 + 108 >> 2] + 55 | 0] = 248;
     HEAP8[HEAP32[$2 + 108 >> 2] + 58 | 0] = 224;
     HEAP8[HEAP32[$2 + 108 >> 2] + 59 | 0] = 7;
     HEAP8[HEAP32[$2 + 108 >> 2] + 62 | 0] = 31;
     break block7;
    }
    HEAP8[HEAP32[$2 + 108 >> 2] + 14 | 0] = 12;
    HEAP8[HEAP32[$2 + 108 >> 2] + 20 | 0] = HEAP32[$2 + 148 >> 2];
    HEAP8[HEAP32[$2 + 108 >> 2] + 21 | 0] = HEAP32[$2 + 148 >> 2] >> 8;
    HEAP8[HEAP32[$2 + 108 >> 2] + 22 | 0] = 1;
    HEAP8[HEAP32[$2 + 108 >> 2] + 24 | 0] = HEAP32[$2 + 140 >> 2];
    if (HEAP8[$2 + 139 | 0] & 1) {
     block8 : {
      if (HEAP32[$2 + 140 >> 2] == 1) {
       HEAP8[HEAP32[$2 + 108 >> 2] + 26 | 0] = 255;
       HEAP8[HEAP32[$2 + 108 >> 2] + 27 | 0] = 255;
       HEAP8[HEAP32[$2 + 108 >> 2] + 28 | 0] = 255;
       break block8;
      }
      block9 : {
       if (HEAP32[$2 + 144 >> 2] == 3) {
        HEAP32[$2 + 96 >> 2] = 0;
        while (1) {
         if (HEAP32[$2 + 96 >> 2] < HEAP32[$2 + 128 >> 2]) {
          HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 96 >> 2], 3) + 26 | 0) | 0] = HEAP32[$2 + 96 >> 2] & 1 ? 255 : 0;
          HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 96 >> 2], 3) + 27 | 0) | 0] = HEAP32[$2 + 96 >> 2] & 2 ? 255 : 0;
          HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 96 >> 2], 3) + 28 | 0) | 0] = HEAP32[$2 + 96 >> 2] & 4 ? 255 : 0;
          HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 96 >> 2] + 1;
          continue;
         }
         break;
        };
        break block9;
       }
       block10 : {
        if (HEAP32[$2 + 144 >> 2] == 4) {
         HEAP32[$2 + 92 >> 2] = 0;
         while (1) {
          if (HEAP32[$2 + 92 >> 2] < 16) {
           HEAP32[$2 + 88 >> 2] = HEAPU16[(HEAP32[$2 + 92 >> 2] << 1) + 234352 >> 1];
           HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 92 >> 2], 3) + 26 | 0) | 0] = HEAP32[$2 + 88 >> 2] << 3 & 248;
           HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 92 >> 2], 3) + 27 | 0) | 0] = HEAP32[$2 + 88 >> 2] >> 3 & 252;
           HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 92 >> 2], 3) + 28 | 0) | 0] = HEAP32[$2 + 88 >> 2] >> 8 & 248;
           HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 92 >> 2] + 1;
           continue;
          }
          break;
         };
         break block10;
        }
        block11 : {
         if (HEAP32[$2 + 144 >> 2] == 8) {
          HEAP32[$2 + 84 >> 2] = 0;
          while (1) {
           if (HEAP32[$2 + 84 >> 2] < 255) {
            HEAP32[$2 + 80 >> 2] = HEAPU16[(HEAP32[$2 + 84 >> 2] << 1) + 234384 >> 1];
            HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 84 >> 2], 3) + 26 | 0) | 0] = HEAP32[$2 + 80 >> 2] << 3 & 248;
            HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 84 >> 2], 3) + 27 | 0) | 0] = HEAP32[$2 + 80 >> 2] >> 3 & 252;
            HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 84 >> 2], 3) + 28 | 0) | 0] = HEAP32[$2 + 80 >> 2] >> 8 & 248;
            HEAP32[$2 + 84 >> 2] = HEAP32[$2 + 84 >> 2] + 1;
            continue;
           }
           break;
          };
          break block11;
         }
         HEAP32[$2 + 76 >> 2] = 0;
         while (1) {
          if (HEAP32[$2 + 76 >> 2] < 1 << HEAP32[$2 + 144 >> 2]) {
           HEAP8[$2 + 75 | 0] = (Math_imul(HEAP32[$2 + 76 >> 2], 255) | 0) / (1 << HEAP32[$2 + 144 >> 2]);
           HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 76 >> 2], 3) + 26 | 0) | 0] = HEAPU8[$2 + 75 | 0];
           HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 76 >> 2], 3) + 27 | 0) | 0] = HEAPU8[$2 + 75 | 0];
           HEAP8[HEAP32[$2 + 108 >> 2] + (Math_imul(HEAP32[$2 + 76 >> 2], 3) + 28 | 0) | 0] = HEAPU8[$2 + 75 | 0];
           HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 76 >> 2] + 1;
           continue;
          }
          break;
         };
        }
       }
      }
     }
    }
   }
   HEAP32[$2 + 68 >> 2] = (1 << HEAP32[$2 + 140 >> 2]) - 1;
   HEAP32[$2 + 64 >> 2] = 8 / HEAP32[$2 + 140 >> 2];
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 124 >> 2];
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 148 >> 2] - 1;
   while (1) {
    if (HEAP32[$2 + 56 >> 2] >= 0) {
     HEAP32[$2 + 52 >> 2] = 0;
     block12 : {
      if (HEAP32[$2 + 140 >> 2] < 8) {
       HEAP32[$2 + 48 >> 2] = 0;
       while (1) {
        if (HEAP32[$2 + 48 >> 2] < HEAP32[$2 + 152 >> 2]) {
         HEAP32[$2 + 44 >> 2] = 0;
         HEAP32[$2 + 40 >> 2] = 0;
         while (1) {
          if (HEAP32[$2 + 40 >> 2] < HEAP32[$2 + 64 >> 2]) {
           $0 = HEAP32[$2 + 48 >> 2];
           HEAP32[$2 + 48 >> 2] = $0 + 1;
           HEAP32[$2 + 36 >> 2] = graphicsGetPixel($2 + 159 | 0, $0, HEAP32[$2 + 56 >> 2]);
           if ((HEAPU8[$2 + 163 | 0] | HEAPU8[$2 + 164 | 0] << 8 | (HEAPU8[$2 + 165 | 0] << 16 | HEAPU8[$2 + 166 | 0] << 24)) == 6) {
            HEAP32[$2 + 36 >> 2] = !!(HEAP32[$2 + 36 >> 2] & 16) | ((HEAP32[$2 + 36 >> 2] & 32768 ? 4 : 0) | (HEAP32[$2 + 36 >> 2] & 1024 ? 2 : 0))
           }
           HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 36 >> 2] & HEAP32[$2 + 68 >> 2] | HEAP32[$2 + 44 >> 2] << HEAP32[$2 + 140 >> 2];
           HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 40 >> 2] + 1;
           continue;
          }
          break;
         };
         $1 = HEAP32[$2 + 44 >> 2];
         $3 = HEAP32[$2 + 108 >> 2];
         $0 = HEAP32[$2 + 60 >> 2];
         HEAP32[$2 + 60 >> 2] = $0 + 1;
         HEAP8[$3 + $0 | 0] = $1;
         HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
         continue;
        }
        break;
       };
       break block12;
      }
      HEAP32[$2 + 32 >> 2] = 0;
      while (1) {
       if (HEAP32[$2 + 32 >> 2] < HEAP32[$2 + 152 >> 2]) {
        HEAP32[$2 + 28 >> 2] = graphicsGetPixel($2 + 159 | 0, HEAP32[$2 + 32 >> 2], HEAP32[$2 + 56 >> 2]);
        HEAP32[$2 + 24 >> 2] = 0;
        while (1) {
         if (HEAP32[$2 + 24 >> 2] < HEAP32[$2 + 140 >> 2]) {
          $1 = HEAP32[$2 + 28 >> 2];
          $3 = HEAP32[$2 + 108 >> 2];
          $0 = HEAP32[$2 + 60 >> 2];
          HEAP32[$2 + 60 >> 2] = $0 + 1;
          HEAP8[$3 + $0 | 0] = $1;
          HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
          HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] >>> 8;
          HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] + 8;
          continue;
         }
         break;
        };
        HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
        continue;
       }
       break;
      };
     }
     if (HEAP32[$2 + 52 >> 2] < HEAP32[$2 + 132 >> 2]) {
      HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] + (HEAP32[$2 + 132 >> 2] - HEAP32[$2 + 52 >> 2] | 0)
     }
     if (!(!(HEAP8[$2 + 231 | 0] & 1) | HEAP32[$2 + 60 >> 2] <= 2)) {
      jshKickWatchDog();
      HEAP8[$2 + 23 | 0] = !HEAP32[$2 + 56 >> 2];
      if (HEAP8[$2 + 23 | 0] & 1) {
       $0 = HEAP32[$2 + 60 >> 2]
      } else {
       $0 = HEAP32[$2 + 60 >> 2] - (HEAP32[$2 + 60 >> 2] % 3 | 0) | 0
      }
      HEAP32[$2 + 16 >> 2] = $0;
      HEAP32[$2 + 12 >> 2] = jsvNewArrayBufferFromString(HEAP32[$2 + 112 >> 2], HEAP32[$2 + 16 >> 2]);
      HEAP32[$2 + 8 >> 2] = jswrap_btoa(HEAP32[$2 + 12 >> 2]);
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      if (HEAP32[$2 + 8 >> 2]) {
       HEAP32[$2 >> 2] = HEAP32[$2 + 8 >> 2];
       jsiConsolePrintf(4263, $2);
      }
      jsvUnLock(HEAP32[$2 + 8 >> 2]);
      if (HEAP32[$2 + 16 >> 2] < HEAP32[$2 + 60 >> 2]) {
       $1 = HEAP32[$2 + 108 >> 2];
       $3 = HEAP32[$2 + 108 >> 2];
       $4 = HEAP32[$2 + 16 >> 2];
       $0 = HEAP32[$2 + 60 >> 2] - HEAP32[$2 + 16 >> 2] | 0;
       if ($0) {
        wasm2js_memory_copy($1, $3 + $4 | 0, $0)
       }
      }
      HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] - HEAP32[$2 + 16 >> 2];
     }
     HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] - 1;
     continue;
    }
    break;
   };
   if (HEAP8[$2 + 231 | 0] & 1) {
    jsiConsolePrintf(28752, 0);
    jsvUnLock(HEAP32[$2 + 112 >> 2]);
    HEAP32[$2 + 236 >> 2] = 0;
    break block;
   }
   HEAP32[$2 + 236 >> 2] = HEAP32[$2 + 112 >> 2];
  }
  __stack_pointer = $2 + 240 | 0;
  return HEAP32[$2 + 236 >> 2];
 }
 
 function jswrap_graphics_asBMP($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  $0 = jswrap_graphics_asBMP_X(HEAP32[$1 + 12 >> 2], 0);
  __stack_pointer = $1 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_graphics_asURL($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = jswrap_graphics_asBMP_X(HEAP32[$1 + 24 >> 2], 0);
  block : {
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 + 16 >> 2] = jswrap_btoa(HEAP32[$1 + 20 >> 2]);
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
   if (!HEAP32[$1 + 16 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break block;
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 16 >> 2];
   HEAP32[$1 + 12 >> 2] = jsvVarPrintf(4173, $1);
   jsvUnLock(HEAP32[$1 + 16 >> 2]);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
  }
  __stack_pointer = $1 + 32 | 0;
  return HEAP32[$1 + 28 >> 2];
 }
 
 function jswrap_graphics_dump($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  jsiConsolePrintf(22832, 0);
  jsvUnLock(jswrap_graphics_asBMP_X(HEAP32[$1 + 12 >> 2], 1));
  __stack_pointer = $1 + 16 | 0;
 }
 
 function jswrap_graphics_quadraticBezier($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  $3 = __stack_pointer - 160 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 152 >> 2] = $0;
  HEAP32[$3 + 148 >> 2] = $1;
  HEAP32[$3 + 144 >> 2] = $2;
  HEAP32[$3 + 140 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$3 + 140 >> 2]) {
    HEAP32[$3 + 156 >> 2] = 0;
    break block;
   }
   if ((jsvGetArrayLength(HEAP32[$3 + 148 >> 2]) | 0) != 6) {
    HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 140 >> 2];
    break block;
   }
   HEAP32[$3 + 136 >> 2] = 5;
   HEAP32[$3 + 108 >> 2] = 0;
   jsvIteratorNew($3 + 44 | 0, HEAP32[$3 + 148 >> 2], 1);
   HEAP32[$3 + 40 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 40 >> 2] < 6) {
     $0 = jsvIteratorGetIntegerValue($3 + 44 | 0);
     HEAP32[($3 + 112 | 0) + (HEAP32[$3 + 40 >> 2] << 2) >> 2] = $0;
     jsvIteratorNext($3 + 44 | 0);
     HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 40 >> 2] + 1;
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 44 | 0);
   if (jsvIsObject(HEAP32[$3 + 144 >> 2]) & 1) {
    HEAP32[$3 + 108 >> 2] = jsvObjectGetIntegerChild(HEAP32[$3 + 144 >> 2], 4505)
   }
   HEAP32[$3 + 36 >> 2] = 4096;
   HEAP32[$3 + 32 >> 2] = 12;
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 112 >> 2] - HEAP32[$3 + 128 >> 2];
   if (HEAP32[$3 + 28 >> 2] < 0) {
    HEAP32[$3 + 28 >> 2] = 0 - HEAP32[$3 + 28 >> 2]
   }
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 116 >> 2] - HEAP32[$3 + 132 >> 2];
   if (HEAP32[$3 + 24 >> 2] < 0) {
    HEAP32[$3 + 24 >> 2] = 0 - HEAP32[$3 + 24 >> 2]
   }
   if (HEAP32[$3 + 28 >> 2] < HEAP32[$3 + 24 >> 2]) {
    $0 = HEAP32[$3 + 28 >> 2]
   } else {
    $0 = HEAP32[$3 + 24 >> 2]
   }
   HEAP32[$3 + 20 >> 2] = $0;
   if (!HEAP32[$3 + 20 >> 2]) {
    HEAP32[$3 + 20 >> 2] = 1
   }
   HEAP32[$3 + 16 >> 2] = (HEAP32[$3 + 136 >> 2] << 12) / HEAP32[$3 + 20 >> 2];
   if (HEAP32[$3 + 16 >> 2] >= 4096) {
    HEAP32[$3 + 16 >> 2] = 1365
   }
   if (HEAP32[$3 + 16 >> 2] < 409) {
    HEAP32[$3 + 16 >> 2] = 409
   }
   if (HEAP32[$3 + 108 >> 2] > 0) {
    HEAP32[$3 + 16 >> 2] = 4096 / HEAP32[$3 + 108 >> 2]
   }
   jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 116 >> 2]);
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2];
   while (1) {
    if (HEAP32[$3 + 12 >> 2] <= 4096) {
     HEAP32[$3 + 8 >> 2] = Math_imul(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 12 >> 2]) >> 12;
     HEAP32[$3 + 4 >> 2] = Math_imul(4096 - HEAP32[$3 + 12 >> 2] | 0, 4096 - HEAP32[$3 + 12 >> 2] | 0) >> 12;
     HEAP32[$3 >> 2] = Math_imul(HEAP32[$3 + 12 >> 2], 4096 - HEAP32[$3 + 12 >> 2] << 1) >> 12;
     jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], ((Math_imul(HEAP32[$3 + 112 >> 2], HEAP32[$3 + 4 >> 2]) + Math_imul(HEAP32[$3 + 120 >> 2], HEAP32[$3 >> 2]) | 0) + Math_imul(HEAP32[$3 + 128 >> 2], HEAP32[$3 + 8 >> 2]) | 0) + 2048 >> 12, ((Math_imul(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 4 >> 2]) + Math_imul(HEAP32[$3 + 124 >> 2], HEAP32[$3 >> 2]) | 0) + Math_imul(HEAP32[$3 + 132 >> 2], HEAP32[$3 + 8 >> 2]) | 0) + 2048 >> 12);
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 12 >> 2];
     continue;
    }
    break;
   };
   jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], HEAP32[$3 + 128 >> 2], HEAP32[$3 + 132 >> 2]);
   HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 140 >> 2];
  }
  __stack_pointer = $3 + 160 | 0;
  return HEAP32[$3 + 156 >> 2];
 }
 
 function jswrap_graphics_transformVertices($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0.0;
  $3 = __stack_pointer - 336 | 0;
  __stack_pointer = $3;
  HEAP32[$3 + 328 >> 2] = $0;
  HEAP32[$3 + 324 >> 2] = $1;
  HEAP32[$3 + 320 >> 2] = $2;
  HEAP32[$3 + 316 >> 2] = jsvNewEmptyArray();
  block : {
   if (!HEAP32[$3 + 316 >> 2]) {
    HEAP32[$3 + 332 >> 2] = 0;
    break block;
   }
   if (!(jsvIsIterable(HEAP32[$3 + 324 >> 2]) & 1)) {
    HEAP32[$3 + 332 >> 2] = HEAP32[$3 + 316 >> 2];
    break block;
   }
   block1 : {
    if (jsvIsObject(HEAP32[$3 + 320 >> 2]) & 1) {
     HEAPF64[$3 + 248 >> 3] = 0;
     HEAPF64[$3 + 240 >> 3] = 0;
     HEAPF64[$3 + 232 >> 3] = 1;
     HEAPF64[$3 + 224 >> 3] = 0;
     HEAP32[$3 + 176 >> 2] = 3934;
     HEAP16[$3 + 180 >> 1] = 11;
     HEAP16[($3 + 176 | 0) + 6 >> 1] = 0;
     HEAP32[$3 + 184 >> 2] = $3 + 248;
     HEAP32[$3 + 188 >> 2] = 3805;
     HEAP16[$3 + 192 >> 1] = 11;
     HEAP16[($3 + 176 | 0) + 18 >> 1] = 0;
     HEAP32[$3 + 196 >> 2] = $3 + 240;
     HEAP32[$3 + 200 >> 2] = 18030;
     HEAP16[$3 + 204 >> 1] = 11;
     HEAP16[($3 + 176 | 0) + 30 >> 1] = 0;
     HEAP32[$3 + 208 >> 2] = $3 + 232;
     HEAP32[$3 + 212 >> 2] = 17552;
     HEAP16[$3 + 216 >> 1] = 11;
     HEAP16[($3 + 176 | 0) + 42 >> 1] = 0;
     HEAP32[$3 + 220 >> 2] = $3 + 224;
     if (!(jsvReadConfigObject(HEAP32[$3 + 320 >> 2], $3 + 176 | 0, 4) & 1)) {
      HEAP32[$3 + 332 >> 2] = HEAP32[$3 + 316 >> 2];
      break block;
     }
     HEAPF64[$3 + 168 >> 3] = 1;
     HEAPF64[$3 + 160 >> 3] = 0;
     if (HEAPF64[$3 + 224 >> 3] != 0.0) {
      HEAPF64[$3 + 168 >> 3] = jswrap_math_cos(HEAPF64[$3 + 224 >> 3]);
      HEAPF64[$3 + 160 >> 3] = jswrap_math_sin(HEAPF64[$3 + 224 >> 3]);
     }
     HEAPF64[$3 + 256 >> 3] = HEAPF64[$3 + 168 >> 3] * HEAPF64[$3 + 232 >> 3];
     HEAPF64[$3 + 272 >> 3] = -HEAPF64[$3 + 160 >> 3] * HEAPF64[$3 + 232 >> 3];
     HEAPF64[$3 + 288 >> 3] = HEAPF64[$3 + 248 >> 3];
     HEAPF64[$3 + 264 >> 3] = HEAPF64[$3 + 160 >> 3] * HEAPF64[$3 + 232 >> 3];
     HEAPF64[$3 + 280 >> 3] = HEAPF64[$3 + 168 >> 3] * HEAPF64[$3 + 232 >> 3];
     HEAPF64[$3 + 296 >> 3] = HEAPF64[$3 + 240 >> 3];
     break block1;
    }
    block3 : {
     block2 : {
      if (!(jsvIsIterable(HEAP32[$3 + 320 >> 2]) & 1)) {
       break block2
      }
      if ((jsvGetLength(HEAP32[$3 + 320 >> 2]) | 0) != 6) {
       break block2
      }
      jsvIteratorNew($3 + 96 | 0, HEAP32[$3 + 320 >> 2], 1);
      HEAP32[$3 + 92 >> 2] = 0;
      while (1) {
       if (HEAP32[$3 + 92 >> 2] < 6) {
        $4 = jsvIteratorGetFloatValue($3 + 96 | 0);
        HEAPF64[($3 + 256 | 0) + (HEAP32[$3 + 92 >> 2] << 3) >> 3] = $4;
        jsvIteratorNext($3 + 96 | 0);
        HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 92 >> 2] + 1;
        continue;
       }
       break;
      };
      jsvIteratorFree($3 + 96 | 0);
      break block3;
     }
     jsExceptionHere(3, 4634, 0);
     HEAP32[$3 + 332 >> 2] = 0;
     break block;
    }
   }
   jsvIteratorNew($3 + 28 | 0, HEAP32[$3 + 324 >> 2], 1);
   while (1) {
    block4 : {
     if (!(jsvIteratorHasElement($3 + 28 | 0) & 1)) {
      break block4
     }
     HEAPF64[$3 + 16 >> 3] = jsvIteratorGetFloatValue($3 + 28 | 0);
     jsvIteratorNext($3 + 28 | 0);
     if (!(jsvIteratorHasElement($3 + 28 | 0) & 1)) {
      break block4
     }
     HEAPF64[$3 + 8 >> 3] = jsvIteratorGetFloatValue($3 + 28 | 0);
     jsvIteratorNext($3 + 28 | 0);
     jsvArrayPushAndUnLock(HEAP32[$3 + 316 >> 2], jsvNewFromFloat(HEAPF64[$3 + 256 >> 3] * HEAPF64[$3 + 16 >> 3] + HEAPF64[$3 + 272 >> 3] * HEAPF64[$3 + 8 >> 3] + HEAPF64[$3 + 288 >> 3]));
     jsvArrayPushAndUnLock(HEAP32[$3 + 316 >> 2], jsvNewFromFloat(HEAPF64[$3 + 264 >> 3] * HEAPF64[$3 + 16 >> 3] + HEAPF64[$3 + 280 >> 3] * HEAPF64[$3 + 8 >> 3] + HEAPF64[$3 + 296 >> 3]));
     continue;
    }
    break;
   };
   jsvIteratorFree($3 + 28 | 0);
   HEAP32[$3 + 332 >> 2] = HEAP32[$3 + 316 >> 2];
  }
  __stack_pointer = $3 + 336 | 0;
  return HEAP32[$3 + 332 >> 2];
 }
 
 function jswrap_graphics_floodFill($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 128 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 120 >> 2] = $0;
  HEAP32[$4 + 116 >> 2] = $1;
  HEAP32[$4 + 112 >> 2] = $2;
  HEAP32[$4 + 108 >> 2] = $3;
  block : {
   if (!(graphicsGetFromVar($4 + 36 | 0, HEAP32[$4 + 120 >> 2]) & 1)) {
    HEAP32[$4 + 124 >> 2] = 0;
    break block;
   }
   if ((HEAPU8[$4 + 96 | 0] | HEAPU8[$4 + 97 | 0] << 8 | (HEAPU8[$4 + 98 | 0] << 16 | HEAPU8[$4 + 99 | 0] << 24)) == 592) {
    jsExceptionHere(1, 15777, 0);
    HEAP32[$4 + 124 >> 2] = 0;
    break block;
   }
   HEAP32[$4 + 32 >> 2] = HEAPU8[$4 + 53 | 0] | HEAPU8[$4 + 54 | 0] << 8 | (HEAPU8[$4 + 55 | 0] << 16 | HEAPU8[$4 + 56 | 0] << 24);
   if (HEAP32[$4 + 108 >> 2]) {
    HEAP32[$4 + 32 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 120 >> 2], HEAP32[$4 + 108 >> 2], 0, 0)
   }
   HEAP32[$4 + 28 >> 2] = graphicsGetPixel($4 + 36 | 0, HEAP32[$4 + 116 >> 2], HEAP32[$4 + 112 >> 2]);
   HEAP32[$4 + 24 >> 2] = 64;
   HEAP32[$4 + 20 >> 2] = $4;
   $0 = $4 - 128 | 0;
   __stack_pointer = $0;
   HEAP32[$4 + 16 >> 2] = 0;
   block1 : {
    if (HEAP32[$4 + 16 >> 2] < 64) {
     $2 = HEAP32[$4 + 116 >> 2];
     $1 = HEAP32[$4 + 16 >> 2];
     HEAP32[$4 + 16 >> 2] = $1 + 1;
     HEAP16[($1 << 1) + $0 >> 1] = $2;
     $2 = HEAP32[$4 + 112 >> 2];
     $1 = HEAP32[$4 + 16 >> 2];
     HEAP32[$4 + 16 >> 2] = $1 + 1;
     HEAP16[($1 << 1) + $0 >> 1] = $2;
     break block1;
    }
    HEAP32[$4 + 16 >> 2] = 65;
   }
   while (1) {
    $1 = 0;
    $1 = HEAP32[$4 + 16 >> 2] > 0 ? HEAP32[$4 + 16 >> 2] <= 64 : $1;
    if ($1) {
     $1 = HEAP32[$4 + 16 >> 2] - 1 | 0;
     HEAP32[$4 + 16 >> 2] = $1;
     HEAP16[$4 + 14 >> 1] = HEAPU16[($1 << 1) + $0 >> 1];
     $1 = HEAP32[$4 + 16 >> 2] - 1 | 0;
     HEAP32[$4 + 16 >> 2] = $1;
     HEAP16[$4 + 12 >> 1] = HEAPU16[($1 << 1) + $0 >> 1];
     HEAP16[$4 + 10 >> 1] = HEAPU16[$4 + 12 >> 1];
     while (1) {
      if (_jswrap_graphics_floodFill_inside($4 + 36 | 0, (HEAP16[$4 + 10 >> 1] << 16 >> 16) - 1 | 0, HEAP16[$4 + 14 >> 1] << 16 >> 16, HEAP32[$4 + 28 >> 2]) & 1) {
       $1 = HEAPU16[$4 + 10 >> 1] - 1 | 0;
       HEAP16[$4 + 10 >> 1] = $1;
       graphicsSetPixel($4 + 36 | 0, $1 << 16 >> 16, HEAP16[$4 + 14 >> 1] << 16 >> 16, HEAP32[$4 + 32 >> 2]);
       continue;
      }
      break;
     };
     while (1) {
      if (_jswrap_graphics_floodFill_inside($4 + 36 | 0, HEAP16[$4 + 12 >> 1] << 16 >> 16, HEAP16[$4 + 14 >> 1] << 16 >> 16, HEAP32[$4 + 28 >> 2]) & 1) {
       $1 = HEAPU16[$4 + 12 >> 1];
       HEAP16[$4 + 12 >> 1] = $1 + 1;
       graphicsSetPixel($4 + 36 | 0, $1 << 16 >> 16, HEAP16[$4 + 14 >> 1] << 16 >> 16, HEAP32[$4 + 32 >> 2]);
       continue;
      }
      break;
     };
     HEAP8[$4 + 9 | 0] = 0;
     HEAP16[$4 + 6 >> 1] = HEAPU16[$4 + 10 >> 1];
     while (1) {
      if (HEAP16[$4 + 6 >> 1] << 16 >> 16 < HEAP16[$4 + 12 >> 1] << 16 >> 16) {
       block2 : {
        if (!(_jswrap_graphics_floodFill_inside($4 + 36 | 0, HEAP16[$4 + 6 >> 1] << 16 >> 16, (HEAP16[$4 + 14 >> 1] << 16 >> 16) + 1 | 0, HEAP32[$4 + 28 >> 2]) & 1)) {
         HEAP8[$4 + 9 | 0] = 0;
         break block2;
        }
        if (!(HEAP8[$4 + 9 | 0] & 1)) {
         block3 : {
          if (HEAP32[$4 + 16 >> 2] < 64) {
           $2 = HEAPU16[$4 + 6 >> 1];
           $1 = HEAP32[$4 + 16 >> 2];
           HEAP32[$4 + 16 >> 2] = $1 + 1;
           HEAP16[($1 << 1) + $0 >> 1] = $2;
           $2 = HEAP16[$4 + 14 >> 1] << 16 >> 16;
           $1 = HEAP32[$4 + 16 >> 2];
           HEAP32[$4 + 16 >> 2] = $1 + 1;
           HEAP16[($1 << 1) + $0 >> 1] = $2 + 1;
           break block3;
          }
          HEAP32[$4 + 16 >> 2] = 65;
         }
         HEAP8[$4 + 9 | 0] = 1;
        }
       }
       HEAP16[$4 + 6 >> 1] = HEAPU16[$4 + 6 >> 1] + 1;
       continue;
      }
      break;
     };
     HEAP8[$4 + 9 | 0] = 0;
     HEAP16[$4 + 4 >> 1] = HEAPU16[$4 + 10 >> 1];
     while (1) {
      if (HEAP16[$4 + 4 >> 1] << 16 >> 16 < HEAP16[$4 + 12 >> 1] << 16 >> 16) {
       block4 : {
        if (!(_jswrap_graphics_floodFill_inside($4 + 36 | 0, HEAP16[$4 + 4 >> 1] << 16 >> 16, (HEAP16[$4 + 14 >> 1] << 16 >> 16) - 1 | 0, HEAP32[$4 + 28 >> 2]) & 1)) {
         HEAP8[$4 + 9 | 0] = 0;
         break block4;
        }
        if (!(HEAP8[$4 + 9 | 0] & 1)) {
         block5 : {
          if (HEAP32[$4 + 16 >> 2] < 64) {
           $2 = HEAPU16[$4 + 4 >> 1];
           $1 = HEAP32[$4 + 16 >> 2];
           HEAP32[$4 + 16 >> 2] = $1 + 1;
           HEAP16[($1 << 1) + $0 >> 1] = $2;
           $2 = HEAP16[$4 + 14 >> 1] << 16 >> 16;
           $1 = HEAP32[$4 + 16 >> 2];
           HEAP32[$4 + 16 >> 2] = $1 + 1;
           HEAP16[($1 << 1) + $0 >> 1] = $2 - 1;
           break block5;
          }
          HEAP32[$4 + 16 >> 2] = 65;
         }
         HEAP8[$4 + 9 | 0] = 1;
        }
       }
       HEAP16[$4 + 4 >> 1] = HEAPU16[$4 + 4 >> 1] + 1;
       continue;
      }
      break;
     };
     continue;
    }
    break;
   };
   if (HEAP32[$4 + 16 >> 2]) {
    jsiConsolePrintf(27708, 0)
   }
   graphicsSetVar($4 + 36 | 0);
   HEAP32[$4 + 124 >> 2] = jsvLockAgain(HEAP32[$4 + 120 >> 2]);
  }
  __stack_pointer = $4 + 128 | 0;
  return HEAP32[$4 + 124 >> 2];
 }
 
 function _jswrap_graphics_floodFill_inside($0, $1, $2, $3) {
  var $4 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 24 >> 2] = $0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  block2 : {
   block1 : {
    block : {
     if ((HEAP32[$4 + 20 >> 2] | HEAP32[$4 + 16 >> 2]) < 0) {
      break block
     }
     $0 = HEAP32[$4 + 24 >> 2];
     if (HEAP32[$4 + 20 >> 2] >= (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8)) {
      break block
     }
     $0 = HEAP32[$4 + 24 >> 2];
     if (HEAP32[$4 + 16 >> 2] < (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) {
      break block1
     }
    }
    HEAP8[$4 + 31 | 0] = 0;
    break block2;
   }
   HEAP8[$4 + 31 | 0] = (graphicsGetPixel(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]) | 0) == HEAP32[$4 + 12 >> 2];
  }
  __stack_pointer = $4 + 32 | 0;
  return HEAP8[$4 + 31 | 0] & 1;
 }
 
 function jswrap_graphics_theme($0) {
  $0 = $0 | 0;
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 8 >> 2] = jsvNewObject();
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 17024, jsvNewFromInteger(HEAPU8[416613] | HEAPU8[416614] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 17028, jsvNewFromInteger(HEAPU8[416615] | HEAPU8[416616] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 22372, jsvNewFromInteger(HEAPU8[416617] | HEAPU8[416618] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 22376, jsvNewFromInteger(HEAPU8[416619] | HEAPU8[416620] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 21470, jsvNewFromInteger(HEAPU8[416621] | HEAPU8[416622] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 21474, jsvNewFromInteger(HEAPU8[416623] | HEAPU8[416624] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 15945, jsvNewFromBool(HEAP8[416625] & 1));
  __stack_pointer = $1 + 16 | 0;
  return HEAP32[$1 + 8 >> 2];
 }
 
 function jswrap_graphics_setTheme($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = $1;
  if (jsvIsObject(HEAP32[$2 + 8 >> 2]) & 1) {
   HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 17024);
   if (HEAP32[$2 + 4 >> 2]) {
    $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
    HEAP8[416613] = $0;
    HEAP8[416614] = $0 >>> 8;
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
   }
   HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 17028);
   if (HEAP32[$2 + 4 >> 2]) {
    $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
    HEAP8[416615] = $0;
    HEAP8[416616] = $0 >>> 8;
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
   }
   HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 22372);
   if (HEAP32[$2 + 4 >> 2]) {
    $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
    HEAP8[416617] = $0;
    HEAP8[416618] = $0 >>> 8;
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
   }
   HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 22376);
   if (HEAP32[$2 + 4 >> 2]) {
    $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
    HEAP8[416619] = $0;
    HEAP8[416620] = $0 >>> 8;
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
   }
   HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 21470);
   if (HEAP32[$2 + 4 >> 2]) {
    $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
    HEAP8[416621] = $0;
    HEAP8[416622] = $0 >>> 8;
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
   }
   HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 21474);
   if (HEAP32[$2 + 4 >> 2]) {
    $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
    HEAP8[416623] = $0;
    HEAP8[416624] = $0 >>> 8;
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
   }
   HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 15945);
   if (HEAP32[$2 + 4 >> 2]) {
    HEAP8[416625] = jsvGetBoolAndUnLock(HEAP32[$2 + 4 >> 2]) & 1
   }
  }
  $0 = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
  __stack_pointer = $2 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_graphics_filter($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
  $4 = __stack_pointer - 288 | 0;
  $3 = $4;
  __stack_pointer = $3;
  HEAP32[$3 + 280 >> 2] = $0;
  HEAP32[$3 + 276 >> 2] = $1;
  HEAP32[$3 + 272 >> 2] = $2;
  block : {
   if (!(graphicsGetFromVar($3 + 200 | 0, HEAP32[$3 + 280 >> 2]) & 1)) {
    HEAP32[$3 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 196 >> 2] = 0;
   HEAP32[$3 + 192 >> 2] = 0;
   HEAP32[$3 + 188 >> 2] = 1;
   HEAP32[$3 + 184 >> 2] = 0;
   HEAP32[$3 + 180 >> 2] = (1 << HEAPU8[$3 + 216 | 0]) - 1;
   HEAP8[$3 + 179 | 0] = 0;
   HEAP32[$3 + 172 >> 2] = 0;
   HEAP32[$3 + 96 >> 2] = 4131;
   HEAP16[$3 + 100 >> 1] = 10;
   HEAP16[($3 + 96 | 0) + 6 >> 1] = 0;
   HEAP32[$3 + 104 >> 2] = $3 + 196;
   HEAP32[$3 + 108 >> 2] = 16557;
   HEAP16[$3 + 112 >> 1] = 10;
   HEAP16[($3 + 96 | 0) + 18 >> 1] = 0;
   HEAP32[$3 + 116 >> 2] = $3 + 192;
   HEAP32[$3 + 120 >> 2] = 4144;
   HEAP16[$3 + 124 >> 1] = 10;
   HEAP16[($3 + 96 | 0) + 30 >> 1] = 0;
   HEAP32[$3 + 128 >> 2] = $3 + 188;
   HEAP32[$3 + 132 >> 2] = 4966;
   HEAP16[$3 + 136 >> 1] = 10;
   HEAP16[($3 + 96 | 0) + 42 >> 1] = 0;
   HEAP32[$3 + 140 >> 2] = $3 + 184;
   HEAP32[$3 + 144 >> 2] = 3877;
   HEAP16[$3 + 148 >> 1] = 10;
   HEAP16[($3 + 96 | 0) + 54 >> 1] = 0;
   HEAP32[$3 + 152 >> 2] = $3 + 180;
   HEAP32[$3 + 156 >> 2] = 7935;
   HEAP16[$3 + 160 >> 1] = 29;
   HEAP16[($3 + 96 | 0) + 66 >> 1] = 0;
   HEAP32[$3 + 164 >> 2] = $3 + 172;
   HEAP32[$3 + 92 >> 2] = 0;
   HEAP32[$3 + 88 >> 2] = jsvGetDataPointer(HEAP32[$3 + 276 >> 2], $3 + 92 | 0);
   if (!(HEAP32[$3 + 88 >> 2] | !HEAP32[$3 + 276 >> 2])) {
    HEAP32[$3 + 92 >> 2] = jsvIterateCallbackCount(HEAP32[$3 + 276 >> 2]);
    block2 : {
     if (HEAP32[$3 + 92 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
      jsExceptionHere(1, 20608, 0);
      break block2;
     }
     $4 = $4 - (HEAP32[$3 + 92 >> 2] + 15 & -16) | 0;
     __stack_pointer = $4;
     HEAP32[$3 + 88 >> 2] = $4;
     jsvIterateCallbackToBytes(HEAP32[$3 + 276 >> 2], HEAP32[$3 + 88 >> 2], HEAP32[$3 + 92 >> 2]);
    }
   }
   if (!(wasm2js_i32$0 = jsvReadConfigObject(HEAP32[$3 + 272 >> 2], $3 + 96 | 0, 6) & 1, wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAP32[$3 + 88 >> 2], wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
    jsExceptionHere(1, 7147, 0);
    HEAP32[$3 + 284 >> 2] = 0;
    break block;
   }
   if (HEAP32[$3 + 172 >> 2]) {
    block4 : {
     if (jsvIsStringEqual(HEAP32[$3 + 172 >> 2], 3877) & 1) {
      HEAP8[$3 + 179 | 0] = 1;
      break block4;
     }
     jsExceptionHere(1, 7927, 0);
     jsvUnLock(HEAP32[$3 + 172 >> 2]);
     HEAP32[$3 + 284 >> 2] = 0;
     break block;
    }
    jsvUnLock(HEAP32[$3 + 172 >> 2]);
   }
   if (HEAP32[$3 + 92 >> 2] != (Math_imul(HEAP32[$3 + 196 >> 2], HEAP32[$3 + 192 >> 2]) | 0)) {
    jsExceptionHere(1, 16527, 0);
    HEAP32[$3 + 284 >> 2] = 0;
    break block;
   }
   HEAP32[$3 + 84 >> 2] = HEAPU8[$3 + 212 | 0] | HEAPU8[$3 + 213 | 0] << 8;
   HEAP32[$3 + 80 >> 2] = HEAPU8[$3 + 214 | 0] | HEAPU8[$3 + 215 | 0] << 8;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 84 >> 2] + HEAP32[$3 + 196 >> 2];
   HEAP32[$3 + 72 >> 2] = Math_imul(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 192 >> 2] - 1 | 0);
   HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 196 >> 2] - 1 >> 1;
   HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 192 >> 2] - 1 >> 1;
   HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 196 >> 2] - 1;
   HEAP32[$3 + 56 >> 2] = Math_imul(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 192 >> 2]);
   $4 = $4 - (HEAP32[$3 + 56 >> 2] + 15 & -16) | 0;
   __stack_pointer = $4;
   HEAP32[$3 + 52 >> 2] = $4;
   if (!HEAP32[$3 + 52 >> 2]) {
    jsExceptionHere(1, 16896, 0);
    HEAP32[$3 + 284 >> 2] = 0;
    break block;
   }
   $0 = HEAP32[$3 + 52 >> 2];
   $1 = HEAP32[$3 + 56 >> 2];
   if ($1) {
    wasm2js_memory_fill($0, 0, $1)
   }
   HEAP32[$3 + 48 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 48 >> 2] < HEAP32[$3 + 64 >> 2]) {
     HEAP32[$3 + 44 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 44 >> 2] < HEAP32[$3 + 84 >> 2]) {
       $0 = graphicsGetPixel($3 + 200 | 0, HEAP32[$3 + 44 >> 2], HEAP32[$3 + 48 >> 2]);
       HEAP8[HEAP32[$3 + 52 >> 2] + (HEAP32[$3 + 68 >> 2] + (HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 44 >> 2] | 0) | 0) | 0] = $0;
       HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + 1;
       continue;
      }
      break;
     };
     $2 = HEAP32[$3 + 52 >> 2];
     $1 = HEAP32[$3 + 52 >> 2];
     $0 = HEAP32[$3 + 76 >> 2];
     $4 = Math_imul(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 192 >> 2] - 1 | 0);
     if ($4) {
      wasm2js_memory_copy($2, $1 + $0 | 0, $4)
     }
     HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 64 >> 2];
   while (1) {
    if (HEAP32[$3 + 40 >> 2] < (HEAP32[$3 + 80 >> 2] + HEAP32[$3 + 64 >> 2] | 0)) {
     HEAP32[$3 + 36 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 36 >> 2] < (HEAP32[$3 + 196 >> 2] - 1 | 0)) {
       $0 = graphicsGetPixel($3 + 200 | 0, HEAP32[$3 + 36 >> 2], HEAP32[$3 + 40 >> 2]);
       HEAP8[HEAP32[$3 + 52 >> 2] + (HEAP32[$3 + 68 >> 2] + (HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 36 >> 2] | 0) | 0) | 0] = $0;
       HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 36 >> 2] + 1;
       continue;
      }
      break;
     };
     HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 196 >> 2] - 1;
     while (1) {
      if (HEAP32[$3 + 32 >> 2] < (HEAP32[$3 + 84 >> 2] + HEAP32[$3 + 60 >> 2] | 0)) {
       $0 = graphicsGetPixel($3 + 200 | 0, HEAP32[$3 + 32 >> 2], HEAP32[$3 + 40 >> 2]);
       HEAP8[HEAP32[$3 + 52 >> 2] + (HEAP32[$3 + 68 >> 2] + (HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 32 >> 2] | 0) | 0) | 0] = $0;
       HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 184 >> 2];
       HEAP32[$3 + 24 >> 2] = 0;
       HEAP32[$3 + 20 >> 2] = 0;
       while (1) {
        if (HEAP32[$3 + 20 >> 2] < HEAP32[$3 + 192 >> 2]) {
         HEAP32[$3 + 16 >> 2] = (HEAP32[$3 + 32 >> 2] + Math_imul(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 76 >> 2]) | 0) - HEAP32[$3 + 60 >> 2];
         HEAP32[$3 + 12 >> 2] = 0;
         while (1) {
          if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 196 >> 2]) {
           $0 = HEAP32[$3 + 88 >> 2];
           $1 = HEAP32[$3 + 24 >> 2];
           HEAP32[$3 + 24 >> 2] = $1 + 1;
           $1 = HEAP8[$0 + $1 | 0];
           $0 = HEAP32[$3 + 52 >> 2];
           $2 = HEAP32[$3 + 16 >> 2];
           HEAP32[$3 + 16 >> 2] = $2 + 1;
           HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + Math_imul($1, HEAPU8[$0 + $2 | 0]);
           HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
           continue;
          }
          break;
         };
         HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + 1;
         continue;
        }
        break;
       };
       HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 28 >> 2] / HEAP32[$3 + 188 >> 2];
       if (HEAP32[$3 + 8 >> 2] < 0) {
        HEAP32[$3 + 8 >> 2] = 0
       }
       if (HEAP32[$3 + 8 >> 2] > HEAP32[$3 + 180 >> 2]) {
        HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 180 >> 2]
       }
       if (HEAP8[$3 + 179 | 0] & 1) {
        HEAP32[$3 + 4 >> 2] = graphicsGetPixel($3 + 200 | 0, HEAP32[$3 + 32 >> 2] - HEAP32[$3 + 60 >> 2] | 0, HEAP32[$3 + 40 >> 2] - HEAP32[$3 + 64 >> 2] | 0);
        if (HEAP32[$3 + 4 >> 2] > HEAP32[$3 + 8 >> 2]) {
         HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 4 >> 2]
        }
       }
       graphicsSetPixel($3 + 200 | 0, HEAP32[$3 + 32 >> 2] - HEAP32[$3 + 60 >> 2] | 0, HEAP32[$3 + 40 >> 2] - HEAP32[$3 + 64 >> 2] | 0, HEAP32[$3 + 8 >> 2]);
       HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
       continue;
      }
      break;
     };
     $2 = HEAP32[$3 + 52 >> 2];
     $1 = HEAP32[$3 + 52 >> 2];
     $0 = HEAP32[$3 + 76 >> 2];
     $4 = Math_imul(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 192 >> 2] - 1 | 0);
     if ($4) {
      wasm2js_memory_copy($2, $1 + $0 | 0, $4)
     }
     HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 40 >> 2] + 1;
     continue;
    }
    break;
   };
   HEAP32[$3 + 284 >> 2] = jsvLockAgain(HEAP32[$3 + 280 >> 2]);
  }
  __stack_pointer = $3 + 288 | 0;
  return HEAP32[$3 + 284 >> 2];
 }
 
 function terminalGetGFX($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block : {
   if (!(HEAPU8[416680] | HEAPU8[416681] << 8 | (HEAPU8[416682] << 16 | HEAPU8[416683] << 24))) {
    HEAP8[$1 + 15 | 0] = 0;
    break block;
   }
   wasm2js_memory_copy(HEAP32[$1 + 8 >> 2], 416628, 72);
   HEAP8[$1 + 15 | 0] = 1;
  }
  return HEAP8[$1 + 15 | 0] & 1;
 }
 
 function terminalSetGFX($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 12 >> 2] = $0;
  wasm2js_memory_copy(416628, HEAP32[$1 + 12 >> 2], 72);
  HEAP8[441164] = 1;
 }
 
 function terminalScroll() {
  var $0 = 0, $1 = 0;
  $0 = __stack_pointer - 80 | 0;
  __stack_pointer = $0;
  HEAP8[244492] = HEAPU8[244492] - 1;
  if (terminalGetGFX($0 + 8 | 0) & 1) {
   HEAP32[$0 + 4 >> 2] = HEAPU8[$0 + 29 | 0] | HEAPU8[$0 + 30 | 0] << 8 | (HEAPU8[$0 + 31 | 0] << 16 | HEAPU8[$0 + 32 | 0] << 24);
   $1 = HEAPU8[416615] | HEAPU8[416616] << 8;
   HEAP8[$0 + 29 | 0] = $1;
   HEAP8[$0 + 30 | 0] = $1 >>> 8;
   HEAP8[$0 + 31 | 0] = $1 >>> 16;
   HEAP8[$0 + 32 | 0] = $1 >>> 24;
   graphicsScroll($0 + 8 | 0, 0, -8);
   $1 = HEAP32[$0 + 4 >> 2];
   HEAP8[$0 + 29 | 0] = $1;
   HEAP8[$0 + 30 | 0] = $1 >>> 8;
   HEAP8[$0 + 31 | 0] = $1 >>> 16;
   HEAP8[$0 + 32 | 0] = $1 >>> 24;
   terminalSetGFX($0 + 8 | 0);
   if (!(jshIsInInterrupt() & 1)) {
    jswrap_terminal_idle()
   }
  }
  __stack_pointer = $0 + 80 | 0;
 }
 
 function jswrap_terminal_idle() {
  if (HEAP8[441164] & 1) {
   graphicsInternalFlip();
   HEAP8[441164] = 0;
  }
  return 0;
 }
 
 function terminalSendChar($0) {
  var $1 = 0;
  $1 = __stack_pointer - 176 | 0;
  __stack_pointer = $1;
  HEAP8[$1 + 175 | 0] = $0;
  block : {
   if (!HEAPU8[441165]) {
    if (HEAPU8[$1 + 175 | 0] == 8) {
     if (HEAPU8[441163]) {
      HEAP8[441163] = HEAPU8[441163] - 1
     }
     break block;
    }
    block1 : {
     if (HEAPU8[$1 + 175 | 0] == 10) {
      HEAP8[441163] = 0;
      HEAP8[244492] = HEAPU8[244492] + 1;
      while (1) {
       if (HEAPU8[244492] >= 22) {
        terminalScroll();
        continue;
       }
       break;
      };
      break block1;
     }
     block2 : {
      if (HEAPU8[$1 + 175 | 0] == 13) {
       HEAP8[441163] = 0;
       break block2;
      }
      block3 : {
       if (HEAPU8[$1 + 175 | 0] == 27) {
        HEAP8[441165] = 27;
        break block3;
       }
       if (!(HEAPU8[$1 + 175 | 0] == 19 | HEAPU8[$1 + 175 | 0] == 17)) {
        if (terminalGetGFX($1 + 103 | 0) & 1) {
         HEAP16[$1 + 100 >> 1] = Math_imul(HEAPU8[441163], 6);
         HEAP16[$1 + 98 >> 1] = ((HEAPU8[$1 + 117 | 0] | HEAPU8[$1 + 118 | 0] << 8) + (HEAPU8[244492] << 3) | 0) - 176;
         HEAP32[$1 + 92 >> 2] = HEAPU8[$1 + 120 | 0] | HEAPU8[$1 + 121 | 0] << 8 | (HEAPU8[$1 + 122 | 0] << 16 | HEAPU8[$1 + 123 | 0] << 24);
         HEAP32[$1 + 88 >> 2] = HEAPU8[$1 + 124 | 0] | HEAPU8[$1 + 125 | 0] << 8 | (HEAPU8[$1 + 126 | 0] << 16 | HEAPU8[$1 + 127 | 0] << 24);
         $0 = HEAPU8[416613] | HEAPU8[416614] << 8;
         HEAP8[$1 + 120 | 0] = $0;
         HEAP8[$1 + 121 | 0] = $0 >>> 8;
         HEAP8[$1 + 122 | 0] = $0 >>> 16;
         HEAP8[$1 + 123 | 0] = $0 >>> 24;
         $0 = HEAPU8[416615] | HEAPU8[416616] << 8;
         HEAP8[$1 + 124 | 0] = $0;
         HEAP8[$1 + 125 | 0] = $0 >>> 8;
         HEAP8[$1 + 126 | 0] = $0 >>> 16;
         HEAP8[$1 + 127 | 0] = $0 >>> 24;
         graphicsDrawChar6x8($1 + 103 | 0, HEAP16[$1 + 100 >> 1] << 16 >> 16, HEAP16[$1 + 98 >> 1] << 16 >> 16, HEAP8[$1 + 175 | 0] << 24 >> 24, 1, 1, 1);
         $0 = HEAP32[$1 + 92 >> 2];
         HEAP8[$1 + 120 | 0] = $0;
         HEAP8[$1 + 121 | 0] = $0 >>> 8;
         HEAP8[$1 + 122 | 0] = $0 >>> 16;
         HEAP8[$1 + 123 | 0] = $0 >>> 24;
         $0 = HEAP32[$1 + 88 >> 2];
         HEAP8[$1 + 124 | 0] = $0;
         HEAP8[$1 + 125 | 0] = $0 >>> 8;
         HEAP8[$1 + 126 | 0] = $0 >>> 16;
         HEAP8[$1 + 127 | 0] = $0 >>> 24;
         terminalSetGFX($1 + 103 | 0);
        }
        if (HEAPU8[441163] < 255) {
         HEAP8[441163] = HEAPU8[441163] + 1
        }
       }
      }
     }
    }
    break block;
   }
   block5 : {
    if (HEAPU8[441165] == 27) {
     if (HEAPU8[441166] == 91) {
      if (HEAPU8[441167] == 63) {
       if (HEAPU8[441168] == 55) {
        terminalControlCharsReset();
        break block5;
       }
       block6 : {
        if (HEAPU8[$1 + 175 | 0] == 55) {
         HEAP8[441168] = 55;
         break block6;
        }
        terminalControlCharsReset();
       }
       break block5;
      }
      block7 : {
       if (HEAPU8[$1 + 175 | 0] == 63) {
        HEAP8[441167] = 63;
        break block7;
       }
       terminalControlCharsReset();
       block12 : {
        block13 : {
         switch (HEAP8[$1 + 175 | 0] - 65 | 0) {
         case 0:
          if (HEAPU8[244492]) {
           HEAP8[244492] = HEAPU8[244492] - 1
          }
          break block12;
         case 1:
          HEAP8[244492] = HEAPU8[244492] + 1;
          while (1) {
           if (HEAPU8[244492] >= 22) {
            terminalScroll();
            continue;
           }
           break;
          };
          break block12;
         case 2:
          if (HEAPU8[441163] < 255) {
           HEAP8[441163] = HEAPU8[441163] + 1
          }
          break block12;
         case 3:
          if (HEAPU8[441163]) {
           HEAP8[441163] = HEAPU8[441163] - 1
          }
          break block12;
         case 9:
          break block13;
         default:
          break block12;
         };
        }
        if (terminalGetGFX($1 + 16 | 0) & 1) {
         HEAP16[$1 + 14 >> 1] = Math_imul(HEAPU8[441163], 6);
         HEAP16[$1 + 12 >> 1] = ((HEAPU8[$1 + 30 | 0] | HEAPU8[$1 + 31 | 0] << 8) + (HEAPU8[244492] << 3) | 0) - 176;
         if ((HEAPU8[$1 + 24 | 0] | HEAPU8[$1 + 25 | 0] << 8 | (HEAPU8[$1 + 26 | 0] << 16 | HEAPU8[$1 + 27 | 0] << 24)) & 16) {
          $0 = HEAPU8[$1 + 30 | 0] | HEAPU8[$1 + 31 | 0] << 8
         } else {
          $0 = HEAPU8[$1 + 28 | 0] | HEAPU8[$1 + 29 | 0] << 8
         }
         HEAP16[$1 + 10 >> 1] = $0;
         if ((HEAPU8[$1 + 24 | 0] | HEAPU8[$1 + 25 | 0] << 8 | (HEAPU8[$1 + 26 | 0] << 16 | HEAPU8[$1 + 27 | 0] << 24)) & 16) {
          $0 = HEAPU8[$1 + 28 | 0] | HEAPU8[$1 + 29 | 0] << 8
         } else {
          $0 = HEAPU8[$1 + 30 | 0] | HEAPU8[$1 + 31 | 0] << 8
         }
         HEAP16[$1 + 8 >> 1] = $0;
         graphicsFillRect($1 + 16 | 0, HEAP16[$1 + 14 >> 1] << 16 >> 16, HEAP16[$1 + 12 >> 1] << 16 >> 16, (HEAP16[$1 + 10 >> 1] << 16 >> 16) - 1 | 0, (HEAP16[$1 + 12 >> 1] << 16 >> 16) + 7 | 0, 0);
         graphicsFillRect($1 + 16 | 0, 0, (HEAP16[$1 + 12 >> 1] << 16 >> 16) + 8 | 0, (HEAP16[$1 + 10 >> 1] << 16 >> 16) - 1 | 0, (HEAP16[$1 + 8 >> 1] << 16 >> 16) - 1 | 0, 0);
         terminalSetGFX($1 + 16 | 0);
        }
       }
      }
      break block5;
     }
     block16 : {
      if (HEAP8[$1 + 175 | 0] == 91) {
       HEAP8[441166] = 91;
       break block16;
      }
      terminalControlCharsReset();
     }
     break block5;
    }
    terminalControlCharsReset();
   }
  }
  __stack_pointer = $1 + 176 | 0;
 }
 
 function terminalControlCharsReset() {
  HEAP8[441165] = 0;
  HEAP8[441166] = 0;
  HEAP8[441167] = 0;
  HEAP8[441168] = 0;
 }
 
 function jswrap_terminal_init() {
  terminalControlCharsReset();
  HEAP8[441163] = 0;
  HEAP8[244492] = 21;
 }
 
 function jswrap_crypto_error_to_str($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAP32[$1 + 8 >> 2] = $0;
  block4 : {
   block3 : {
    block2 : {
     block : {
      block1 : {
       $0 = HEAP32[$1 + 8 >> 2];
       if (($0 | 0) != -20864) {
        if (($0 | 0) == -20736) {
         break block
        }
        if (($0 | 0) == -20608) {
         break block1
        }
        if (($0 | 0) == -15) {
         break block2
        }
        break block3;
       }
       HEAP32[$1 + 12 >> 2] = 3544;
       break block4;
      }
      HEAP32[$1 + 12 >> 2] = 18010;
      break block4;
     }
     HEAP32[$1 + 12 >> 2] = 20552;
     break block4;
    }
    HEAP32[$1 + 12 >> 2] = 19180;
    break block4;
   }
   HEAP32[$1 + 12 >> 2] = 0;
  }
  return HEAP32[$1 + 12 >> 2];
 }
 
 function jswrap_crypto_error($0) {
  var $1 = 0;
  $1 = __stack_pointer - 32 | 0;
  __stack_pointer = $1;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP32[$1 + 24 >> 2] = jswrap_crypto_error_to_str(HEAP32[$1 + 28 >> 2]);
  block : {
   if (HEAP32[$1 + 24 >> 2]) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 24 >> 2];
    jsError(7674, $1);
    break block;
   }
   HEAP32[$1 + 16 >> 2] = 0 - HEAP32[$1 + 28 >> 2];
   jsError(3915, $1 + 16 | 0);
  }
  __stack_pointer = $1 + 32 | 0;
 }
 
 function jswrap_crypto_SHAx($0, $1) {
  var $2 = 0, $3 = 0;
  $3 = __stack_pointer - 32 | 0;
  $2 = $3;
  __stack_pointer = $2;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 24 >> 2], $2 + 16 | 0);
  if (!(HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 24 >> 2])) {
   HEAP32[$2 + 16 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 24 >> 2]);
   block1 : {
    if (HEAP32[$2 + 16 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 20608, 0);
     break block1;
    }
    $3 = $3 - (HEAP32[$2 + 16 >> 2] + 15 & -16) | 0;
    __stack_pointer = $3;
    HEAP32[$2 + 12 >> 2] = $3;
    jsvIterateCallbackToBytes(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
   }
  }
  block2 : {
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break block2;
   }
   HEAP32[$2 + 8 >> 2] = 20;
   if (HEAP32[$2 + 20 >> 2] > 1) {
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 20 >> 2] / 8
   }
   HEAP32[$2 + 4 >> 2] = 0;
   HEAP32[$2 >> 2] = jsvNewArrayBufferWithPtr(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
   if (!HEAP32[$2 + 4 >> 2]) {
    jsError(4741, 0);
    HEAP32[$2 + 28 >> 2] = 0;
    break block2;
   }
   block3 : {
    if (HEAP32[$2 + 20 >> 2] == 1) {
     mbedtls_sha1(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2]);
     break block3;
    }
    block4 : {
     if (HEAP32[$2 + 20 >> 2] == 224) {
      mbedtls_sha256(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 1);
      break block4;
     }
     block5 : {
      if (HEAP32[$2 + 20 >> 2] == 256) {
       mbedtls_sha256(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 0);
       break block5;
      }
      block6 : {
       if (HEAP32[$2 + 20 >> 2] == 384) {
        mbedtls_sha512(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 1);
        break block6;
       }
       if (HEAP32[$2 + 20 >> 2] == 512) {
        mbedtls_sha512(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 0)
       }
      }
     }
    }
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
  }
  __stack_pointer = $2 + 32 | 0;
  return HEAP32[$2 + 28 >> 2];
 }
 
 function jswrap_crypto_AES_ccmCrypt($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  $6 = __stack_pointer - 160 | 0;
  $5 = $6;
  __stack_pointer = $5;
  HEAP32[$5 + 152 >> 2] = $0;
  HEAP32[$5 + 148 >> 2] = $1;
  HEAP32[$5 + 144 >> 2] = $2;
  HEAP32[$5 + 140 >> 2] = $3;
  HEAP8[$5 + 139 | 0] = $4;
  $0 = $5 + 126 | 0;
  HEAP8[$0 | 0] = 0;
  HEAP8[$0 + 1 | 0] = 0;
  HEAP8[$0 + 2 | 0] = 0;
  HEAP8[$0 + 3 | 0] = 0;
  HEAP8[$0 + 4 | 0] = 0;
  HEAP8[$0 + 5 | 0] = 0;
  HEAP8[$0 + 6 | 0] = 0;
  HEAP8[$0 + 7 | 0] = 0;
  HEAP8[$0 + 5 | 0] = 0;
  HEAP8[$0 + 6 | 0] = 0;
  HEAP8[$0 + 7 | 0] = 0;
  HEAP8[$0 + 8 | 0] = 0;
  HEAP8[$0 + 9 | 0] = 0;
  HEAP8[$0 + 10 | 0] = 0;
  HEAP8[$0 + 11 | 0] = 0;
  HEAP8[$0 + 12 | 0] = 0;
  HEAP32[$5 + 120 >> 2] = 0;
  block2 : {
   block3 : {
    block : {
     if (!(jsvIsArray(HEAP32[$5 + 144 >> 2]) & 1)) {
      if (!(jsvIsArrayBuffer(HEAP32[$5 + 144 >> 2]) & 1)) {
       break block
      }
     }
     jsvIterateCallbackToBytes(HEAP32[$5 + 144 >> 2], $5 + 126 | 0, 13);
     HEAP32[$5 + 120 >> 2] = jsvGetLength(HEAP32[$5 + 144 >> 2]);
     if (!(HEAPU32[$5 + 120 >> 2] <= 13 & HEAP32[$5 + 120 >> 2] >= 2)) {
      jswrap_crypto_error(-20736);
      HEAP32[$5 + 156 >> 2] = 0;
      break block2;
     }
     break block3;
    }
    jswrap_crypto_error(-20736);
    HEAP32[$5 + 156 >> 2] = 0;
    break block2;
   }
   HEAP32[$5 + 116 >> 2] = 0;
   HEAP32[$5 + 112 >> 2] = jsvGetDataPointer(HEAP32[$5 + 152 >> 2], $5 + 116 | 0);
   if (!(HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 152 >> 2])) {
    HEAP32[$5 + 116 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 152 >> 2]);
    block5 : {
     if (HEAP32[$5 + 116 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
      jsExceptionHere(1, 20608, 0);
      break block5;
     }
     $6 = $6 - (HEAP32[$5 + 116 >> 2] + 15 & -16) | 0;
     __stack_pointer = $6;
     HEAP32[$5 + 112 >> 2] = $6;
     jsvIterateCallbackToBytes(HEAP32[$5 + 152 >> 2], HEAP32[$5 + 112 >> 2], HEAP32[$5 + 116 >> 2]);
    }
   }
   if (!HEAP32[$5 + 112 >> 2]) {
    HEAP32[$5 + 156 >> 2] = 0;
    break block2;
   }
   HEAP32[$5 + 108 >> 2] = 0;
   HEAP32[$5 + 104 >> 2] = jsvGetDataPointer(HEAP32[$5 + 148 >> 2], $5 + 108 | 0);
   if (!(HEAP32[$5 + 104 >> 2] | !HEAP32[$5 + 148 >> 2])) {
    HEAP32[$5 + 108 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 148 >> 2]);
    block7 : {
     if (HEAP32[$5 + 108 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
      jsExceptionHere(1, 20608, 0);
      break block7;
     }
     $6 = $6 - (HEAP32[$5 + 108 >> 2] + 15 & -16) | 0;
     __stack_pointer = $6;
     HEAP32[$5 + 104 >> 2] = $6;
     jsvIterateCallbackToBytes(HEAP32[$5 + 148 >> 2], HEAP32[$5 + 104 >> 2], HEAP32[$5 + 108 >> 2]);
    }
   }
   if (!HEAP32[$5 + 104 >> 2]) {
    HEAP32[$5 + 156 >> 2] = 0;
    break block2;
   }
   HEAP32[$5 + 100 >> 2] = 0;
   HEAP32[$5 + 96 >> 2] = jsvNewArrayBufferWithPtr(HEAP32[$5 + 116 >> 2], $5 + 100 | 0);
   if (!HEAP32[$5 + 100 >> 2]) {
    HEAP32[$5 + 156 >> 2] = 0;
    break block2;
   }
   HEAP32[$5 + 92 >> 2] = 0;
   mbedtls_ccm_init($5 + 36 | 0);
   HEAP32[$5 + 92 >> 2] = mbedtls_ccm_setkey($5 + 36 | 0, 2, HEAP32[$5 + 104 >> 2], HEAP32[$5 + 108 >> 2] << 3);
   if (!HEAP32[$5 + 92 >> 2]) {
    block11 : {
     if (HEAP8[$5 + 139 | 0] & 1) {
      HEAP32[$5 + 32 >> 2] = 0;
      block8 : {
       if (jsvIsNumeric(HEAP32[$5 + 140 >> 2]) & 1) {
        HEAP32[$5 + 32 >> 2] = jsvGetInteger(HEAP32[$5 + 140 >> 2]);
        break block8;
       }
       HEAP32[$5 + 92 >> 2] = -20736;
      }
      if (!HEAP32[$5 + 92 >> 2]) {
       if (HEAP32[$5 + 32 >> 2] & 1 | (HEAP32[$5 + 32 >> 2] < 4 | HEAP32[$5 + 32 >> 2] > 16)) {
        HEAP32[$5 + 92 >> 2] = -20736
       }
      }
      if (!HEAP32[$5 + 92 >> 2]) {
       $0 = HEAP32[$5 + 32 >> 2];
       HEAP32[$5 + 28 >> 2] = $6;
       $6 = $6 - ($0 + 15 & -16) | 0;
       __stack_pointer = $6;
       HEAP32[$5 + 24 >> 2] = $0;
       if ($0) {
        wasm2js_memory_fill($6, 0, $0)
       }
       HEAP32[$5 + 92 >> 2] = mbedtls_ccm_encrypt_and_tag($5 + 36 | 0, HEAP32[$5 + 116 >> 2], $5 + 126 | 0, HEAP32[$5 + 120 >> 2], 0, 0, HEAP32[$5 + 112 >> 2], HEAP32[$5 + 100 >> 2], $6, $0);
       if (!HEAP32[$5 + 92 >> 2]) {
        HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 96 >> 2];
        HEAP32[$5 + 96 >> 2] = jsvNewObject();
        jsvObjectSetChildAndUnLock(HEAP32[$5 + 96 >> 2], 20636, HEAP32[$5 + 20 >> 2]);
        jsvObjectSetChildAndUnLock(HEAP32[$5 + 96 >> 2], 17038, jsvNewArrayBufferWithData(HEAP32[$5 + 32 >> 2], $6));
       }
      }
      break block11;
     }
     HEAP32[$5 + 16 >> 2] = 0;
     HEAP32[$5 + 12 >> 2] = jsvGetDataPointer(HEAP32[$5 + 140 >> 2], $5 + 16 | 0);
     if (!(HEAP32[$5 + 12 >> 2] | !HEAP32[$5 + 140 >> 2])) {
      HEAP32[$5 + 16 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 140 >> 2]);
      block13 : {
       if (HEAP32[$5 + 16 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
        jsExceptionHere(1, 20608, 0);
        break block13;
       }
       $6 = $6 - (HEAP32[$5 + 16 >> 2] + 15 & -16) | 0;
       __stack_pointer = $6;
       HEAP32[$5 + 12 >> 2] = $6;
       jsvIterateCallbackToBytes(HEAP32[$5 + 140 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 16 >> 2]);
      }
     }
     if (!HEAP32[$5 + 12 >> 2]) {
      HEAP32[$5 + 92 >> 2] = -20736
     }
     if (!HEAP32[$5 + 92 >> 2]) {
      HEAP32[$5 + 92 >> 2] = mbedtls_ccm_auth_decrypt($5 + 36 | 0, HEAP32[$5 + 116 >> 2], $5 + 126 | 0, HEAP32[$5 + 120 >> 2], 0, 0, HEAP32[$5 + 112 >> 2], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 16 >> 2])
     }
    }
   }
   mbedtls_ccm_free($5 + 36 | 0);
   if (!HEAP32[$5 + 92 >> 2]) {
    HEAP32[$5 + 156 >> 2] = HEAP32[$5 + 96 >> 2];
    break block2;
   }
   jswrap_crypto_error(HEAP32[$5 + 92 >> 2]);
   jsvUnLock(HEAP32[$5 + 96 >> 2]);
   HEAP32[$5 + 156 >> 2] = 0;
  }
  __stack_pointer = $5 + 160 | 0;
  return HEAP32[$5 + 156 >> 2];
 }
 
 function jswrap_crypto_AES_ccmEncrypt($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = jswrap_crypto_AES_ccmCrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 1);
  __stack_pointer = $4 + 16 | 0;
  return $0 | 0;
 }
 
 function jswrap_crypto_AES_ccmDecrypt($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = $2;
  HEAP32[$4 >> 2] = $3;
  $0 = jswrap_crypto_AES_ccmCrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 0);
  __stack_pointer = $4 + 16 | 0;
  return $0 | 0;
 }
 
 function atan($0) {
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0.0, $6 = 0.0, $7 = 0, $8 = 0, $9 = 0;
  wasm2js_scratch_store_f64(+$0);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $1 = $4 & 2147483647;
  if ($1 >>> 0 >= 1141899264) {
   wasm2js_scratch_store_f64(1.5707963267948966);
   $1 = wasm2js_scratch_load_i32(1) | 0;
   $4 = wasm2js_scratch_load_i32(0) | 0;
   $7 = $4;
   $2 = $1 & 2147483647;
   $8 = $2;
   wasm2js_scratch_store_f64(+$0);
   $2 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $4 = $2 & -2147483648;
   $1 = $4;
   $2 = $7;
   wasm2js_scratch_store_i32(0, $9 | $2);
   $4 = $8;
   $1 = $4 | $1;
   wasm2js_scratch_store_i32(1, $1 | 0);
   $5 = +wasm2js_scratch_load_f64();
   $1 = __DOUBLE_BITS_2018($0);
   $4 = $1;
   $2 = i64toi32_i32$HIGH_BITS;
   $1 = $2 & 2147483647;
   $2 = $4;
   return ($1 | 0) == 2146435072 & ($2 | 0) != 0 | $1 >>> 0 > 2146435072 ? $0 : $5;
  }
  block1 : {
   block : {
    if ($1 >>> 0 <= 1071382527) {
     $2 = -1;
     if ($1 >>> 0 >= 1044381696) {
      break block
     }
     break block1;
    }
    $0 = fabs($0);
    if ($1 >>> 0 <= 1072889855) {
     if ($1 >>> 0 <= 1072037887) {
      $0 = ($0 + $0 + -1.0) / ($0 + 2.0);
      $2 = 0;
      break block;
     }
     $0 = ($0 + -1.0) / ($0 + 1.0);
     $2 = 1;
     break block;
    }
    if ($1 >>> 0 <= 1073971199) {
     $0 = ($0 + -1.5) / ($0 * 1.5 + 1.0);
     $2 = 2;
     break block;
    }
    $0 = -1.0 / $0;
    $2 = 3;
   }
   $6 = $0 * $0;
   $3 = $6 * $6;
   $5 = $3 * ($3 * ($3 * ($3 * ($3 * -.036531572744216916 + -.058335701337905735) + -.0769187620504483) + -.11111110405462356) + -.19999999999876483);
   $3 = $6 * ($3 * ($3 * ($3 * ($3 * ($3 * .016285820115365782 + .049768779946159324) + .06661073137387531) + .09090887133436507) + .14285714272503466) + .3333333333333293);
   if ($1 >>> 0 <= 1071382527) {
    return $0 - $0 * ($5 + $3)
   }
   $1 = $2 << 3;
   $0 = HEAPF64[$1 + 235040 >> 3] - ($0 * ($5 + $3) - HEAPF64[$1 + 235072 >> 3] - $0);
   $2 = $4;
   $0 = ($2 | 0) < 0 ? -$0 : $0;
  }
  return $0;
 }
 
 function __DOUBLE_BITS_2018($0) {
  var $1 = 0, $2 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $2 = wasm2js_scratch_load_i32(0) | 0;
  i64toi32_i32$HIGH_BITS = $1;
  return $2;
 }
 
 function atan2($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0, $9 = 0, $10 = 0;
  $2 = __DOUBLE_BITS_2020($1);
  $4 = $2;
  $3 = i64toi32_i32$HIGH_BITS;
  $2 = $3 & 2147483647;
  $3 = $4;
  block : {
   if (!$3 & ($2 | 0) == 2146435072 | $2 >>> 0 < 2146435072) {
    $3 = __DOUBLE_BITS_2020($0);
    $5 = $3;
    $2 = i64toi32_i32$HIGH_BITS;
    $3 = $2 & 2147483647;
    $2 = $5;
    if (!$2 & ($3 | 0) == 2146435072 | $3 >>> 0 < 2146435072) {
     break block
    }
   }
   return $0 + $1;
  }
  wasm2js_scratch_store_f64(+$1);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $5 = $2;
  $6 = $4;
  if (!($2 - 1072693248 | $4)) {
   return atan($0)
  }
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $9 = $5 >>> 30 & 2;
  $7 = $9 | $3 >>> 31;
  $2 = $3;
  $3 = $4;
  $4 = $2 & 2147483647;
  block3 : {
   if (!($4 | $3)) {
    block2 : {
     switch ($7 - 2 | 0) {
     case 0:
      return 3.141592653589793;
     case 1:
      break block2;
     default:
      break block3;
     };
    }
    return -3.141592653589793;
   }
   $5 = $5 & 2147483647;
   if (!($6 | $5)) {
    wasm2js_scratch_store_f64(1.5707963267948966);
    $2 = wasm2js_scratch_load_i32(1) | 0;
    $4 = wasm2js_scratch_load_i32(0) | 0;
    $5 = $4;
    $3 = $2 & 2147483647;
    $6 = $3;
    wasm2js_scratch_store_f64(+$0);
    $3 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    $4 = $3 & -2147483648;
    $3 = $5;
    $5 = $10;
    wasm2js_scratch_store_i32(0, $3 | $5);
    $2 = $4;
    $4 = $6;
    $2 = $2 | $4;
    wasm2js_scratch_store_i32(1, $2 | 0);
    return +wasm2js_scratch_load_f64();
   }
   block4 : {
    if (($5 | 0) == 2146435072) {
     if (($4 | 0) != 2146435072) {
      break block4
     }
     return HEAPF64[($7 << 3) + 235104 >> 3];
    }
    if (!(($4 | 0) != 2146435072 & $5 + 67108864 >>> 0 >= $4 >>> 0)) {
     wasm2js_scratch_store_f64(1.5707963267948966);
     $2 = wasm2js_scratch_load_i32(1) | 0;
     $4 = wasm2js_scratch_load_i32(0) | 0;
     $5 = $4;
     $3 = $2 & 2147483647;
     $6 = $3;
     wasm2js_scratch_store_f64(+$0);
     $3 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     $4 = $3 & -2147483648;
     $3 = $5;
     $5 = $10;
     wasm2js_scratch_store_i32(0, $3 | $5);
     $2 = $4;
     $4 = $6;
     $2 = $2 | $4;
     wasm2js_scratch_store_i32(1, $2 | 0);
     return +wasm2js_scratch_load_f64();
    }
    block5 : {
     if ($9) {
      $8 = 0.0;
      if ($4 + 67108864 >>> 0 < $5 >>> 0) {
       break block5
      }
     }
     $8 = atan(fabs($0 / $1));
    }
    $0 = $8;
    block8 : {
     switch ($7 - 1 | 0) {
     case 0:
      return -$0;
     case 1:
      return 3.141592653589793 - ($0 + -1.2246467991473532e-16);
     case 2:
      break block8;
     default:
      break block3;
     };
    }
    return $0 + -1.2246467991473532e-16 + -3.141592653589793;
   }
   $0 = HEAPF64[($7 << 3) + 235136 >> 3];
  }
  return $0;
 }
 
 function __DOUBLE_BITS_2020($0) {
  var $1 = 0, $2 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $2 = wasm2js_scratch_load_i32(0) | 0;
  i64toi32_i32$HIGH_BITS = $1;
  return $2;
 }
 
 function ceil($0) {
  $0 = +$0;
  return +Math_ceil($0);
 }
 
 function __cos($0, $1) {
  var $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0;
  $2 = $0 * $0;
  $3 = $2 * .5;
  $4 = 1.0 - $3;
  $5 = 1.0 - $4 - $3;
  $3 = $2 * $2;
  return $4 + ($5 + ($2 * ($2 * ($2 * ($2 * 2.480158728947673e-05 + -.001388888888887411) + .0416666666666666) + $3 * $3 * ($2 * ($2 * -1.1359647557788195e-11 + 2.087572321298175e-09) + -2.7557314351390663e-07)) - $0 * $1));
 }
 
 function __rem_pio2_large($0, $1, $2, $3, $4) {
  var $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0.0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0.0, $19 = 0.0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
  $8 = __stack_pointer - 560 | 0;
  __stack_pointer = $8;
  $7 = ($2 - 3 | 0) / 24 | 0;
  $17 = ($7 | 0) > 0 ? $7 : 0;
  $16 = Math_imul($17, -24) + $2 | 0;
  $12 = HEAP32[($4 << 2) + 235168 >> 2];
  $13 = $3 - 1 | 0;
  if (($12 + $13 | 0) >= 0) {
   $6 = $3 + $12 | 0;
   $2 = $17 - $13 | 0;
   $7 = 0;
   while (1) {
    $5 = ($2 | 0) < 0 ? 0.0 : +HEAP32[($2 << 2) + 235184 >> 2];
    HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = $5;
    $2 = $2 + 1 | 0;
    $7 = $7 + 1 | 0;
    if (($7 | 0) != ($6 | 0)) {
     continue
    }
    break;
   };
  }
  $14 = $16 - 24 | 0;
  $6 = 0;
  $9 = ($12 | 0) > 0 ? $12 : 0;
  $15 = ($3 | 0) <= 0;
  while (1) {
   block : {
    if ($15) {
     $5 = 0.0;
     break block;
    }
    $7 = $6 + $13 | 0;
    $2 = 0;
    $5 = 0.0;
    while (1) {
     $5 = HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3] + $5;
     $2 = $2 + 1 | 0;
     if (($3 | 0) != ($2 | 0)) {
      continue
     }
     break;
    };
   }
   HEAPF64[($6 << 3) + $8 >> 3] = $5;
   $2 = ($6 | 0) == ($9 | 0);
   $6 = $6 + 1 | 0;
   if (!$2) {
    continue
   }
   break;
  };
  $22 = 47 - $16 | 0;
  $20 = 48 - $16 | 0;
  $23 = $16 - 25 | 0;
  $6 = $12;
  block11 : {
   while (1) {
    $5 = HEAPF64[($6 << 3) + $8 >> 3];
    $2 = 0;
    $7 = $6;
    if (($6 | 0) > 0) {
     while (1) {
      $11 = ($8 + 480 | 0) + ($2 << 2) | 0;
      $10 = $5 * 5.9604644775390625e-08;
      if (Math_abs($10) < 2147483647.0) {
       $9 = ~~$10
      } else {
       $9 = -2147483648
      }
      $10 = +($9 | 0);
      $5 = $10 * -16777216.0 + $5;
      if (Math_abs($5) < 2147483647.0) {
       $9 = ~~$5
      } else {
       $9 = -2147483648
      }
      HEAP32[$11 >> 2] = $9;
      $7 = $7 - 1 | 0;
      $5 = HEAPF64[($7 << 3) + $8 >> 3] + $10;
      $2 = $2 + 1 | 0;
      if (($6 | 0) != ($2 | 0)) {
       continue
      }
      break;
     }
    }
    $5 = scalbn($5, $14);
    $5 = $5 + floor($5 * .125) * -8.0;
    $13 = Math_abs($5) < 2147483647.0 ? ~~$5 : -2147483648;
    $5 = $5 - +($13 | 0);
    block3 : {
     block4 : {
      block2 : {
       $21 = ($14 | 0) <= 0;
       block1 : {
        if (!$21) {
         $7 = ($6 << 2) + $8 | 0;
         $2 = $7 + 476 | 0;
         $9 = $2;
         $2 = HEAP32[$7 + 476 >> 2];
         $7 = $2;
         $2 = $2 >> $20;
         $7 = $7 - ($2 << $20) | 0;
         HEAP32[$9 >> 2] = $7;
         $13 = $2 + $13 | 0;
         $11 = $7 >> $22;
         break block1;
        }
        if ($14) {
         break block2
        }
        $11 = HEAP32[(($6 << 2) + $8 | 0) + 476 >> 2] >> 23;
       }
       if (($11 | 0) <= 0) {
        break block3
       }
       break block4;
      }
      $11 = 2;
      if ($5 >= .5) {
       break block4
      }
      $11 = 0;
      break block3;
     }
     $2 = 0;
     $9 = 0;
     $7 = 1;
     if (($6 | 0) > 0) {
      while (1) {
       $15 = ($8 + 480 | 0) + ($2 << 2) | 0;
       $7 = HEAP32[$15 >> 2];
       block6 : {
        block5 : {
         if ($9) {
          $9 = 16777215
         } else {
          if (!$7) {
           break block5
          }
          $9 = 16777216;
         }
         HEAP32[$15 >> 2] = $9 - $7;
         $7 = 0;
         $9 = 1;
         break block6;
        }
        $7 = 1;
        $9 = 0;
       }
       $2 = $2 + 1 | 0;
       if (($6 | 0) != ($2 | 0)) {
        continue
       }
       break;
      }
     }
     block7 : {
      if ($21) {
       break block7
      }
      $2 = 8388607;
      block8 : {
       switch ($23 | 0) {
       case 1:
        $2 = 4194303;
        break;
       case 0:
        break block8;
       default:
        break block7;
       };
      }
      $15 = ($6 << 2) + $8 | 0;
      $9 = $15 + 476 | 0;
      HEAP32[$9 >> 2] = HEAP32[$15 + 476 >> 2] & $2;
     }
     $13 = $13 + 1 | 0;
     if (($11 | 0) != 2) {
      break block3
     }
     $5 = 1.0 - $5;
     $11 = 2;
     if ($7) {
      break block3
     }
     $5 = $5 - scalbn(1.0, $14);
    }
    if ($5 == 0.0) {
     $7 = 0;
     block10 : {
      $2 = $6;
      if (($12 | 0) >= ($2 | 0)) {
       break block10
      }
      while (1) {
       $2 = $2 - 1 | 0;
       $7 = HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2] | $7;
       if (($2 | 0) > ($12 | 0)) {
        continue
       }
       break;
      };
      if (!$7) {
       break block10
      }
      while (1) {
       $14 = $14 - 24 | 0;
       $6 = $6 - 1 | 0;
       if (!HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2]) {
        continue
       }
       break;
      };
      break block11;
     }
     $2 = 1;
     while (1) {
      $7 = $2;
      $2 = $2 + 1 | 0;
      if (!HEAP32[($8 + 480 | 0) + ($12 - $7 << 2) >> 2]) {
       continue
      }
      break;
     };
     $9 = $6 + $7 | 0;
     while (1) {
      $7 = $3 + $6 | 0;
      $6 = $6 + 1 | 0;
      HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = HEAP32[($17 + $6 << 2) + 235184 >> 2];
      $2 = 0;
      $5 = 0.0;
      if (($3 | 0) > 0) {
       while (1) {
        $5 = HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3] + $5;
        $2 = $2 + 1 | 0;
        if (($3 | 0) != ($2 | 0)) {
         continue
        }
        break;
       }
      }
      HEAPF64[($6 << 3) + $8 >> 3] = $5;
      if (($6 | 0) < ($9 | 0)) {
       continue
      }
      break;
     };
     $6 = $9;
     continue;
    }
    break;
   };
   $5 = scalbn($5, 24 - $16 | 0);
   block12 : {
    if ($5 >= 16777216.0) {
     $3 = ($8 + 480 | 0) + ($6 << 2) | 0;
     $10 = $5 * 5.9604644775390625e-08;
     if (Math_abs($10) < 2147483647.0) {
      $2 = ~~$10
     } else {
      $2 = -2147483648
     }
     $10 = +($2 | 0) * -16777216.0 + $5;
     if (Math_abs($10) < 2147483647.0) {
      $0 = ~~$10
     } else {
      $0 = -2147483648
     }
     HEAP32[$3 >> 2] = $0;
     $6 = $6 + 1 | 0;
     $14 = $16;
     break block12;
    }
    $2 = Math_abs($5) < 2147483647.0 ? ~~$5 : -2147483648;
   }
   HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2] = $2;
  }
  $5 = scalbn(1.0, $14);
  if (($6 | 0) >= 0) {
   $3 = $6;
   while (1) {
    $2 = $3;
    HEAPF64[($2 << 3) + $8 >> 3] = $5 * +HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2];
    $3 = $2 - 1 | 0;
    $5 = $5 * 5.9604644775390625e-08;
    if ($2) {
     continue
    }
    break;
   };
   $7 = $6;
   while (1) {
    $5 = 0.0;
    $2 = 0;
    $9 = $6 - $7 | 0;
    $0 = ($9 | 0) > ($12 | 0) ? $12 : $9;
    if (($0 | 0) >= 0) {
     while (1) {
      $5 = HEAPF64[($2 << 3) + 237952 >> 3] * HEAPF64[($2 + $7 << 3) + $8 >> 3] + $5;
      $3 = ($0 | 0) != ($2 | 0);
      $2 = $2 + 1 | 0;
      if ($3) {
       continue
      }
      break;
     }
    }
    HEAPF64[($8 + 160 | 0) + ($9 << 3) >> 3] = $5;
    $0 = ($7 | 0) > 0;
    $7 = $7 - 1 | 0;
    if ($0) {
     continue
    }
    break;
   };
  }
  block16 : {
   block18 : {
    block14 : {
     switch ($4 | 0) {
     case 3:
      block17 : {
       if (($6 | 0) <= 0) {
        break block17
       }
       $5 = HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
       $2 = $6;
       while (1) {
        $3 = $2 - 1 | 0;
        $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
        $10 = HEAPF64[$7 >> 3];
        $18 = $10;
        $10 = $10 + $5;
        HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($18 - $10);
        HEAPF64[$7 >> 3] = $10;
        $0 = $2 >>> 0 > 1;
        $5 = $10;
        $2 = $3;
        if ($0) {
         continue
        }
        break;
       };
       if (($6 | 0) == 1) {
        break block17
       }
       $5 = HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
       $2 = $6;
       while (1) {
        $3 = $2 - 1 | 0;
        $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
        $10 = HEAPF64[$7 >> 3];
        $18 = $10;
        $10 = $10 + $5;
        HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($18 - $10);
        HEAPF64[$7 >> 3] = $10;
        $0 = $2 >>> 0 > 2;
        $5 = $10;
        $2 = $3;
        if ($0) {
         continue
        }
        break;
       };
       while (1) {
        $19 = $19 + HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
        $0 = $6 >>> 0 > 2;
        $6 = $6 - 1 | 0;
        if ($0) {
         continue
        }
        break;
       };
      }
      $5 = HEAPF64[$8 + 160 >> 3];
      if ($11) {
       break block18
      }
      HEAPF64[$1 >> 3] = $5;
      $5 = HEAPF64[$8 + 168 >> 3];
      HEAPF64[$1 + 16 >> 3] = $19;
      HEAPF64[$1 + 8 >> 3] = $5;
      break block16;
     case 0:
      $5 = 0.0;
      if (($6 | 0) >= 0) {
       while (1) {
        $2 = $6;
        $6 = $2 - 1 | 0;
        $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
        if ($2) {
         continue
        }
        break;
       }
      }
      HEAPF64[$1 >> 3] = $11 ? -$5 : $5;
      break block16;
     case 1:
     case 2:
      break block14;
     default:
      break block16;
     };
    }
    $5 = 0.0;
    if (($6 | 0) >= 0) {
     $3 = $6;
     while (1) {
      $2 = $3;
      $3 = $2 - 1 | 0;
      $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
      if ($2) {
       continue
      }
      break;
     };
    }
    HEAPF64[$1 >> 3] = $11 ? -$5 : $5;
    $5 = HEAPF64[$8 + 160 >> 3] - $5;
    $2 = 1;
    if (($6 | 0) > 0) {
     while (1) {
      $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
      $0 = ($2 | 0) != ($6 | 0);
      $2 = $2 + 1 | 0;
      if ($0) {
       continue
      }
      break;
     }
    }
    HEAPF64[$1 + 8 >> 3] = $11 ? -$5 : $5;
    break block16;
   }
   HEAPF64[$1 >> 3] = -$5;
   $5 = HEAPF64[$8 + 168 >> 3];
   HEAPF64[$1 + 16 >> 3] = -$19;
   HEAPF64[$1 + 8 >> 3] = -$5;
  }
  __stack_pointer = $8 + 560 | 0;
  return $13 & 7;
 }
 
 function __rem_pio2($0, $1) {
  var $2 = 0.0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0;
  $7 = __stack_pointer - 48 | 0;
  __stack_pointer = $7;
  wasm2js_scratch_store_f64(+$0);
  $8 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  block1 : {
   block2 : {
    $3 = $8;
    $9 = $3 & 2147483647;
    block : {
     if ($9 >>> 0 <= 1074752122) {
      if (($3 & 1048575) == 598523) {
       break block
      }
      if ($9 >>> 0 <= 1073928572) {
       $6 = $3;
       if (($3 | 0) > 0) {
        $4 = 1
       } else {
        $4 = ($6 | 0) >= 0
       }
       if ($4) {
        $0 = $0 + -1.5707963267341256;
        $2 = $0 + -6.077100506506192e-11;
        HEAPF64[$1 >> 3] = $2;
        HEAPF64[$1 + 8 >> 3] = $0 - $2 + -6.077100506506192e-11;
        $3 = 1;
        break block1;
       }
       $0 = $0 + 1.5707963267341256;
       $2 = $0 + 6.077100506506192e-11;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + 6.077100506506192e-11;
       $3 = -1;
       break block1;
      }
      if (($8 | 0) > 0) {
       $4 = 1
      } else {
       $4 = ($8 | 0) >= 0
      }
      if ($4) {
       $0 = $0 + -3.1415926534682512;
       $2 = $0 + -1.2154201013012384e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.2154201013012384e-10;
       $3 = 2;
       break block1;
      }
      $0 = $0 + 3.1415926534682512;
      $2 = $0 + 1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.2154201013012384e-10;
      $3 = -2;
      break block1;
     }
     if ($9 >>> 0 <= 1075594811) {
      if ($9 >>> 0 <= 1075183036) {
       if (($9 | 0) == 1074977148) {
        break block
       }
       $4 = $8;
       if (($8 | 0) > 0) {
        $4 = 1
       } else {
        $4 = ($4 | 0) >= 0
       }
       if ($4) {
        $0 = $0 + -4.712388980202377;
        $2 = $0 + -1.8231301519518578e-10;
        HEAPF64[$1 >> 3] = $2;
        HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.8231301519518578e-10;
        $3 = 3;
        break block1;
       }
       $0 = $0 + 4.712388980202377;
       $2 = $0 + 1.8231301519518578e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.8231301519518578e-10;
       $3 = -3;
       break block1;
      }
      if (($9 | 0) == 1075388923) {
       break block
      }
      $6 = $8;
      if (($8 | 0) > 0) {
       $4 = 1
      } else {
       $4 = ($6 | 0) >= 0
      }
      if ($4) {
       $0 = $0 + -6.2831853069365025;
       $2 = $0 + -2.430840202602477e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -2.430840202602477e-10;
       $3 = 4;
       break block1;
      }
      $0 = $0 + 6.2831853069365025;
      $2 = $0 + 2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 2.430840202602477e-10;
      $3 = -4;
      break block1;
     }
     if ($9 >>> 0 > 1094263290) {
      break block2
     }
    }
    $5 = $0 * .6366197723675814 + 6755399441055744.0 + -6755399441055744.0;
    if (Math_abs($5) < 2147483647.0) {
     $3 = ~~$5
    } else {
     $3 = -2147483648
    }
    $2 = $0 + $5 * -1.5707963267341256;
    $10 = $5 * 6.077100506506192e-11;
    $11 = $2 - $10;
    block3 : {
     if ($11 < -.7853981633974483) {
      $3 = $3 - 1 | 0;
      $5 = $5 + -1.0;
      $10 = $5 * 6.077100506506192e-11;
      $2 = $0 + $5 * -1.5707963267341256;
      break block3;
     }
     if (!($11 > .7853981633974483)) {
      break block3
     }
     $3 = $3 + 1 | 0;
     $5 = $5 + 1.0;
     $10 = $5 * 6.077100506506192e-11;
     $2 = $0 + $5 * -1.5707963267341256;
    }
    $0 = $2 - $10;
    HEAPF64[$1 >> 3] = $0;
    wasm2js_scratch_store_f64(+$0);
    $6 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    $12 = $9 >>> 20 | 0;
    block4 : {
     if (($12 - ($6 >>> 20 & 2047) | 0) < 17) {
      break block4
     }
     $0 = $5 * 6.077100506303966e-11;
     $11 = $2 - $0;
     $10 = $5 * 2.0222662487959506e-21 - ($2 - $11 - $0);
     $0 = $11 - $10;
     HEAPF64[$1 >> 3] = $0;
     wasm2js_scratch_store_f64(+$0);
     $6 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     if (($12 - ($6 >>> 20 & 2047) | 0) < 50) {
      $2 = $11;
      break block4;
     }
     $0 = $5 * 2.0222662487111665e-21;
     $2 = $11 - $0;
     $10 = $5 * 8.4784276603689e-32 - ($11 - $2 - $0);
     $0 = $2 - $10;
     HEAPF64[$1 >> 3] = $0;
    }
    HEAPF64[$1 + 8 >> 3] = $2 - $0 - $10;
    break block1;
   }
   if ($9 >>> 0 >= 2146435072) {
    $0 = $0 - $0;
    HEAPF64[$1 >> 3] = $0;
    HEAPF64[$1 + 8 >> 3] = $0;
    $3 = 0;
    break block1;
   }
   $13 = $7 + 16 | 8;
   $6 = $8 & 1048575;
   wasm2js_scratch_store_i32(0, $4 | 0);
   $6 = $6 | 1096810496;
   wasm2js_scratch_store_i32(1, $6 | 0);
   $0 = +wasm2js_scratch_load_f64();
   $3 = $7 + 16 | 0;
   $12 = 1;
   while (1) {
    $2 = +((Math_abs($0) < 2147483647.0 ? ~~$0 : -2147483648) | 0);
    HEAPF64[$3 >> 3] = $2;
    $0 = ($0 - $2) * 16777216.0;
    $6 = $12 & 1;
    $12 = 0;
    $3 = $13;
    if ($6) {
     continue
    }
    break;
   };
   HEAPF64[$7 + 32 >> 3] = $0;
   $3 = 2;
   while (1) {
    $12 = $3;
    $3 = $3 - 1 | 0;
    if (HEAPF64[($7 + 16 | 0) + ($12 << 3) >> 3] == 0.0) {
     continue
    }
    break;
   };
   $3 = __rem_pio2_large($7 + 16 | 0, $7, ($9 >>> 20 | 0) - 1046 | 0, $12 + 1 | 0, 1);
   $0 = HEAPF64[$7 >> 3];
   if (($8 | 0) < 0) {
    HEAPF64[$1 >> 3] = -$0;
    HEAPF64[$1 + 8 >> 3] = -HEAPF64[$7 + 8 >> 3];
    $3 = 0 - $3 | 0;
    break block1;
   }
   HEAPF64[$1 >> 3] = $0;
   HEAPF64[$1 + 8 >> 3] = HEAPF64[$7 + 8 >> 3];
  }
  __stack_pointer = $7 + 48 | 0;
  return $3;
 }
 
 function __sin($0, $1, $2) {
  var $3 = 0.0, $4 = 0.0, $5 = 0.0;
  $3 = $0 * $0;
  $5 = $3 * ($3 * $3) * ($3 * 1.58969099521155e-10 + -2.5050760253406863e-08) + ($3 * ($3 * 2.7557313707070068e-06 + -1.984126982985795e-04) + .00833333333332249);
  $4 = $0 * $3;
  if (!$2) {
   return $4 * ($3 * $5 + -.16666666666666632) + $0
  }
  return $0 - ($3 * ($1 * .5 - $4 * $5) - $1 + $4 * .16666666666666632);
 }
 
 function cos($0) {
  var $1 = 0.0, $2 = 0, $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $2 = $2 & 2147483647;
  block : {
   if ($2 >>> 0 <= 1072243195) {
    $1 = 1.0;
    if ($2 >>> 0 < 1044816030) {
     break block
    }
    $1 = __cos($0, 0.0);
    break block;
   }
   $1 = $0 - $0;
   if ($2 >>> 0 >= 2146435072) {
    break block
   }
   $2 = __rem_pio2($0, $3);
   $0 = HEAPF64[$3 + 8 >> 3];
   $1 = HEAPF64[$3 >> 3];
   block3 : {
    switch (($2 & 3) - 1 | 0) {
    default:
     $1 = __cos($1, $0);
     break block;
    case 0:
     $1 = -__sin($1, $0, 1);
     break block;
    case 1:
     $1 = -__cos($1, $0);
     break block;
    case 2:
     break block3;
    };
   }
   $1 = __sin($1, $0, 1);
  }
  __stack_pointer = $3 + 16 | 0;
  return $1;
 }
 
 function __math_xflow($0, $1) {
  return $1 * fp_barrier($0 ? -$1 : $1);
 }
 
 function fp_barrier($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  return HEAPF64[$1 + 8 >> 3];
 }
 
 function __math_uflow($0) {
  return __math_xflow($0, 1.2882297539194267e-231);
 }
 
 function __math_oflow($0) {
  return __math_xflow($0, 3105036184601417870297958.0e207);
 }
 
 function exp($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0.0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0, $9 = 0.0, $10 = 0, $11 = 0;
  block1 : {
   block : {
    $1 = top12($0) & 2047;
    $4 = top12(5.551115123125783e-17);
    if ($1 - $4 >>> 0 < top12(512.0) - $4 >>> 0) {
     $4 = $1;
     break block;
    }
    if ($1 >>> 0 < $4 >>> 0) {
     return +($0 + 1.0)
    }
    $4 = 0;
    if (top12(1024.0) >>> 0 > $1 >>> 0) {
     break block
    }
    wasm2js_scratch_store_f64(+$0);
    $7 = wasm2js_scratch_load_i32(1) | 0;
    $5 = wasm2js_scratch_load_i32(0) | 0;
    $6 = $7;
    $2 = 0.0;
    if (!$5 & ($6 | 0) == -1048576) {
     break block1
    }
    if (top12(Infinity) >>> 0 <= $1 >>> 0) {
     return +($0 + 1.0)
    }
    if (($6 | 0) < 0) {
     return +__math_uflow(0)
    }
    return +__math_oflow(0);
   }
   $2 = HEAPF64[29753];
   $8 = $0 * HEAPF64[29752] + $2;
   $2 = $8 - $2;
   $0 = $2 * HEAPF64[29755] + ($2 * HEAPF64[29754] + $0);
   $2 = $0 * $0;
   $9 = $2 * $2 * ($0 * HEAPF64[29759] + HEAPF64[29758]);
   $2 = $2 * ($0 * HEAPF64[29757] + HEAPF64[29756]);
   wasm2js_scratch_store_f64(+$8);
   $1 = wasm2js_scratch_load_i32(1) | 0;
   $5 = wasm2js_scratch_load_i32(0) | 0;
   $6 = $1;
   $1 = $5 << 4 & 2032;
   $0 = $9 + ($2 + (HEAPF64[$1 + 238128 >> 3] + $0));
   $3 = $1 + 238136 | 0;
   $1 = HEAP32[$3 >> 2];
   $10 = $1;
   $11 = HEAP32[$3 + 4 >> 2];
   $1 = $5 << 13;
   $3 = $1;
   $1 = $11;
   $1 = $3 + $1 | 0;
   $3 = $10 + 0 | 0;
   $1 = $7 >>> 0 > $3 >>> 0 ? $1 + 1 | 0 : $1;
   if (!$4) {
    return +specialcase($0, $3, $1, $5, $6)
   }
   wasm2js_scratch_store_i32(0, $3 | 0);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $2 = +wasm2js_scratch_load_f64();
   $2 = $2 * $0 + $2;
  }
  return +$2;
 }
 
 function top12($0) {
  var $1 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  return $1 >>> 20 | 0;
 }
 
 function specialcase($0, $1, $2, $3, $4) {
  var $5 = 0.0, $6 = 0.0, $7 = 0.0;
  if (!($3 & -2147483648)) {
   wasm2js_scratch_store_i32(0, $1 | 0);
   wasm2js_scratch_store_i32(1, $2 - 1058013184 | 0);
   $5 = +wasm2js_scratch_load_f64();
   return ($5 * $0 + $5) * 5486124068793688683255936.0e279;
  }
  wasm2js_scratch_store_i32(0, $1 | 0);
  wasm2js_scratch_store_i32(1, $2 + 1071644672 | 0);
  $5 = +wasm2js_scratch_load_f64();
  $6 = $5 * $0;
  $0 = $6 + $5;
  if ($0 < 1.0) {
   fp_force_eval(fp_barrier_2034() * 2.2250738585072014e-308);
   $7 = $0 + 1.0;
   $0 = $7 + ($6 + ($5 - $0) + ($0 + (1.0 - $7))) + -1.0;
   $0 = $0 == 0.0 ? 0.0 : $0;
  }
  return $0 * 2.2250738585072014e-308;
 }
 
 function fp_barrier_2034() {
  var $0 = 0;
  $0 = __stack_pointer - 16 | 0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 1048576;
  return HEAPF64[$0 + 8 >> 3];
 }
 
 function fp_force_eval($0) {
  HEAPF64[(__stack_pointer - 16 | 0) + 8 >> 3] = $0;
 }
 
 function fabs($0) {
  $0 = +$0;
  return +Math_abs($0);
 }
 
 function floor($0) {
  $0 = +$0;
  return +Math_floor($0);
 }
 
 function __math_divzero($0) {
  return fp_barrier_2039($0 ? -1.0 : 1.0) / 0.0;
 }
 
 function fp_barrier_2039($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  return HEAPF64[$1 + 8 >> 3];
 }
 
 function __math_invalid($0) {
  $0 = $0 - $0;
  return $0 / $0;
 }
 
 function log($0) {
  $0 = +$0;
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0, $10 = 0.0, $11 = 0.0, $12 = 0;
  $4 = top16($0);
  wasm2js_scratch_store_f64(+$0);
  $9 = wasm2js_scratch_load_i32(1) | 0;
  $5 = wasm2js_scratch_load_i32(0) | 0;
  $2 = $9;
  $1 = 1072562176;
  $1 = $2 - $1 | 0;
  if (($1 | 0) == 198911 | $1 >>> 0 < 198911) {
   if (!$5 & ($2 | 0) == 1072693248) {
    return 0.0
   }
   $0 = $0 + -1.0;
   $3 = $0 * 134217728.0;
   $3 = $0 + $3 - $3;
   $8 = HEAPF64[30029];
   $10 = $3 * $3 * $8;
   $11 = $0 + $10;
   $6 = $0 * $0;
   $7 = $0 * $6;
   return +($11 + ($7 * ($7 * ($7 * ($7 * HEAPF64[30039] + ($6 * HEAPF64[30038] + ($0 * HEAPF64[30037] + HEAPF64[30036]))) + ($6 * HEAPF64[30035] + ($0 * HEAPF64[30034] + HEAPF64[30033]))) + ($6 * HEAPF64[30032] + ($0 * HEAPF64[30031] + HEAPF64[30030]))) + (($0 - $3) * $8 * ($0 + $3) + ($10 + ($0 - $11)))));
  }
  block : {
   if ($4 - 32752 >>> 0 <= 4294934559) {
    if ($0 == 0.0) {
     return +__math_divzero(1)
    }
    if (!$5 & ($2 | 0) == 2146435072) {
     break block
    }
    if (!(($4 & 32752) != 32752 & $4 >>> 0 <= 32767)) {
     return +__math_invalid($0)
    }
    wasm2js_scratch_store_f64(+($0 * 4503599627370496.0));
    $2 = wasm2js_scratch_load_i32(1) | 0;
    $1 = wasm2js_scratch_load_i32(0) | 0;
    $2 = $2 - 54525952 | 0;
    $5 = $1;
   }
   $1 = 1072037888;
   $1 = $2 - $1 | 0;
   $6 = +($1 >> 20);
   $4 = ($1 >>> 13 & 127) << 4;
   $7 = $6 * HEAPF64[30022] + HEAPF64[$4 + 240328 >> 3];
   $1 = $1 & -1048576;
   $12 = $1;
   $0 = HEAPF64[$4 + 240320 >> 3];
   $9 = 0;
   $1 = $5 - $9 | 0;
   wasm2js_scratch_store_i32(0, $1 | 0);
   $1 = $2;
   $2 = $12;
   wasm2js_scratch_store_i32(1, $1 - ($2 + ($5 >>> 0 < $9 >>> 0) | 0) | 0);
   $0 = $0 * (+wasm2js_scratch_load_f64() - HEAPF64[$4 + 242368 >> 3] - HEAPF64[$4 + 242376 >> 3]);
   $8 = $7 + $0;
   $3 = $0 * $0;
   $0 = $8 + ($0 * $3 * ($3 * ($0 * HEAPF64[30028] + HEAPF64[30027]) + ($0 * HEAPF64[30026] + HEAPF64[30025])) + ($3 * HEAPF64[30024] + ($6 * HEAPF64[30023] + ($0 + ($7 - $8)))));
  }
  return +$0;
 }
 
 function top16($0) {
  var $1 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  return $1 >>> 16 | 0;
 }
 
 function memcmp($0, $1, $2) {
  var $3 = 0, $4 = 0;
  block1 : {
   block : {
    if ($2 >>> 0 >= 4) {
     if (($0 | $1) & 3) {
      break block
     }
     while (1) {
      if (HEAP32[$0 >> 2] != HEAP32[$1 >> 2]) {
       break block
      }
      $1 = $1 + 4 | 0;
      $0 = $0 + 4 | 0;
      $2 = $2 - 4 | 0;
      if ($2 >>> 0 > 3) {
       continue
      }
      break;
     };
    }
    if (!$2) {
     break block1
    }
   }
   while (1) {
    $3 = HEAPU8[$0 | 0];
    $4 = HEAPU8[$1 | 0];
    if (($3 | 0) == ($4 | 0)) {
     $1 = $1 + 1 | 0;
     $0 = $0 + 1 | 0;
     $2 = $2 - 1 | 0;
     if ($2) {
      continue
     }
     break block1;
    }
    break;
   };
   return $3 - $4 | 0;
  }
  return 0;
 }
 
 function scalbn($0, $1) {
  block : {
   if (($1 | 0) >= 1024) {
    $0 = $0 * 8988465674311579538646525.0e283;
    if ($1 >>> 0 < 2047) {
     $1 = $1 - 1023 | 0;
     break block;
    }
    $0 = $0 * 8988465674311579538646525.0e283;
    $1 = ($1 >>> 0 >= 3069 ? 3069 : $1) - 2046 | 0;
    break block;
   }
   if (($1 | 0) > -1023) {
    break block
   }
   $0 = $0 * 2.004168360008973e-292;
   if ($1 >>> 0 > 4294965304) {
    $1 = $1 + 969 | 0;
    break block;
   }
   $0 = $0 * 2.004168360008973e-292;
   $1 = ($1 >>> 0 <= 4294964336 ? -2960 : $1) + 1938 | 0;
  }
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $1 + 1023 << 20);
  return $0 * +wasm2js_scratch_load_f64();
 }
 
 function sin($0) {
  var $1 = 0, $2 = 0, $3 = 0.0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $1 = $1 & 2147483647;
  block : {
   if ($1 >>> 0 <= 1072243195) {
    if ($1 >>> 0 < 1045430272) {
     break block
    }
    $0 = __sin($0, 0.0, 0);
    break block;
   }
   if ($1 >>> 0 >= 2146435072) {
    $0 = $0 - $0;
    break block;
   }
   $1 = __rem_pio2($0, $2);
   $0 = HEAPF64[$2 + 8 >> 3];
   $3 = HEAPF64[$2 >> 3];
   block3 : {
    switch (($1 & 3) - 1 | 0) {
    default:
     $0 = __sin($3, $0, 1);
     break block;
    case 0:
     $0 = __cos($3, $0);
     break block;
    case 1:
     $0 = -__sin($3, $0, 1);
     break block;
    case 2:
     break block3;
    };
   }
   $0 = -__cos($3, $0);
  }
  __stack_pointer = $2 + 16 | 0;
  return $0;
 }
 
 function strchr($0, $1) {
  $0 = __strchrnul($0, $1);
  return HEAPU8[$0 | 0] == ($1 & 255) ? $0 : 0;
 }
 
 function __strchrnul($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  block : {
   block2 : {
    block1 : {
     $4 = $1 & 255;
     if ($4) {
      if ($0 & 3) {
       $2 = $1 & 255;
       while (1) {
        $3 = HEAPU8[$0 | 0];
        if (!$3 | ($2 | 0) == ($3 | 0)) {
         break block
        }
        $0 = $0 + 1 | 0;
        if ($0 & 3) {
         continue
        }
        break;
       };
      }
      $2 = HEAP32[$0 >> 2];
      if ((($2 | 16843008 - $2) & -2139062144) != -2139062144) {
       break block1
      }
      $4 = Math_imul($4, 16843009);
      while (1) {
       $3 = $2 ^ $4;
       if ((($3 | 16843008 - $3) & -2139062144) != -2139062144) {
        break block1
       }
       $2 = HEAP32[$0 + 4 >> 2];
       $3 = $0 + 4 | 0;
       $0 = $3;
       if (((16843008 - $2 | $2) & -2139062144) == -2139062144) {
        continue
       }
       break;
      };
      break block2;
     }
     return strlen($0) + $0 | 0;
    }
    $3 = $0;
   }
   while (1) {
    $0 = $3;
    $2 = HEAPU8[$0 | 0];
    if (!$2) {
     break block
    }
    $3 = $0 + 1 | 0;
    if (($1 & 255) != ($2 | 0)) {
     continue
    }
    break;
   };
  }
  return $0;
 }
 
 function strcmp($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = HEAPU8[$0 | 0];
  $3 = HEAPU8[$1 | 0];
  block : {
   if (!$2 | ($3 | 0) != ($2 | 0)) {
    break block
   }
   while (1) {
    $3 = HEAPU8[$1 + 1 | 0];
    $2 = HEAPU8[$0 + 1 | 0];
    if (!$2) {
     break block
    }
    $1 = $1 + 1 | 0;
    $0 = $0 + 1 | 0;
    if (($2 | 0) == ($3 | 0)) {
     continue
    }
    break;
   };
  }
  return $2 - $3 | 0;
 }
 
 function __stpcpy($0, $1) {
  var $2 = 0;
  block1 : {
   block : {
    if (($0 ^ $1) & 3) {
     $2 = HEAPU8[$1 | 0];
     break block;
    }
    if ($1 & 3) {
     while (1) {
      $2 = HEAPU8[$1 | 0];
      HEAP8[$0 | 0] = $2;
      if (!$2) {
       break block1
      }
      $0 = $0 + 1 | 0;
      $1 = $1 + 1 | 0;
      if ($1 & 3) {
       continue
      }
      break;
     }
    }
    $2 = HEAP32[$1 >> 2];
    if ((($2 | 16843008 - $2) & -2139062144) != -2139062144) {
     break block
    }
    while (1) {
     HEAP32[$0 >> 2] = $2;
     $0 = $0 + 4 | 0;
     $2 = HEAP32[$1 + 4 >> 2];
     $1 = $1 + 4 | 0;
     if (((16843008 - $2 | $2) & -2139062144) == -2139062144) {
      continue
     }
     break;
    };
   }
   HEAP8[$0 | 0] = $2;
   if (!($2 & 255)) {
    break block1
   }
   while (1) {
    $2 = HEAPU8[$1 + 1 | 0];
    HEAP8[$0 + 1 | 0] = $2;
    $0 = $0 + 1 | 0;
    $1 = $1 + 1 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  return $0;
 }
 
 function strcpy($0, $1) {
  __stpcpy($0, $1);
  return $0;
 }
 
 function strlen($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  block1 : {
   block : {
    $1 = $0;
    if (!($1 & 3)) {
     break block
    }
    if (!HEAPU8[$1 | 0]) {
     return 0
    }
    while (1) {
     $1 = $1 + 1 | 0;
     if (!($1 & 3)) {
      break block
     }
     if (HEAPU8[$1 | 0]) {
      continue
     }
     break;
    };
    break block1;
   }
   while (1) {
    $2 = $1;
    $1 = $1 + 4 | 0;
    $3 = HEAP32[$2 >> 2];
    if ((($3 | 16843008 - $3) & -2139062144) == -2139062144) {
     continue
    }
    break;
   };
   while (1) {
    $1 = $2;
    $2 = $1 + 1 | 0;
    if (HEAPU8[$1 | 0]) {
     continue
    }
    break;
   };
  }
  return $1 - $0 | 0;
 }
 
 function strncat($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = strlen($0) + $0 | 0;
  block : {
   if (!$2) {
    break block
   }
   while (1) {
    $4 = HEAPU8[$1 | 0];
    if (!$4) {
     break block
    }
    HEAP8[$3 | 0] = $4;
    $3 = $3 + 1 | 0;
    $1 = $1 + 1 | 0;
    $2 = $2 - 1 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  HEAP8[$3 | 0] = 0;
  return $0;
 }
 
 function emscripten_stack_init() {
  __stack_base = 506720;
  __stack_end = 441184;
 }
 
 function emscripten_stack_get_free() {
  return __stack_pointer - __stack_end | 0;
 }
 
 function emscripten_stack_get_base() {
  return __stack_base | 0;
 }
 
 function emscripten_stack_get_end() {
  return __stack_end | 0;
 }
 
 function __lock($0) {
  
 }
 
 function __unlock($0) {
  
 }
 
 function __ofl_lock() {
  __lock(441172);
  return 441176;
 }
 
 function __ofl_unlock() {
  __unlock(441172);
 }
 
 function __lockfile($0) {
  return 1;
 }
 
 function __unlockfile($0) {
  
 }
 
 function fflush($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  if (!$0) {
   if (HEAP32[110295]) {
    $1 = fflush(HEAP32[110295])
   }
   if (HEAP32[110295]) {
    $1 = fflush(HEAP32[110295]) | $1
   }
   $0 = HEAP32[__ofl_lock() >> 2];
   if ($0) {
    while (1) {
     if (HEAP32[$0 + 76 >> 2] < 0) {
      $2 = 0
     } else {
      $2 = __lockfile($0)
     }
     $2 = !$2;
     if (HEAP32[$0 + 20 >> 2] != HEAP32[$0 + 28 >> 2]) {
      $1 = fflush($0) | $1
     }
     if (!$2) {
      __unlockfile($0)
     }
     $0 = HEAP32[$0 + 56 >> 2];
     if ($0) {
      continue
     }
     break;
    }
   }
   __ofl_unlock();
   return $1 | 0;
  }
  if (HEAP32[$0 + 76 >> 2] < 0) {
   $1 = 0
  } else {
   $1 = __lockfile($0)
  }
  $2 = !$1;
  block2 : {
   block1 : {
    block : {
     if (HEAP32[$0 + 20 >> 2] == HEAP32[$0 + 28 >> 2]) {
      break block
     }
     FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, 0, 0) | 0;
     if (HEAP32[$0 + 20 >> 2]) {
      break block
     }
     $1 = -1;
     if (!$2) {
      break block1
     }
     break block2;
    }
    $1 = HEAP32[$0 + 4 >> 2];
    $3 = HEAP32[$0 + 8 >> 2];
    if (($1 | 0) != ($3 | 0)) {
     $1 = $1 - $3 | 0;
     FUNCTION_TABLE[HEAP32[$0 + 40 >> 2]]($0, $1, $1 >> 31, 1) | 0;
    }
    $1 = 0;
    HEAP32[$0 + 28 >> 2] = 0;
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = 0;
    HEAP32[$0 + 4 >> 2] = 0;
    HEAP32[$0 + 8 >> 2] = 0;
    if ($2) {
     break block2
    }
   }
   __unlockfile($0);
  }
  return $1 | 0;
 }
 
 function _emscripten_stack_restore($0) {
  $0 = $0 | 0;
  __stack_pointer = $0;
 }
 
 function _emscripten_stack_alloc($0) {
  $0 = $0 | 0;
  $0 = __stack_pointer - $0 & -16;
  __stack_pointer = $0;
  return $0 | 0;
 }
 
 function emscripten_stack_get_current() {
  return __stack_pointer | 0;
 }
 
 function dynCall_vji($0, $1, $2, $3) {
  FUNCTION_TABLE[$0 | 0]($1, $2, $3);
 }
 
 function legalstub$dynCall_vji($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  dynCall_vji($0, $1, $2, $3);
 }
 
 function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  $4 = $2 >>> 16 | 0;
  $5 = $0 >>> 16 | 0;
  $3 = (Math_imul($4, $5) + Math_imul($1, $2) | 0) + Math_imul($3, $0) | 0;
  $2 = $2 & 65535;
  $0 = $0 & 65535;
  $1 = Math_imul($2, $0);
  $2 = ($1 >>> 16 | 0) + Math_imul($2, $5) | 0;
  $3 = $3 + ($2 >>> 16 | 0) | 0;
  $2 = Math_imul($0, $4) + ($2 & 65535) | 0;
  i64toi32_i32$HIGH_BITS = $3 + ($2 >>> 16 | 0) | 0;
  return $1 & 65535 | $2 << 16;
 }
 
 function __wasm_i64_mul($0, $1, $2, $3) {
  $3 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3);
  return $3;
 }
 
 function __wasm_rotl_i32($0, $1) {
  var $2 = 0;
  $2 = $1 & 31;
  $1 = 0 - $1 & 31;
  return (-1 >>> $2 & $0) << $2 | (-1 << $1 & $0) >>> $1;
 }
 
 // EMSCRIPTEN_END_FUNCS
;
 bufferView = HEAPU8;
 initActiveSegments(imports);
 var FUNCTION_TABLE = Table([null, jswrap_object_toString, jsvStringIteratorPrintfCallback, jsvIsInternalFunctionKey, jsvIsInternalObjectKey, jsvIterateCallbackCountCb, jsvIterateCallbackToBytesCb, vcbprintf_callback_jsiConsolePrintString, espruino_snprintf_cb, jswrap_eval, gen_jswrap_Graphics_Graphics, jswrap_dataview_constructor, jswrap_date_constructor, jswrap_error_constructor, jswrap_syntaxerror_constructor, jswrap_typeerror_constructor, jswrap_internalerror_constructor, jswrap_referenceerror_constructor, jswrap_regexp_constructor, jswrap_onewire_constructor, jswrap_promise_constructor, jswrap_serial_constructor, gen_jswrap_StorageFile_StorageFile, jswrap_spi_constructor, jswrap_i2c_constructor, jswrap_waveform_constructor, jswrap_pin_constructor, gen_jswrap_Bangle_Bangle, gen_jswrap_E_E, gen_jswrap_NRF_NRF, gen_jswrap_Bluetooth_Bluetooth, gen_jswrap_Unistroke_Unistroke, jswrap_array_constructor, gen_jswrap_console_console, gen_jswrap_JSON_JSON, jswrap_number_constructor, jswrap_object_constructor, gen_jswrap_timer_timer, jswrap_string_constructor, gen_jswrap_Modules_Modules, gen_jswrap_Math_Math, gen_jswrap_Flash_Flash, gen_jswrap_fs_fs, gen_jswrap_process_process, gen_jswrap_Storage_Storage, gen_jswrap_heatshrink_heatshrink, gen_jswrap_crypto_crypto, gen_jswrap_AES_AES, jswrap_arraybuffer_constructor, gen_jswrap_ArrayBufferView_ArrayBufferView, jswrap_function_constructor, jswrap_pin_analog, jswrap_pin_getInfo, jswrap_pin_getMode, jswrap_pin_mode, jswrap_pin_pulse, jswrap_pin_pwm, jswrap_pin_read, jswrap_pin_reset, jswrap_pin_set, jswrap_pin_toggle, jswrap_pin_write, gen_jswrap_BTN, gen_jswrap_BTN1, jswrap_boolean_constructor, gen_jswrap_Float32Array_Float32Array, gen_jswrap_Float64Array_Float64Array, gen_jswrap_HIGH, gen_jswrap_I2C1, gen_jswrap_Infinity, gen_jswrap_Int16Array_Int16Array, gen_jswrap_Int32Array_Int32Array, gen_jswrap_Int8Array_Int8Array, gen_jswrap_LED1, gen_jswrap_LED2, gen_jswrap_LOW, gen_jswrap_LoopbackA, gen_jswrap_LoopbackB, gen_jswrap_NaN, gen_jswrap_SPI1, gen_jswrap_Serial1, gen_jswrap_Terminal, gen_jswrap_USB, gen_jswrap_Uint16Array_Uint16Array, gen_jswrap_Uint24Array_Uint24Array, gen_jswrap_Uint32Array_Uint32Array, gen_jswrap_Uint8Array_Uint8Array, gen_jswrap_Uint8ClampedArray_Uint8ClampedArray, gen_jswrap_VIBRATE, jshPinAnalog, jswrap_io_analogWrite, jswrap_arguments, jswrap_atob, jswrap_btoa, jswrap_interface_changeInterval, jswrap_interface_clearInterval, jswrap_interface_clearTimeout, jswrap_interface_clearWatch, jswrap_decodeURIComponent, jswrap_io_digitalPulse, jswrap_io_digitalRead, jswrap_io_digitalWrite, gen_jswrap_dump, jswrap_interface_echo, jswrap_interface_edit, jswrap_encodeURIComponent, jswrap_io_getPinMode, jswrap_interface_getSerial, gen_jswrap_getTime, jswrap_global, jswrap_isFinite, jswrap_isNaN, jswrap_interface_load, jswrap_parseFloat, jswrap_parseInt, gen_jswrap_peek16, gen_jswrap_peek32, gen_jswrap_peek8, jswrap_io_pinMode, gen_jswrap_poke16, gen_jswrap_poke32, gen_jswrap_poke8, jswrap_print, jswrap_require, jswrap_interface_reset, jswrap_interface_setBusyIndicator, jswrap_interface_setInterval, jswrap_interface_setSleepIndicator, jswrap_interactive_setTime, jswrap_interface_setTimeout, jswrap_interface_setWatch, jswrap_io_shiftOut, jswrap_trace, jswrap_banglejs_accelRd, jswrap_banglejs_accelWr, jswrap_banglejs_appRect, jswrap_banglejs_barometerRd, jswrap_banglejs_barometerWr, jswrap_banglejs_beep, jswrap_banglejs_buzz, jswrap_banglejs_compassRd, jswrap_banglejs_compassWr, jswrap_banglejs_dbg, gen_jswrap_Bangle_drawWidgets, jswrap_banglejs_factoryReset, jswrap_banglejs_getAccel, jswrap_banglejs_getCompass, jswrap_banglejs_getGPSFix, jswrap_banglejs_getHealthStatus, jswrap_banglejs_getLCDMode, jswrap_banglejs_getLogo, jswrap_banglejs_getOptions, jswrap_banglejs_getPressure, jswrap_banglejs_getStepCount, jswrap_banglejs_hrmRd, jswrap_banglejs_hrmWr, jswrap_banglejs_isBacklightOn, jswrap_banglejs_isBarometerOn, jswrap_banglejs_isCharging, jswrap_banglejs_isCompassOn, jswrap_banglejs_isGPSOn, jswrap_banglejs_isHRMOn, jswrap_banglejs_isLCDOn, jswrap_banglejs_isLocked, jswrap_banglejs_lcdWr, gen_jswrap_Bangle_load, gen_jswrap_Bangle_loadWidgets, jswrap_banglejs_off, jswrap_banglejs_project, jswrap_banglejs_resetCompass, jswrap_banglejs_setLCDPowerBacklight, jswrap_banglejs_setBarometerPower, jswrap_banglejs_setCompassPower, jswrap_banglejs_setGPSPower, jswrap_banglejs_setHRMPower, jswrap_banglejs_setLCDBrightness, jswrap_banglejs_setLCDMode, jswrap_banglejs_setLCDOffset, jswrap_banglejs_setLCDOverlay, jswrap_banglejs_setLCDPower, jswrap_banglejs_setLCDTimeout, jswrap_banglejs_setLocked, jswrap_banglejs_setOptions, jswrap_banglejs_setPollInterval, jswrap_banglejs_setStepCount, gen_jswrap_Bangle_setUI, gen_jswrap_Bangle_showClock, gen_jswrap_Bangle_showLauncher, jswrap_banglejs_showLoadingScreen, gen_jswrap_Bangle_showRecoveryMenu, gen_jswrap_Bangle_showTestScreen, jswrap_banglejs_softOff, jswrap_banglejs_touchRd, jswrap_banglejs_touchWr, jswrap_espruino_CRC32, jswrap_espruino_FFT, jswrap_espruino_HSBtoRGB, jswrap_espruino_asUTF8, jswrap_espruino_asm, jswrap_espruino_clip, jswrap_espruino_compiledC, jswrap_espruino_convolve, jswrap_espruino_decodeUTF8, jsvDefragment, jswrap_e_dumpFragmentation, jswrap_e_dumpStr, jswrap_e_dumpVariables, jswrap_espruino_enableWatchdog, jswrap_espruino_fromUTF8, jswrap_espruino_getAddressOf, gen_jswrap_E_getAnalogVRef, jswrap_espruino_getBattery, jswrap_espruino_getClock, jswrap_espruino_getConsole, jswrap_espruino_getErrorFlags, jsfGetFlags, jswrap_espruino_getPowerUsage, jswrap_espruino_getSizeOf, jswrap_espruino_getTemperature, jshGetRandomNumber, gen_jswrap_E_internal, jswrap_espruino_isUTF8, jswrap_espruino_kickWatchdog, jswrap_espruino_lockConsole, jswrap_espruino_lookupNoCase, jswrap_espruino_mapInPlace, jswrap_espruino_memoryArea, jswrap_espruino_memoryMap, jswrap_espruino_nativeCall, jswrap_pipe, jswrap_espruino_reboot, jswrap_espruino_reverseByte, jswrap_espruino_setBootCode, jswrap_espruino_setClock, jswrap_espruino_setConsole, jswrap_espruino_setDST, jsfSetFlags, jswrap_espruino_setPassword, jswrap_espruino_setTimeZone, gen_jswrap_E_showAlert, gen_jswrap_E_showMenu, gen_jswrap_E_showMessage, gen_jswrap_E_showPrompt, gen_jswrap_E_showScroller, srand, jswrap_espruino_stopEventPropagation, jswrap_espruino_sum, jswrap_espruino_toArrayBuffer, jswrap_espruino_toFlatString, jswrap_espruino_toJS, jswrap_espruino_toString, jswrap_espruino_toUint8Array, jswrap_espruino_variance, gen_jswrap_NRF_getAddress, gen_jswrap_NRF_getSecurityStatus, gen_jswrap_NRF_setAdvertising, gen_jswrap_NRF_setServices, gen_jswrap_Bluetooth_setConsole, jswrap_graphics_asBMP, jswrap_graphics_asImage, jswrap_graphics_asURL, jswrap_graphics_blendColor, jswrap_graphics_blit, jswrap_graphics_clear, jswrap_graphics_clearRect, jswrap_graphics_drawCircle, jswrap_graphics_drawCircleAA, jswrap_graphics_drawEllipse, jswrap_graphics_drawImage, jswrap_graphics_drawImages, jswrap_graphics_drawLine, jswrap_graphics_drawLineAA, gen_jswrap_Graphics_drawPoly, gen_jswrap_Graphics_drawPolyAA, jswrap_graphics_drawRect, jswrap_graphics_drawString, jswrap_graphics_dump, jswrap_graphics_fillCircle, jswrap_graphics_fillEllipse, gen_jswrap_Graphics_fillPoly, gen_jswrap_Graphics_fillPolyAA, jswrap_graphics_fillRect, jswrap_graphics_filter, jswrap_graphics_findFont, jswrap_graphics_floodFill, jswrap_graphics_getBPP, gen_jswrap_Graphics_getBgColor, gen_jswrap_Graphics_getColor, jswrap_graphics_getFont, jswrap_graphics_getFontHeight, jswrap_graphics_getFonts, gen_jswrap_Graphics_getHeight, jswrap_graphics_getModified, jswrap_graphics_getPixel, jswrap_graphics_getVectorFontPolys, gen_jswrap_Graphics_getWidth, jswrap_graphics_imageMetrics, jswrap_graphics_lineTo, jswrap_graphics_moveTo, jswrap_graphics_quadraticBezier, jswrap_graphics_reset, jswrap_graphics_scroll, gen_jswrap_Graphics_setBgColor, jswrap_graphics_setClipRect, gen_jswrap_Graphics_setColor, jswrap_graphics_setFont, jswrap_graphics_setFont12x20, jswrap_graphics_setFont14, jswrap_graphics_setFont17, jswrap_graphics_setFont22, jswrap_graphics_setFont28, jswrap_graphics_setFont6x15, jswrap_graphics_setFontAlign, gen_jswrap_Graphics_setFontBitmap, jswrap_graphics_setFontCustom, jswrap_graphics_setFontPBF, gen_jswrap_Graphics_setFontVector, jswrap_graphics_setPixel, jswrap_graphics_setRotation, jswrap_graphics_setTheme, jswrap_graphics_stringMetrics, jswrap_graphics_stringWidth, jswrap_graphics_theme, jswrap_graphics_toColor, jswrap_graphics_transformVertices, jswrap_graphics_wrapString, jswrap_unistroke_new, jswrap_unistroke_recognise, jswrap_array_concat, jswrap_array_every, jswrap_array_fill, jswrap_array_filter, jswrap_array_find, jswrap_array_findIndex, jswrap_array_forEach, jswrap_array_includes, jswrap_array_indexOf, jswrap_array_join, jswrap_object_length, jswrap_array_map, gen_jswrap_Array_pop, jswrap_array_push, jswrap_array_reduce, jswrap_array_reverse, jswrap_array_shift, jswrap_array_slice, jswrap_array_some, jswrap_array_sort, jswrap_array_splice, jswrap_array_unshift, gen_jswrap_Array_isArray, gen_jswrap_ArrayBuffer_byteLength, gen_jswrap_ArrayBufferView_buffer, gen_jswrap_ArrayBufferView_byteLength, gen_jswrap_ArrayBufferView_byteOffset, jswrap_arraybufferview_indexOf, jswrap_arraybufferview_map, jswrap_arraybufferview_set, jswrap_arraybufferview_sort, jswrap_arraybufferview_subarray, gen_jswrap_DataView_getFloat32, gen_jswrap_DataView_getFloat64, gen_jswrap_DataView_getInt16, gen_jswrap_DataView_getInt32, gen_jswrap_DataView_getInt8, gen_jswrap_DataView_getUint16, gen_jswrap_DataView_getUint32, gen_jswrap_DataView_getUint8, gen_jswrap_DataView_setFloat32, gen_jswrap_DataView_setFloat64, gen_jswrap_DataView_setInt16, gen_jswrap_DataView_setInt32, gen_jswrap_DataView_setInt8, gen_jswrap_DataView_setUint16, gen_jswrap_DataView_setUint32, gen_jswrap_DataView_setUint8, jswrap_date_now, jswrap_date_parse, jswrap_date_getDate, jswrap_date_getDay, jswrap_date_getFullYear, jswrap_date_getHours, jswrap_date_getIsDST, jswrap_date_getMilliseconds, jswrap_date_getMinutes, jswrap_date_getMonth, jswrap_date_getSeconds, jswrap_date_getTime, jswrap_date_getTimezoneOffset, jswrap_date_setDate, jswrap_date_setFullYear, jswrap_date_setHours, jswrap_date_setMilliseconds, jswrap_date_setMinutes, jswrap_date_setMonth, jswrap_date_setSeconds, jswrap_date_setTime, jswrap_date_toISOString, jswrap_date_toLocalISOString, jswrap_date_toString, jswrap_date_toUTCString, jswrap_error_toString, jswrap_console_trace, jswrap_json_parse, jswrap_json_stringify, gen_jswrap_Number_MAX_VALUE, gen_jswrap_Number_MIN_VALUE, gen_jswrap_Number_NEGATIVE_INFINITY, gen_jswrap_Number_NaN, gen_jswrap_Number_POSITIVE_INFINITY, jswrap_number_toFixed, jswrap_object_on, jswrap_object_clone, jswrap_object_emit, jswrap_object_hasOwnProperty, jswrap_object_prependListener, jswrap_object_removeAllListeners, jswrap_object_removeListener, jswrap_object_valueOf, jswrap_object_assign, jswrap_object_create, jswrap_object_defineProperties, jswrap_object_defineProperty, gen_jswrap_Object_entries, jswrap_object_fromEntries, jswrap_object_getOwnPropertyDescriptor, jswrap_object_getOwnPropertyDescriptors, gen_jswrap_Object_getOwnPropertyNames, jswrap_object_getPrototypeOf, gen_jswrap_Object_keys, jswrap_object_setPrototypeOf, gen_jswrap_Object_values, jswrap_function_apply_or_call, jswrap_function_bind, jswrap_function_replaceWith, jswrap_regexp_exec, jswrap_regexp_test, jswrap_timer_add, jswrap_timer_get, jswrap_timer_list, jswrap_timer_remove, jswrap_string_charAt, jswrap_string_charCodeAt, jswrap_string_concat, jswrap_string_endsWith, gen_jswrap_String_includes, gen_jswrap_String_indexOf, gen_jswrap_String_lastIndexOf, jswrap_string_match, gen_jswrap_String_padEnd, gen_jswrap_String_padStart, gen_jswrap_String_removeAccents, jswrap_string_repeat, jswrap_string_replace, jswrap_string_replaceAll, jswrap_string_slice, jswrap_string_split, jswrap_string_startsWith, jswrap_string_substr, jswrap_string_substring, gen_jswrap_String_toLowerCase, gen_jswrap_String_toUpperCase, jswrap_string_trim, jswrap_string_fromCharCode, jswrap_modules_addCached, jswrap_modules_getCached, jswrap_modules_removeAllCached, jswrap_modules_removeCached, gen_jswrap_Math_E, gen_jswrap_Math_LN10, gen_jswrap_Math_LN2, gen_jswrap_Math_LOG10E, gen_jswrap_Math_LOG2E, gen_jswrap_Math_PI, gen_jswrap_Math_SQRT1_2, gen_jswrap_Math_SQRT2, fabs, gen_jswrap_Math_acos, jswrap_math_asin, jswrap_math_atan, jswrap_math_atan2, ceil, jswrap_math_clip, jswrap_math_cos, exp, floor, log, gen_jswrap_Math_max, gen_jswrap_Math_min, jswrap_math_pow, gen_jswrap_Math_randInt, gen_jswrap_Math_random, jswrap_math_round, jswrap_math_sign, jswrap_math_sin, jswrap_math_sqrt, gen_jswrap_Math_tan, wrapAround, jswrap_flash_erasePage, jswrap_flash_getFree, jswrap_flash_getPage, jswrap_flash_read, jswrap_flash_write, jswrap_process_env, jswrap_process_memory, gen_jswrap_process_version, jswrap_onewire_read, jswrap_onewire_reset, jswrap_onewire_search, jswrap_onewire_select, jswrap_onewire_skip, jswrap_onewire_write, jswrap_promise_all, jswrap_promise_reject, jswrap_promise_resolve, jswrap_promise_catch, jswrap_promise_then, gen_jswrap_Serial_find, jswrap_stream_available, jswrap_serial_flush, jswrap_serial_inject, jswrap_serial_isConnected, jswrap_serial_print, jswrap_serial_println, jswrap_stream_read, jswrap_serial_setConsole, jswrap_serial_setup, jswrap_serial_unsetup, jswrap_serial_write, jswrap_storage_compact, jswrap_storage_erase, jswrap_storage_eraseAll, jswrap_storage_getFree, jswrap_storage_getStats, jswrap_storage_hash, jswrap_storage_list, jswrap_storage_open, jswrap_storage_optimise, jswrap_storage_read, jswrap_storage_readArrayBuffer, jswrap_storage_readJSON, jswrap_storage_write, jswrap_storage_writeJSON, jswrap_storagefile_erase, jswrap_storagefile_getLength, jswrap_storagefile_read, jswrap_storagefile_readLine, jswrap_storagefile_write, gen_jswrap_SPI_find, jswrap_spi_send, jswrap_spi_send4bit, jswrap_spi_send8bit, jswrap_spi_setup, jswrap_spi_write, gen_jswrap_I2C_find, jswrap_i2c_readFrom, jswrap_i2c_readReg, jswrap_i2c_setup, jswrap_i2c_writeTo, jswrap_waveform_startInput, jswrap_waveform_startOutput, jswrap_waveform_stop, jswrap_heatshrink_compress, jswrap_heatshrink_decompress, jswrap_graphics_createArrayBuffer, jswrap_graphics_createCallback, jswrap_graphics_createImage, jswrap_graphics_getInstance, gen_jswrap_crypto_SHA1, gen_jswrap_crypto_SHA224, gen_jswrap_crypto_SHA256, gen_jswrap_crypto_SHA384, gen_jswrap_crypto_SHA512, jswrap_crypto_AES_ccmDecrypt, jswrap_crypto_AES_ccmEncrypt, jsiConsolePrintString, jsiTabComplete_findCommon, jsiTabComplete_printCommon, heatshrink_var_input_cb, packet_decompress_cb, jsiPacketTimeoutHandler, jsiPacketFileTimeoutHandler, jstPinTaskChecker, jstBufferTaskChecker, jsserialHardwareFunc, jsserialSoftwareFunc, jsserialEventCallback, jsspiHardwareFunc, jsspiFastSoftwareFunc, jsspiSoftwareFunc, heatshrink_ptr_output_cb, graphicsFallbackSetPixel, graphicsFallbackGetPixel, graphicsFallbackFillRect, graphicsFallbackBlit, graphicsFallbackScroll, graphicsSetPixel, lcdSetPixel_ArrayBuffer_flat1, lcdGetPixel_ArrayBuffer_flat1, lcdFillRect_ArrayBuffer_flat1, lcdSetPixel_ArrayBuffer_flat2, lcdGetPixel_ArrayBuffer_flat2, lcdFillRect_ArrayBuffer_flat2, lcdSetPixel_ArrayBuffer_flat4, lcdGetPixel_ArrayBuffer_flat4, lcdFillRect_ArrayBuffer_flat4, lcdSetPixel_ArrayBuffer_flat8, lcdGetPixel_ArrayBuffer_flat8, lcdFillRect_ArrayBuffer_flat8, lcdScroll_ArrayBuffer_flat8, lcdSetPixel_ArrayBuffer_flat, lcdGetPixel_ArrayBuffer_flat, lcdFillRect_ArrayBuffer_flat, lcdScroll_ArrayBuffer_flat, lcdSetPixel_ArrayBuffer, lcdGetPixel_ArrayBuffer, lcdFillRect_ArrayBuffer, lcdSetPixel_JS, lcdFillRect_JS, lcdMemLCD_setPixel, _lcdMemLCD_setPixel_mirrored, lcdMemLCD_fillRect, lcdMemLCD_getPixel, lcdMemLCD_scroll, aes_crypt_ecb_wrap, aes_setkey_enc_wrap, aes_setkey_dec_wrap, aes_ctx_alloc, aes_ctx_free, ccm_aes_setkey_wrap, ccm_ctx_alloc, ccm_ctx_free, lcd_flip, btn1Handler, jswrap_banglejs_postInit, _jswrap_arraybufferview_sort_float, _jswrap_arraybufferview_sort_int, jsvArrayAddUnique, _jswrap_object_entries_cb, _jswrap_object_values_cb, jswrap_timer_queue_interrupt_js, _jswrap_espruino_toString_char, _jswrap_espruino_toUint8Array_char, jswrap_io_shiftOutCallback, jswrap_pipe_src_close_listener, jswrap_pipe_drain_listener, jswrap_pipe_dst_close_listener, jsvLockAgainSafe, jsvUnLock, jsvSkipName, jsvMathsOp, jsvNewWithFlags, jsvNewFromFloat, jsvNewFromInteger, jsvNewFromString, jsvNewFromBool, jsvGetFloat, jsvGetInteger, jsvGetBool, jsvReplaceWith, jspeFunctionCall, jspGetNamedVariable, jspGetNamedField, jspGetVarNamedField, _jswrap_onewire_write_cb, _jswrap_prombox_resolve, _jswrap_prombox_reject, _jswrap_prombox_queueresolve, _jswrap_prombox_queuereject, _jswrap_prombox_all_reject, _jswrap_prombox_all_resolve, _jswrap_promise_reaction_call, _jswrap_serial_inject_cb, jswrap_spi_send_cb, jswrap_spi_write_cb, heatshrink_var_output_cb, jswrap_graphics_getFonts_callback, graphicsFillPoly, _jswrap_graphics_getVectorFontPolys_cb, graphicsDrawLineAA, graphicsDrawLine, jswrap_graphics_setFont6x8, jswrap_graphics_setFont4x6]);
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
 }
 
 return {
  "memory": Object.create(Object.prototype, {
   "grow": {
    
   }, 
   "buffer": {
    "get": function () {
     return buffer;
    }
    
   }
  }), 
  "__wasm_call_ctors": __wasm_call_ctors, 
  "__indirect_function_table": FUNCTION_TABLE, 
  "jshPushIOCharEvent": jshPushIOCharEvent, 
  "jshGetCharToTransmit": jshGetCharToTransmit, 
  "jshGetDeviceToTransmit": jshGetDeviceToTransmit, 
  "jsGfxChanged": jsGfxChanged, 
  "jsGfxGetPtr": jsGfxGetPtr, 
  "jsInit": jsInit, 
  "jsIdle": jsIdle, 
  "jsSendPinWatchEvent": jsSendPinWatchEvent, 
  "jsSendTouchEvent": jsSendTouchEvent, 
  "jsKill": jsKill, 
  "fflush": fflush, 
  "emscripten_stack_init": emscripten_stack_init, 
  "emscripten_stack_get_free": emscripten_stack_get_free, 
  "emscripten_stack_get_base": emscripten_stack_get_base, 
  "emscripten_stack_get_end": emscripten_stack_get_end, 
  "_emscripten_stack_restore": _emscripten_stack_restore, 
  "_emscripten_stack_alloc": _emscripten_stack_alloc, 
  "emscripten_stack_get_current": emscripten_stack_get_current, 
  "dynCall_vji": legalstub$dynCall_vji
 };
}

  return asmFunc(info);
}

)(info);
  },

  instantiate: /** @suppress{checkTypes} */ function(binary, info) {
    return {
      then: function(ok) {
        var module = new WebAssembly.Module(binary);
        ok({
          'instance': new WebAssembly.Instance(module, info)
        });
        // Emulate a simple WebAssembly.instantiate(..).then(()=>{}).catch(()=>{}) syntax.
        return { catch: function() {} };
      }
    };
  },

  RuntimeError: Error,

  isWasm2js: true,
};
// end include: wasm2js.js
if (WebAssembly.isWasm2js) {
  // We don't need to actually download a wasm binary, mark it as present but
  // empty.
  wasmBinary = [];
}

if (typeof WebAssembly != 'object') {
  err('no native wasm support detected');
}

// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.
function _malloc() {
  abort('malloc() called but not included in the build - add `_malloc` to EXPORTED_FUNCTIONS');
}
function _free() {
  // Show a helpful error since we used to include free by default in the past.
  abort('free() called but not included in the build - add `_free` to EXPORTED_FUNCTIONS');
}

// Memory management

var HEAP,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

var runtimeInitialized = false;

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');

// include: runtime_shared.js
// include: runtime_stack_check.js
// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // If the stack ends at address zero we write our cookies 4 bytes into the
  // stack.  This prevents interference with SAFE_HEAP and ASAN which also
  // monitor writes to address zero.
  if (max == 0) {
    max += 4;
  }
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAPU32[((max)>>2)] = 0x02135467;
  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAPU32[((0)>>2)] = 1668509029;
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  // See writeStackCookie().
  if (max == 0) {
    max += 4;
  }
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {
    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
  }
  // Also test the global address 0 for integrity.
  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {
    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
  }
}
// end include: runtime_stack_check.js
// include: runtime_exceptions.js
// end include: runtime_exceptions.js
// include: runtime_debug.js
// Endianness check
(() => {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
})();

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
}

function legacyModuleProp(prop, newName, incoming=true) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      get() {
        let extra = incoming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';
        abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra);

      }
    });
  }
}

function consumedModuleProp(prop) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      set() {
        abort(`Attempt to set \`Module.${prop}\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);

      }
    });
  }
}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
  }
}

// forcing the filesystem exports a few things by default
function isExportedByForceFilesystem(name) {
  return name === 'FS_createPath' ||
         name === 'FS_createDataFile' ||
         name === 'FS_createPreloadedFile' ||
         name === 'FS_unlink' ||
         name === 'addRunDependency' ||
         // The old FS has some functionality that WasmFS lacks.
         name === 'FS_createLazyFile' ||
         name === 'FS_createDevice' ||
         name === 'removeRunDependency';
}

/**
 * Intercept access to a global symbol.  This enables us to give informative
 * warnings/errors when folks attempt to use symbols they did not include in
 * their build, or no symbols that no longer exist.
 */
function hookGlobalSymbolAccess(sym, func) {
  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
    Object.defineProperty(globalThis, sym, {
      configurable: true,
      get() {
        func();
        return undefined;
      }
    });
  }
}

function missingGlobal(sym, msg) {
  hookGlobalSymbolAccess(sym, () => {
    warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`);
  });
}

missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
missingGlobal('asm', 'Please use wasmExports instead');

function missingLibrarySymbol(sym) {
  hookGlobalSymbolAccess(sym, () => {
    // Can't `abort()` here because it would break code that does runtime
    // checks.  e.g. `if (typeof SDL === 'undefined')`.
    var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;
    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
    // library.js, which means $name for a JS name with no prefix, or name
    // for a JS name like _name.
    var librarySymbol = sym;
    if (!librarySymbol.startsWith('_')) {
      librarySymbol = '$' + sym;
    }
    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;
    if (isExportedByForceFilesystem(sym)) {
      msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
    }
    warnOnce(msg);
  });

  // Any symbol that is not included from the JS library is also (by definition)
  // not exported on the Module object.
  unexportedRuntimeSymbol(sym);
}

function unexportedRuntimeSymbol(sym) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get() {
        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
        if (isExportedByForceFilesystem(sym)) {
          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
        }
        abort(msg);
      }
    });
  }
}

var runtimeDebug = true; // Switch to false at runtime to disable logging at the right times

// Used by XXXXX_DEBUG settings to output debug messages.
function dbg(...args) {
  if (!runtimeDebug && typeof runtimeDebug != 'undefined') return;
  // TODO(sbc): Make this configurable somehow.  Its not always convenient for
  // logging to show up as warnings.
  console.warn(...args);
}
// end include: runtime_debug.js
// include: memoryprofiler.js
// end include: memoryprofiler.js


function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
}

// end include: runtime_shared.js
assert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')

assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

// If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
assert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');
assert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  consumedModuleProp('preRun');
  callRuntimeCallbacks(onPreRuns);
}

function initRuntime() {
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  checkStackCookie();

  

  wasmExports['__wasm_call_ctors']();

  
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  consumedModuleProp('postRun');

  callRuntimeCallbacks(onPostRuns);
}

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};
var runDependencyWatcher = null;

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  Module['monitorRunDependencies']?.(runDependencies);

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(() => {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err(`dependency: ${dep}`);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  Module['monitorRunDependencies']?.(runDependencies);

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// show errors on likely calls to FS when it was not included
var FS = {
  error() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
  },
  init() { FS.error() },
  createDataFile() { FS.error() },
  createPreloadedFile() { FS.error() },
  createLazyFile() { FS.error() },
  open() { FS.error() },
  mkdev() { FS.error() },
  registerDevice() { FS.error() },
  analyzePath() { FS.error() },

  ErrnoError() { FS.error() },
};
Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;

function createExportWrapper(name, nargs) {
  return (...args) => {
    assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
    var f = wasmExports[name];
    assert(f, `exported native function \`${name}\` not found`);
    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.
    assert(args.length <= nargs, `native function \`${name}\` called with ${args.length} args but expects ${nargs}`);
    return f(...args);
  };
}

var wasmBinaryFile;

function findWasmBinary() {
    return locateFile('emulator_banglejs2.wasm');
}

function getBinarySync(file) {
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw 'both async and sync fetching of the wasm failed';
}

async function getWasmBinary(binaryFile) {
  // If we don't have the binary yet, load it asynchronously using readAsync.
  if (!wasmBinary) {
    // Fetch the binary using readAsync
    try {
      var response = await readAsync(binaryFile);
      return new Uint8Array(response);
    } catch {
      // Fall back to getBinarySync below;
    }
  }

  // Otherwise, getBinarySync should be able to get it synchronously
  return getBinarySync(binaryFile);
}

async function instantiateArrayBuffer(binaryFile, imports) {
  try {
    var binary = await getWasmBinary(binaryFile);
    var instance = await WebAssembly.instantiate(binary, imports);
    return instance;
  } catch (reason) {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    // Warn on some common problems.
    if (isFileURI(wasmBinaryFile)) {
      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
    }
    abort(reason);
  }
}

async function instantiateAsync(binary, binaryFile, imports) {
  if (!binary && typeof WebAssembly.instantiateStreaming == 'function'
      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
      && !isFileURI(binaryFile)
      // Avoid instantiateStreaming() on Node.js environment for now, as while
      // Node.js v18.1.0 implements it, it does not have a full fetch()
      // implementation yet.
      //
      // Reference:
      //   https://github.com/emscripten-core/emscripten/pull/16917
      && !ENVIRONMENT_IS_NODE
     ) {
    try {
      var response = fetch(binaryFile, { credentials: 'same-origin' });
      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
      return instantiationResult;
    } catch (reason) {
      // We expect the most common failure cause to be a bad MIME type for the binary,
      // in which case falling back to ArrayBuffer instantiation should work.
      err(`wasm streaming compile failed: ${reason}`);
      err('falling back to ArrayBuffer instantiation');
      // fall back of instantiateArrayBuffer below
    };
  }
  return instantiateArrayBuffer(binaryFile, imports);
}

function getWasmImports() {
  // prepare imports
  return {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
  }
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
async function createWasm() {
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    

    wasmMemory = wasmExports['memory'];
    
    assert(wasmMemory, 'memory not found in wasm exports');
    updateMemoryViews();

    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above PTHREADS-enabled path.
    return receiveInstance(result['instance']);
  }

  var info = getWasmImports();

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {
    return new Promise((resolve, reject) => {
      try {
        Module['instantiateWasm'](info, (mod, inst) => {
          receiveInstance(mod, inst);
          resolve(mod.exports);
        });
      } catch(e) {
        err(`Module.instantiateWasm callback failed with error: ${e}`);
        reject(e);
      }
    });
  }

  wasmBinaryFile ??= findWasmBinary();
    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// end include: preamble.js

// Begin JS library code


  class ExitStatus {
      name = 'ExitStatus';
      constructor(status) {
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    }

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };
  var onPostRuns = [];
  var addOnPostRun = (cb) => onPostRuns.unshift(cb);

  var onPreRuns = [];
  var addOnPreRun = (cb) => onPreRuns.unshift(cb);


  
    /**
     * @param {number} ptr
     * @param {string} type
     */
  function getValue(ptr, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': return HEAP8[ptr];
      case 'i8': return HEAP8[ptr];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': abort('to do getValue(i64) use WASM_BIGINT');
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      case '*': return HEAPU32[((ptr)>>2)];
      default: abort(`invalid type for getValue: ${type}`);
    }
  }

  var noExitRuntime = Module['noExitRuntime'] || true;

  var ptrToString = (ptr) => {
      assert(typeof ptr === 'number');
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      ptr >>>= 0;
      return '0x' + ptr.toString(16).padStart(8, '0');
    };

  
    /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */
  function setValue(ptr, value, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': HEAP8[ptr] = value; break;
      case 'i8': HEAP8[ptr] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': abort('to do setValue(i64) use WASM_BIGINT');
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      case '*': HEAPU32[((ptr)>>2)] = value; break;
      default: abort(`invalid type for setValue: ${type}`);
    }
  }

  var stackRestore = (val) => __emscripten_stack_restore(val);

  var stackSave = () => _emscripten_stack_get_current();

  var warnOnce = (text) => {
      warnOnce.shown ||= {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;
        err(text);
      }
    };

  var readEmAsmArgsArray = [];
  var readEmAsmArgs = (sigPtr, buf) => {
      // Nobody should have mutated _readEmAsmArgsArray underneath us to be something else than an array.
      assert(Array.isArray(readEmAsmArgsArray));
      // The input buffer is allocated on the stack, so it must be stack-aligned.
      assert(buf % 16 == 0);
      readEmAsmArgsArray.length = 0;
      var ch;
      // Most arguments are i32s, so shift the buffer pointer so it is a plain
      // index into HEAP32.
      while (ch = HEAPU8[sigPtr++]) {
        var chr = String.fromCharCode(ch);
        var validChars = ['d', 'f', 'i', 'p'];
        assert(validChars.includes(chr), `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`);
        // Floats are always passed as doubles, so all types except for 'i'
        // are 8 bytes and require alignment.
        var wide = (ch != 105);
        wide &= (ch != 112);
        buf += wide && (buf % 8) ? 4 : 0;
        readEmAsmArgsArray.push(
          // Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
          ch == 112 ? HEAPU32[((buf)>>2)] :
          ch == 105 ?
            HEAP32[((buf)>>2)] :
            HEAPF64[((buf)>>3)]
        );
        buf += wide ? 8 : 4;
      }
      return readEmAsmArgsArray;
    };
  var runEmAsmFunction = (code, sigPtr, argbuf) => {
      var args = readEmAsmArgs(sigPtr, argbuf);
      assert(ASM_CONSTS.hasOwnProperty(code), `No EM_ASM constant found at address ${code}.  The loaded WebAssembly file is likely out of sync with the generated JavaScript.`);
      return ASM_CONSTS[code](...args);
    };
  var _emscripten_asm_const_double = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };

  var _emscripten_asm_const_int = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };

  var getCFunc = (ident) => {
      var func = Module['_' + ident]; // closure exported function
      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
      return func;
    };
  
  var writeArrayToMemory = (array, buffer) => {
      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
      HEAP8.set(array, buffer);
    };
  
  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
  
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;
  
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.charCodeAt(i); // possibly a lead surrogate
        if (u >= 0xD800 && u <= 0xDFFF) {
          var u1 = str.charCodeAt(++i);
          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
        }
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    };
  
  
  
  
  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;
  
    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number=} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.  Also, use the length info to avoid running tiny
      // strings through TextDecoder, since .subarray() allocates garbage.
      // (As a tiny code save trick, compare endPtr against endIdx using a negation,
      // so that undefined/NaN means Infinity)
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
  
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      // If building with TextDecoder, we have already computed the string length
      // above, so test loop end condition against that
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }
  
        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  
    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead) => {
      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
    };
  
    /**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */
  var ccall = (ident, returnType, argTypes, args, opts) => {
      // For fast lookup of conversion functions
      var toC = {
        'string': (str) => {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) { // null string
            ret = stringToUTF8OnStack(str);
          }
          return ret;
        },
        'array': (arr) => {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        }
      };
  
      function convertReturnValue(ret) {
        if (returnType === 'string') {
          return UTF8ToString(ret);
        }
        if (returnType === 'boolean') return Boolean(ret);
        return ret;
      }
  
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      assert(returnType !== 'array', 'Return type should not be "array".');
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func(...cArgs);
      function onDone(ret) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret);
      }
  
      ret = onDone(ret);
      return ret;
    };
// End JS library code

function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}
var ASM_CONSTS = {
  244706: () => { jsHandleIO(); },  
 244724: ($0, $1) => { hwSetPinValue($0,$1) },  
 244749: ($0) => { return hwGetPinValue($0) },  
 244778: () => { return Date.now(); },  
 244801: ($0, $1, $2) => { hwFlashWritePtr($0,$1,$2); },  
 244832: ($0) => { return hwFlashRead($0) },  
 244859: ($0, $1, $2) => { hwFlashWritePtr($0,$1,$2); }
};
function emscripten_memcpy_js(dest,src,numBytes) { var destHeap = new Uint8Array(Module.HEAPU8.buffer, dest, numBytes); var srcHeap = new Uint8Array(Module.HEAPU8.buffer, src, numBytes); destHeap.set(srcHeap); }
var wasmImports = {
  /** @export */
  emscripten_asm_const_double: _emscripten_asm_const_double,
  /** @export */
  emscripten_asm_const_int: _emscripten_asm_const_int
};
var wasmExports;
createWasm();
var ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors', 0);
var _jshPushIOCharEvent = Module['_jshPushIOCharEvent'] = createExportWrapper('jshPushIOCharEvent', 2);
var _jshGetCharToTransmit = Module['_jshGetCharToTransmit'] = createExportWrapper('jshGetCharToTransmit', 1);
var _jshGetDeviceToTransmit = Module['_jshGetDeviceToTransmit'] = createExportWrapper('jshGetDeviceToTransmit', 0);
var _jsGfxChanged = Module['_jsGfxChanged'] = createExportWrapper('jsGfxChanged', 0);
var _jsGfxGetPtr = Module['_jsGfxGetPtr'] = createExportWrapper('jsGfxGetPtr', 1);
var _jsInit = Module['_jsInit'] = createExportWrapper('jsInit', 0);
var _jsIdle = Module['_jsIdle'] = createExportWrapper('jsIdle', 0);
var _jsSendPinWatchEvent = Module['_jsSendPinWatchEvent'] = createExportWrapper('jsSendPinWatchEvent', 1);
var _jsSendTouchEvent = Module['_jsSendTouchEvent'] = createExportWrapper('jsSendTouchEvent', 4);
var _jsKill = Module['_jsKill'] = createExportWrapper('jsKill', 0);
var _fflush = createExportWrapper('fflush', 1);
var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();
var _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();
var _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();
var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();
var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);
var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);
var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();
var dynCall_vji = Module['dynCall_vji'] = createExportWrapper('dynCall_vji', 4);


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

Module['ccall'] = ccall;
var missingLibrarySymbols = [
  'writeI53ToI64',
  'writeI53ToI64Clamped',
  'writeI53ToI64Signaling',
  'writeI53ToU64Clamped',
  'writeI53ToU64Signaling',
  'readI53FromI64',
  'readI53FromU64',
  'convertI32PairToI53',
  'convertI32PairToI53Checked',
  'convertU32PairToI53',
  'getTempRet0',
  'setTempRet0',
  'zeroMemory',
  'exitJS',
  'getHeapMax',
  'abortOnCannotGrowMemory',
  'growMemory',
  'strError',
  'inetPton4',
  'inetNtop4',
  'inetPton6',
  'inetNtop6',
  'readSockaddr',
  'writeSockaddr',
  'emscriptenLog',
  'runMainThreadEmAsm',
  'jstoi_q',
  'getExecutableName',
  'listenOnce',
  'autoResumeAudioContext',
  'dynCallLegacy',
  'getDynCaller',
  'dynCall',
  'setWasmTableEntry',
  'getWasmTableEntry',
  'handleException',
  'keepRuntimeAlive',
  'runtimeKeepalivePush',
  'runtimeKeepalivePop',
  'callUserCallback',
  'maybeExit',
  'asmjsMangle',
  'asyncLoad',
  'alignMemory',
  'mmapAlloc',
  'HandleAllocator',
  'getNativeTypeSize',
  'addOnInit',
  'addOnPostCtor',
  'addOnPreMain',
  'addOnExit',
  'STACK_SIZE',
  'STACK_ALIGN',
  'POINTER_SIZE',
  'ASSERTIONS',
  'cwrap',
  'uleb128Encode',
  'sigToWasmTypes',
  'generateFuncType',
  'convertJsFunctionToWasm',
  'getEmptyTableSlot',
  'updateTableMap',
  'getFunctionAddress',
  'addFunction',
  'removeFunction',
  'reallyNegative',
  'unSign',
  'strLen',
  'reSign',
  'formatString',
  'intArrayFromString',
  'intArrayToString',
  'AsciiToString',
  'stringToAscii',
  'UTF16ToString',
  'stringToUTF16',
  'lengthBytesUTF16',
  'UTF32ToString',
  'stringToUTF32',
  'lengthBytesUTF32',
  'stringToNewUTF8',
  'registerKeyEventCallback',
  'maybeCStringToJsString',
  'findEventTarget',
  'getBoundingClientRect',
  'fillMouseEventData',
  'registerMouseEventCallback',
  'registerWheelEventCallback',
  'registerUiEventCallback',
  'registerFocusEventCallback',
  'fillDeviceOrientationEventData',
  'registerDeviceOrientationEventCallback',
  'fillDeviceMotionEventData',
  'registerDeviceMotionEventCallback',
  'screenOrientation',
  'fillOrientationChangeEventData',
  'registerOrientationChangeEventCallback',
  'fillFullscreenChangeEventData',
  'registerFullscreenChangeEventCallback',
  'JSEvents_requestFullscreen',
  'JSEvents_resizeCanvasForFullscreen',
  'registerRestoreOldStyle',
  'hideEverythingExceptGivenElement',
  'restoreHiddenElements',
  'setLetterbox',
  'softFullscreenResizeWebGLRenderTarget',
  'doRequestFullscreen',
  'fillPointerlockChangeEventData',
  'registerPointerlockChangeEventCallback',
  'registerPointerlockErrorEventCallback',
  'requestPointerLock',
  'fillVisibilityChangeEventData',
  'registerVisibilityChangeEventCallback',
  'registerTouchEventCallback',
  'fillGamepadEventData',
  'registerGamepadEventCallback',
  'registerBeforeUnloadEventCallback',
  'fillBatteryEventData',
  'battery',
  'registerBatteryEventCallback',
  'setCanvasElementSize',
  'getCanvasElementSize',
  'jsStackTrace',
  'getCallstack',
  'convertPCtoSourceLocation',
  'getEnvStrings',
  'checkWasiClock',
  'flush_NO_FILESYSTEM',
  'wasiRightsToMuslOFlags',
  'wasiOFlagsToMuslOFlags',
  'initRandomFill',
  'randomFill',
  'safeSetTimeout',
  'setImmediateWrapped',
  'safeRequestAnimationFrame',
  'clearImmediateWrapped',
  'registerPostMainLoop',
  'registerPreMainLoop',
  'getPromise',
  'makePromise',
  'idsToPromises',
  'makePromiseCallback',
  'ExceptionInfo',
  'findMatchingCatch',
  'Browser_asyncPrepareDataCounter',
  'isLeapYear',
  'ydayFromDate',
  'arraySum',
  'addDays',
  'getSocketFromFD',
  'getSocketAddress',
  'FS_createPreloadedFile',
  'FS_modeStringToFlags',
  'FS_getMode',
  'FS_stdin_getChar',
  'FS_unlink',
  'FS_createDataFile',
  'FS_mkdirTree',
  '_setNetworkCallback',
  'heapObjectForWebGLType',
  'toTypedArrayIndex',
  'webgl_enable_ANGLE_instanced_arrays',
  'webgl_enable_OES_vertex_array_object',
  'webgl_enable_WEBGL_draw_buffers',
  'webgl_enable_WEBGL_multi_draw',
  'webgl_enable_EXT_polygon_offset_clamp',
  'webgl_enable_EXT_clip_control',
  'webgl_enable_WEBGL_polygon_mode',
  'emscriptenWebGLGet',
  'computeUnpackAlignedImageSize',
  'colorChannelsInGlTextureFormat',
  'emscriptenWebGLGetTexPixelData',
  'emscriptenWebGLGetUniform',
  'webglGetUniformLocation',
  'webglPrepareUniformLocationsBeforeFirstUse',
  'webglGetLeftBracePos',
  'emscriptenWebGLGetVertexAttrib',
  '__glGetActiveAttribOrUniform',
  'writeGLArray',
  'registerWebGlEventCallback',
  'runAndAbortIfError',
  'ALLOC_NORMAL',
  'ALLOC_STACK',
  'allocate',
  'writeStringToMemory',
  'writeAsciiToMemory',
  'setErrNo',
  'demangle',
  'stackTrace',
];
missingLibrarySymbols.forEach(missingLibrarySymbol)

var unexportedSymbols = [
  'run',
  'addRunDependency',
  'removeRunDependency',
  'out',
  'err',
  'callMain',
  'abort',
  'wasmMemory',
  'wasmExports',
  'writeStackCookie',
  'checkStackCookie',
  'stackSave',
  'stackRestore',
  'stackAlloc',
  'ptrToString',
  'ENV',
  'ERRNO_CODES',
  'DNS',
  'Protocols',
  'Sockets',
  'timers',
  'warnOnce',
  'readEmAsmArgsArray',
  'readEmAsmArgs',
  'runEmAsmFunction',
  'jstoi_s',
  'wasmTable',
  'noExitRuntime',
  'addOnPreRun',
  'addOnPostRun',
  'getCFunc',
  'freeTableIndexes',
  'functionsInTableMap',
  'setValue',
  'getValue',
  'PATH',
  'PATH_FS',
  'UTF8Decoder',
  'UTF8ArrayToString',
  'UTF8ToString',
  'stringToUTF8Array',
  'stringToUTF8',
  'lengthBytesUTF8',
  'UTF16Decoder',
  'stringToUTF8OnStack',
  'writeArrayToMemory',
  'JSEvents',
  'specialHTMLTargets',
  'findCanvasEventTarget',
  'currentFullscreenStrategy',
  'restoreOldWindowedStyle',
  'UNWIND_CACHE',
  'ExitStatus',
  'emSetImmediate',
  'emClearImmediate_deps',
  'emClearImmediate',
  'promiseMap',
  'uncaughtExceptionCount',
  'exceptionLast',
  'exceptionCaught',
  'Browser',
  'getPreloadedImageData__data',
  'wget',
  'MONTH_DAYS_REGULAR',
  'MONTH_DAYS_LEAP',
  'MONTH_DAYS_REGULAR_CUMULATIVE',
  'MONTH_DAYS_LEAP_CUMULATIVE',
  'SYSCALLS',
  'preloadPlugins',
  'FS_stdin_getChar_buffer',
  'FS_createPath',
  'FS_createDevice',
  'FS_readFile',
  'FS',
  'FS_createLazyFile',
  'MEMFS',
  'TTY',
  'PIPEFS',
  'SOCKFS',
  'tempFixedLengthArray',
  'miniTempWebGLFloatBuffers',
  'miniTempWebGLIntBuffers',
  'GL',
  'AL',
  'GLUT',
  'EGL',
  'GLEW',
  'IDBStore',
  'SDL',
  'SDL_gfx',
  'allocateUTF8',
  'allocateUTF8OnStack',
  'print',
  'printErr',
];
unexportedSymbols.forEach(unexportedRuntimeSymbol);



var calledRun;

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

function run() {

  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    assert(!calledRun);
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    Module['onRuntimeInitialized']?.();
    consumedModuleProp('onRuntimeInitialized');

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(() => {
      setTimeout(() => Module['setStatus'](''), 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  }
  try { // it doesn't matter if it fails
    _fflush(0);
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}
consumedModuleProp('preInit');

run();

// end include: postamble.js

